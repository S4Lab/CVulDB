linux-scraping__linux-grsecurity
commit 85f40de77cd0ed626359737b1a7a318ab32cad05
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Sat Oct 25 00:28:33 2014 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Sat Oct 25 00:28:33 2014 -0400

    grsec: Apply grsecurity-3.0-3.14.22-201410250026.patch
    
    commit a8ee169c76b4fab6f6adf4ebd56b4dee23b0b4f5
    Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Date:   Fri Oct 17 22:55:59 2014 +0200
    
        kvm: fix excessive pages un-pinning in kvm_iommu_map error path.
    
        The third parameter of kvm_unpin_pages() when called from
        kvm_iommu_map_pages() is wrong, it should be the number of pages to un-pin
        and not the page size.
    
        This error was facilitated with an inconsistent API: kvm_pin_pages() takes
        a size, but kvn_unpin_pages() takes a number of pages, so fix the problem
        by matching the two.
    
        This was introduced by commit 350b8bd ("kvm: iommu: fix the third parameter
        of kvm_iommu_put_pages (CVE-2014-3601)"), which fixes the lack of
        un-pinning for pages intended to be un-pinned (i.e. memory leak) but
        unfortunately potentially aggravated the number of pages we un-pin that
        should have stayed pinned. As far as I understand though, the same
        practical mitigations apply.
    
        This issue was found during review of Red Hat 6.6 patches to prepare
        Ksplice rebootless updates.
    
        Thanks to Vegard for his time on a late Friday evening to help me in
        understanding this code.
    
        Fixes: 350b8bd ("kvm: iommu: fix the third parameter of... (CVE-2014-3601)")
        Cc: stable@vger.kernel.org
        Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
        Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
        Signed-off-by: Jamie Iles <jamie.iles@oracle.com>
        Reviewed-by: Sasha Levin <sasha.levin@oracle.com>
        Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    
     virt/kvm/iommu.c |    8 ++++----
     1 files changed, 4 insertions(+), 4 deletions(-)
    
    commit 0eee7e7448e396c762d91984b588d017becbb09d
    Author: David S. Miller <davem@davemloft.net>
    Date:   Thu Oct 23 12:58:13 2014 -0700
    
        sparc64: Fix register corruption in top-most kernel stack frame during boot.
    
        Meelis Roos reported that kernels built with gcc-4.9 do not boot, we
        eventually narrowed this down to only impacting machines using
        UltraSPARC-III and derivitive cpus.
    
        The crash happens right when the first user process is spawned:
    
        [   54.451346] Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000004
        [   54.451346]
        [   54.571516] CPU: 1 PID: 1 Comm: init Not tainted 3.16.0-rc2-00211-gd7933ab #96
        [   54.666431] Call Trace:
        [   54.698453]  [0000000000762f8c] panic+0xb0/0x224
        [   54.759071]  [000000000045cf68] do_exit+0x948/0x960
        [   54.823123]  [000000000042cbc0] fault_in_user_windows+0xe0/0x100
        [   54.902036]  [0000000000404ad0] __handle_user_windows+0x0/0x10
        [   54.978662] Press Stop-A (L1-A) to return to the boot prom
        [   55.050713] ---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000004
    
        Further investigation showed that compiling only per_cpu_patch() with
        an older compiler fixes the boot.
    
        Detailed analysis showed that the function is not being miscompiled by
        gcc-4.9, but it is using a different register allocation ordering.
    
        With the gcc-4.9 compiled function, something during the code patching
        causes some of the %i* input registers to get corrupted.  Perhaps
        we have a TLB miss path into the firmware that is deep enough to
        cause a register window spill and subsequent restore when we get
        back from the TLB miss trap.
    
        Let's plug this up by doing two things:
    
        1) Stop using the firmware stack for client interface calls into
           the firmware.  Just use the kernel's stack.
    
        2) As soon as we can, call into a new function "start_early_boot()"
           to put a one-register-window buffer between the firmware's
           deepest stack frame and the top-most initial kernel one.
    
        Reported-by: Meelis Roos <mroos@linux.ee>
        Tested-by: Meelis Roos <mroos@linux.ee>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
        Conflicts:
    
            arch/sparc/include/asm/oplib_64.h
            arch/sparc/include/asm/setup.h
            arch/sparc/kernel/entry.h
    
     arch/sparc/include/asm/oplib_64.h |    3 +-
     arch/sparc/include/asm/setup.h    |    4 +++
     arch/sparc/kernel/entry.h         |   11 +++------
     arch/sparc/kernel/head_64.S       |   40 +++---------------------------------
     arch/sparc/kernel/hvtramp.S       |    1 -
     arch/sparc/kernel/setup_64.c      |   28 ++++++++++++++++++-------
     arch/sparc/kernel/trampoline_64.S |   12 ++++++----
     arch/sparc/prom/cif.S             |    5 +--
     arch/sparc/prom/init_64.c         |    6 ++--
     arch/sparc/prom/p1275.c           |    2 -
     10 files changed, 46 insertions(+), 66 deletions(-)
    
    commit e097432d404243fff21a5fc7e1b0fae16ac8d494
    Author: David S. Miller <davem@davemloft.net>
    Date:   Fri Oct 24 09:59:02 2014 -0700
    
        sparc64: Implement __get_user_pages_fast().
    
        It is not sufficient to only implement get_user_pages_fast(), you
        must also implement the atomic version __get_user_pages_fast()
        otherwise you end up using the weak symbol fallback implementation
        which simply returns zero.
    
        This is dangerous, because it causes the futex code to loop forever
        if transparent hugepages are supported (see get_futex_key()).
    
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     arch/sparc/mm/gup.c |   30 ++++++++++++++++++++++++++++++
     1 files changed, 30 insertions(+), 0 deletions(-)
    
    commit 7b1ebc6b0c9ab5ffe46742ab8b5eecfe8f1d7945
    Author: Bjorn Helgaas <bhelgaas@google.com>
    Date:   Mon Oct 13 18:01:34 2014 -0600
    
        x86, intel-mid: Remove "weak" from function declarations
    
        For the following interfaces:
    
          get_penwell_ops()
          get_cloverview_ops()
          get_tangier_ops()
    
        there is only one implementation, so they do not need to be marked "weak".
    
        Remove the "weak" attribute from their declarations.
    
        Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
        Acked-by: Ingo Molnar <mingo@kernel.org>
        CC: David Cohen <david.a.cohen@linux.intel.com>
        CC: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
        CC: x86@kernel.org
        Conflicts:
    
            arch/x86/platform/intel-mid/intel_mid_weak_decls.h
    
        Conflicts:
    
            arch/x86/platform/intel-mid/intel_mid_weak_decls.h
    
     arch/x86/platform/intel-mid/intel_mid_weak_decls.h |    7 +++----
     arch/x86/platform/intel-mid/mfld.c                 |    4 ++--
     arch/x86/platform/intel-mid/mrfl.c                 |    2 +-
     3 files changed, 6 insertions(+), 7 deletions(-)
    
    commit 6c7d2283a0b891e3798d628ba23869e87d2df378
    Author: Bjorn Helgaas <bhelgaas@google.com>
    Date:   Mon Oct 13 18:59:09 2014 -0600
    
        clocksource: Remove "weak" from clocksource_default_clock() declaration
    
        kernel/time/jiffies.c provides a default clocksource_default_clock()
        definition explicitly marked "weak".  arch/s390 provides its own definition
        intended to override the default, but the "weak" attribute on the
        declaration applied to the s390 definition as well, so the linker chose one
        based on link order (see 10629d711ed7 ("PCI: Remove __weak annotation from
        pcibios_get_phb_of_node decl")).
    
        Remove the "weak" attribute from the clocksource_default_clock()
        declaration so we always prefer a non-weak definition over the weak one,
        independent of link order.
    
        Fixes: f1b82746c1e9 ("clocksource: Cleanup clocksource selection")
        Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
        Acked-by: John Stultz <john.stultz@linaro.org>
        Acked-by: Ingo Molnar <mingo@kernel.org>
        CC: Daniel Lezcano <daniel.lezcano@linaro.org>
        CC: Martin Schwidefsky <schwidefsky@de.ibm.com>
    
     include/linux/clocksource.h |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 94d5fc2f833615221953713c50482de19add9cd6
    Author: Bjorn Helgaas <bhelgaas@google.com>
    Date:   Mon Oct 13 18:59:41 2014 -0600
    
        vmcore: Remove "weak" from function declarations
    
        For the following functions:
    
          elfcorehdr_alloc()
          elfcorehdr_free()
          elfcorehdr_read()
          elfcorehdr_read_notes()
          remap_oldmem_pfn_range()
    
        fs/proc/vmcore.c provides default definitions explicitly marked "weak".
        arch/s390 provides its own definitions intended to override the default
        ones, but the "weak" attribute on the declarations applied to the s390
        definitions as well, so the linker chose one based on link order (see
        10629d711ed7 ("PCI: Remove __weak annotation from pcibios_get_phb_of_node
        decl")).
    
        Remove the "weak" attribute from the declarations so we always prefer a
        non-weak definition over the weak one, independent of link order.
    
        Fixes: be8a8d069e50 ("vmcore: introduce ELF header in new memory feature")
        Fixes: 9cb218131de1 ("vmcore: introduce remap_oldmem_pfn_range()")
        Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
        Acked-by: Andrew Morton <akpm@linux-foundation.org>
        Acked-by: Vivek Goyal <vgoyal@redhat.com>
        CC: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    
     include/linux/crash_dump.h |   15 +++++++--------
     1 files changed, 7 insertions(+), 8 deletions(-)
    
    commit a69ac3a59aee2e75db96470f1c9053e0952998b6
    Author: Vineet Gupta <vgupta@synopsys.com>
    Date:   Mon Oct 20 10:17:04 2014 -0600
    
        ARC: kgdb: generic kgdb_arch_pc() suffices
    
        The ARC version of kgdb_arch_pc() is identical to the generic version in
        kernel/debug/debug_core.c.  Drop the ARC version so we use the generic one.
    
        Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
        Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    
     arch/arc/kernel/kgdb.c |    5 -----
     1 files changed, 0 insertions(+), 5 deletions(-)
    
    commit 21560a63031fe5d22c71cae090cf92fdfc6dc273
    Author: Bjorn Helgaas <bhelgaas@google.com>
    Date:   Mon Oct 13 19:00:25 2014 -0600
    
        kgdb: Remove "weak" from kgdb_arch_pc() declaration
    
        kernel/debug/debug_core.c provides a default kgdb_arch_pc() definition
        explicitly marked "weak".  Several architectures provide their own
        definitions intended to override the default, but the "weak" attribute on
        the declaration applied to the arch definitions as well, so the linker
        chose one based on link order (see 10629d711ed7 ("PCI: Remove __weak
        annotation from pcibios_get_phb_of_node decl")).
    
        Remove the "weak" attribute from the declaration so we always prefer a
        non-weak definition over the weak one, independent of link order.
    
        Fixes: 688b744d8bc8 ("kgdb: fix signedness mixmatches, add statics, add declaration to header")
        Tested-by: Vineet Gupta <vgupta@synopsys.com>       # for ARC build
        Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
        Reviewed-by: Harvey Harrison <harvey.harrison@gmail.com>
    
     include/linux/kgdb.h |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit ddc947af9fabf397a2cf742123f64bf78028e9dc
    Author: Bjorn Helgaas <bhelgaas@google.com>
    Date:   Mon Oct 13 19:00:47 2014 -0600
    
        memory-hotplug: Remove "weak" from memory_block_size_bytes() declaration
    
        drivers/base/memory.c provides a default memory_block_size_bytes()
        definition explicitly marked "weak".  Several architectures provide their
        own definitions intended to override the default, but the "weak" attribute
        on the declaration applied to the arch definitions as well, so the linker
        chose one based on link order (see 10629d711ed7 ("PCI: Remove __weak
        annotation from pcibios_get_phb_of_node decl")).
    
        Remove the "weak" attribute from the declaration so we always prefer a
        non-weak definition over the weak one, independent of link order.
    
        Fixes: 41f107266b19 ("drivers: base: Add prototype declaration to the header file")
        Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
        Acked-by: Andrew Morton <akpm@linux-foundation.org>
        CC: Rashika Kheria <rashika.kheria@gmail.com>
        CC: Nathan Fontenot <nfont@austin.ibm.com>
        CC: Anton Blanchard <anton@au1.ibm.com>
        CC: Heiko Carstens <heiko.carstens@de.ibm.com>
        CC: Yinghai Lu <yinghai@kernel.org>
    
     include/linux/memory.h |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit d2c7990f8f104ba878e2000efa2be6df3e74ceed
    Author: Daniel Borkmann <dborkman@redhat.com>
    Date:   Sun Sep 7 23:23:38 2014 +0200
    
        crypto: memzero_explicit - make sure to clear out sensitive data
    
        Recently, in commit 13aa93c70e71 ("random: add and use memzero_explicit()
        for clearing data"), we have found that GCC may optimize some memset()
        cases away when it detects a stack variable is not being used anymore
        and going out of scope. This can happen, for example, in cases when we
        are clearing out sensitive information such as keying material or any
        e.g. intermediate results from crypto computations, etc.
    
        With the help of Coccinelle, we can figure out and fix such occurences
        in the crypto subsytem as well. Julia Lawall provided the following
        Coccinelle program:
    
          @@
          type T;
          identifier x;
          @@
    
          T x;
          ... when exists
              when any
          -memset
          +memzero_explicit
             (&x,
          -0,
             ...)
          ... when != x
              when strict
    
          @@
          type T;
          identifier x;
          @@
    
          T x[...];
          ... when exists
              when any
          -memset
          +memzero_explicit
             (x,
          -0,
             ...)
          ... when != x
              when strict
    
        Therefore, make use of the drop-in replacement memzero_explicit() for
        exactly such cases instead of using memset().
    
        Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
        Cc: Julia Lawall <julia.lawall@lip6.fr>
        Cc: Herbert Xu <herbert@gondor.apana.org.au>
        Cc: Theodore Ts'o <tytso@mit.edu>
        Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
        Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
        Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
        Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    
     crypto/cts.c            |    3 ++-
     crypto/sha1_generic.c   |    2 +-
     crypto/sha256_generic.c |    5 ++---
     crypto/sha512_generic.c |    2 +-
     crypto/tgr192.c         |    4 ++--
     crypto/vmac.c           |    2 +-
     crypto/wp512.c          |    8 ++++----
     7 files changed, 13 insertions(+), 13 deletions(-)
    
    commit 9834d21f9fb72e5eabbfc5290261987ae21133af
    Author: Daniel Borkmann <dborkman@redhat.com>
    Date:   Tue Aug 26 23:16:35 2014 -0400
    
        random: add and use memzero_explicit() for clearing data
    
        zatimend has reported that in his environment (3.16/gcc4.8.3/corei7)
        memset() calls which clear out sensitive data in extract_{buf,entropy,
        entropy_user}() in random driver are being optimized away by gcc.
    
        Add a helper memzero_explicit() (similarly as explicit_bzero() variants)
        that can be used in such cases where a variable with sensitive data is
        being cleared out in the end. Other use cases might also be in crypto
        code. [ I have put this into lib/string.c though, as it's always built-in
        and doesn't need any dependencies then. ]
    
        Fixes kernel bugzilla: 82041
    
        Reported-by: zatimend@hotmail.co.uk
        Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
        Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
        Cc: Alexey Dobriyan <adobriyan@gmail.com>
        Signed-off-by: Theodore Ts'o <tytso@mit.edu>
        Cc: stable@vger.kernel.org
    
        Conflicts:
    
            drivers/char/random.c
    
     drivers/char/random.c  |   10 +++++-----
     include/linux/string.h |    5 +++--
     lib/string.c           |   16 ++++++++++++++++
     3 files changed, 24 insertions(+), 7 deletions(-)
    
    commit 26b683871a4b2dafca09f16efd38101a5d97abba
    Author: Li RongQing <roy.qing.li@gmail.com>
    Date:   Wed Oct 22 17:09:53 2014 +0800
    
        xfrm6: fix a potential use after free in xfrm6_policy.c
    
        pskb_may_pull() maybe change skb->data and make nh and exthdr pointer
        oboslete, so recompute the nd and exthdr
    
        Signed-off-by: Li RongQing <roy.qing.li@gmail.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/ipv6/xfrm6_policy.c |   11 ++++++++---
     1 files changed, 8 insertions(+), 3 deletions(-)
    
    commit 9f9123ab40959f0c63f267a46016c6d0fa823c2f
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Thu Oct 23 19:20:18 2014 -0400
    
        allow print_bad_pte to display symbols
    
     mm/memory.c |    4 ++--
     1 files changed, 2 insertions(+), 2 deletions(-)
    
    commit a6f917db2aff6f1156220d766c3de2933261c2c1
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Oct 22 18:36:16 2014 -0400
    
        Remove argument from gr_update_task_in_ip_table, as it's always called with 'current'
    
        Conflicts:
    
            net/ipv4/inet_hashtables.c
    
     grsecurity/grsec_sock.c    |    4 ++--
     net/ipv4/inet_hashtables.c |    4 ++--
     2 files changed, 4 insertions(+), 4 deletions(-)
    
    commit 481cc2a6877c249b8d32ae06575cb5ee05290d77
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Oct 22 18:19:01 2014 -0400
    
        hold sighand lock while accessing ->signal
    
     fs/proc/array.c |   10 +++++++++-
     1 files changed, 9 insertions(+), 1 deletions(-)
    
    Signature-tree: eaf464144c201563e134ebf9eca041aa31848928

diff --git a/arch/arc/kernel/kgdb.c b/arch/arc/kernel/kgdb.c
index a2ff5c5d1450..ecf6a7869375 100644
--- a/arch/arc/kernel/kgdb.c
+++ b/arch/arc/kernel/kgdb.c
@@ -158,11 +158,6 @@ int kgdb_arch_handle_exception(int e_vector, int signo, int err_code,
 	return -1;
 }
 
-unsigned long kgdb_arch_pc(int exception, struct pt_regs *regs)
-{
-	return instruction_pointer(regs);
-}
-
 int kgdb_arch_init(void)
 {
 	single_step_data.armed = 0;
diff --git a/arch/sparc/include/asm/oplib_64.h b/arch/sparc/include/asm/oplib_64.h
index a12dbe3b7762..0337e85e1e6a 100644
--- a/arch/sparc/include/asm/oplib_64.h
+++ b/arch/sparc/include/asm/oplib_64.h
@@ -62,7 +62,8 @@ struct linux_mem_p1275 {
 /* You must call prom_init() before using any of the library services,
  * preferably as early as possible.  Pass it the romvec pointer.
  */
-extern void prom_init(void *cif_handler, void *cif_stack);
+void prom_init(void *cif_handler);
+void prom_init_report(void);
 
 /* Boot argument acquisition, returns the boot command line string. */
 extern char *prom_getbootargs(void);
diff --git a/arch/sparc/include/asm/setup.h b/arch/sparc/include/asm/setup.h
index 5e35e0517318..b1a29e966091 100644
--- a/arch/sparc/include/asm/setup.h
+++ b/arch/sparc/include/asm/setup.h
@@ -24,6 +24,10 @@ static inline int con_is_present(void)
 }
 #endif
 
+#ifdef CONFIG_SPARC64
+void __init start_early_boot(void);
+#endif
+
 extern void sun_do_break(void);
 extern int stop_a_enabled;
 extern int scons_pwroff;
diff --git a/arch/sparc/kernel/entry.h b/arch/sparc/kernel/entry.h
index 140966fbd303..620009dbc2de 100644
--- a/arch/sparc/kernel/entry.h
+++ b/arch/sparc/kernel/entry.h
@@ -66,13 +66,10 @@ struct pause_patch_entry {
 extern struct pause_patch_entry __pause_3insn_patch,
 	__pause_3insn_patch_end;
 
-extern void __init per_cpu_patch(void);
-extern void sun4v_patch_1insn_range(struct sun4v_1insn_patch_entry *,
-				    struct sun4v_1insn_patch_entry *);
-extern void sun4v_patch_2insn_range(struct sun4v_2insn_patch_entry *,
-				    struct sun4v_2insn_patch_entry *);
-extern void __init sun4v_patch(void);
-extern void __init boot_cpu_id_too_large(int cpu);
+void sun4v_patch_1insn_range(struct sun4v_1insn_patch_entry *,
+			     struct sun4v_1insn_patch_entry *);
+void sun4v_patch_2insn_range(struct sun4v_2insn_patch_entry *,
+			     struct sun4v_2insn_patch_entry *);
 extern unsigned int dcache_parity_tl1_occurred;
 extern unsigned int icache_parity_tl1_occurred;
 
diff --git a/arch/sparc/kernel/head_64.S b/arch/sparc/kernel/head_64.S
index 452f04fe8da6..fbea0ac57f22 100644
--- a/arch/sparc/kernel/head_64.S
+++ b/arch/sparc/kernel/head_64.S
@@ -660,14 +660,12 @@ tlb_fixup_done:
 	sethi	%hi(init_thread_union), %g6
 	or	%g6, %lo(init_thread_union), %g6
 	ldx	[%g6 + TI_TASK], %g4
-	mov	%sp, %l6
 
 	wr	%g0, ASI_P, %asi
 	mov	1, %g1
 	sllx	%g1, THREAD_SHIFT, %g1
 	sub	%g1, (STACKFRAME_SZ + STACK_BIAS), %g1
 	add	%g6, %g1, %sp
-	mov	0, %fp
 
 	/* Set per-cpu pointer initially to zero, this makes
 	 * the boot-cpu use the in-kernel-image per-cpu areas
@@ -694,44 +692,14 @@ tlb_fixup_done:
 	 nop
 #endif
 
-	mov	%l6, %o1			! OpenPROM stack
 	call	prom_init
 	 mov	%l7, %o0			! OpenPROM cif handler
 
-	/* Initialize current_thread_info()->cpu as early as possible.
-	 * In order to do that accurately we have to patch up the get_cpuid()
-	 * assembler sequences.  And that, in turn, requires that we know
-	 * if we are on a Starfire box or not.  While we're here, patch up
-	 * the sun4v sequences as well.
+	/* To create a one-register-window buffer between the kernel's
+	 * initial stack and the last stack frame we use from the firmware,
+	 * do the rest of the boot from a C helper function.
 	 */
-	call	check_if_starfire
-	 nop
-	call	per_cpu_patch
-	 nop
-	call	sun4v_patch
-	 nop
-
-#ifdef CONFIG_SMP
-	call	hard_smp_processor_id
-	 nop
-	cmp	%o0, NR_CPUS
-	blu,pt	%xcc, 1f
-	 nop
-	call	boot_cpu_id_too_large
-	 nop
-	/* Not reached... */
-
-1:
-#else
-	mov	0, %o0
-#endif
-	sth	%o0, [%g6 + TI_CPU]
-
-	call	prom_init_report
-	 nop
-
-	/* Off we go.... */
-	call	start_kernel
+	call	start_early_boot
 	 nop
 	/* Not reached... */
 
diff --git a/arch/sparc/kernel/hvtramp.S b/arch/sparc/kernel/hvtramp.S
index b7ddcdd1dea9..cdbfec299f2f 100644
--- a/arch/sparc/kernel/hvtramp.S
+++ b/arch/sparc/kernel/hvtramp.S
@@ -109,7 +109,6 @@ hv_cpu_startup:
 	sllx		%g5, THREAD_SHIFT, %g5
 	sub		%g5, (STACKFRAME_SZ + STACK_BIAS), %g5
 	add		%g6, %g5, %sp
-	mov		0, %fp
 
 	call		init_irqwork_curcpu
 	 nop
diff --git a/arch/sparc/kernel/setup_64.c b/arch/sparc/kernel/setup_64.c
index 3fdb455e3318..949f7737e9fc 100644
--- a/arch/sparc/kernel/setup_64.c
+++ b/arch/sparc/kernel/setup_64.c
@@ -30,6 +30,7 @@
 #include <linux/cpu.h>
 #include <linux/initrd.h>
 #include <linux/module.h>
+#include <linux/start_kernel.h>
 
 #include <asm/io.h>
 #include <asm/processor.h>
@@ -174,7 +175,7 @@ char reboot_command[COMMAND_LINE_SIZE];
 
 static struct pt_regs fake_swapper_regs = { { 0, }, 0, 0, 0, 0 };
 
-void __init per_cpu_patch(void)
+static void __init per_cpu_patch(void)
 {
 	struct cpuid_patch_entry *p;
 	unsigned long ver;
@@ -266,7 +267,7 @@ void sun4v_patch_2insn_range(struct sun4v_2insn_patch_entry *start,
 	}
 }
 
-void __init sun4v_patch(void)
+static void __init sun4v_patch(void)
 {
 	extern void sun4v_hvapi_init(void);
 
@@ -335,14 +336,25 @@ static void __init pause_patch(void)
 	}
 }
 
-#ifdef CONFIG_SMP
-void __init boot_cpu_id_too_large(int cpu)
+void __init start_early_boot(void)
 {
-	prom_printf("Serious problem, boot cpu id (%d) >= NR_CPUS (%d)\n",
-		    cpu, NR_CPUS);
-	prom_halt();
+	int cpu;
+
+	check_if_starfire();
+	per_cpu_patch();
+	sun4v_patch();
+
+	cpu = hard_smp_processor_id();
+	if (cpu >= NR_CPUS) {
+		prom_printf("Serious problem, boot cpu id (%d) >= NR_CPUS (%d)\n",
+			    cpu, NR_CPUS);
+		prom_halt();
+	}
+	current_thread_info()->cpu = cpu;
+
+	prom_init_report();
+	start_kernel();
 }
-#endif
 
 /* On Ultra, we support all of the v8 capabilities. */
 unsigned long sparc64_elf_hwcap = (HWCAP_SPARC_FLUSH | HWCAP_SPARC_STBAR |
diff --git a/arch/sparc/kernel/trampoline_64.S b/arch/sparc/kernel/trampoline_64.S
index 737f8cbc7d56..88ede1d53b4c 100644
--- a/arch/sparc/kernel/trampoline_64.S
+++ b/arch/sparc/kernel/trampoline_64.S
@@ -109,10 +109,13 @@ startup_continue:
 	brnz,pn		%g1, 1b
 	 nop
 
-	sethi		%hi(p1275buf), %g2
-	or		%g2, %lo(p1275buf), %g2
-	ldx		[%g2 + 0x10], %l2
-	add		%l2, -(192 + 128), %sp
+	/* Get onto temporary stack which will be in the locked
+	 * kernel image.
+	 */
+	sethi		%hi(tramp_stack), %g1
+	or		%g1, %lo(tramp_stack), %g1
+	add		%g1, TRAMP_STACK_SIZE, %g1
+	sub		%g1, STACKFRAME_SZ + STACK_BIAS + 256, %sp
 	flushw
 
 	/* Setup the loop variables:
@@ -394,7 +397,6 @@ after_lock_tlb:
 	sllx		%g5, THREAD_SHIFT, %g5
 	sub		%g5, (STACKFRAME_SZ + STACK_BIAS), %g5
 	add		%g6, %g5, %sp
-	mov		0, %fp
 
 	rdpr		%pstate, %o1
 	or		%o1, PSTATE_IE, %o1
diff --git a/arch/sparc/mm/gup.c b/arch/sparc/mm/gup.c
index 1aed0432c64b..ae6ce383d4df 100644
--- a/arch/sparc/mm/gup.c
+++ b/arch/sparc/mm/gup.c
@@ -160,6 +160,36 @@ static int gup_pud_range(pgd_t pgd, unsigned long addr, unsigned long end,
 	return 1;
 }
 
+int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
+			  struct page **pages)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long addr, len, end;
+	unsigned long next, flags;
+	pgd_t *pgdp;
+	int nr = 0;
+
+	start &= PAGE_MASK;
+	addr = start;
+	len = (unsigned long) nr_pages << PAGE_SHIFT;
+	end = start + len;
+
+	local_irq_save(flags);
+	pgdp = pgd_offset(mm, addr);
+	do {
+		pgd_t pgd = *pgdp;
+
+		next = pgd_addr_end(addr, end);
+		if (pgd_none(pgd))
+			break;
+		if (!gup_pud_range(pgd, addr, next, write, pages, &nr))
+			break;
+	} while (pgdp++, addr = next, addr != end);
+	local_irq_restore(flags);
+
+	return nr;
+}
+
 int get_user_pages_fast(unsigned long start, int nr_pages, int write,
 			struct page **pages)
 {
diff --git a/arch/sparc/prom/cif.S b/arch/sparc/prom/cif.S
index 9c86b4b7d429..8050f381f518 100644
--- a/arch/sparc/prom/cif.S
+++ b/arch/sparc/prom/cif.S
@@ -11,11 +11,10 @@
 	.text
 	.globl	prom_cif_direct
 prom_cif_direct:
+	save	%sp, -192, %sp
 	sethi	%hi(p1275buf), %o1
 	or	%o1, %lo(p1275buf), %o1
-	ldx	[%o1 + 0x0010], %o2	! prom_cif_stack
-	save	%o2, -192, %sp
-	ldx	[%i1 + 0x0008], %l2	! prom_cif_handler
+	ldx	[%o1 + 0x0008], %l2	! prom_cif_handler
 	mov	%g4, %l0
 	mov	%g5, %l1
 	mov	%g6, %l3
diff --git a/arch/sparc/prom/init_64.c b/arch/sparc/prom/init_64.c
index d95db755828f..110b0d78b864 100644
--- a/arch/sparc/prom/init_64.c
+++ b/arch/sparc/prom/init_64.c
@@ -26,13 +26,13 @@ phandle prom_chosen_node;
  * It gets passed the pointer to the PROM vector.
  */
 
-extern void prom_cif_init(void *, void *);
+extern void prom_cif_init(void *);
 
-void __init prom_init(void *cif_handler, void *cif_stack)
+void __init prom_init(void *cif_handler)
 {
 	phandle node;
 
-	prom_cif_init(cif_handler, cif_stack);
+	prom_cif_init(cif_handler);
 
 	prom_chosen_node = prom_finddevice(prom_chosen_path);
 	if (!prom_chosen_node || (s32)prom_chosen_node == -1)
diff --git a/arch/sparc/prom/p1275.c b/arch/sparc/prom/p1275.c
index e58b81726319..c27c30e4cb5e 100644
--- a/arch/sparc/prom/p1275.c
+++ b/arch/sparc/prom/p1275.c
@@ -19,7 +19,6 @@
 struct {
 	long prom_callback;			/* 0x00 */
 	void (*prom_cif_handler)(long *);	/* 0x08 */
-	unsigned long prom_cif_stack;		/* 0x10 */
 } p1275buf;
 
 extern void prom_world(int);
@@ -51,5 +50,4 @@ void p1275_cmd_direct(unsigned long *args)
 void prom_cif_init(void *cif_handler, void *cif_stack)
 {
 	p1275buf.prom_cif_handler = (void (*)(long *))cif_handler;
-	p1275buf.prom_cif_stack = (unsigned long)cif_stack;
 }
diff --git a/arch/x86/platform/intel-mid/intel_mid_weak_decls.h b/arch/x86/platform/intel-mid/intel_mid_weak_decls.h
index 46aa25c8ce06..59a68ed4cabc 100644
--- a/arch/x86/platform/intel-mid/intel_mid_weak_decls.h
+++ b/arch/x86/platform/intel-mid/intel_mid_weak_decls.h
@@ -10,10 +10,9 @@
  */
 
 
-/* __attribute__((weak)) makes these declarations overridable */
 /* For every CPU addition a new get_<cpuname>_ops interface needs
  * to be added.
  */
-extern void *get_penwell_ops(void) __attribute__((weak));
-extern void *get_cloverview_ops(void) __attribute__((weak));
-extern void *get_tangier_ops(void) __attribute__((weak));
+extern const void *get_penwell_ops(void);
+extern const void *get_cloverview_ops(void);
+extern const void *get_tangier_ops(void);
diff --git a/arch/x86/platform/intel-mid/mfld.c b/arch/x86/platform/intel-mid/mfld.c
index 23381d2174ae..8ddc10ee292e 100644
--- a/arch/x86/platform/intel-mid/mfld.c
+++ b/arch/x86/platform/intel-mid/mfld.c
@@ -64,12 +64,12 @@ static void __init penwell_arch_setup(void)
 	pm_power_off = mfld_power_off;
 }
 
-void *get_penwell_ops(void)
+const void *get_penwell_ops(void)
 {
 	return &penwell_ops;
 }
 
-void *get_cloverview_ops(void)
+const void *get_cloverview_ops(void)
 {
 	return &penwell_ops;
 }
diff --git a/arch/x86/platform/intel-mid/mrfl.c b/arch/x86/platform/intel-mid/mrfl.c
index aaca91753d32..66eadbc09ce1 100644
--- a/arch/x86/platform/intel-mid/mrfl.c
+++ b/arch/x86/platform/intel-mid/mrfl.c
@@ -97,7 +97,7 @@ static struct intel_mid_ops tangier_ops = {
 	.arch_setup = tangier_arch_setup,
 };
 
-void *get_tangier_ops(void)
+const void *get_tangier_ops(void)
 {
 	return &tangier_ops;
 }
diff --git a/crypto/cts.c b/crypto/cts.c
index 042223f8e733..133f0874c95e 100644
--- a/crypto/cts.c
+++ b/crypto/cts.c
@@ -202,7 +202,8 @@ static int cts_cbc_decrypt(struct crypto_cts_ctx *ctx,
 	/* 5. Append the tail (BB - Ln) bytes of Xn (tmp) to Cn to create En */
 	memcpy(s + bsize + lastn, tmp + lastn, bsize - lastn);
 	/* 6. Decrypt En to create Pn-1 */
-	memset(iv, 0, sizeof(iv));
+	memzero_explicit(iv, sizeof(iv));
+
 	sg_set_buf(&sgsrc[0], s + bsize, bsize);
 	sg_set_buf(&sgdst[0], d, bsize);
 	err = crypto_blkcipher_decrypt_iv(&lcldesc, sgdst, sgsrc, bsize);
diff --git a/crypto/sha1_generic.c b/crypto/sha1_generic.c
index 42794803c480..7bb047432782 100644
--- a/crypto/sha1_generic.c
+++ b/crypto/sha1_generic.c
@@ -64,7 +64,7 @@ int crypto_sha1_update(struct shash_desc *desc, const u8 *data,
 			src = data + done;
 		} while (done + SHA1_BLOCK_SIZE <= len);
 
-		memset(temp, 0, sizeof(temp));
+		memzero_explicit(temp, sizeof(temp));
 		partial = 0;
 	}
 	memcpy(sctx->buffer + partial, src, len - done);
diff --git a/crypto/sha256_generic.c b/crypto/sha256_generic.c
index 543366779524..32c5e5ea205a 100644
--- a/crypto/sha256_generic.c
+++ b/crypto/sha256_generic.c
@@ -210,10 +210,9 @@ static void sha256_transform(u32 *state, const u8 *input)
 
 	/* clear any sensitive info... */
 	a = b = c = d = e = f = g = h = t1 = t2 = 0;
-	memset(W, 0, 64 * sizeof(u32));
+	memzero_explicit(W, 64 * sizeof(u32));
 }
 
-
 static int sha224_init(struct shash_desc *desc)
 {
 	struct sha256_state *sctx = shash_desc_ctx(desc);
@@ -316,7 +315,7 @@ static int sha224_final(struct shash_desc *desc, u8 *hash)
 	sha256_final(desc, D);
 
 	memcpy(hash, D, SHA224_DIGEST_SIZE);
-	memset(D, 0, SHA256_DIGEST_SIZE);
+	memzero_explicit(D, SHA256_DIGEST_SIZE);
 
 	return 0;
 }
diff --git a/crypto/sha512_generic.c b/crypto/sha512_generic.c
index 6ed124f3ea0f..04d295a8bc08 100644
--- a/crypto/sha512_generic.c
+++ b/crypto/sha512_generic.c
@@ -238,7 +238,7 @@ static int sha384_final(struct shash_desc *desc, u8 *hash)
 	sha512_final(desc, D);
 
 	memcpy(hash, D, 48);
-	memset(D, 0, 64);
+	memzero_explicit(D, 64);
 
 	return 0;
 }
diff --git a/crypto/tgr192.c b/crypto/tgr192.c
index 87403556fd0b..3c7af0d1ff7a 100644
--- a/crypto/tgr192.c
+++ b/crypto/tgr192.c
@@ -612,7 +612,7 @@ static int tgr160_final(struct shash_desc *desc, u8 * out)
 
 	tgr192_final(desc, D);
 	memcpy(out, D, TGR160_DIGEST_SIZE);
-	memset(D, 0, TGR192_DIGEST_SIZE);
+	memzero_explicit(D, TGR192_DIGEST_SIZE);
 
 	return 0;
 }
@@ -623,7 +623,7 @@ static int tgr128_final(struct shash_desc *desc, u8 * out)
 
 	tgr192_final(desc, D);
 	memcpy(out, D, TGR128_DIGEST_SIZE);
-	memset(D, 0, TGR192_DIGEST_SIZE);
+	memzero_explicit(D, TGR192_DIGEST_SIZE);
 
 	return 0;
 }
diff --git a/crypto/vmac.c b/crypto/vmac.c
index 2eb11a30c29c..d84c24bd7ff7 100644
--- a/crypto/vmac.c
+++ b/crypto/vmac.c
@@ -613,7 +613,7 @@ static int vmac_final(struct shash_desc *pdesc, u8 *out)
 	}
 	mac = vmac(ctx->partial, ctx->partial_size, nonce, NULL, ctx);
 	memcpy(out, &mac, sizeof(vmac_t));
-	memset(&mac, 0, sizeof(vmac_t));
+	memzero_explicit(&mac, sizeof(vmac_t));
 	memset(&ctx->__vmac_ctx, 0, sizeof(struct vmac_ctx));
 	ctx->partial_size = 0;
 	return 0;
diff --git a/crypto/wp512.c b/crypto/wp512.c
index 180f1d6e03f4..ec64e7762fbb 100644
--- a/crypto/wp512.c
+++ b/crypto/wp512.c
@@ -1102,8 +1102,8 @@ static int wp384_final(struct shash_desc *desc, u8 *out)
 	u8 D[64];
 
 	wp512_final(desc, D);
-	memcpy (out, D, WP384_DIGEST_SIZE);
-	memset (D, 0, WP512_DIGEST_SIZE);
+	memcpy(out, D, WP384_DIGEST_SIZE);
+	memzero_explicit(D, WP512_DIGEST_SIZE);
 
 	return 0;
 }
@@ -1113,8 +1113,8 @@ static int wp256_final(struct shash_desc *desc, u8 *out)
 	u8 D[64];
 
 	wp512_final(desc, D);
-	memcpy (out, D, WP256_DIGEST_SIZE);
-	memset (D, 0, WP512_DIGEST_SIZE);
+	memcpy(out, D, WP256_DIGEST_SIZE);
+	memzero_explicit(D, WP512_DIGEST_SIZE);
 
 	return 0;
 }
diff --git a/drivers/char/random.c b/drivers/char/random.c
index de805d0371db..58488cc38666 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -1060,8 +1060,8 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	 * pool while mixing, and hash one final time.
 	 */
 	sha_transform(hash.w, extract, workspace);
-	memset(extract, 0, sizeof(extract));
-	memset(workspace, 0, sizeof(workspace));
+	memzero_explicit(extract, sizeof(extract));
+	memzero_explicit(workspace, sizeof(workspace));
 
 	/*
 	 * In case the hash function has some recognizable output
@@ -1073,7 +1073,7 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	hash.w[2] ^= rol32(hash.w[2], 16);
 
 	memcpy(out, &hash, EXTRACT_SIZE);
-	memset(&hash, 0, sizeof(hash));
+	memzero_explicit(&hash, sizeof(hash));
 }
 
 static ssize_t extract_entropy(struct entropy_store *r, void *buf,
@@ -1121,7 +1121,7 @@ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	memzero_explicit(tmp, sizeof(tmp));
 
 	return ret;
 }
@@ -1159,7 +1159,7 @@ static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	memzero_explicit(tmp, sizeof(tmp));
 
 	return ret;
 }
diff --git a/fs/proc/array.c b/fs/proc/array.c
index 6873520f24dc..5b394ec3f847 100644
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -652,7 +652,15 @@ int proc_pid_statm(struct seq_file *m, struct pid_namespace *ns,
 #ifdef CONFIG_GRKERNSEC_PROC_IPADDR
 int proc_pid_ipaddr(struct task_struct *task, char *buffer)
 {
-	return sprintf(buffer, "%pI4\n", &task->signal->curr_ip);
+	unsigned long flags;
+	u32 curr_ip = 0;
+
+	if (lock_task_sighand(task, &flags)) {
+		curr_ip = task->signal->curr_ip;
+		unlock_task_sighand(task, &flags);
+	}
+
+	return sprintf(buffer, "%pI4\n", &curr_ip);
 }
 #endif
 
diff --git a/grsecurity/grsec_sock.c b/grsecurity/grsec_sock.c
index c0aef3a01d8a..e3650b67d18a 100644
--- a/grsecurity/grsec_sock.c
+++ b/grsecurity/grsec_sock.c
@@ -121,10 +121,10 @@ static struct signal_struct * gr_lookup_task_ip_table(__u32 saddr, __u32 daddr,
 
 #endif
 
-void gr_update_task_in_ip_table(struct task_struct *task, const struct inet_sock *inet)
+void gr_update_task_in_ip_table(const struct inet_sock *inet)
 {
 #ifdef CONFIG_GRKERNSEC
-	struct signal_struct *sig = task->signal;
+	struct signal_struct *sig = current->signal;
 	struct conn_table_entry *newent;
 
 	newent = kmalloc(sizeof(struct conn_table_entry), GFP_ATOMIC);
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 67301a405712..879065d8d208 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -289,7 +289,7 @@ extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 extern void clocksource_suspend(void);
 extern void clocksource_resume(void);
-extern struct clocksource * __init __weak clocksource_default_clock(void);
+extern struct clocksource * __init clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);
 
 extern u64
diff --git a/include/linux/crash_dump.h b/include/linux/crash_dump.h
index 7032518f8542..60023e5d3169 100644
--- a/include/linux/crash_dump.h
+++ b/include/linux/crash_dump.h
@@ -14,14 +14,13 @@
 extern unsigned long long elfcorehdr_addr;
 extern unsigned long long elfcorehdr_size;
 
-extern int __weak elfcorehdr_alloc(unsigned long long *addr,
-				   unsigned long long *size);
-extern void __weak elfcorehdr_free(unsigned long long addr);
-extern ssize_t __weak elfcorehdr_read(char *buf, size_t count, u64 *ppos);
-extern ssize_t __weak elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos);
-extern int __weak remap_oldmem_pfn_range(struct vm_area_struct *vma,
-					 unsigned long from, unsigned long pfn,
-					 unsigned long size, pgprot_t prot);
+extern int elfcorehdr_alloc(unsigned long long *addr, unsigned long long *size);
+extern void elfcorehdr_free(unsigned long long addr);
+extern ssize_t elfcorehdr_read(char *buf, size_t count, u64 *ppos);
+extern ssize_t elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos);
+extern int remap_oldmem_pfn_range(struct vm_area_struct *vma,
+				  unsigned long from, unsigned long pfn,
+				  unsigned long size, pgprot_t prot);
 
 extern ssize_t copy_oldmem_page(unsigned long, char *, size_t,
 						unsigned long, int);
diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index c134867620df..19f605fd212d 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -283,7 +283,7 @@ struct kgdb_io {
 
 extern struct kgdb_arch		arch_kgdb_ops;
 
-extern unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs);
+extern unsigned long kgdb_arch_pc(int exception, struct pt_regs *regs);
 
 #ifdef CONFIG_SERIAL_KGDB_NMI
 extern int kgdb_register_nmi_console(void);
diff --git a/include/linux/memory.h b/include/linux/memory.h
index bb7384e3c3d8..8b8d8d12348e 100644
--- a/include/linux/memory.h
+++ b/include/linux/memory.h
@@ -35,7 +35,7 @@ struct memory_block {
 };
 
 int arch_get_memory_phys_device(unsigned long start_pfn);
-unsigned long __weak memory_block_size_bytes(void);
+unsigned long memory_block_size_bytes(void);
 
 /* These states are exposed to userspace as text strings in sysfs */
 #define	MEM_ONLINE		(1<<0) /* exposed to userspace */
diff --git a/include/linux/string.h b/include/linux/string.h
index ac889c5ea11b..0ed878d0465c 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -129,7 +129,7 @@ int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __printf(3, 4);
 #endif
 
 extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
-			const void *from, size_t available);
+				       const void *from, size_t available);
 
 /**
  * strstarts - does @str start with @prefix?
@@ -141,7 +141,8 @@ static inline bool strstarts(const char *str, const char *prefix)
 	return strncmp(str, prefix, strlen(prefix)) == 0;
 }
 
-extern size_t memweight(const void *ptr, size_t bytes);
+size_t memweight(const void *ptr, size_t bytes);
+void memzero_explicit(void *s, size_t count);
 
 /**
  * kbasename - return the last part of a pathname.
diff --git a/lib/string.c b/lib/string.c
index 315fad2b11ff..64941b2be4ad 100644
--- a/lib/string.c
+++ b/lib/string.c
@@ -586,6 +586,22 @@ void *memset(void *s, int c, size_t count)
 EXPORT_SYMBOL(memset);
 #endif
 
+/**
+ * memzero_explicit - Fill a region of memory (e.g. sensitive
+ *		      keying data) with 0s.
+ * @s: Pointer to the start of the area.
+ * @count: The size of the area.
+ *
+ * memzero_explicit() doesn't need an arch-specific version as
+ * it just invokes the one of memset() implicitly.
+ */
+void memzero_explicit(void *s, size_t count)
+{
+	memset(s, 0, count);
+	OPTIMIZER_HIDE_VAR(s);
+}
+EXPORT_SYMBOL(memzero_explicit);
+
 #ifndef __HAVE_ARCH_MEMCPY
 /**
  * memcpy - Copy one area of memory to another
diff --git a/mm/memory.c b/mm/memory.c
index 3771c0a7b5f3..55613ed24f56 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -685,10 +685,10 @@ static void print_bad_pte(struct vm_area_struct *vma, unsigned long addr,
 	 * Choose text because data symbols depend on CONFIG_KALLSYMS_ALL=y
 	 */
 	if (vma->vm_ops)
-		printk(KERN_ALERT "vma->vm_ops->fault: %pSR\n",
+		printk(KERN_ALERT "vma->vm_ops->fault: %pAR\n",
 		       vma->vm_ops->fault);
 	if (vma->vm_file)
-		printk(KERN_ALERT "vma->vm_file->f_op->mmap: %pSR\n",
+		printk(KERN_ALERT "vma->vm_file->f_op->mmap: %pAR\n",
 		       vma->vm_file->f_op->mmap);
 	dump_stack();
 	add_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);
diff --git a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
index 0d8d592fa0f6..9c17cab72339 100644
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@ -50,7 +50,7 @@ static unsigned int inet_sk_ehashfn(const struct sock *sk)
 	return inet_ehashfn(net, laddr, lport, faddr, fport);
 }
 
-extern void gr_update_task_in_ip_table(struct task_struct *task, const struct inet_sock *inet);
+extern void gr_update_task_in_ip_table(const struct inet_sock *inet);
 
 /*
  * Allocate and initialize a new local port bind bucket.
@@ -557,7 +557,7 @@ int __inet_hash_connect(struct inet_timewait_death_row *death_row,
 			twrefcnt += inet_twsk_bind_unhash(tw, hinfo);
 		spin_unlock(&head->lock);
 
-		gr_update_task_in_ip_table(current, inet_sk(sk));
+		gr_update_task_in_ip_table(inet_sk(sk));
 
 		if (tw) {
 			inet_twsk_deschedule(tw, death_row);
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index 865d38ed475d..d32ac8c5028d 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -170,8 +170,10 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 		case IPPROTO_DCCP:
 			if (!onlyproto && (nh + offset + 4 < skb->data ||
 			     pskb_may_pull(skb, nh + offset + 4 - skb->data))) {
-				__be16 *ports = (__be16 *)exthdr;
+				__be16 *ports;
 
+				nh = skb_network_header(skb);
+				ports = (__be16 *)(nh + offset);
 				fl6->fl6_sport = ports[!!reverse];
 				fl6->fl6_dport = ports[!reverse];
 			}
@@ -180,8 +182,10 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 
 		case IPPROTO_ICMPV6:
 			if (!onlyproto && pskb_may_pull(skb, nh + offset + 2 - skb->data)) {
-				u8 *icmp = (u8 *)exthdr;
+				u8 *icmp;
 
+				nh = skb_network_header(skb);
+				icmp = (u8 *)(nh + offset);
 				fl6->fl6_icmp_type = icmp[0];
 				fl6->fl6_icmp_code = icmp[1];
 			}
@@ -192,8 +196,9 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 		case IPPROTO_MH:
 			if (!onlyproto && pskb_may_pull(skb, nh + offset + 3 - skb->data)) {
 				struct ip6_mh *mh;
-				mh = (struct ip6_mh *)exthdr;
 
+				nh = skb_network_header(skb);
+				mh = (struct ip6_mh *)(nh + offset);
 				fl6->fl6_mh_type = mh->ip6mh_type;
 			}
 			fl6->flowi6_proto = nexthdr;
diff --git a/virt/kvm/iommu.c b/virt/kvm/iommu.c
index 714b94932312..1f0dc1e5f1f0 100644
--- a/virt/kvm/iommu.c
+++ b/virt/kvm/iommu.c
@@ -43,13 +43,13 @@ static void kvm_iommu_put_pages(struct kvm *kvm,
 				gfn_t base_gfn, unsigned long npages);
 
 static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
-			   unsigned long size)
+			   unsigned long npages)
 {
 	gfn_t end_gfn;
 	pfn_t pfn;
 
 	pfn     = gfn_to_pfn_memslot(slot, gfn);
-	end_gfn = gfn + (size >> PAGE_SHIFT);
+	end_gfn = gfn + npages;
 	gfn    += 1;
 
 	if (is_error_noslot_pfn(pfn))
@@ -119,7 +119,7 @@ int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 		 * Pin all pages we are about to map in memory. This is
 		 * important because we unmap and unpin in 4kb steps later.
 		 */
-		pfn = kvm_pin_pages(slot, gfn, page_size);
+		pfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);
 		if (is_error_noslot_pfn(pfn)) {
 			gfn += 1;
 			continue;
@@ -131,7 +131,7 @@ int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 		if (r) {
 			printk(KERN_ERR "kvm_iommu_map_address:"
 			       "iommu failed to map pfn=%llx\n", pfn);
-			kvm_unpin_pages(kvm, pfn, page_size);
+			kvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);
 			goto unmap_pages;
 		}
 
