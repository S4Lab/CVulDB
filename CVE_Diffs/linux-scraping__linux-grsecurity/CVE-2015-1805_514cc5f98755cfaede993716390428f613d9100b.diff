linux-scraping__linux-grsecurity
commit 514cc5f98755cfaede993716390428f613d9100b
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Mon Jun 8 22:55:48 2015 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Mon Jun 8 22:55:48 2015 -0400

    grsec: Apply grsecurity-3.1-3.2.69-201506082246.patch
    
    commit 61d4a80220bc6bc70f8cf43f3ea3b4a36c1cf395
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Jun 8 21:15:22 2015 -0400
    
        use -std=gnu89 for HOSTCFLAGS
    
     Makefile |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 5614c872ad694f964cfbea588a55a924d4079041
    Author: Helge Deller <deller@gmx.de>
    Date:   Thu Jun 4 23:57:18 2015 +0200
    
        compat: cleanup coding in compat_get_bitmap() and compat_put_bitmap()
    
        In the functions compat_get_bitmap() and compat_put_bitmap() the
        variable nr_compat_longs stores how many compat_ulong_t words should be
        copied in a loop.
    
        The copy loop itself is this:
          if (nr_compat_longs-- > 0) {
              if (__get_user(um, umask)) return -EFAULT;
          } else {
              um = 0;
          }
    
        Since nr_compat_longs gets unconditionally decremented in each loop and
        since it's type is unsigned this could theoretically lead to out of
        bounds accesses to userspace if nr_compat_longs wraps around to
        (unsigned)(-1).
    
        Although the callers currently do not trigger out-of-bounds accesses, we
        should better implement the loop in a safe way to completely avoid such
        warp-arounds.
    
        Signed-off-by: Helge Deller <deller@gmx.de>
        Cc: Linus Torvalds <torvalds@linux-foundation.org>
        Cc: Al Viro <viro@zeniv.linux.org.uk>
    
     kernel/compat.c |    6 ++++--
     1 files changed, 4 insertions(+), 2 deletions(-)
    
    commit 737ed1a5841292f8e226093cbbbb2ca7810824b3
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Jun 8 20:58:12 2015 -0400
    
        Backport CVE-2015-1805 fix from http://seclists.org/oss-sec/2015/q2/652
    
     fs/pipe.c |   55 ++++++++++++++++++++++++++++++++-----------------------
     1 files changed, 32 insertions(+), 23 deletions(-)
    
    Signature-tree: d159b4b59e088495973f972323b863cdb4c42edd

diff --git a/Makefile b/Makefile
index 3889f72fa29c..b024b7bea7d4 100644
--- a/Makefile
+++ b/Makefile
@@ -245,7 +245,7 @@ CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -W -Wmissing-prototypes -Wstrict-prototypes -Wno-unused-parameter -Wno-missing-field-initializers -O2 -fomit-frame-pointer -fno-delete-null-pointer-checks
+HOSTCFLAGS   = -Wall -W -Wmissing-prototypes -Wstrict-prototypes -Wno-unused-parameter -Wno-missing-field-initializers -O2 -fomit-frame-pointer -fno-delete-null-pointer-checks -std=gnu89
 HOSTCFLAGS  += $(call cc-option, -Wno-empty-body)
 HOSTCXXFLAGS = -O2 -Wall -W -Wno-array-bounds
 
diff --git a/fs/pipe.c b/fs/pipe.c
index a2aefd9d5edd..db6ce8236a15 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -103,25 +103,27 @@ void pipe_wait(struct pipe_inode_info *pipe)
 }
 
 static int
-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
-			int atomic)
+pipe_iov_copy_from_user(void *addr, int *offset, struct iovec *iov,
+			size_t *remaining, int atomic)
 {
 	unsigned long copy;
 
-	while (len > 0) {
+	while (*remaining > 0) {
 		while (!iov->iov_len)
 			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
+		copy = min_t(unsigned long, *remaining, iov->iov_len);
 
 		if (atomic) {
-			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
+			if (__copy_from_user_inatomic(addr + *offset,
+						      iov->iov_base, copy))
 				return -EFAULT;
 		} else {
-			if (copy_from_user(to, iov->iov_base, copy))
+			if (copy_from_user(addr + *offset,
+					   iov->iov_base, copy))
 				return -EFAULT;
 		}
-		to += copy;
-		len -= copy;
+		*offset += copy;
+		*remaining -= copy;
 		iov->iov_base += copy;
 		iov->iov_len -= copy;
 	}
@@ -129,25 +131,27 @@ pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
 }
 
 static int
-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
-		      int atomic)
+pipe_iov_copy_to_user(struct iovec *iov, void *addr, int *offset,
+		      size_t *remaining, int atomic)
 {
 	unsigned long copy;
 
-	while (len > 0) {
+	while (*remaining > 0) {
 		while (!iov->iov_len)
 			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
+		copy = min_t(unsigned long, *remaining, iov->iov_len);
 
 		if (atomic) {
-			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
+			if (__copy_to_user_inatomic(iov->iov_base,
+						    addr + *offset, copy))
 				return -EFAULT;
 		} else {
-			if (copy_to_user(iov->iov_base, from, copy))
+			if (copy_to_user(iov->iov_base,
+					 addr + *offset, copy))
 				return -EFAULT;
 		}
-		from += copy;
-		len -= copy;
+		*offset += copy;
+		*remaining -= copy;
 		iov->iov_base += copy;
 		iov->iov_len -= copy;
 	}
@@ -383,7 +387,7 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
 			void *addr;
-			size_t chars = buf->len;
+			size_t chars = buf->len, remaining;
 			int error, atomic;
 
 			if (chars > total_len)
@@ -397,9 +401,11 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			}
 
 			atomic = !iov_fault_in_pages_write(iov, chars);
+			remaining = chars;
 redo:
 			addr = ops->map(pipe, buf, atomic);
-			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
+			error = pipe_iov_copy_to_user(iov, addr, &buf->offset,
+						      &remaining, atomic);
 			ops->unmap(pipe, buf, addr);
 			if (unlikely(error)) {
 				/*
@@ -414,7 +420,6 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 				break;
 			}
 			ret += chars;
-			buf->offset += chars;
 			buf->len -= chars;
 
 			/* Was it a packet buffer? Clean up and exit */
@@ -521,6 +526,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
 			int error, atomic = 1;
 			void *addr;
+			size_t remaining = chars;
 
 			error = ops->confirm(pipe, buf);
 			if (error)
@@ -529,8 +535,8 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			iov_fault_in_pages_read(iov, chars);
 redo1:
 			addr = ops->map(pipe, buf, atomic);
-			error = pipe_iov_copy_from_user(offset + addr, iov,
-							chars, atomic);
+			error = pipe_iov_copy_from_user(addr, &offset, iov,
+							&remaining, atomic);
 			ops->unmap(pipe, buf, addr);
 			ret = error;
 			do_wakeup = 1;
@@ -565,6 +571,8 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			struct page *page = pipe->tmp_page;
 			char *src;
 			int error, atomic = 1;
+			int offset = 0;
+			size_t remaining;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
@@ -585,14 +593,15 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 				chars = total_len;
 
 			iov_fault_in_pages_read(iov, chars);
+			remaining = chars;
 redo2:
 			if (atomic)
 				src = kmap_atomic(page, KM_USER0);
 			else
 				src = kmap(page);
 
-			error = pipe_iov_copy_from_user(src, iov, chars,
-							atomic);
+			error = pipe_iov_copy_from_user(src, &offset, iov,
+							&remaining, atomic);
 			if (atomic)
 				kunmap_atomic(src, KM_USER0);
 			else
diff --git a/kernel/compat.c b/kernel/compat.c
index f44fb27af32c..1e3815fe045d 100644
--- a/kernel/compat.c
+++ b/kernel/compat.c
@@ -856,7 +856,8 @@ long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,
 			 * bitmap. We must however ensure the end of the
 			 * kernel bitmap is zeroed.
 			 */
-			if (nr_compat_longs-- > 0) {
+			if (nr_compat_longs) {
+				nr_compat_longs--;
 				if (__get_user(um, umask))
 					return -EFAULT;
 			} else {
@@ -898,7 +899,8 @@ long compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,
 			 * We dont want to write past the end of the userspace
 			 * bitmap.
 			 */
-			if (nr_compat_longs-- > 0) {
+			if (nr_compat_longs) {
+				nr_compat_longs--;
 				if (__put_user(um, umask))
 					return -EFAULT;
 			}
