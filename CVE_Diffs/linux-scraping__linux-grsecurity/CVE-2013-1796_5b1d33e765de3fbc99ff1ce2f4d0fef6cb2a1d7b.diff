linux-scraping__linux-grsecurity
commit 5b1d33e765de3fbc99ff1ce2f4d0fef6cb2a1d7b
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Thu Mar 21 00:13:10 2013 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Thu Mar 21 00:13:10 2013 -0400

    grsec: Apply grsecurity-2.9.1-2.6.32.60-201303210008.patch
    
    commit 165cbf75043fd4fb87e7acd69026bf28f0e82a51
    Author: Andy Honig <ahonig@google.com>
    Date:   Mon Mar 11 09:34:52 2013 -0700
    
        Upstream commit: c300aa64ddf57d9c5d9c898a64b36877345dd4a9
    
        KVM: x86: fix for buffer overflow in handling of MSR_KVM_SYSTEM_TIME (CVE-2013-1796)
    
        If the guest sets the GPA of the time_page so that the request to update the
        time straddles a page then KVM will write onto an incorrect page.  The
        write is done byusing kmap atomic to get a pointer to the page for the time
        structure and then performing a memcpy to that page starting at an offset
        that the guest controls.  Well behaved guests always provide a 32-byte aligned
        address, however a malicious guest could use this to corrupt host kernel
        memory.
    
        Tested: Tested against kvmclock unit test.
    
        Signed-off-by: Andrew Honig <ahonig@google.com>
        Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    
     arch/x86/kvm/x86.c |    5 +++++
     1 files changed, 5 insertions(+), 0 deletions(-)
    
    commit 47a2883549a2231fa1dc247e3ea6a2dc1f6dc595
    Author: Andy Honig <ahonig@google.com>
    Date:   Wed Feb 20 14:49:16 2013 -0800
    
        Upstream commit: a2c118bfab8bc6b8bb213abfc35201e441693d55
    
        KVM: Fix bounds checking in ioapic indirect register reads (CVE-2013-1798)
    
        If the guest specifies a IOAPIC_REG_SELECT with an invalid value and follows
        that with a read of the IOAPIC_REG_WINDOW KVM does not properly validate
        that request.  ioapic_read_indirect contains an
        ASSERT(redir_index < IOAPIC_NUM_PINS), but the ASSERT has no effect in
        non-debug builds.  In recent kernels this allows a guest to cause a kernel
        oops by reading invalid memory.  In older kernels (pre-3.3) this allows a
        guest to read from large ranges of host memory.
    
        Tested: tested against apic unit tests.
    
        Signed-off-by: Andrew Honig <ahonig@google.com>
        Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    
     virt/kvm/ioapic.c |    7 +++++--
     1 files changed, 5 insertions(+), 2 deletions(-)
    
    commit 250401e33cee8e7eb2d34a1f3f01f7f84c80cadf
    Author: Dan Carpenter <dan.carpenter@oracle.com>
    Date:   Sat Mar 16 12:48:11 2013 +0300
    
        Upstream commit: 4502403dcf8f5c76abd4dbab8726c8e4ecb5cd34
    
        selinux: use GFP_ATOMIC under spin_lock
    
        The call tree here is:
    
        sk_clone_lock()              <- takes bh_lock_sock(newsk);
        xfrm_sk_clone_policy()
        __xfrm_sk_clone_policy()
        clone_policy()               <- uses GFP_ATOMIC for allocations
        security_xfrm_policy_clone()
        security_ops->xfrm_policy_clone_security()
        selinux_xfrm_policy_clone()
    
        Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
        Cc: stable@kernel.org
        Signed-off-by: James Morris <james.l.morris@oracle.com>
    
     security/selinux/xfrm.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 6e88421f710848759000d681d7d055c94305daef
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Mar 20 17:37:59 2013 -0400
    
        fix compilation
    
     fs/binfmt_elf.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    Signature-tree: 290ce349f172dedebb418213e6ec2e50805608cb

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index ea708b4b01a1..fe56f441ac5e 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -925,6 +925,11 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data)
 		/* ...but clean it before doing the actual write */
 		vcpu->arch.time_offset = data & ~(PAGE_MASK | 1);
 
+		/* Check that the address is 32-byte aligned. */
+		if (vcpu->arch.time_offset &
+				(sizeof(struct pvclock_vcpu_time_info) - 1))
+			break;
+
 		vcpu->arch.time_page =
 				gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);
 
diff --git a/security/selinux/xfrm.c b/security/selinux/xfrm.c
index f3cb9ed731a9..22c91e32e93b 100644
--- a/security/selinux/xfrm.c
+++ b/security/selinux/xfrm.c
@@ -309,7 +309,7 @@ int selinux_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,
 
 	if (old_ctx) {
 		new_ctx = kmalloc(sizeof(*old_ctx) + old_ctx->ctx_len,
-				  GFP_KERNEL);
+				  GFP_ATOMIC);
 		if (!new_ctx)
 			return -ENOMEM;
 
diff --git a/virt/kvm/ioapic.c b/virt/kvm/ioapic.c
index 9fe140bb38ec..69969aef0c36 100644
--- a/virt/kvm/ioapic.c
+++ b/virt/kvm/ioapic.c
@@ -71,9 +71,12 @@ static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 			u32 redir_index = (ioapic->ioregsel - 0x10) >> 1;
 			u64 redir_content;
 
-			ASSERT(redir_index < IOAPIC_NUM_PINS);
+			if (redir_index < IOAPIC_NUM_PINS)
+				redir_content =
+					ioapic->redirtbl[redir_index].bits;
+			else
+				redir_content = ~0ULL;
 
-			redir_content = ioapic->redirtbl[redir_index].bits;
 			result = (ioapic->ioregsel & 0x1) ?
 			    (redir_content >> 32) & 0xffffffff :
 			    redir_content & 0xffffffff;
