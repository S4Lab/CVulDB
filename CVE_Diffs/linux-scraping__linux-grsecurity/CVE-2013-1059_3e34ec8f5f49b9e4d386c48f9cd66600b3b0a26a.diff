linux-scraping__linux-grsecurity
commit 3e34ec8f5f49b9e4d386c48f9cd66600b3b0a26a
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Fri Jul 12 23:09:21 2013 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Fri Jul 12 23:09:21 2013 -0400

    grsec: Apply grsecurity-2.9.1-3.2.48-201307122306.patch
    
    commit 1260485ad5ba01ffbe8061990b016bbe4f5341a1
    Author: Michal Schmidt <mschmidt@redhat.com>
    Date:   Mon Jul 1 17:23:30 2013 +0200
    
        ethtool: make .get_dump_data() harder to misuse by drivers
    
        As the patch "bnx2x: remove zeroing of dump data buffer" showed,
        it is too easy implement .get_dump_data incorrectly in a driver.
    
        Let's make sure drivers cannot get confused by userspace requesting
        a too big dump.
    
        Also WARN if the driver sets dump->len to something weird and make
        sure the length reported to userspace is the actual length of data
        copied to userspace.
    
        Signed-off-by: Michal Schmidt <mschmidt@redhat.com>
        Reviewed-by: Ben Hutchings <ben@decadent.org.uk>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/core/ethtool.c |   21 ++++++++++++++++++++-
     1 files changed, 20 insertions(+), 1 deletions(-)
    
    commit a4f05ca2e193b208add48dd0bf2102d5c9389ca2
    Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Date:   Tue Jul 2 09:02:07 2013 +0800
    
        l2tp: add missing .owner to struct pppox_proto
    
        Add missing .owner of struct pppox_proto. This prevents the
        module from being removed from underneath its users.
    
        Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/l2tp/l2tp_ppp.c |    3 ++-
     1 files changed, 2 insertions(+), 1 deletions(-)
    
    commit 1bc0c45722231b226f08ed71ad8a5366fe57743f
    Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Date:   Sun Jun 30 14:37:11 2013 +1000
    
        cxgb3: Missing rtnl lock in error recovery
    
        When exercising error injection on IBM pseries machine, I hit the
        following warning:
    
        [  251.450043] RTAS: event: 89, Type: Platform Error, Severity: 2
        [  253.549822] cxgb3 0006:01:00.0: enabling device (0140 -> 0142)
        [  253.713560] cxgb3 0006:01:00.0: adapter recovering, PEX ERR 0x100
        [  254.895437] RTNL: assertion failed at net/core/dev.c (2031)
        [  254.895467] CPU: 6 PID: 5449 Comm: eehd Tainted: G        W    3.10.0-rc7-00157-gea461ab #19
        [  254.895474] Call Trace:
        [  254.895483] [c000000fac56f7d0] [c000000000014dcc] .show_stack+0x7c/0x1f0 (unreliable)
        [  254.895493] [c000000fac56f8a0] [c0000000007ba318] .dump_stack+0x28/0x3c
        [  254.895500] [c000000fac56f910] [c0000000006c0384] .netif_set_real_num_tx_queues+0x224/0x230
        [  254.895515] [c000000fac56f9b0] [d00000000ef35510] .cxgb_open+0x80/0x3f0 [cxgb3]
        [  254.895525] [c000000fac56fa50] [d00000000ef35914] .t3_resume_ports+0x94/0x100 [cxgb3]
        [  254.895533] [c000000fac56fae0] [c00000000005fc8c] .eeh_report_resume+0x8c/0xd0
        [  254.895539] [c000000fac56fb60] [c00000000005e9fc] .eeh_pe_dev_traverse+0x9c/0x190
        [  254.895545] [c000000fac56fc10] [c000000000060000] .eeh_handle_event+0x110/0x330
        [  254.895551] [c000000fac56fca0] [c000000000060350] .eeh_event_handler+0x130/0x1a0
        [  254.895558] [c000000fac56fd30] [c0000000000ad758] .kthread+0xe8/0xf0
        [  254.895566] [c000000fac56fe30] [c00000000000a05c] .ret_from_kernel_thread+0x5c/0x80
    
        It appears that t3_resume_ports() is called with the rtnl_lock held from
        the fatal error task but not from the PCI error callbacks. This fixes it.
    
        Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c |    2 ++
     1 files changed, 2 insertions(+), 0 deletions(-)
    
    commit fee9f261fe65cb61c0469180ccb82a9348b03812
    Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Date:   Mon Jul 1 20:21:30 2013 +0200
    
        ipv6: call udp_push_pending_frames when uncorking a socket with AF_INET pending data
    
        We accidentally call down to ip6_push_pending_frames when uncorking
        pending AF_INET data on a ipv6 socket. This results in the following
        splat (from Dave Jones):
    
        skbuff: skb_under_panic: text:ffffffff816765f6 len:48 put:40 head:ffff88013deb6df0 data:ffff88013deb6dec tail:0x2c end:0xc0 dev:<NULL>
        ------------[ cut here ]------------
        kernel BUG at net/core/skbuff.c:126!
        invalid opcode: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC
        Modules linked in: dccp_ipv4 dccp 8021q garp bridge stp dlci mpoa snd_seq_dummy sctp fuse hidp tun bnep nfnetlink scsi_transport_iscsi rfcomm can_raw can_bcm af_802154 appletalk caif_socket can caif ipt_ULOG x25 rose af_key pppoe pppox ipx phonet irda llc2 ppp_generic slhc p8023 psnap p8022 llc crc_ccitt atm bluetooth
        +netrom ax25 nfc rfkill rds af_rxrpc coretemp hwmon kvm_intel kvm crc32c_intel snd_hda_codec_realtek ghash_clmulni_intel microcode pcspkr snd_hda_codec_hdmi snd_hda_intel snd_hda_codec snd_hwdep usb_debug snd_seq snd_seq_device snd_pcm e1000e snd_page_alloc snd_timer ptp snd pps_core soundcore xfs libcrc32c
        CPU: 2 PID: 8095 Comm: trinity-child2 Not tainted 3.10.0-rc7+ #37
        task: ffff8801f52c2520 ti: ffff8801e6430000 task.ti: ffff8801e6430000
        RIP: 0010:[<ffffffff816e759c>]  [<ffffffff816e759c>] skb_panic+0x63/0x65
        RSP: 0018:ffff8801e6431de8  EFLAGS: 00010282
        RAX: 0000000000000086 RBX: ffff8802353d3cc0 RCX: 0000000000000006
        RDX: 0000000000003b90 RSI: ffff8801f52c2ca0 RDI: ffff8801f52c2520
        RBP: ffff8801e6431e08 R08: 0000000000000000 R09: 0000000000000000
        R10: 0000000000000001 R11: 0000000000000001 R12: ffff88022ea0c800
        R13: ffff88022ea0cdf8 R14: ffff8802353ecb40 R15: ffffffff81cc7800
        FS:  00007f5720a10740(0000) GS:ffff880244c00000(0000) knlGS:0000000000000000
        CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
        CR2: 0000000005862000 CR3: 000000022843c000 CR4: 00000000001407e0
        DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
        DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600
        Stack:
         ffff88013deb6dec 000000000000002c 00000000000000c0 ffffffff81a3f6e4
         ffff8801e6431e18 ffffffff8159a9aa ffff8801e6431e90 ffffffff816765f6
         ffffffff810b756b 0000000700000002 ffff8801e6431e40 0000fea9292aa8c0
        Call Trace:
         [<ffffffff8159a9aa>] skb_push+0x3a/0x40
         [<ffffffff816765f6>] ip6_push_pending_frames+0x1f6/0x4d0
         [<ffffffff810b756b>] ? mark_held_locks+0xbb/0x140
         [<ffffffff81694919>] udp_v6_push_pending_frames+0x2b9/0x3d0
         [<ffffffff81694660>] ? udplite_getfrag+0x20/0x20
         [<ffffffff8162092a>] udp_lib_setsockopt+0x1aa/0x1f0
         [<ffffffff811cc5e7>] ? fget_light+0x387/0x4f0
         [<ffffffff816958a4>] udpv6_setsockopt+0x34/0x40
         [<ffffffff815949f4>] sock_common_setsockopt+0x14/0x20
         [<ffffffff81593c31>] SyS_setsockopt+0x71/0xd0
         [<ffffffff816f5d54>] tracesys+0xdd/0xe2
        Code: 00 00 48 89 44 24 10 8b 87 d8 00 00 00 48 89 44 24 08 48 8b 87 e8 00 00 00 48 c7 c7 c0 04 aa 81 48 89 04 24 31 c0 e8 e1 7e ff ff <0f> 0b 55 48 89 e5 0f 0b 55 48 89 e5 0f 0b 55 48 89 e5 0f 0b 55
        RIP  [<ffffffff816e759c>] skb_panic+0x63/0x65
         RSP <ffff8801e6431de8>
    
        This patch adds a check if the pending data is of address family AF_INET
        and directly calls udp_push_ending_frames from udp_v6_push_pending_frames
        if that is the case.
    
        This bug was found by Dave Jones with trinity.
    
        (Also move the initialization of fl6 below the AF_INET check, even if
        not strictly necessary.)
    
        Cc: Dave Jones <davej@redhat.com>
        Cc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
        Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     include/net/udp.h |    1 +
     net/ipv4/udp.c    |    3 ++-
     net/ipv6/udp.c    |    7 ++++++-
     3 files changed, 9 insertions(+), 2 deletions(-)
    
    commit 4c257cabf004ccfb84605d8fab7bba27aa4673b7
    Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Date:   Tue Jul 2 08:04:05 2013 +0200
    
        ipv6: ip6_append_data_mtu did not care about pmtudisc and frag_size
    
        If the socket had an IPV6_MTU value set, ip6_append_data_mtu lost track
        of this when appending the second frame on a corked socket. This results
        in the following splat:
    
        [37598.993962] ------------[ cut here ]------------
        [37598.994008] kernel BUG at net/core/skbuff.c:2064!
        [37598.994008] invalid opcode: 0000 [#1] SMP
        [37598.994008] Modules linked in: tcp_lp uvcvideo videobuf2_vmalloc videobuf2_memops videobuf2_core videodev media vfat fat usb_storage fuse ebtable_nat xt_CHECKSUM bridge stp llc ipt_MASQUERADE nf_conntrack_netbios_ns nf_conntrack_broadcast ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat
        +nf_nat_ipv4 nf_nat iptable_mangle nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables be2iscsi iscsi_boot_sysfs bnx2i cnic uio cxgb4i cxgb4 cxgb3i cxgb3 mdio libcxgbi ib_iser rdma_cm ib_addr iw_cm ib_cm ib_sa ib_mad ib_core iscsi_tcp libiscsi_tcp libiscsi
        +scsi_transport_iscsi rfcomm bnep iTCO_wdt iTCO_vendor_support snd_hda_codec_conexant arc4 iwldvm mac80211 snd_hda_intel acpi_cpufreq mperf coretemp snd_hda_codec microcode cdc_wdm cdc_acm
        [37598.994008]  snd_hwdep cdc_ether snd_seq snd_seq_device usbnet mii joydev btusb snd_pcm bluetooth i2c_i801 e1000e lpc_ich mfd_core ptp iwlwifi pps_core snd_page_alloc mei cfg80211 snd_timer thinkpad_acpi snd tpm_tis soundcore rfkill tpm tpm_bios vhost_net tun macvtap macvlan kvm_intel kvm uinput binfmt_misc
        +dm_crypt i915 i2c_algo_bit drm_kms_helper drm i2c_core wmi video
        [37598.994008] CPU 0
        [37598.994008] Pid: 27320, comm: t2 Not tainted 3.9.6-200.fc18.x86_64 #1 LENOVO 27744PG/27744PG
        [37598.994008] RIP: 0010:[<ffffffff815443a5>]  [<ffffffff815443a5>] skb_copy_and_csum_bits+0x325/0x330
        [37598.994008] RSP: 0018:ffff88003670da18  EFLAGS: 00010202
        [37598.994008] RAX: ffff88018105c018 RBX: 0000000000000004 RCX: 00000000000006c0
        [37598.994008] RDX: ffff88018105a6c0 RSI: ffff88018105a000 RDI: ffff8801e1b0aa00
        [37598.994008] RBP: ffff88003670da78 R08: 0000000000000000 R09: ffff88018105c040
        [37598.994008] R10: ffff8801e1b0aa00 R11: 0000000000000000 R12: 000000000000fff8
        [37598.994008] R13: 00000000000004fc R14: 00000000ffff0504 R15: 0000000000000000
        [37598.994008] FS:  00007f28eea59740(0000) GS:ffff88023bc00000(0000) knlGS:0000000000000000
        [37598.994008] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
        [37598.994008] CR2: 0000003d935789e0 CR3: 00000000365cb000 CR4: 00000000000407f0
        [37598.994008] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
        [37598.994008] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
        [37598.994008] Process t2 (pid: 27320, threadinfo ffff88003670c000, task ffff88022c162ee0)
        [37598.994008] Stack:
        [37598.994008]  ffff88022e098a00 ffff88020f973fc0 0000000000000008 00000000000004c8
        [37598.994008]  ffff88020f973fc0 00000000000004c4 ffff88003670da78 ffff8801e1b0a200
        [37598.994008]  0000000000000018 00000000000004c8 ffff88020f973fc0 00000000000004c4
        [37598.994008] Call Trace:
        [37598.994008]  [<ffffffff815fc21f>] ip6_append_data+0xccf/0xfe0
        [37598.994008]  [<ffffffff8158d9f0>] ? ip_copy_metadata+0x1a0/0x1a0
        [37598.994008]  [<ffffffff81661f66>] ? _raw_spin_lock_bh+0x16/0x40
        [37598.994008]  [<ffffffff8161548d>] udpv6_sendmsg+0x1ed/0xc10
        [37598.994008]  [<ffffffff812a2845>] ? sock_has_perm+0x75/0x90
        [37598.994008]  [<ffffffff815c3693>] inet_sendmsg+0x63/0xb0
        [37598.994008]  [<ffffffff812a2973>] ? selinux_socket_sendmsg+0x23/0x30
        [37598.994008]  [<ffffffff8153a450>] sock_sendmsg+0xb0/0xe0
        [37598.994008]  [<ffffffff810135d1>] ? __switch_to+0x181/0x4a0
        [37598.994008]  [<ffffffff8153d97d>] sys_sendto+0x12d/0x180
        [37598.994008]  [<ffffffff810dfb64>] ? __audit_syscall_entry+0x94/0xf0
        [37598.994008]  [<ffffffff81020ed1>] ? syscall_trace_enter+0x231/0x240
        [37598.994008]  [<ffffffff8166a7e7>] tracesys+0xdd/0xe2
        [37598.994008] Code: fe 07 00 00 48 c7 c7 04 28 a6 81 89 45 a0 4c 89 4d b8 44 89 5d a8 e8 1b ac b1 ff 44 8b 5d a8 4c 8b 4d b8 8b 45 a0 e9 cf fe ff ff <0f> 0b 66 0f 1f 84 00 00 00 00 00 66 66 66 66 90 55 48 89 e5 48
        [37598.994008] RIP  [<ffffffff815443a5>] skb_copy_and_csum_bits+0x325/0x330
        [37598.994008]  RSP <ffff88003670da18>
        [37599.007323] ---[ end trace d69f6a17f8ac8eee ]---
    
        While there, also check if path mtu discovery is activated for this
        socket. The logic was adapted from ip6_append_data when first writing
        on the corked socket.
    
        This bug was introduced with commit
        0c1833797a5a6ec23ea9261d979aa18078720b74 ("ipv6: fix incorrect ipsec
        fragment").
    
        v2:
        a) Replace IPV6_PMTU_DISC_DO with IPV6_PMTUDISC_PROBE.
        b) Don't pass ipv6_pinfo to ip6_append_data_mtu (suggestion by Gao
           feng, thanks!).
        c) Change mtu to unsigned int, else we get a warning about
           non-matching types because of the min()-macro type-check.
    
        Acked-by: Gao feng <gaofeng@cn.fujitsu.com>
        Cc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
        Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/ipv6/ip6_output.c |   16 ++++++++++------
     1 files changed, 10 insertions(+), 6 deletions(-)
    
    commit 51eda273360f39fb15e6b1ec548379d88046a780
    Author: Tyler Hicks <tyhicks@canonical.com>
    Date:   Thu Jun 20 13:13:59 2013 -0700
    
        libceph: Fix NULL pointer dereference in auth client code
    
        A malicious monitor can craft an auth reply message that could cause a
        NULL function pointer dereference in the client's kernel.
    
        To prevent this, the auth_none protocol handler needs an empty
        ceph_auth_client_ops->build_request() function.
    
        CVE-2013-1059
    
        Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
        Reported-by: Chanam Park <chanam.park@hkpco.kr>
        Reviewed-by: Seth Arnold <seth.arnold@canonical.com>
        Reviewed-by: Sage Weil <sage@inktank.com>
        Cc: stable@vger.kernel.org
    
     net/ceph/auth_none.c |    6 ++++++
     1 files changed, 6 insertions(+), 0 deletions(-)
    
    commit 27d9c8c8bc887a5a9eae1e420cb68bd226a305e1
    Author: Eric Paris <eparis@redhat.com>
    Date:   Wed Jul 3 15:08:29 2013 -0700
    
        fork: reorder permissions when violating number of processes limits
    
        When a task is attempting to violate the RLIMIT_NPROC limit we have a
        check to see if the task is sufficiently priviledged.  The check first
        looks at CAP_SYS_ADMIN, then CAP_SYS_RESOURCE, then if the task is uid=0.
    
        A result is that tasks which are allowed by the uid=0 check are first
        checked against the security subsystem.  This results in the security
        subsystem auditting a denial for sys_admin and sys_resource and then the
        task passing the uid=0 check.
    
        This patch rearranges the code to first check uid=0, since if we pass that
        we shouldn't hit the security system at all.  We then check sys_resource,
        since it is the smallest capability which will solve the problem.  Lastly
        we check the fallback everything cap_sysadmin.  We don't want to give this
        capability many places since it is so powerful.
    
        This will eliminate many of the false positive/needless denial messages we
        get when a root task tries to violate the nproc limit.  (note that
        kthreads count against root, so on a sufficiently large machine we can
        actually get past the default limits before any userspace tasks are
        launched.)
    
        Signed-off-by: Eric Paris <eparis@redhat.com>
        Cc: Al Viro <viro@zeniv.linux.org.uk>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
     kernel/fork.c |    4 ++--
     1 files changed, 2 insertions(+), 2 deletions(-)
    
    commit 49aae3c3a876328afdd7a94cda92b7bb906ce109
    Author: Chen Gang <gang.chen@asianux.com>
    Date:   Sat Jun 22 13:26:09 2013 +0800
    
        arch: sparc: kernel: check the memory length before use strcpy().
    
        For the related next strcpy(), the destination length is less than 512,
        but the source maximize length may be 'OPROMMAXPARAM' (4096) which is
        more than 512.
    
        One work flow may:
          openprom_sunos_ioctl() ->  if (cmd == OPROMSETOPT)
            getstrings() ->  will alloc buffer with size 'OPROMMAXPARAM'.
            opromsetopt() ->  devide the buffer into 'var' and 'value'
              of_set_property() -> pass
                prom_setprop() -> pass
                  ldom_set_var()
    
        And do not mind the additional 4 alignment buffer increasing, since
        'sizeof(pkt) - sizeof(pkt.header)' is 4 alignment at least.
    
        Signed-off-by: Chen Gang <gang.chen@asianux.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     arch/sparc/kernel/ds.c |   10 ++++++++++
     1 files changed, 10 insertions(+), 0 deletions(-)
    
    Signature-tree: 776dfab376aa58a6db95359dab6f28109de6e473

diff --git a/arch/sparc/kernel/ds.c b/arch/sparc/kernel/ds.c
index 27728e138f9b..0010e923025a 100644
--- a/arch/sparc/kernel/ds.c
+++ b/arch/sparc/kernel/ds.c
@@ -783,6 +783,16 @@ void ldom_set_var(const char *var, const char *value)
 		char  *base, *p;
 		int msg_len, loops;
 
+		if (strlen(var) + strlen(value) + 2 >
+		    sizeof(pkt) - sizeof(pkt.header)) {
+			printk(KERN_ERR PFX
+				"contents length: %zu, which more than max: %lu,"
+				"so could not set (%s) variable to (%s).\n",
+				strlen(var) + strlen(value) + 2,
+				sizeof(pkt) - sizeof(pkt.header), var, value);
+			return;
+		}
+
 		memset(&pkt, 0, sizeof(pkt));
 		pkt.header.data.tag.type = DS_DATA;
 		pkt.header.data.handle = cp->handle;
diff --git a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
index 4d15c8f99c3b..1bc76895fc6e 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
@@ -3031,7 +3031,9 @@ static void t3_io_resume(struct pci_dev *pdev)
 	CH_ALERT(adapter, "adapter recovering, PEX ERR 0x%x\n",
 		 t3_read_reg(adapter, A_PCIE_PEX_ERR));
 
+	rtnl_lock();
 	t3_resume_ports(adapter);
+	rtnl_unlock();
 }
 
 static struct pci_error_handlers t3_err_handler = {
diff --git a/include/net/udp.h b/include/net/udp.h
index 3b285f402f48..e1583300b962 100644
--- a/include/net/udp.h
+++ b/include/net/udp.h
@@ -180,6 +180,7 @@ extern int udp_get_port(struct sock *sk, unsigned short snum,
 extern void udp_err(struct sk_buff *, u32);
 extern int udp_sendmsg(struct kiocb *iocb, struct sock *sk,
 			    struct msghdr *msg, size_t len);
+extern int udp_push_pending_frames(struct sock *sk);
 extern void udp_flush_pending_frames(struct sock *sk);
 extern int udp_rcv(struct sk_buff *skb);
 extern int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);
diff --git a/kernel/fork.c b/kernel/fork.c
index 8adf56ac5db5..64aeae30e7ea 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1176,8 +1176,8 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 
 	if (atomic_read(&p->real_cred->user->processes) >=
 			task_rlimit(p, RLIMIT_NPROC)) {
-		if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&
-		    p->real_cred->user != INIT_USER)
+		if (p->real_cred->user != INIT_USER &&
+		    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))
 			goto bad_fork_free;
 	}
 	current->flags &= ~PF_NPROC_EXCEEDED;
diff --git a/net/ceph/auth_none.c b/net/ceph/auth_none.c
index 214c2bb43d62..9f78c5f01a60 100644
--- a/net/ceph/auth_none.c
+++ b/net/ceph/auth_none.c
@@ -39,6 +39,11 @@ static int should_authenticate(struct ceph_auth_client *ac)
 	return xi->starting;
 }
 
+static int build_request(struct ceph_auth_client *ac, void *buf, void *end)
+{
+	return 0;
+}
+
 /*
  * the generic auth code decode the global_id, and we carry no actual
  * authenticate state, so nothing happens here.
@@ -107,6 +112,7 @@ static const struct ceph_auth_client_ops ceph_auth_none_ops = {
 	.destroy = destroy,
 	.is_authenticated = is_authenticated,
 	.should_authenticate = should_authenticate,
+	.build_request = build_request,
 	.handle_reply = handle_reply,
 	.create_authorizer = ceph_auth_none_create_authorizer,
 	.destroy_authorizer = ceph_auth_none_destroy_authorizer,
diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index 236724669855..4a0a6777e787 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -1612,10 +1612,19 @@ static int ethtool_get_dump_data(struct net_device *dev,
 	if (ret)
 		return ret;
 
-	len = (tmp.len > dump.len) ? dump.len : tmp.len;
+	len = min(tmp.len, dump.len);
 	if (!len)
 		return -EFAULT;
 
+	/* Don't ever let the driver think there's more space available
+	 * than it requested with .get_dump_flag().
+	 */
+	dump.len = len;
+
+	/* Always allocate enough space to hold the whole thing so that the
+	 * driver does not need to check the length and bother with partial
+	 * dumping.
+	 */
 	data = vzalloc(tmp.len);
 	if (!data)
 		return -ENOMEM;
@@ -1623,6 +1632,16 @@ static int ethtool_get_dump_data(struct net_device *dev,
 	if (ret)
 		goto out;
 
+	/* There are two sane possibilities:
+	 * 1. The driver's .get_dump_data() does not touch dump.len.
+	 * 2. Or it may set dump.len to how much it really writes, which
+	 *    should be tmp.len (or len if it can do a partial dump).
+	 * In any case respond to userspace with the actual length of data
+	 * it's receiving.
+	 */
+	WARN_ON(dump.len != len && dump.len != tmp.len);
+	dump.len = len;
+
 	if (copy_to_user(useraddr, &dump, sizeof(dump))) {
 		ret = -EFAULT;
 		goto out;
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index bd913a1dde39..79830d4187a1 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -774,7 +774,7 @@ static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4)
 /*
  * Push out all pending data as one UDP datagram. Socket is locked.
  */
-static int udp_push_pending_frames(struct sock *sk)
+int udp_push_pending_frames(struct sock *sk)
 {
 	struct udp_sock  *up = udp_sk(sk);
 	struct inet_sock *inet = inet_sk(sk);
@@ -793,6 +793,7 @@ static int udp_push_pending_frames(struct sock *sk)
 	up->pending = 0;
 	return err;
 }
+EXPORT_SYMBOL(udp_push_pending_frames);
 
 int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		size_t len)
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 7a0f1684ddb7..db6004364313 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -1184,11 +1184,12 @@ static inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,
 	return src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;
 }
 
-static void ip6_append_data_mtu(int *mtu,
+static void ip6_append_data_mtu(unsigned int *mtu,
 				int *maxfraglen,
 				unsigned int fragheaderlen,
 				struct sk_buff *skb,
-				struct rt6_info *rt)
+				struct rt6_info *rt,
+				bool pmtuprobe)
 {
 	if (!(rt->dst.flags & DST_XFRM_TUNNEL)) {
 		if (skb == NULL) {
@@ -1200,7 +1201,9 @@ static void ip6_append_data_mtu(int *mtu,
 			 * this fragment is not first, the headers
 			 * space is regarded as data space.
 			 */
-			*mtu = dst_mtu(rt->dst.path);
+			*mtu = min(*mtu, pmtuprobe ?
+				   rt->dst.dev->mtu :
+				   dst_mtu(rt->dst.path));
 		}
 		*maxfraglen = ((*mtu - fragheaderlen) & ~7)
 			      + fragheaderlen - sizeof(struct frag_hdr);
@@ -1217,11 +1220,10 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct inet_cork *cork;
 	struct sk_buff *skb, *skb_prev = NULL;
-	unsigned int maxfraglen, fragheaderlen;
+	unsigned int maxfraglen, fragheaderlen, mtu;
 	int exthdrlen;
 	int dst_exthdrlen;
 	int hh_len;
-	int mtu;
 	int copy;
 	int err;
 	int offset = 0;
@@ -1384,7 +1386,9 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 			/* update mtu and maxfraglen if necessary */
 			if (skb == NULL || skb_prev == NULL)
 				ip6_append_data_mtu(&mtu, &maxfraglen,
-						    fragheaderlen, skb, rt);
+						    fragheaderlen, skb, rt,
+						    np->pmtudisc ==
+						    IPV6_PMTUDISC_PROBE);
 
 			skb_prev = skb;
 
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 7d4ede11574c..729da6184ffe 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -900,11 +900,16 @@ static int udp_v6_push_pending_frames(struct sock *sk)
 	struct udphdr *uh;
 	struct udp_sock  *up = udp_sk(sk);
 	struct inet_sock *inet = inet_sk(sk);
-	struct flowi6 *fl6 = &inet->cork.fl.u.ip6;
+	struct flowi6 *fl6;
 	int err = 0;
 	int is_udplite = IS_UDPLITE(sk);
 	__wsum csum = 0;
 
+	if (up->pending == AF_INET)
+		return udp_push_pending_frames(sk);
+
+	fl6 = &inet->cork.fl.u.ip6;
+
 	/* Grab the skbuff where UDP header space exists. */
 	if ((skb = skb_peek(&sk->sk_write_queue)) == NULL)
 		goto out;
diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c
index 74410e61b420..e579006526b3 100644
--- a/net/l2tp/l2tp_ppp.c
+++ b/net/l2tp/l2tp_ppp.c
@@ -1778,7 +1778,8 @@ static const struct proto_ops pppol2tp_ops = {
 
 static const struct pppox_proto pppol2tp_proto = {
 	.create		= pppol2tp_create,
-	.ioctl		= pppol2tp_ioctl
+	.ioctl		= pppol2tp_ioctl,
+	.owner		= THIS_MODULE,
 };
 
 #ifdef CONFIG_L2TP_V3
