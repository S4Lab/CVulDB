linux-scraping__linux-grsecurity
commit 98894e8138461ec7bedc12b2697d1e9dc9d1a510
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Mon Jul 7 20:48:30 2014 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Mon Jul 7 20:48:30 2014 -0400

    grsec: Apply grsecurity-3.0-3.2.60-201407072042.patch
    
    commit 4526f7c8009b81c1de66725f95122217316050e2
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Jul 7 17:22:16 2014 -0400
    
        fix gcc warning
    
     net/netfilter/nf_conntrack_core.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit f754fafe847590003a676629746d0b76e6b34a4f
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Jul 7 16:07:41 2014 -0400
    
        Backport extra commit for safety sake:
        commit f302b21ee907f65af6434d8618d2c1a921c02d48
        Author: Andy Lutomirski <luto@amacapital.net>
        Date:   Wed Jul 2 14:52:55 2014 -0700
    
            x86_64,ptrace: Enforce RIP <= TASK_SIZE_MAX (CVE-2014-4699)
    
            Don't allow ptrace to set RIP to a value that couldn't happen by
            ordinary control flow. There are CPU bugs^Wfeatures that can have
            interesting effects if RIP is non-canonical.
    
            I didn't make the corresponding x86_32 change, since x86_32 has no
            concept of canonical addresses.
    
            putreg32 doesn't need this fix: value is only 32 bits, so it can't
            be non-canonical.
    
            Fixes CVE-2014-4699.  There are arguably still bugs here, but this
            fixes the major issue.
    
            Signed-off-by: Andy Lutomirski <luto@amacapital.net>
            CVE-2014-4699
            BugLink: http://bugs.launchpad.net/bugs/1337339
            Acked-by: Andy Whitcroft <apw@canonical.com>
            Signed-off-by: John Johansen <john.johansen@canonical.com>
            Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    
     arch/x86/kernel/ptrace.c |   14 ++++++++++++++
     1 files changed, 14 insertions(+), 0 deletions(-)
    
    Signature-tree: 44b214b14e005b14487c8e2c4bfffddf9a8b6b32

diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c
index 60e10867d5ef..c7c8aac0ee31 100644
--- a/arch/x86/kernel/ptrace.c
+++ b/arch/x86/kernel/ptrace.c
@@ -448,6 +448,20 @@ static int putreg(struct task_struct *child,
 		if (child->thread.gs != value)
 			return do_arch_prctl(child, ARCH_SET_GS, value);
 		return 0;
+
+	case offsetof(struct user_regs_struct,ip):
+		/*
+		 * Protect against any attempt to set ip to an
+		 * impossible address.  There are dragons lurking if the
+		 * address is noncanonical.  (This explicitly allows
+		 * setting ip to TASK_SIZE_MAX, because user code can do
+		 * that all by itself by running off the end of its
+		 * address space.
+		 */
+		if (value > TASK_SIZE_MAX)
+			return -EIO;
+		break;
+
 #endif
 	}
 
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 5f4df88bb893..b7a282c239f3 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -1509,7 +1509,7 @@ static int nf_conntrack_init_net(struct net *net)
 	}
 
 #ifdef CONFIG_GRKERNSEC_HIDESYM
-	net->ct.slabname = kasprintf(GFP_KERNEL, "nf_conntrack_%08lx", atomic_inc_return_unchecked(&conntrack_cache_id));
+	net->ct.slabname = kasprintf(GFP_KERNEL, "nf_conntrack_%08x", atomic_inc_return_unchecked(&conntrack_cache_id));
 #else
 	net->ct.slabname = kasprintf(GFP_KERNEL, "nf_conntrack_%p", net);
 #endif
