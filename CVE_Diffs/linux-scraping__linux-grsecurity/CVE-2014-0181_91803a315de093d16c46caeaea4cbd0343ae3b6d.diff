linux-scraping__linux-grsecurity
commit 91803a315de093d16c46caeaea4cbd0343ae3b6d
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Thu Jun 5 13:11:32 2014 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Thu Jun 5 13:11:32 2014 -0400

    grsec: Apply grsecurity-3.0-3.14.5-201406051310.patch
    
    commit 9e87724f22aa5c91e0f564f92bcf47e6e5e1c80f
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Thu Jun 5 12:35:51 2014 -0400
    
        randomize layouts of two futex structs
    
     kernel/futex.c |    4 ++--
     1 files changed, 2 insertions(+), 2 deletions(-)
    
    commit 064d5806d5d604f0179d6bba35a9ee38aedc3d36
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Mon May 12 20:45:35 2014 +0000
    
        Upstream commit: f0d71b3dcb8332f7971b5f2363632573e6d9486a
    
        futex: Prevent attaching to kernel threads
    
        We happily allow userspace to declare a random kernel thread to be the
        owner of a user space PI futex.
    
        Found while analysing the fallout of Dave Jones syscall fuzzer.
    
        We also should validate the thread group for private futexes and find
        some fast way to validate whether the "alleged" owner has RW access on
        the file which backs the SHM, but that's a separate issue.
    
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Cc: Dave Jones <davej@redhat.com>
        Cc: Linus Torvalds <torvalds@linux-foundation.org>
        Cc: Peter Zijlstra <peterz@infradead.org>
        Cc: Darren Hart <darren@dvhart.com>
        Cc: Davidlohr Bueso <davidlohr@hp.com>
        Cc: Steven Rostedt <rostedt@goodmis.org>
        Cc: Clark Williams <williams@redhat.com>
        Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
        Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
        Cc: Roland McGrath <roland@hack.frob.com>
        Cc: Carlos ODonell <carlos@redhat.com>
        Cc: Jakub Jelinek <jakub@redhat.com>
        Cc: Michael Kerrisk <mtk.manpages@gmail.com>
        Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
        Link: http://lkml.kernel.org/r/20140512201701.194824402@linutronix.de
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Cc: stable@vger.kernel.org
    
     kernel/futex.c |    5 +++++
     1 files changed, 5 insertions(+), 0 deletions(-)
    
    commit 9c7b78634a505475c3283b3178220bc97c93ea79
    Author: Ursula Braun <ursula.braun@de.ibm.com>
    Date:   Tue May 13 14:38:02 2014 +0200
    
        Upstream commit: f5738e2ef88070ef1372e6e718124d88e9abe4ac
    
        af_iucv: wrong mapping of sent and confirmed skbs
    
        When sending data through IUCV a MESSAGE COMPLETE interrupt
        signals that sent data memory can be freed or reused again.
        With commit f9c41a62bba3f3f7ef3541b2a025e3371bcbba97
        "af_iucv: fix recvmsg by replacing skb_pull() function" the
        MESSAGE COMPLETE callback iucv_callback_txdone() identifies
        the wrong skb as being confirmed, which leads to data corruption.
        This patch fixes the skb mapping logic in iucv_callback_txdone().
    
        Signed-off-by: Ursula Braun <ursula.braun@de.ibm.com>
        Signed-off-by: Frank Blaschka <frank.blaschka@de.ibm.com>
        Cc: <stable@vger.kernel.org>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/iucv/af_iucv.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 7db9658af6838283b8f765027088b9f2b5d406d9
    Author: Dan Carpenter <dan.carpenter@oracle.com>
    Date:   Fri May 23 19:37:21 2014 +0300
    
        Upstream commit: 7df566bbdd0af0785542b89466a937e94257fcfb
    
        qlcnic: info leak in qlcnic_dcb_peer_app_info()
    
        This function is called from dcbnl_build_peer_app().  The "info"
        struct isn't initialized at all so we disclose 2 bytes of uninitialized
        stack data.  We should clear it before passing it to the user.
    
        Fixes: 48365e485275 ('qlcnic: dcb: Add support for CEE Netlink interface.')
        Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     drivers/net/ethernet/qlogic/qlcnic/qlcnic_dcb.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    commit bea241de3bca2bd2d116d7d6fc4d7947333f6c93
    Author: Eric W. Biederman <ebiederm@xmission.com>
    Date:   Fri May 30 11:04:00 2014 -0700
    
        Upstream commit: 2d7a85f4b06e9c27ff629f07a524c48074f07f81
    
        netlink: Only check file credentials for implicit destinations
    
        It was possible to get a setuid root or setcap executable to write to
        it's stdout or stderr (which has been set made a netlink socket) and
        inadvertently reconfigure the networking stack.
    
        To prevent this we check that both the creator of the socket and
        the currentl applications has permission to reconfigure the network
        stack.
    
        Unfortunately this breaks Zebra which always uses sendto/sendmsg
        and creates it's socket without any privileges.
    
        To keep Zebra working don't bother checking if the creator of the
        socket has privilege when a destination address is specified.  Instead
        rely exclusively on the privileges of the sender of the socket.
    
        Note from Andy: This is exactly Eric's code except for some comment
        clarifications and formatting fixes.  Neither I nor, I think, anyone
        else is thrilled with this approach, but I'm hesitant to wait on a
        better fix since 3.15 is almost here.
    
        Note to stable maintainers: This is a mess.  An earlier series of
        patches in 3.15 fix a rather serious security issue (CVE-2014-0181),
        but they did so in a way that breaks Zebra.  The offending series
        includes:
    
            commit aa4cf9452f469f16cea8c96283b641b4576d4a7b
            Author: Eric W. Biederman <ebiederm@xmission.com>
            Date:   Wed Apr 23 14:28:03 2014 -0700
    
                net: Add variants of capable for use on netlink messages
    
        If a given kernel version is missing that series of fixes, it's
        probably worth backporting it and this patch.  if that series is
        present, then this fix is critical if you care about Zebra.
    
        Cc: stable@vger.kernel.org
        Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
        Signed-off-by: Andy Lutomirski <luto@amacapital.net>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     include/linux/netlink.h  |    7 ++++---
     net/netlink/af_netlink.c |    7 ++++++-
     2 files changed, 10 insertions(+), 4 deletions(-)
    
    commit 93f6913dfd0fc9a7dadfed16d187cb760557567d
    Author: Eric W. Biederman <ebiederm@xmission.com>
    Date:   Wed Apr 23 14:28:03 2014 -0700
    
        Upstream commit: aa4cf9452f469f16cea8c96283b641b4576d4a7b
    
        net: Add variants of capable for use on netlink messages
    
        netlink_net_capable - The common case use, for operations that are safe on a network namespace
        netlink_capable - For operations that are only known to be safe for the global root
        netlink_ns_capable - The general case of capable used to handle special cases
    
        __netlink_ns_capable - Same as netlink_ns_capable except taking a netlink_skb_parms instead of
                           the skbuff of a netlink message.
    
        Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     include/linux/netlink.h  |    7 +++++
     net/netlink/af_netlink.c |   65 ++++++++++++++++++++++++++++++++++++++++++++++
     2 files changed, 72 insertions(+), 0 deletions(-)
    
    commit 83eee88f79157580fe01a244a628f5c39f205eb8
    Author: Eric W. Biederman <ebiederm@xmission.com>
    Date:   Wed Apr 23 14:25:48 2014 -0700
    
        Upstream commit: 5187cd055b6e81fc6526109456f8b20623148d5f
    
        netlink: Rename netlink_capable netlink_allowed
    
        netlink_capable is a static internal function in af_netlink.c and we
        have better uses for the name netlink_capable.
    
        Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/netlink/af_netlink.c |   10 +++++-----
     1 files changed, 5 insertions(+), 5 deletions(-)
    
    commit b79e73e3664f6d9fdaa5db1bbb653a584026a64a
    Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Date:   Wed Jun 4 15:58:24 2014 +0200
    
        Upstream commit: 0c36b390a546055b6815d4b93a2c9fed4d980ffb
    
        percpu-refcount: fix usage of this_cpu_ops
    
        The percpu-refcount infrastructure uses the underscore variants of
        this_cpu_ops in order to modify percpu reference counters.
        (e.g. __this_cpu_inc()).
    
        However the underscore variants do not atomically update the percpu
        variable, instead they may be implemented using read-modify-write
        semantics (more than one instruction).  Therefore it is only safe to
        use the underscore variant if the context is always the same (process,
        softirq, or hardirq). Otherwise it is possible to lose updates.
    
        This problem is something that Sebastian has seen within the aio
        subsystem which uses percpu refcounters both in process and softirq
        context leading to reference counts that never dropped to zeroes; even
        though the number of "get" and "put" calls matched.
    
        Fix this by using the non-underscore this_cpu_ops variant which
        provides correct per cpu atomic semantics and fixes the corrupted
        reference counts.
    
        Cc: Kent Overstreet <kmo@daterainc.com>
        Cc: <stable@vger.kernel.org> # v3.11+
        Reported-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
        Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
        Signed-off-by: Tejun Heo <tj@kernel.org>
        References: http://lkml.kernel.org/g/alpine.LFD.2.11.1406041540520.21183@denkbrett
    
     include/linux/percpu-refcount.h |    6 +++---
     1 files changed, 3 insertions(+), 3 deletions(-)
    
    commit bdd7037701e89d9d9137f6e81336648ad6bb6d90
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Thu Jun 5 11:43:32 2014 -0400
    
        futex: Make lookup_pi_state more robust
    
        The current implementation of lookup_pi_state has ambigous handling of
        the TID value 0 in the user space futex. We can get into the kernel
        even if the TID value is 0, because either there is a stale waiters
        bit or the owner died bit is set or we are called from the requeue_pi
        path or from user space just for fun.
    
        The current code avoids an explicit sanity check for pid = 0 in case
        that kernel internal state (waiters) are found for the user space
        address. This can lead to state leakage and worse under some
        circumstances.
    
        Handle the cases explicit:
    
             Waiter | pi_state | pi->owner | uTID      | uODIED | ?
    
        [1]  NULL   | ---      | ---       | 0         | 0/1    | Valid
        [2]  NULL   | ---      | ---       | >0        | 0/1    | Valid
    
        [3]  Found  | NULL     | --        | Any       | 0/1    | Invalid
    
        [4]  Found  | Found    | NULL      | 0         | 1      | Valid
        [5]  Found  | Found    | NULL      | >0        | 1      | Invalid
    
        [6]  Found  | Found    | task      | 0         | 1      | Valid
    
        [7]  Found  | Found    | NULL      | Any       | 0      | Invalid
        [8]  Found  | Found    | task      | ==taskTID | 0/1    | Valid
        [9]  Found  | Found    | task      | 0         | 0      | Invalid
        [10] Found  | Found    | task      | !=taskTID | 0/1    | Invalid
    
        [1]  Indicates that the kernel can acquire the futex atomically. We
             came came here due to a stale FUTEX_WAITERS/FUTEX_OWNER_DIED bit.
    
        [2]  Valid, if TID does not belong to a kernel thread. If no matching
             thread is found then it indicates that the owner TID has died.
    
        [3]  Invalid. The waiter is queued on a non PI futex
    
        [4]  Valid state after exit_robust_list(), which sets the user space
             value to FUTEX_WAITERS | FUTEX_OWNER_DIED.
    
        [5]  The user space value got manipulated between exit_robust_list()
             and exit_pi_state_list()
    
        [6]  Valid state after exit_pi_state_list() which sets the new owner in
             the pi_state but cannot access the user space value.
    
        [7]  pi_state->owner can only be NULL when the OWNER_DIED bit is set.
    
        [8]  Owner and user space value match
    
        [9]  There is no transient state which sets the user space TID to 0
             except exit_robust_list(), but this is indicated by the
             FUTEX_OWNER_DIED bit. See [4]
    
        [10] There is no transient state which leaves owner and user space
             TID out of sync.
    
        Backport to 3.13
          conflicts: kernel/futex.c
    
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Signed-off-by: John Johansen <john.johansen@canonical.com>
        Cc: Kees Cook <keescook@chromium.org>
        Cc: Will Drewry <wad@chromium.org>
        Cc: Darren Hart <dvhart@linux.intel.com>
        Cc: stable@vger.kernel.org
    
     kernel/futex.c |  123 ++++++++++++++++++++++++++++++++++++++++++++++++--------
     1 files changed, 106 insertions(+), 17 deletions(-)
    
    commit 62fa4abca42b8ac782c4961ee22a2f45e8347f2c
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue Jun 3 12:27:07 2014 +0000
    
        futex: Always cleanup owner tid in unlock_pi
    
        If the owner died bit is set at futex_unlock_pi, we currently do not
        cleanup the user space futex. So the owner TID of the current owner
        (the unlocker) persists. That's observable inconsistant state,
        especially when the ownership of the pi state got transferred.
    
        Clean it up unconditionally.
    
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Cc: Kees Cook <keescook@chromium.org>
        Cc: Will Drewry <wad@chromium.org>
        Cc: Darren Hart <dvhart@linux.intel.com>
        Cc: stable@vger.kernel.org
        Signed-off-by: Brad Spengler <spender@grsecurity.net>
    
     kernel/futex.c |   40 ++++++++++++++++++----------------------
     1 files changed, 18 insertions(+), 22 deletions(-)
    
    commit b3fe7a7c6ce8135784b22649ac41ea26bd560dbc
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue Jun 3 12:27:06 2014 +0000
    
        futex: Validate atomic acquisition in
    
        We need to protect the atomic acquisition in the kernel against rogue
        user space which sets the user space futex to 0, so the kernel side
        acquisition succeeds while there is existing state in the kernel
        associated to the real owner.
    
        Verify whether the futex has waiters associated with kernel state. If
        it has, return -EINVAL. The state is corrupted already, so no point in
        cleaning it up. Subsequent calls will fail as well. Not our problem.
    
        [ tglx: Use futex_top_waiter() and explain why we do not need to try
            restoring the already corrupted user space state. ]
    
        Signed-off-by: Darren Hart <dvhart@linux.intel.com>
        Cc: Kees Cook <keescook@chromium.org>
        Cc: Will Drewry <wad@chromium.org>
        Cc: stable@vger.kernel.org
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Signed-off-by: Brad Spengler <spender@grsecurity.net>
    
     kernel/futex.c |   14 +++++++++++---
     1 files changed, 11 insertions(+), 3 deletions(-)
    
    commit 9353b65389c326aacfe98091f7f67170361a3ea9
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue Jun 3 12:27:06 2014 +0000
    
        futex-prevent-requeue-pi-on-same-futex.patch
    
        If uaddr == uaddr2, then we have broken the rule of only requeueing
        from a non-pi futex to a pi futex with this call. If we attempt this,
        then dangling pointers may be left for rt_waiter resulting in an
        exploitable condition.
    
        This change brings futex_requeue() into line with
        futex_wait_requeue_pi() which performs the same check as per commit
        6f7b0a2a5 (futex: Forbid uaddr == uaddr2 in futex_wait_requeue_pi())
    
        [ tglx: Compare the resulting keys as well, as uaddrs might be
            different depending on the mapping ]
    
        Fixes CVE-2014-3153.
    
        Reported-by: Pinkie Pie
        Signed-off-by: Will Drewry <wad@chromium.org>
        Signed-off-by: Kees Cook <keescook@chromium.org>
        Cc: stable@vger.kernel.org
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Signed-off-by: Brad Spengler <spender@grsecurity.net>
    
     kernel/futex.c |   25 +++++++++++++++++++++++++
     1 files changed, 25 insertions(+), 0 deletions(-)
    
    commit 5f91521cf6929379a912ebc9ede7957afc8812a3
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Tue Jun 3 09:49:01 2014 -0400
    
        fix compiler warning
    
     fs/exec.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    Signature-tree: 49da7d6efe35083120adc56603cf776390e3507f

diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_dcb.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_dcb.c
index 7d4f54912bad..3e46c894a107 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_dcb.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_dcb.c
@@ -1022,6 +1022,7 @@ static int qlcnic_dcb_peer_app_info(struct net_device *netdev,
 	struct qlcnic_dcb_cee *peer;
 	int i;
 
+	memset(info, 0, sizeof(*info));
 	*app_count = 0;
 
 	if (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))
diff --git a/fs/exec.c b/fs/exec.c
index 75b208f4e1c7..6b2fd7099bd0 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -2052,7 +2052,7 @@ void __check_object_size(const void *ptr, unsigned long n, bool to_user, bool co
 #endif
 
 #ifndef CONFIG_STACK_GROWSUP
-	const void * stackstart = task_stack_page(current);
+	unsigned long stackstart = (unsigned long)task_stack_page(current);
 	if (unlikely(current_stack_pointer < stackstart + 512 ||
 		     current_stack_pointer >= stackstart + THREAD_SIZE))
 		BUG();
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index aad8eeaf416d..034cda789a15 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -16,9 +16,10 @@ static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
 }
 
 enum netlink_skb_flags {
-	NETLINK_SKB_MMAPED	= 0x1,		/* Packet data is mmaped */
-	NETLINK_SKB_TX		= 0x2,		/* Packet was sent by userspace */
-	NETLINK_SKB_DELIVERED	= 0x4,		/* Packet was delivered */
+	NETLINK_SKB_MMAPED	= 0x1,	/* Packet data is mmaped */
+	NETLINK_SKB_TX		= 0x2,	/* Packet was sent by userspace */
+	NETLINK_SKB_DELIVERED	= 0x4,	/* Packet was delivered */
+	NETLINK_SKB_DST		= 0x8,	/* Dst set in sendto or sendmsg */
 };
 
 struct netlink_skb_parms {
@@ -169,4 +170,11 @@ struct netlink_tap {
 extern int netlink_add_tap(struct netlink_tap *nt);
 extern int netlink_remove_tap(struct netlink_tap *nt);
 
+bool __netlink_ns_capable(const struct netlink_skb_parms *nsp,
+			  struct user_namespace *ns, int cap);
+bool netlink_ns_capable(const struct sk_buff *skb,
+			struct user_namespace *ns, int cap);
+bool netlink_capable(const struct sk_buff *skb, int cap);
+bool netlink_net_capable(const struct sk_buff *skb, int cap);
+
 #endif	/* __LINUX_NETLINK_H */
diff --git a/include/linux/percpu-refcount.h b/include/linux/percpu-refcount.h
index 95961f0bf62d..0afb48fd449d 100644
--- a/include/linux/percpu-refcount.h
+++ b/include/linux/percpu-refcount.h
@@ -110,7 +110,7 @@ static inline void percpu_ref_get(struct percpu_ref *ref)
 	pcpu_count = ACCESS_ONCE(ref->pcpu_count);
 
 	if (likely(REF_STATUS(pcpu_count) == PCPU_REF_PTR))
-		__this_cpu_inc(*pcpu_count);
+		this_cpu_inc(*pcpu_count);
 	else
 		atomic_inc(&ref->count);
 
@@ -139,7 +139,7 @@ static inline bool percpu_ref_tryget(struct percpu_ref *ref)
 	pcpu_count = ACCESS_ONCE(ref->pcpu_count);
 
 	if (likely(REF_STATUS(pcpu_count) == PCPU_REF_PTR)) {
-		__this_cpu_inc(*pcpu_count);
+		this_cpu_inc(*pcpu_count);
 		ret = true;
 	}
 
@@ -164,7 +164,7 @@ static inline void percpu_ref_put(struct percpu_ref *ref)
 	pcpu_count = ACCESS_ONCE(ref->pcpu_count);
 
 	if (likely(REF_STATUS(pcpu_count) == PCPU_REF_PTR))
-		__this_cpu_dec(*pcpu_count);
+		this_cpu_dec(*pcpu_count);
 	else if (unlikely(atomic_dec_and_test(&ref->count)))
 		ref->release(ref);
 
diff --git a/kernel/futex.c b/kernel/futex.c
index bb6becca8bf4..c0f67cfbaa1d 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -189,7 +189,7 @@ struct futex_pi_state {
 	atomic_t refcount;
 
 	union futex_key key;
-};
+} __randomize_layout;
 
 /**
  * struct futex_q - The hashed futex queue entry, one per waiting task
@@ -223,7 +223,7 @@ struct futex_q {
 	struct rt_mutex_waiter *rt_waiter;
 	union futex_key *requeue_pi_key;
 	u32 bitset;
-};
+} __randomize_layout;
 
 static const struct futex_q futex_q_init = {
 	/* list gets initialized in queue_me()*/
@@ -735,6 +735,55 @@ void exit_pi_state_list(struct task_struct *curr)
 	raw_spin_unlock_irq(&curr->pi_lock);
 }
 
+/*
+ * We need to check the following states:
+ *
+ *      Waiter | pi_state | pi->owner | uTID      | uODIED | ?
+ *
+ * [1]  NULL   | ---      | ---       | 0         | 0/1    | Valid
+ * [2]  NULL   | ---      | ---       | >0        | 0/1    | Valid
+ *
+ * [3]  Found  | NULL     | --        | Any       | 0/1    | Invalid
+ *
+ * [4]  Found  | Found    | NULL      | 0         | 1      | Valid
+ * [5]  Found  | Found    | NULL      | >0        | 1      | Invalid
+ *
+ * [6]  Found  | Found    | task      | 0         | 1      | Valid
+ *
+ * [7]  Found  | Found    | NULL      | Any       | 0      | Invalid
+ *
+ * [8]  Found  | Found    | task      | ==taskTID | 0/1    | Valid
+ * [9]  Found  | Found    | task      | 0         | 0      | Invalid
+ * [10] Found  | Found    | task      | !=taskTID | 0/1    | Invalid
+ *
+ * [1]	Indicates that the kernel can acquire the futex atomically. We
+ *	came came here due to a stale FUTEX_WAITERS/FUTEX_OWNER_DIED bit.
+ *
+ * [2]	Valid, if TID does not belong to a kernel thread. If no matching
+ *      thread is found then it indicates that the owner TID has died.
+ *
+ * [3]	Invalid. The waiter is queued on a non PI futex
+ *
+ * [4]	Valid state after exit_robust_list(), which sets the user space
+ *	value to FUTEX_WAITERS | FUTEX_OWNER_DIED.
+ *
+ * [5]	The user space value got manipulated between exit_robust_list()
+ *	and exit_pi_state_list()
+ *
+ * [6]	Valid state after exit_pi_state_list() which sets the new owner in
+ *	the pi_state but cannot access the user space value.
+ *
+ * [7]	pi_state->owner can only be NULL when the OWNER_DIED bit is set.
+ *
+ * [8]	Owner and user space value match
+ *
+ * [9]	There is no transient state which sets the user space TID to 0
+ *	except exit_robust_list(), but this is indicated by the
+ *	FUTEX_OWNER_DIED bit. See [4]
+ *
+ * [10] There is no transient state which leaves owner and user space
+ *	TID out of sync.
+ */
 static int
 lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 		union futex_key *key, struct futex_pi_state **ps)
@@ -747,12 +796,13 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 	plist_for_each_entry_safe(this, next, &hb->chain, list) {
 		if (match_futex(&this->key, key)) {
 			/*
-			 * Another waiter already exists - bump up
-			 * the refcount and return its pi_state:
+			 * Sanity check the waiter before increasing
+			 * the refcount and attaching to it.
 			 */
 			pi_state = this->pi_state;
 			/*
-			 * Userspace might have messed up non-PI and PI futexes
+			 * Userspace might have messed up non-PI and
+			 * PI futexes [3]
 			 */
 			if (unlikely(!pi_state))
 				return -EINVAL;
@@ -760,34 +810,70 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 			WARN_ON(!atomic_read(&pi_state->refcount));
 
 			/*
-			 * When pi_state->owner is NULL then the owner died
-			 * and another waiter is on the fly. pi_state->owner
-			 * is fixed up by the task which acquires
-			 * pi_state->rt_mutex.
-			 *
-			 * We do not check for pid == 0 which can happen when
-			 * the owner died and robust_list_exit() cleared the
-			 * TID.
+			 * Handle the owner died case:
 			 */
-			if (pid && pi_state->owner) {
+			if (uval & FUTEX_OWNER_DIED) {
+				/*
+				 * exit_pi_state_list sets owner to NULL and
+				 * wakes the topmost waiter. The task which
+				 * acquires the pi_state->rt_mutex will fixup
+				 * owner.
+				 */
+				if (!pi_state->owner) {
+					/*
+					 * No pi state owner, but the user
+					 * space TID is not 0. Inconsistent
+					 * state. [5]
+					 */
+					if (pid)
+						return -EINVAL;
+					/*
+					 * Take a ref on the state and
+					 * return. [4]
+					 */
+					goto out_state;
+				}
+
 				/*
-				 * Bail out if user space manipulated the
-				 * futex value.
+				 * If TID is 0, then either the dying owner
+				 * has not yet executed exit_pi_state_list()
+				 * or some waiter acquired the rtmutex in the
+				 * pi state, but did not yet fixup the TID in
+				 * user space.
+				 *
+				 * Take a ref on the state and return. [6]
 				 */
-				if (pid != task_pid_vnr(pi_state->owner))
+				if (!pid)
+					goto out_state;
+			} else {
+				/*
+				 * If the owner died bit is not set,
+				 * then the pi_state must have an
+				 * owner. [7]
+				 */
+				if (!pi_state->owner)
 					return -EINVAL;
 			}
 
+			/*
+			 * Bail out if user space manipulated the
+			 * futex value. If pi state exists then the
+			 * owner TID must be the same as the user
+			 * space TID. [9/10]
+			 */
+			if (pid != task_pid_vnr(pi_state->owner))
+				return -EINVAL;
+
+		out_state:
 			atomic_inc(&pi_state->refcount);
 			*ps = pi_state;
-
 			return 0;
 		}
 	}
 
 	/*
 	 * We are the first waiter - try to look up the real owner and attach
-	 * the new pi_state to it, but bail out when TID = 0
+	 * the new pi_state to it, but bail out when TID = 0 [1]
 	 */
 	if (!pid)
 		return -ESRCH;
@@ -795,6 +881,11 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 	if (!p)
 		return -ESRCH;
 
+	if (!p->mm) {
+		put_task_struct(p);
+		return -EPERM;
+	}
+
 	/*
 	 * We need to look at the task state flags to figure out,
 	 * whether the task is exiting. To protect against the do_exit
@@ -815,6 +906,9 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 		return ret;
 	}
 
+	/*
+	 * No existing pi state. First waiter. [2]
+	 */
 	pi_state = alloc_pi_state();
 
 	/*
@@ -886,10 +980,18 @@ static int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,
 		return -EDEADLK;
 
 	/*
-	 * Surprise - we got the lock. Just return to userspace:
+	 * Surprise - we got the lock, but we do not trust user space at all.
 	 */
-	if (unlikely(!curval))
-		return 1;
+	if (unlikely(!curval)) {
+		/*
+		 * We verify whether there is kernel state for this
+		 * futex. If not, we can safely assume, that the 0 ->
+		 * TID transition is correct. If state exists, we do
+		 * not bother to fixup the user space state as it was
+		 * corrupted already.
+		 */
+		return futex_top_waiter(hb, key) ? -EINVAL : 1;
+	}
 
 	uval = curval;
 
@@ -1020,6 +1122,7 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)
 	struct task_struct *new_owner;
 	struct futex_pi_state *pi_state = this->pi_state;
 	u32 uninitialized_var(curval), newval;
+	int ret = 0;
 
 	if (!pi_state)
 		return -EINVAL;
@@ -1043,23 +1146,19 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)
 		new_owner = this->task;
 
 	/*
-	 * We pass it to the next owner. (The WAITERS bit is always
-	 * kept enabled while there is PI state around. We must also
-	 * preserve the owner died bit.)
+	 * We pass it to the next owner. The WAITERS bit is always
+	 * kept enabled while there is PI state around. We cleanup the
+	 * owner died bit, because we are the owner.
 	 */
-	if (!(uval & FUTEX_OWNER_DIED)) {
-		int ret = 0;
-
-		newval = FUTEX_WAITERS | task_pid_vnr(new_owner);
+	newval = FUTEX_WAITERS | task_pid_vnr(new_owner);
 
-		if (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))
-			ret = -EFAULT;
-		else if (curval != uval)
-			ret = -EINVAL;
-		if (ret) {
-			raw_spin_unlock(&pi_state->pi_mutex.wait_lock);
-			return ret;
-		}
+	if (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))
+		ret = -EFAULT;
+	else if (curval != uval)
+		ret = -EINVAL;
+	if (ret) {
+		raw_spin_unlock(&pi_state->pi_mutex.wait_lock);
+		return ret;
 	}
 
 	raw_spin_lock_irq(&pi_state->owner->pi_lock);
@@ -1416,6 +1515,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	u32 curval2;
 
 	if (requeue_pi) {
+		/*
+		 * Requeue PI only works on two distinct uaddrs. This
+		 * check is only valid for private futexes. See below.
+		 */
+		if (uaddr1 == uaddr2)
+			return -EINVAL;
+
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
@@ -1454,6 +1560,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (requeue_pi && match_futex(&key1, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
@@ -2293,9 +2408,10 @@ static int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)
 	/*
 	 * To avoid races, try to do the TID -> 0 atomic transition
 	 * again. If it succeeds then we can return without waking
-	 * anyone else up:
+	 * anyone else up. We only try this if neither the waiters nor
+	 * the owner died bit are set.
 	 */
-	if (!(uval & FUTEX_OWNER_DIED) &&
+	if (!(uval & ~FUTEX_TID_MASK) &&
 	    cmpxchg_futex_value_locked(&uval, uaddr, vpid, 0))
 		goto pi_faulted;
 	/*
@@ -2325,11 +2441,9 @@ static int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)
 	/*
 	 * No waiters - kernel unlocks the futex:
 	 */
-	if (!(uval & FUTEX_OWNER_DIED)) {
-		ret = unlock_futex_pi(uaddr, uval);
-		if (ret == -EFAULT)
-			goto pi_faulted;
-	}
+	ret = unlock_futex_pi(uaddr, uval);
+	if (ret == -EFAULT)
+		goto pi_faulted;
 
 out_unlock:
 	spin_unlock(&hb->lock);
@@ -2491,6 +2605,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	if (ret)
 		goto out_key2;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (match_futex(&q.key, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
 	futex_wait_queue_me(hb, &q, to);
 
diff --git a/net/iucv/af_iucv.c b/net/iucv/af_iucv.c
index 3e832594be4d..c7e9f1417867 100644
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@ -1829,7 +1829,7 @@ static void iucv_callback_txdone(struct iucv_path *path,
 		spin_lock_irqsave(&list->lock, flags);
 
 		while (list_skb != (struct sk_buff *)list) {
-			if (msg->tag != IUCV_SKB_CB(list_skb)->tag) {
+			if (msg->tag == IUCV_SKB_CB(list_skb)->tag) {
 				this = list_skb;
 				break;
 			}
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index ca8f86fcf204..c72ef1f3e594 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -1360,7 +1360,74 @@ static int netlink_autobind(struct socket *sock)
 	return err;
 }
 
-static inline int netlink_capable(const struct socket *sock, unsigned int flag)
+/**
+ * __netlink_ns_capable - General netlink message capability test
+ * @nsp: NETLINK_CB of the socket buffer holding a netlink command from userspace.
+ * @user_ns: The user namespace of the capability to use
+ * @cap: The capability to use
+ *
+ * Test to see if the opener of the socket we received the message
+ * from had when the netlink socket was created and the sender of the
+ * message has has the capability @cap in the user namespace @user_ns.
+ */
+bool __netlink_ns_capable(const struct netlink_skb_parms *nsp,
+			struct user_namespace *user_ns, int cap)
+{
+	return ((nsp->flags & NETLINK_SKB_DST) ||
+		file_ns_capable(nsp->sk->sk_socket->file, user_ns, cap)) &&
+		ns_capable(user_ns, cap);
+}
+EXPORT_SYMBOL(__netlink_ns_capable);
+
+/**
+ * netlink_ns_capable - General netlink message capability test
+ * @skb: socket buffer holding a netlink command from userspace
+ * @user_ns: The user namespace of the capability to use
+ * @cap: The capability to use
+ *
+ * Test to see if the opener of the socket we received the message
+ * from had when the netlink socket was created and the sender of the
+ * message has has the capability @cap in the user namespace @user_ns.
+ */
+bool netlink_ns_capable(const struct sk_buff *skb,
+			struct user_namespace *user_ns, int cap)
+{
+	return __netlink_ns_capable(&NETLINK_CB(skb), user_ns, cap);
+}
+EXPORT_SYMBOL(netlink_ns_capable);
+
+/**
+ * netlink_capable - Netlink global message capability test
+ * @skb: socket buffer holding a netlink command from userspace
+ * @cap: The capability to use
+ *
+ * Test to see if the opener of the socket we received the message
+ * from had when the netlink socket was created and the sender of the
+ * message has has the capability @cap in all user namespaces.
+ */
+bool netlink_capable(const struct sk_buff *skb, int cap)
+{
+	return netlink_ns_capable(skb, &init_user_ns, cap);
+}
+EXPORT_SYMBOL(netlink_capable);
+
+/**
+ * netlink_net_capable - Netlink network namespace message capability test
+ * @skb: socket buffer holding a netlink command from userspace
+ * @cap: The capability to use
+ *
+ * Test to see if the opener of the socket we received the message
+ * from had when the netlink socket was created and the sender of the
+ * message has has the capability @cap over the network namespace of
+ * the socket we received the message from.
+ */
+bool netlink_net_capable(const struct sk_buff *skb, int cap)
+{
+	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
+}
+EXPORT_SYMBOL(netlink_net_capable);
+
+static inline int netlink_allowed(const struct socket *sock, unsigned int flag)
 {
 	return (nl_table[sock->sk->sk_protocol].flags & flag) ||
 		ns_capable(sock_net(sock->sk)->user_ns, CAP_NET_ADMIN);
@@ -1428,7 +1495,7 @@ static int netlink_bind(struct socket *sock, struct sockaddr *addr,
 
 	/* Only superuser is allowed to listen multicasts */
 	if (nladdr->nl_groups) {
-		if (!netlink_capable(sock, NL_CFG_F_NONROOT_RECV))
+		if (!netlink_allowed(sock, NL_CFG_F_NONROOT_RECV))
 			return -EPERM;
 		err = netlink_realloc_groups(sk);
 		if (err)
@@ -1490,7 +1557,7 @@ static int netlink_connect(struct socket *sock, struct sockaddr *addr,
 		return -EINVAL;
 
 	if ((nladdr->nl_groups || nladdr->nl_pid) &&
-	    !netlink_capable(sock, NL_CFG_F_NONROOT_SEND))
+	    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))
 		return -EPERM;
 
 	if (!nlk->portid)
@@ -2096,7 +2163,7 @@ static int netlink_setsockopt(struct socket *sock, int level, int optname,
 		break;
 	case NETLINK_ADD_MEMBERSHIP:
 	case NETLINK_DROP_MEMBERSHIP: {
-		if (!netlink_capable(sock, NL_CFG_F_NONROOT_RECV))
+		if (!netlink_allowed(sock, NL_CFG_F_NONROOT_RECV))
 			return -EPERM;
 		err = netlink_realloc_groups(sk);
 		if (err)
@@ -2228,6 +2295,7 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	struct sk_buff *skb;
 	int err;
 	struct scm_cookie scm;
+	u32 netlink_skb_flags = 0;
 
 	if (msg->msg_flags&MSG_OOB)
 		return -EOPNOTSUPP;
@@ -2247,8 +2315,9 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
 		if ((dst_group || dst_portid) &&
-		    !netlink_capable(sock, NL_CFG_F_NONROOT_SEND))
+		    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))
 			goto out;
+		netlink_skb_flags |= NETLINK_SKB_DST;
 	} else {
 		dst_portid = nlk->dst_portid;
 		dst_group = nlk->dst_group;
@@ -2278,6 +2347,7 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	NETLINK_CB(skb).portid	= nlk->portid;
 	NETLINK_CB(skb).dst_group = dst_group;
 	NETLINK_CB(skb).creds	= siocb->scm->creds;
+	NETLINK_CB(skb).flags	= netlink_skb_flags;
 
 	err = -EFAULT;
 	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
