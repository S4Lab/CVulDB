linux-scraping__linux-grsecurity
commit 51c162884cedb0ff4615b7167e00a901b937fae8
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Thu Jun 5 13:11:43 2014 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Thu Jun 5 13:11:43 2014 -0400

    grsec: Apply grsecurity-3.0-3.2.59-201406051309.patch
    
    commit a3d64cfb85e859de3464c2dcf94f33a3a32dbfd5
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Thu Jun 5 12:33:38 2014 -0400
    
        randomize layouts of two futex structs
    
     kernel/futex.c |    4 ++--
     1 files changed, 2 insertions(+), 2 deletions(-)
    
    commit c806e64af3e3c62c371707ceaebe8dcd64a89501
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Mon May 12 20:45:35 2014 +0000
    
        Upstream commit: f0d71b3dcb8332f7971b5f2363632573e6d9486a
    
        futex: Prevent attaching to kernel threads
    
        We happily allow userspace to declare a random kernel thread to be the
        owner of a user space PI futex.
    
        Found while analysing the fallout of Dave Jones syscall fuzzer.
    
        We also should validate the thread group for private futexes and find
        some fast way to validate whether the "alleged" owner has RW access on
        the file which backs the SHM, but that's a separate issue.
    
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Cc: Dave Jones <davej@redhat.com>
        Cc: Linus Torvalds <torvalds@linux-foundation.org>
        Cc: Peter Zijlstra <peterz@infradead.org>
        Cc: Darren Hart <darren@dvhart.com>
        Cc: Davidlohr Bueso <davidlohr@hp.com>
        Cc: Steven Rostedt <rostedt@goodmis.org>
        Cc: Clark Williams <williams@redhat.com>
        Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
        Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
        Cc: Roland McGrath <roland@hack.frob.com>
        Cc: Carlos ODonell <carlos@redhat.com>
        Cc: Jakub Jelinek <jakub@redhat.com>
        Cc: Michael Kerrisk <mtk.manpages@gmail.com>
        Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
        Link: http://lkml.kernel.org/r/20140512201701.194824402@linutronix.de
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Cc: stable@vger.kernel.org
    
     kernel/futex.c |    5 +++++
     1 files changed, 5 insertions(+), 0 deletions(-)
    
    commit 0bb5fb443fb3ec3e5430cc63c42f835b7e8dbcaa
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue Jun 3 12:27:08 2014 +0000
    
        futex: Make lookup_pi_state more robust
    
        The current implementation of lookup_pi_state has ambigous handling of
        the TID value 0 in the user space futex. We can get into the kernel
        even if the TID value is 0, because either there is a stale waiters
        bit or the owner died bit is set or we are called from the requeue_pi
        path or from user space just for fun.
    
        The current code avoids an explicit sanity check for pid = 0 in case
        that kernel internal state (waiters) are found for the user space
        address. This can lead to state leakage and worse under some
        circumstances.
    
        Handle the cases explicit:
    
             Waiter | pi_state | pi->owner | uTID      | uODIED | ?
    
        [1]  NULL   | ---      | ---       | 0         | 0/1    | Valid
        [2]  NULL   | ---      | ---       | >0        | 0/1    | Valid
    
        [3]  Found  | NULL     | --        | Any       | 0/1    | Invalid
    
        [4]  Found  | Found    | NULL      | 0         | 1      | Valid
        [5]  Found  | Found    | NULL      | >0        | 1      | Invalid
    
        [6]  Found  | Found    | task      | 0         | 1      | Valid
    
        [7]  Found  | Found    | NULL      | Any       | 0      | Invalid
    
        [8]  Found  | Found    | task      | ==taskTID | 0/1    | Valid
        [9]  Found  | Found    | task      | 0         | 0      | Invalid
        [10] Found  | Found    | task      | !=taskTID | 0/1    | Invalid
    
        [1]  Indicates that the kernel can acquire the futex atomically. We
             came came here due to a stale FUTEX_WAITERS/FUTEX_OWNER_DIED bit.
    
        [2]  Valid, if TID does not belong to a kernel thread. If no matching
             thread is found then it indicates that the owner TID has died.
    
        [3]  Invalid. The waiter is queued on a non PI futex
    
        [4]  Valid state after exit_robust_list(), which sets the user space
             value to FUTEX_WAITERS | FUTEX_OWNER_DIED.
    
        [5]  The user space value got manipulated between exit_robust_list()
             and exit_pi_state_list()
    
        [6]  Valid state after exit_pi_state_list() which sets the new owner in
             the pi_state but cannot access the user space value.
    
        [7]  pi_state->owner can only be NULL when the OWNER_DIED bit is set.
    
        [8]  Owner and user space value match
    
        [9]  There is no transient state which sets the user space TID to 0
             except exit_robust_list(), but this is indicated by the
             FUTEX_OWNER_DIED bit. See [4]
    
        [10] There is no transient state which leaves owner and user space
             TID out of sync.
    
        Backport to 3.13
          conflicts: kernel/futex.c
    
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Signed-off-by: John Johansen <john.johansen@canonical.com>
        Cc: Kees Cook <keescook@chromium.org>
        Cc: Will Drewry <wad@chromium.org>
        Cc: Darren Hart <dvhart@linux.intel.com>
        Cc: stable@vger.kernel.org
        Signed-off-by: Brad Spengler <spender@grsecurity.net>
    
     kernel/futex.c |  123 ++++++++++++++++++++++++++++++++++++++++++++++++--------
     1 files changed, 106 insertions(+), 17 deletions(-)
    
    commit 2df614887f85813e24ae89492efd29d66b959f57
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue Jun 3 12:27:07 2014 +0000
    
        futex: Always cleanup owner tid in unlock_pi
    
        If the owner died bit is set at futex_unlock_pi, we currently do not
        cleanup the user space futex. So the owner TID of the current owner
        (the unlocker) persists. That's observable inconsistant state,
        especially when the ownership of the pi state got transferred.
    
        Clean it up unconditionally.
    
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Cc: Kees Cook <keescook@chromium.org>
        Cc: Will Drewry <wad@chromium.org>
        Cc: Darren Hart <dvhart@linux.intel.com>
        Cc: stable@vger.kernel.org
        Signed-off-by: Brad Spengler <spender@grsecurity.net>
    
     kernel/futex.c |   40 ++++++++++++++++++----------------------
     1 files changed, 18 insertions(+), 22 deletions(-)
    
    commit 348e435c71215446448474427c173801cc509a63
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue Jun 3 12:27:06 2014 +0000
    
        futex: Validate atomic acquisition in futex_lock_pi_atomic()
    
        We need to protect the atomic acquisition in the kernel against rogue
        user space which sets the user space futex to 0, so the kernel side
        acquisition succeeds while there is existing state in the kernel
        associated to the real owner.
    
        Verify whether the futex has waiters associated with kernel state. If
        it has, return -EINVAL. The state is corrupted already, so no point in
        cleaning it up. Subsequent calls will fail as well. Not our problem.
    
        [ tglx: Use futex_top_waiter() and explain why we do not need to try
            restoring the already corrupted user space state. ]
    
        Signed-off-by: Darren Hart <dvhart@linux.intel.com>
        Cc: Kees Cook <keescook@chromium.org>
        Cc: Will Drewry <wad@chromium.org>
        Cc: stable@vger.kernel.org
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Signed-off-by: Brad Spengler <spender@grsecurity.net>
    
     kernel/futex.c |   14 +++++++++++---
     1 files changed, 11 insertions(+), 3 deletions(-)
    
    commit 8688b2037d58dc0d5b105abb9621e7194cf83815
    Author: Thomas Gleixner <tglx@linutronix.de>
    Date:   Tue Jun 3 12:27:06 2014 +0000
    
        futex-prevent-requeue-pi-on-same-futex.patch futex: Forbid uaddr == uaddr2 in futex_requeue(..., requeue_pi=1)
    
        If uaddr == uaddr2, then we have broken the rule of only requeueing
        from a non-pi futex to a pi futex with this call. If we attempt this,
        then dangling pointers may be left for rt_waiter resulting in an
        exploitable condition.
    
        This change brings futex_requeue() into line with
        futex_wait_requeue_pi() which performs the same check as per commit
        6f7b0a2a5 (futex: Forbid uaddr == uaddr2 in futex_wait_requeue_pi())
    
        [ tglx: Compare the resulting keys as well, as uaddrs might be
            different depending on the mapping ]
    
        Fixes CVE-2014-3153.
    
        Reported-by: Pinkie Pie
        Signed-off-by: Will Drewry <wad@chromium.org>
        Signed-off-by: Kees Cook <keescook@chromium.org>
        Cc: stable@vger.kernel.org
        Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
        Signed-off-by: Brad Spengler <spender@grsecurity.net>
    
     kernel/futex.c |   25 +++++++++++++++++++++++++
     1 files changed, 25 insertions(+), 0 deletions(-)
    
    Signature-tree: 22ab3c0e8ca18feaf33621ae2a9a9adf770e63f7

diff --git a/kernel/futex.c b/kernel/futex.c
index 9a6f6fbe5478..36459d86c260 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -98,7 +98,7 @@ struct futex_pi_state {
 	atomic_t refcount;
 
 	union futex_key key;
-};
+} __randomize_layout;
 
 /**
  * struct futex_q - The hashed futex queue entry, one per waiting task
@@ -132,7 +132,7 @@ struct futex_q {
 	struct rt_mutex_waiter *rt_waiter;
 	union futex_key *requeue_pi_key;
 	u32 bitset;
-};
+} __randomize_layout;
 
 static const struct futex_q futex_q_init = {
 	/* list gets initialized in queue_me()*/
@@ -594,6 +594,55 @@ void exit_pi_state_list(struct task_struct *curr)
 	raw_spin_unlock_irq(&curr->pi_lock);
 }
 
+/*
+ * We need to check the following states:
+ *
+ *      Waiter | pi_state | pi->owner | uTID      | uODIED | ?
+ *
+ * [1]  NULL   | ---      | ---       | 0         | 0/1    | Valid
+ * [2]  NULL   | ---      | ---       | >0        | 0/1    | Valid
+ *
+ * [3]  Found  | NULL     | --        | Any       | 0/1    | Invalid
+ *
+ * [4]  Found  | Found    | NULL      | 0         | 1      | Valid
+ * [5]  Found  | Found    | NULL      | >0        | 1      | Invalid
+ *
+ * [6]  Found  | Found    | task      | 0         | 1      | Valid
+ *
+ * [7]  Found  | Found    | NULL      | Any       | 0      | Invalid
+ *
+ * [8]  Found  | Found    | task      | ==taskTID | 0/1    | Valid
+ * [9]  Found  | Found    | task      | 0         | 0      | Invalid
+ * [10] Found  | Found    | task      | !=taskTID | 0/1    | Invalid
+ *
+ * [1]	Indicates that the kernel can acquire the futex atomically. We
+ *	came came here due to a stale FUTEX_WAITERS/FUTEX_OWNER_DIED bit.
+ *
+ * [2]	Valid, if TID does not belong to a kernel thread. If no matching
+ *      thread is found then it indicates that the owner TID has died.
+ *
+ * [3]	Invalid. The waiter is queued on a non PI futex
+ *
+ * [4]	Valid state after exit_robust_list(), which sets the user space
+ *	value to FUTEX_WAITERS | FUTEX_OWNER_DIED.
+ *
+ * [5]	The user space value got manipulated between exit_robust_list()
+ *	and exit_pi_state_list()
+ *
+ * [6]	Valid state after exit_pi_state_list() which sets the new owner in
+ *	the pi_state but cannot access the user space value.
+ *
+ * [7]	pi_state->owner can only be NULL when the OWNER_DIED bit is set.
+ *
+ * [8]	Owner and user space value match
+ *
+ * [9]	There is no transient state which sets the user space TID to 0
+ *	except exit_robust_list(), but this is indicated by the
+ *	FUTEX_OWNER_DIED bit. See [4]
+ *
+ * [10] There is no transient state which leaves owner and user space
+ *	TID out of sync.
+ */
 static int
 lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 		union futex_key *key, struct futex_pi_state **ps)
@@ -609,12 +658,13 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 	plist_for_each_entry_safe(this, next, head, list) {
 		if (match_futex(&this->key, key)) {
 			/*
-			 * Another waiter already exists - bump up
-			 * the refcount and return its pi_state:
+			 * Sanity check the waiter before increasing
+			 * the refcount and attaching to it.
 			 */
 			pi_state = this->pi_state;
 			/*
-			 * Userspace might have messed up non-PI and PI futexes
+			 * Userspace might have messed up non-PI and
+			 * PI futexes [3]
 			 */
 			if (unlikely(!pi_state))
 				return -EINVAL;
@@ -622,34 +672,70 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 			WARN_ON(!atomic_read(&pi_state->refcount));
 
 			/*
-			 * When pi_state->owner is NULL then the owner died
-			 * and another waiter is on the fly. pi_state->owner
-			 * is fixed up by the task which acquires
-			 * pi_state->rt_mutex.
-			 *
-			 * We do not check for pid == 0 which can happen when
-			 * the owner died and robust_list_exit() cleared the
-			 * TID.
+			 * Handle the owner died case:
 			 */
-			if (pid && pi_state->owner) {
+			if (uval & FUTEX_OWNER_DIED) {
+				/*
+				 * exit_pi_state_list sets owner to NULL and
+				 * wakes the topmost waiter. The task which
+				 * acquires the pi_state->rt_mutex will fixup
+				 * owner.
+				 */
+				if (!pi_state->owner) {
+					/*
+					 * No pi state owner, but the user
+					 * space TID is not 0. Inconsistent
+					 * state. [5]
+					 */
+					if (pid)
+						return -EINVAL;
+					/*
+					 * Take a ref on the state and
+					 * return. [4]
+					 */
+					goto out_state;
+				}
+
 				/*
-				 * Bail out if user space manipulated the
-				 * futex value.
+				 * If TID is 0, then either the dying owner
+				 * has not yet executed exit_pi_state_list()
+				 * or some waiter acquired the rtmutex in the
+				 * pi state, but did not yet fixup the TID in
+				 * user space.
+				 *
+				 * Take a ref on the state and return. [6]
 				 */
-				if (pid != task_pid_vnr(pi_state->owner))
+				if (!pid)
+					goto out_state;
+			} else {
+				/*
+				 * If the owner died bit is not set,
+				 * then the pi_state must have an
+				 * owner. [7]
+				 */
+				if (!pi_state->owner)
 					return -EINVAL;
 			}
 
+			/*
+			 * Bail out if user space manipulated the
+			 * futex value. If pi state exists then the
+			 * owner TID must be the same as the user
+			 * space TID. [9/10]
+			 */
+			if (pid != task_pid_vnr(pi_state->owner))
+				return -EINVAL;
+
+		out_state:
 			atomic_inc(&pi_state->refcount);
 			*ps = pi_state;
-
 			return 0;
 		}
 	}
 
 	/*
 	 * We are the first waiter - try to look up the real owner and attach
-	 * the new pi_state to it, but bail out when TID = 0
+	 * the new pi_state to it, but bail out when TID = 0 [1]
 	 */
 	if (!pid)
 		return -ESRCH;
@@ -657,6 +743,11 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 	if (!p)
 		return -ESRCH;
 
+	if (!p->mm) {
+		put_task_struct(p);
+		return -EPERM;
+	}
+
 	/*
 	 * We need to look at the task state flags to figure out,
 	 * whether the task is exiting. To protect against the do_exit
@@ -677,6 +768,9 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,
 		return ret;
 	}
 
+	/*
+	 * No existing pi state. First waiter. [2]
+	 */
 	pi_state = alloc_pi_state();
 
 	/*
@@ -748,10 +842,18 @@ static int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,
 		return -EDEADLK;
 
 	/*
-	 * Surprise - we got the lock. Just return to userspace:
+	 * Surprise - we got the lock, but we do not trust user space at all.
 	 */
-	if (unlikely(!curval))
-		return 1;
+	if (unlikely(!curval)) {
+		/*
+		 * We verify whether there is kernel state for this
+		 * futex. If not, we can safely assume, that the 0 ->
+		 * TID transition is correct. If state exists, we do
+		 * not bother to fixup the user space state as it was
+		 * corrupted already.
+		 */
+		return futex_top_waiter(hb, key) ? -EINVAL : 1;
+	}
 
 	uval = curval;
 
@@ -881,6 +983,7 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)
 	struct task_struct *new_owner;
 	struct futex_pi_state *pi_state = this->pi_state;
 	u32 uninitialized_var(curval), newval;
+	int ret = 0;
 
 	if (!pi_state)
 		return -EINVAL;
@@ -904,23 +1007,19 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)
 		new_owner = this->task;
 
 	/*
-	 * We pass it to the next owner. (The WAITERS bit is always
-	 * kept enabled while there is PI state around. We must also
-	 * preserve the owner died bit.)
+	 * We pass it to the next owner. The WAITERS bit is always
+	 * kept enabled while there is PI state around. We cleanup the
+	 * owner died bit, because we are the owner.
 	 */
-	if (!(uval & FUTEX_OWNER_DIED)) {
-		int ret = 0;
-
-		newval = FUTEX_WAITERS | task_pid_vnr(new_owner);
+	newval = FUTEX_WAITERS | task_pid_vnr(new_owner);
 
-		if (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))
-			ret = -EFAULT;
-		else if (curval != uval)
-			ret = -EINVAL;
-		if (ret) {
-			raw_spin_unlock(&pi_state->pi_mutex.wait_lock);
-			return ret;
-		}
+	if (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))
+		ret = -EFAULT;
+	else if (curval != uval)
+		ret = -EINVAL;
+	if (ret) {
+		raw_spin_unlock(&pi_state->pi_mutex.wait_lock);
+		return ret;
 	}
 
 	raw_spin_lock_irq(&pi_state->owner->pi_lock);
@@ -1277,6 +1376,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	u32 curval2;
 
 	if (requeue_pi) {
+		/*
+		 * Requeue PI only works on two distinct uaddrs. This
+		 * check is only valid for private futexes. See below.
+		 */
+		if (uaddr1 == uaddr2)
+			return -EINVAL;
+
 		/*
 		 * requeue_pi requires a pi_state, try to allocate it now
 		 * without any locks in case it fails.
@@ -1315,6 +1421,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	if (unlikely(ret != 0))
 		goto out_put_key1;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (requeue_pi && match_futex(&key1, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
@@ -2139,9 +2254,10 @@ static int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)
 	/*
 	 * To avoid races, try to do the TID -> 0 atomic transition
 	 * again. If it succeeds then we can return without waking
-	 * anyone else up:
+	 * anyone else up. We only try this if neither the waiters nor
+	 * the owner died bit are set.
 	 */
-	if (!(uval & FUTEX_OWNER_DIED) &&
+	if (!(uval & ~FUTEX_TID_MASK) &&
 	    cmpxchg_futex_value_locked(&uval, uaddr, vpid, 0))
 		goto pi_faulted;
 	/*
@@ -2173,11 +2289,9 @@ static int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)
 	/*
 	 * No waiters - kernel unlocks the futex:
 	 */
-	if (!(uval & FUTEX_OWNER_DIED)) {
-		ret = unlock_futex_pi(uaddr, uval);
-		if (ret == -EFAULT)
-			goto pi_faulted;
-	}
+	ret = unlock_futex_pi(uaddr, uval);
+	if (ret == -EFAULT)
+		goto pi_faulted;
 
 out_unlock:
 	spin_unlock(&hb->lock);
@@ -2337,6 +2451,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	if (ret)
 		goto out_key2;
 
+	/*
+	 * The check above which compares uaddrs is not sufficient for
+	 * shared futexes. We need to compare the keys:
+	 */
+	if (match_futex(&q.key, &key2)) {
+		ret = -EINVAL;
+		goto out_put_keys;
+	}
+
 	/* Queue the futex_q, drop the hb lock, wait for wakeup. */
 	futex_wait_queue_me(hb, &q, to);
 
