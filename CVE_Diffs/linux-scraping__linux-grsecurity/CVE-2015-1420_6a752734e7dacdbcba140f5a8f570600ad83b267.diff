linux-scraping__linux-grsecurity
commit 6a752734e7dacdbcba140f5a8f570600ad83b267
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Mon Feb 2 18:55:15 2015 -0500
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Mon Feb 2 18:55:15 2015 -0500

    grsec: Apply grsecurity-3.0-3.18.5-201502021854.patch
    
    commit efdd8202f95d861bc69874124417ad1a3ede7896
    Author: Eric Dumazet <edumazet@google.com>
    Date:   Wed Jan 28 05:47:11 2015 -0800
    
        tcp: ipv4: initialize unicast_sock sk_pacing_rate
    
        When I added sk_pacing_rate field, I forgot to initialize its value
        in the per cpu unicast_sock used in ip_send_unicast_reply()
    
        This means that for sch_fq users, RST packets, or ACK packets sent
        on behalf of TIME_WAIT sockets might be sent to slowly or even dropped
        once we reach the per flow limit.
    
        Signed-off-by: Eric Dumazet <edumazet@google.com>
        Fixes: 95bd09eb2750 ("tcp: TSO packets automatic sizing")
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/ipv4/ip_output.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    commit e293835041ed72f9fb4a171c695d451fe7e17b59
    Author: Florian Westphal <fw@strlen.de>
    Date:   Wed Jan 28 10:56:04 2015 +0100
    
        ppp: deflate: never return len larger than output buffer
    
        When we've run out of space in the output buffer to store more data, we
        will call zlib_deflate with a NULL output buffer until we've consumed
        remaining input.
    
        When this happens, olen contains the size the output buffer would have
        consumed iff we'd have had enough room.
    
        This can later cause skb_over_panic when ppp_generic skb_put()s
        the returned length.
    
        Reported-by: Iain Douglas <centos@1n6.org.uk>
        Signed-off-by: Florian Westphal <fw@strlen.de>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     drivers/net/ppp/ppp_deflate.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 567436a11d1473ad14d50a2ff7a65d4422be2500
    Author: Haiyang Zhang <haiyangz@microsoft.com>
    Date:   Thu Jan 29 12:34:49 2015 -0800
    
        hyperv: Fix the error processing in netvsc_send()
    
        The existing code frees the skb in EAGAIN case, in which the skb will be
        retried from upper layer and used again.
        Also, the existing code doesn't free send buffer slot in error case, because
        there is no completion message for unsent packets.
        This patch fixes these problems.
    
        (Please also include this patch for stable trees. Thanks!)
    
        Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
        Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     drivers/net/hyperv/netvsc.c |   11 ++++++++---
     1 files changed, 8 insertions(+), 3 deletions(-)
    
    commit 666c3cec18e8b986267263ee8cfafcfbc99a2ad4
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Feb 2 17:43:03 2015 -0500
    
        Backport fix for CVE-2015-1420:
        http://marc.info/?l=linux-kernel&m=142247707318982&w=2
    
        Though it requires CAP_DAC_READ_SEARCH and (additionally in grsec)
        cannot be performed in a chroot
    
     fs/fhandle.c |    5 +++--
     1 files changed, 3 insertions(+), 2 deletions(-)
    
    commit 2cf14890d0fa46c9b2c3519b3b72fb74fd285c37
    Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Date:   Fri Jan 23 12:01:26 2015 +0100
    
        ipv4: try to cache dst_entries which would cause a redirect
    
        Not caching dst_entries which cause redirects could be exploited by hosts
        on the same subnet, causing a severe DoS attack. This effect aggravated
        since commit f88649721268999 ("ipv4: fix dst race in sk_dst_get()").
    
        Lookups causing redirects will be allocated with DST_NOCACHE set which
        will force dst_release to free them via RCU.  Unfortunately waiting for
        RCU grace period just takes too long, we can end up with >1M dst_entries
        waiting to be released and the system will run OOM. rcuos threads cannot
        catch up under high softirq load.
    
        Attaching the flag to emit a redirect later on to the specific skb allows
        us to cache those dst_entries thus reducing the pressure on allocation
        and deallocation.
    
        This issue was discovered by Marcelo Leitner.
    
        Cc: Julian Anastasov <ja@ssi.bg>
        Signed-off-by: Marcelo Leitner <mleitner@redhat.com>
        Signed-off-by: Florian Westphal <fw@strlen.de>
        Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
        Signed-off-by: Julian Anastasov <ja@ssi.bg>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     include/net/ip.h      |   11 ++++++-----
     net/ipv4/ip_forward.c |    3 ++-
     net/ipv4/route.c      |    9 +++++----
     3 files changed, 13 insertions(+), 10 deletions(-)
    
    commit 65b3676d626dfdf2312db9493ec60b72c5082623
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Feb 2 16:57:54 2015 -0500
    
        Backport from PaX patch:
        - fixed cc-ldoption to work with the HJL fork of binutils, reported by Rogelio M. Serrano Jr.
    
     scripts/Kbuild.include |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 2d5f59e2bfd8d75e3cd8db0944a9b937c323183d
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Feb 2 16:50:13 2015 -0500
    
        Apply fix for Xen regression reported by timevers on the forums:
        https://forums.grsecurity.net/viewtopic.php?f=1&t=4138
    
     arch/x86/xen/enlighten.c |    2 ++
     1 files changed, 2 insertions(+), 0 deletions(-)
    
    Signature-tree: 9ba7c8e35e0c6226530b85ff7d8a1abb029c6bcb

diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c
index e421c18d8ff1..89c3525a1b65 100644
--- a/arch/x86/xen/enlighten.c
+++ b/arch/x86/xen/enlighten.c
@@ -1453,7 +1453,9 @@ static void __ref xen_setup_gdt(int cpu)
 	pv_cpu_ops.load_gdt = xen_load_gdt_boot;
 
 	setup_stack_canary_segment(cpu);
+#ifdef CONFIG_X86_64
 	load_percpu_segment(cpu);
+#endif
 	switch_to_new_gdt(cpu);
 
 	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry;
diff --git a/drivers/net/hyperv/netvsc.c b/drivers/net/hyperv/netvsc.c
index 7d76c9523395..63d7a642733d 100644
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@ -716,7 +716,7 @@ int netvsc_send(struct hv_device *device,
 	u64 req_id;
 	unsigned int section_index = NETVSC_INVALID_INDEX;
 	u32 msg_size = 0;
-	struct sk_buff *skb;
+	struct sk_buff *skb = NULL;
 	u16 q_idx = packet->q_idx;
 
 
@@ -743,8 +743,6 @@ int netvsc_send(struct hv_device *device,
 							   packet);
 			skb = (struct sk_buff *)
 			      (unsigned long)packet->send_completion_tid;
-			if (skb)
-				dev_kfree_skb_any(skb);
 			packet->page_buf_cnt = 0;
 		}
 	}
@@ -807,6 +805,13 @@ int netvsc_send(struct hv_device *device,
 			   packet, ret);
 	}
 
+	if (ret != 0) {
+		if (section_index != NETVSC_INVALID_INDEX)
+			netvsc_free_send_slot(net_device, section_index);
+	} else if (skb) {
+		dev_kfree_skb_any(skb);
+	}
+
 	return ret;
 }
 
diff --git a/drivers/net/ppp/ppp_deflate.c b/drivers/net/ppp/ppp_deflate.c
index 602c625d95d5..b5edc7f96a39 100644
--- a/drivers/net/ppp/ppp_deflate.c
+++ b/drivers/net/ppp/ppp_deflate.c
@@ -246,7 +246,7 @@ static int z_compress(void *arg, unsigned char *rptr, unsigned char *obuf,
 	/*
 	 * See if we managed to reduce the size of the packet.
 	 */
-	if (olen < isize) {
+	if (olen < isize && olen <= osize) {
 		state->stats.comp_bytes += olen;
 		state->stats.comp_packets++;
 	} else {
diff --git a/fs/fhandle.c b/fs/fhandle.c
index ac037c9e2313..2281df9f11b1 100644
--- a/fs/fhandle.c
+++ b/fs/fhandle.c
@@ -195,8 +195,9 @@ static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,
 		goto out_err;
 	}
 	/* copy the full handle */
-	if (copy_from_user(handle, ufh,
-			   sizeof(struct file_handle) +
+	*handle = f_handle;
+	if (copy_from_user(&handle->f_handle,
+			   &ufh->f_handle,
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
 		goto out_handle;
diff --git a/include/net/ip.h b/include/net/ip.h
index a8878afef0e0..1f38247e0c13 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -39,11 +39,12 @@ struct inet_skb_parm {
 	struct ip_options	opt;		/* Compiled IP options		*/
 	unsigned char		flags;
 
-#define IPSKB_FORWARDED		1
-#define IPSKB_XFRM_TUNNEL_SIZE	2
-#define IPSKB_XFRM_TRANSFORMED	4
-#define IPSKB_FRAG_COMPLETE	8
-#define IPSKB_REROUTED		16
+#define IPSKB_FORWARDED		BIT(0)
+#define IPSKB_XFRM_TUNNEL_SIZE	BIT(1)
+#define IPSKB_XFRM_TRANSFORMED	BIT(2)
+#define IPSKB_FRAG_COMPLETE	BIT(3)
+#define IPSKB_REROUTED		BIT(4)
+#define IPSKB_DOREDIRECT	BIT(5)
 
 	u16			frag_max_size;
 };
diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index 3a83ce5efa80..787b3c294ce6 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -129,7 +129,8 @@ int ip_forward(struct sk_buff *skb)
 	 *	We now generate an ICMP HOST REDIRECT giving the route
 	 *	we calculated.
 	 */
-	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&
+	    !skb_sec_path(skb))
 		ip_rt_send_redirect(skb);
 
 	skb->priority = rt_tos2priority(iph->tos);
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index bc6471d4abcd..c5e8a0c18f2e 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -1517,6 +1517,7 @@ static DEFINE_PER_CPU(struct inet_sock, unicast_sock) = {
 		.sk_wmem_alloc	= ATOMIC_INIT(1),
 		.sk_allocation	= GFP_ATOMIC,
 		.sk_flags	= (1UL << SOCK_USE_WRITE_QUEUE),
+		.sk_pacing_rate = ~0U,
 	},
 	.pmtudisc	= IP_PMTUDISC_WANT,
 	.uc_ttl		= -1,
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index d426880bd53f..47de388c6c97 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1554,11 +1554,10 @@ static int __mkroute_input(struct sk_buff *skb,
 
 	do_cache = res->fi && !itag;
 	if (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&
+	    skb->protocol == htons(ETH_P_IP) &&
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
-	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {
-		flags |= RTCF_DOREDIRECT;
-		do_cache = false;
-	}
+	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
+		IPCB(skb)->flags |= IPSKB_DOREDIRECT;
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
@@ -2303,6 +2302,8 @@ static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,
 	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
 	if (rt->rt_flags & RTCF_NOTIFY)
 		r->rtm_flags |= RTM_F_NOTIFY;
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT)
+		r->rtm_flags |= RTCF_DOREDIRECT;
 
 	if (nla_put_be32(skb, RTA_DST, dst))
 		goto nla_put_failure;
diff --git a/scripts/Kbuild.include b/scripts/Kbuild.include
index 65e7b08bb2cc..1b868d594ed2 100644
--- a/scripts/Kbuild.include
+++ b/scripts/Kbuild.include
@@ -144,7 +144,7 @@ cc-ifversion = $(shell [ $(call cc-version, $(CC)) $(1) $(2) ] && echo $(3))
 # cc-ldoption
 # Usage: ldflags += $(call cc-ldoption, -Wl$(comma)--hash-style=both)
 cc-ldoption = $(call try-run,\
-	$(CC) $(1) -nostdlib -x c /dev/null -o "$$TMP",$(1),$(2))
+	$(CC) $(1) -Wl,-r -nostdlib -x c /dev/null -o "$$TMP",$(1),$(2))
 
 # ld-option
 # Usage: LDFLAGS += $(call ld-option, -X)
