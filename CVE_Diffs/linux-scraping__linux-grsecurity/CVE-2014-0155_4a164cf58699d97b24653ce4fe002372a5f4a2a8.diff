linux-scraping__linux-grsecurity
commit 4a164cf58699d97b24653ce4fe002372a5f4a2a8
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Fri Apr 11 18:16:21 2014 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Fri Apr 11 18:16:21 2014 -0400

    grsec: Apply grsecurity-3.0-3.13.9-201404111815.patch
    
    commit 397ff885e5d3da96d0f115caa9d4c697895b3281
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Mon Mar 31 12:26:39 2014 +0200
    
        Upstream commit: 2fec6bb6f484b1a88b4a325724234d6cfd08c918
    
        netfilter: nf_tables: fix wrong format in request_module()
    
        The intended format in request_module is %.*s instead of %*.s.
    
        Reported-by: Florian Westphal <fw@strlen.de>
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    
     net/netfilter/nf_tables_api.c |    4 ++--
     1 files changed, 2 insertions(+), 2 deletions(-)
    
    commit 4d8b1faffb7cfe526eb20b717cb0b6d59f348108
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Mon Mar 24 15:10:37 2014 +0100
    
        Upstream commit: a9bdd8365684810e3de804f8c51e52c26a5eccbb
    
        netfilter: nf_tables: set names cannot be larger than 15 bytes
    
        Currently, nf_tables trims off the set name if it exceeeds 15
        bytes, so explicitly reject set names that are too large.
    
        Reported-by: Giuseppe Longo <giuseppelng@gmail.com>
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    
     net/netfilter/nf_tables_api.c |    3 ++-
     1 files changed, 2 insertions(+), 1 deletions(-)
    
    commit a99a10ea229b7ae7f6af473949ff5138aef76209
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Apr 11 17:33:00 2014 -0400
    
        Upstream commit: 5678de3f15010b9022ee45673f33bcfc71d47b60
    
        KVM: ioapic: fix assignment of ioapic->rtc_status.pending_eoi (CVE-2014-0155)
        QE reported that they got the BUG_ON in ioapic_service to trigger.
        I cannot reproduce it, but there are two reasons why this could happen.
    
        The less likely but also easiest one, is when kvm_irq_delivery_to_apic
        does not deliver to any APIC and returns -1.
    
        Because irqe.shorthand == 0, the kvm_for_each_vcpu loop in that
        function is never reached.  However, you can target the similar loop in
        kvm_irq_delivery_to_apic_fast; just program a zero logical destination
        address into the IOAPIC, or an out-of-range physical destination address.
    
        Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    
     virt/kvm/ioapic.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 7c522310c240fa3b1e671066def9fcab1f232f3b
    Author: Dan Carpenter <dan.carpenter@oracle.com>
    Date:   Tue Apr 8 12:23:09 2014 +0300
    
        Upstream commit: 7563487cbf865284dcd35e9ef5a95380da046737
    
        isdnloop: several buffer overflows
    
        There are three buffer overflows addressed in this patch.
    
        1) In isdnloop_fake_err() we add an 'E' to a 60 character string and
        then copy it into a 60 character buffer.  I have made the destination
        buffer 64 characters and I'm changed the sprintf() to a snprintf().
    
        2) In isdnloop_parse_cmd(), p points to a 6 characters into a 60
        character buffer so we have 54 characters.  The ->eazlist[] is 11
        characters long.  I have modified the code to return if the source
        buffer is too long.
    
        3) In isdnloop_command() the cbuf[] array was 60 characters long but the
        max length of the string then can be up to 79 characters.  I made the
        cbuf array 80 characters long and changed the sprintf() to snprintf().
        I also removed the temporary "dial" buffer and changed it to use "p"
        directly.
    
        Unfortunately, we pass the "cbuf" string from isdnloop_command() to
        isdnloop_writecmd() which truncates anything over 60 characters to make
        it fit in card->omsg[].  (It can accept values up to 255 characters so
        long as there is a '\n' character every 60 characters).  For now I have
        just fixed the memory corruption bug and left the other problems in this
        driver alone.
    
        Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     drivers/isdn/isdnloop/isdnloop.c |   17 +++++++++--------
     1 files changed, 9 insertions(+), 8 deletions(-)
    
    commit 9b011cba3d245a48139ab05099e6a825956f8056
    Author: Andrey Vagin <avagin@openvz.org>
    Date:   Fri Mar 28 13:54:32 2014 +0400
    
        Upstream commit: 223b02d923ecd7c84cf9780bb3686f455d279279
    
        netfilter: nf_conntrack: reserve two bytes for nf_ct_ext->len
    
        "len" contains sizeof(nf_ct_ext) and size of extensions. In a worst
        case it can contain all extensions. Bellow you can find sizes for all
        types of extensions. Their sum is definitely bigger than 256.
    
        nf_ct_ext_types[0]->len = 24
        nf_ct_ext_types[1]->len = 32
        nf_ct_ext_types[2]->len = 24
        nf_ct_ext_types[3]->len = 32
        nf_ct_ext_types[4]->len = 152
        nf_ct_ext_types[5]->len = 2
        nf_ct_ext_types[6]->len = 16
        nf_ct_ext_types[7]->len = 8
    
        I have seen "len" up to 280 and my host has crashes w/o this patch.
    
        The right way to fix this problem is reducing the size of the ecache
        extension (4) and Florian is going to do this, but these changes will
        be quite large to be appropriate for a stable tree.
    
        Fixes: 5b423f6a40a0 (netfilter: nf_conntrack: fix racy timer handling with reliable)
        Cc: Pablo Neira Ayuso <pablo@netfilter.org>
        Cc: Patrick McHardy <kaber@trash.net>
        Cc: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
        Cc: "David S. Miller" <davem@davemloft.net>
        Signed-off-by: Andrey Vagin <avagin@openvz.org>
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    
     include/net/netfilter/nf_conntrack_extend.h |    4 ++--
     1 files changed, 2 insertions(+), 2 deletions(-)
    
    commit c323aca3431ec956221a0333826a0aebcad6182c
    Author: Trond Myklebust <trond.myklebust@primarydata.com>
    Date:   Wed Mar 26 13:24:37 2014 -0700
    
        Upstream commit: e911b8158ee1def8153849b1641b736026b036e0
    
        NFSv4: Fix a use-after-free problem in open()
    
        If we interrupt the nfs4_wait_for_completion_rpc_task() call in
        nfs4_run_open_task(), then we don't prevent the RPC call from
        completing. So freeing up the opendata->f_attr.mdsthreshold
        in the error path in _nfs4_do_open() leads to a use-after-free
        when the XDR decoder tries to decode the mdsthreshold information
        from the server.
    
        Fixes: 82be417aa37c0 (NFSv4.1 cache mdsthreshold values on OPEN)
        Tested-by: Steve Dickson <SteveD@redhat.com>
        Cc: stable@vger.kernel.org # 3.5+
        Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    
     fs/nfs/nfs4proc.c |   19 ++++++++++---------
     1 files changed, 10 insertions(+), 9 deletions(-)
    
    commit afbc7281d89c10419bcaf9cd8f2a34fa1f0dc74a
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Apr 11 16:57:17 2014 -0400
    
        Apply: https://lkml.org/lkml/2014/4/10/736
    
        PAX_REFCOUNT makes this unexploitable, turning it into a harmless memleak
    
     net/ipv4/ping.c |   11 ++++++++---
     1 files changed, 8 insertions(+), 3 deletions(-)
    
    commit 64688b956632b3165fd8aabb9b143f4d365ba382
    Author: H. Peter Anvin <hpa@linux.intel.com>
    Date:   Sun Mar 16 15:31:54 2014 -0700
    
        Upstream commit: b3b42ac2cbae1f3cecbb6229964a4d48af31d382
    
        x86-64, modify_ldt: Ban 16-bit segments on 64-bit kernels
    
        The IRET instruction, when returning to a 16-bit segment, only
        restores the bottom 16 bits of the user space stack pointer.  We have
        a software workaround for that ("espfix") for the 32-bit kernel, but
        it relies on a nonzero stack segment base which is not available in
        32-bit mode.
    
        Since 16-bit support is somewhat crippled anyway on a 64-bit kernel
        (no V86 mode), and most (if not quite all) 64-bit processors support
        virtualization for the users who really need it, simply reject
        attempts at creating a 16-bit segment when running on top of a 64-bit
        kernel.
    
        Cc: Linus Torvalds <torvalds@linux-foundation.org>
        Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
        Link: http://lkml.kernel.org/n/tip-kicdm89kzw9lldryb1br9od0@git.kernel.org
        Cc: <stable@vger.kernel.org>
    
        Conflicts:
    
            arch/x86/kernel/ldt.c
    
     arch/x86/kernel/ldt.c |   11 +++++++++++
     1 files changed, 11 insertions(+), 0 deletions(-)
    
    commit 027b8db0f3266f307c6324f52d19c9425e01a95b
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Apr 7 18:41:45 2014 -0400
    
        Update GRKERNSEC_IO documentation
    
     grsecurity/Kconfig |    3 ++-
     1 files changed, 2 insertions(+), 1 deletions(-)
    
    Signature-tree: 6485f04acef338a383aabd1b22a26c26a373e231

diff --git a/arch/x86/kernel/ldt.c b/arch/x86/kernel/ldt.c
index 1b9724b9334d..37b877691a2a 100644
--- a/arch/x86/kernel/ldt.c
+++ b/arch/x86/kernel/ldt.c
@@ -254,6 +254,17 @@ static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)
 	}
 #endif
 
+	/*
+	 * On x86-64 we do not support 16-bit segments due to
+	 * IRET leaking the high bits of the kernel stack address.
+	 */
+#ifdef CONFIG_X86_64
+	if (!ldt_info.seg_32bit) {
+		error = -EINVAL;
+		goto out_unlock;
+	}
+#endif
+
 	fill_ldt(&ldt, &ldt_info);
 	if (oldmode)
 		ldt.avl = 0;
diff --git a/drivers/isdn/isdnloop/isdnloop.c b/drivers/isdn/isdnloop/isdnloop.c
index e1f8748ff25d..5a4da94aefb0 100644
--- a/drivers/isdn/isdnloop/isdnloop.c
+++ b/drivers/isdn/isdnloop/isdnloop.c
@@ -518,9 +518,9 @@ static isdnloop_stat isdnloop_cmd_table[] =
 static void
 isdnloop_fake_err(isdnloop_card *card)
 {
-	char buf[60];
+	char buf[64];
 
-	sprintf(buf, "E%s", card->omsg);
+	snprintf(buf, sizeof(buf), "E%s", card->omsg);
 	isdnloop_fake(card, buf, -1);
 	isdnloop_fake(card, "NAK", -1);
 }
@@ -903,6 +903,8 @@ isdnloop_parse_cmd(isdnloop_card *card)
 	case 7:
 		/* 0x;EAZ */
 		p += 3;
+		if (strlen(p) >= sizeof(card->eazlist[0]))
+			break;
 		strcpy(card->eazlist[ch - 1], p);
 		break;
 	case 8:
@@ -1133,7 +1135,7 @@ isdnloop_command(isdn_ctrl *c, isdnloop_card *card)
 {
 	ulong a;
 	int i;
-	char cbuf[60];
+	char cbuf[80];
 	isdn_ctrl cmd;
 	isdnloop_cdef cdef;
 
@@ -1198,7 +1200,6 @@ isdnloop_command(isdn_ctrl *c, isdnloop_card *card)
 			break;
 		if ((c->arg & 255) < ISDNLOOP_BCH) {
 			char *p;
-			char dial[50];
 			char dcode[4];
 
 			a = c->arg;
@@ -1210,10 +1211,10 @@ isdnloop_command(isdn_ctrl *c, isdnloop_card *card)
 			} else
 				/* Normal Dial */
 				strcpy(dcode, "CAL");
-			strcpy(dial, p);
-			sprintf(cbuf, "%02d;D%s_R%s,%02d,%02d,%s\n", (int) (a + 1),
-				dcode, dial, c->parm.setup.si1,
-				c->parm.setup.si2, c->parm.setup.eazmsn);
+			snprintf(cbuf, sizeof(cbuf),
+				 "%02d;D%s_R%s,%02d,%02d,%s\n", (int) (a + 1),
+				 dcode, p, c->parm.setup.si1,
+				 c->parm.setup.si2, c->parm.setup.eazmsn);
 			i = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);
 		}
 		break;
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 0e90bf0fa0ae..134691edf25a 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1070,6 +1070,7 @@ static void nfs4_opendata_free(struct kref *kref)
 	dput(p->dentry);
 	nfs_sb_deactive(sb);
 	nfs_fattr_free_names(&p->f_attr);
+	kfree(p->f_attr.mdsthreshold);
 	kfree(p);
 }
 
@@ -2246,10 +2247,12 @@ static int _nfs4_do_open(struct inode *dir,
 		}
 	}
 
-	if (ctx_th && server->attr_bitmask[2] & FATTR4_WORD2_MDSTHRESHOLD) {
-		opendata->f_attr.mdsthreshold = pnfs_mdsthreshold_alloc();
-		if (!opendata->f_attr.mdsthreshold)
-			goto err_free_label;
+	if (server->attr_bitmask[2] & FATTR4_WORD2_MDSTHRESHOLD) {
+		if (!opendata->f_attr.mdsthreshold) {
+			opendata->f_attr.mdsthreshold = pnfs_mdsthreshold_alloc();
+			if (!opendata->f_attr.mdsthreshold)
+				goto err_free_label;
+		}
 		opendata->o_arg.open_bitmap = &nfs4_pnfs_open_bitmap[0];
 	}
 	if (dentry->d_inode != NULL)
@@ -2277,11 +2280,10 @@ static int _nfs4_do_open(struct inode *dir,
 	if (opendata->file_created)
 		*opened |= FILE_CREATED;
 
-	if (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server))
+	if (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server)) {
 		*ctx_th = opendata->f_attr.mdsthreshold;
-	else
-		kfree(opendata->f_attr.mdsthreshold);
-	opendata->f_attr.mdsthreshold = NULL;
+		opendata->f_attr.mdsthreshold = NULL;
+	}
 
 	nfs4_label_free(olabel);
 
@@ -2291,7 +2293,6 @@ static int _nfs4_do_open(struct inode *dir,
 err_free_label:
 	nfs4_label_free(olabel);
 err_opendata_put:
-	kfree(opendata->f_attr.mdsthreshold);
 	nfs4_opendata_put(opendata);
 err_put_state_owner:
 	nfs4_put_state_owner(sp);
diff --git a/grsecurity/Kconfig b/grsecurity/Kconfig
index 81a6826241a4..3abaf02d7345 100644
--- a/grsecurity/Kconfig
+++ b/grsecurity/Kconfig
@@ -53,7 +53,8 @@ config GRKERNSEC_IO
 	  the most notable of which are XFree86 and hwclock.  hwclock can be
 	  remedied by having RTC support in the kernel, so real-time 
 	  clock support is enabled if this option is enabled, to ensure 
-	  that hwclock operates correctly.
+	  that hwclock operates correctly.  If hwclock still does not work,
+	  either update udev or symlink /dev/rtc to /dev/rtc0.
 
 	  If you're using XFree86 or a version of Xorg from 2012 or earlier,
 	  you may not be able to boot into a graphical environment with this
diff --git a/include/net/netfilter/nf_conntrack_extend.h b/include/net/netfilter/nf_conntrack_extend.h
index 956b175523ff..55d15049ab2f 100644
--- a/include/net/netfilter/nf_conntrack_extend.h
+++ b/include/net/netfilter/nf_conntrack_extend.h
@@ -47,8 +47,8 @@ enum nf_ct_ext_id {
 /* Extensions: optional stuff which isn't permanently in struct. */
 struct nf_ct_ext {
 	struct rcu_head rcu;
-	u8 offset[NF_CT_EXT_NUM];
-	u8 len;
+	u16 offset[NF_CT_EXT_NUM];
+	u16 len;
 	char data[0];
 };
 
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index a084e95c8478..76cc7eec4f1a 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -251,23 +251,28 @@ int ping_init_sock(struct sock *sk)
 	struct group_info *group_info = get_current_groups();
 	int i, j, count = group_info->ngroups;
 	kgid_t low, high;
+	int ret = 0;
 
 	inet_get_ping_group_range_net(net, &low, &high);
 	if (gid_lte(low, group) && gid_lte(group, high))
-		return 0;
+		goto out_release_group;
 
 	for (i = 0; i < group_info->nblocks; i++) {
 		int cp_count = min_t(int, NGROUPS_PER_BLOCK, count);
 		for (j = 0; j < cp_count; j++) {
 			kgid_t gid = group_info->blocks[i][j];
 			if (gid_lte(low, gid) && gid_lte(gid, high))
-				return 0;
+				goto out_release_group;
 		}
 
 		count -= cp_count;
 	}
 
-	return -EACCES;
+	ret = -EACCES;
+
+out_release_group:
+	put_group_info(group_info);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(ping_init_sock);
 
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 71a9f49a768b..c09b60cd9b7d 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -148,8 +148,8 @@ static int nf_tables_chain_type_lookup(const struct nft_af_info *afi,
 #ifdef CONFIG_MODULES
 	if (type < 0 && autoload) {
 		nfnl_unlock(NFNL_SUBSYS_NFTABLES);
-		request_module("nft-chain-%u-%*.s", afi->family,
-			       nla_len(nla)-1, (const char *)nla_data(nla));
+		request_module("nft-chain-%u-%.*s", afi->family,
+			       nla_len(nla), (const char *)nla_data(nla));
 		nfnl_lock(NFNL_SUBSYS_NFTABLES);
 		type = __nf_tables_chain_type_lookup(afi->family, nla);
 	}
@@ -1916,7 +1916,8 @@ static const struct nft_set_ops *nft_select_set_ops(const struct nlattr * const
 
 static const struct nla_policy nft_set_policy[NFTA_SET_MAX + 1] = {
 	[NFTA_SET_TABLE]		= { .type = NLA_STRING },
-	[NFTA_SET_NAME]			= { .type = NLA_STRING },
+	[NFTA_SET_NAME]			= { .type = NLA_STRING,
+					    .len = IFNAMSIZ - 1 },
 	[NFTA_SET_FLAGS]		= { .type = NLA_U32 },
 	[NFTA_SET_KEY_TYPE]		= { .type = NLA_U32 },
 	[NFTA_SET_KEY_LEN]		= { .type = NLA_U32 },
diff --git a/virt/kvm/ioapic.c b/virt/kvm/ioapic.c
index 2d682977ce82..39dc5bc742e0 100644
--- a/virt/kvm/ioapic.c
+++ b/virt/kvm/ioapic.c
@@ -306,7 +306,7 @@ static int ioapic_deliver(struct kvm_ioapic *ioapic, int irq, bool line_status)
 		BUG_ON(ioapic->rtc_status.pending_eoi != 0);
 		ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,
 				ioapic->rtc_status.dest_map);
-		ioapic->rtc_status.pending_eoi = ret;
+		ioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);
 	} else
 		ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);
 
