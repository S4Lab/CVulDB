linux-scraping__linux-grsecurity
commit fc1f24b938b3f1adbfbc1ff5899d082c3ee35122
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Thu Mar 21 00:13:16 2013 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Thu Mar 21 00:13:16 2013 -0400

    grsec: Apply grsecurity-2.9.1-3.2.40-201303210010.patch
    
    commit 685d5e7a9759b6a3718a9ea545295325fe609802
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Mar 20 23:32:25 2013 -0400
    
        From c4dab66c31612717f798e1e8ff11b57253a81a31 Mon Sep 17 00:00:00 2001
        From: Kees Cook <keescook@chromium.org>
        Date: Sun, 10 Mar 2013 20:09:31 +0000
        Subject: drm/i915: bounds check execbuffer relocation count
    
        It is possible to wrap the counter used to allocate the buffer for
        relocation copies. This could lead to heap writing overflows.
    
        CVE-2013-0913
    
        Signed-off-by: Kees Cook <keescook@chromium.org>
        Reported-by: Pinkie Pie
        Cc: stable@vger.kernel.org
    
     drivers/gpu/drm/i915/i915_gem_execbuffer.c |   13 +++++++++----
     1 files changed, 9 insertions(+), 4 deletions(-)
    
    commit 4579d7a6f6f261d21954d59b3655a7c44ccb6cd8
    Author: Andy Honig <ahonig@google.com>
    Date:   Mon Mar 11 09:34:52 2013 -0700
    
        Upstream commit: c300aa64ddf57d9c5d9c898a64b36877345dd4a9
    
        KVM: x86: fix for buffer overflow in handling of MSR_KVM_SYSTEM_TIME (CVE-2013-1796)
    
        If the guest sets the GPA of the time_page so that the request to update the
        time straddles a page then KVM will write onto an incorrect page.  The
        write is done byusing kmap atomic to get a pointer to the page for the time
        structure and then performing a memcpy to that page starting at an offset
        that the guest controls.  Well behaved guests always provide a 32-byte aligned
        address, however a malicious guest could use this to corrupt host kernel
        memory.
    
        Tested: Tested against kvmclock unit test.
    
        Signed-off-by: Andrew Honig <ahonig@google.com>
        Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    
     arch/x86/kvm/x86.c |    5 +++++
     1 files changed, 5 insertions(+), 0 deletions(-)
    
    commit 14dc5fc373b2ed0506cd973c6bcea8515a01081b
    Author: Andy Honig <ahonig@google.com>
    Date:   Wed Feb 20 14:49:16 2013 -0800
    
        Upstream commit: a2c118bfab8bc6b8bb213abfc35201e441693d55
    
        KVM: Fix bounds checking in ioapic indirect register reads (CVE-2013-1798)
    
        If the guest specifies a IOAPIC_REG_SELECT with an invalid value and follows
        that with a read of the IOAPIC_REG_WINDOW KVM does not properly validate
        that request.  ioapic_read_indirect contains an
        ASSERT(redir_index < IOAPIC_NUM_PINS), but the ASSERT has no effect in
        non-debug builds.  In recent kernels this allows a guest to cause a kernel
        oops by reading invalid memory.  In older kernels (pre-3.3) this allows a
        guest to read from large ranges of host memory.
    
        Tested: tested against apic unit tests.
    
        Signed-off-by: Andrew Honig <ahonig@google.com>
        Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    
     virt/kvm/ioapic.c |    7 +++++--
     1 files changed, 5 insertions(+), 2 deletions(-)
    
    commit 90174443d8c5f2ef16b5eb87d1dadae7996878f3
    Author: Dan Carpenter <dan.carpenter@oracle.com>
    Date:   Sat Mar 16 12:48:11 2013 +0300
    
        Upstream commit: 4502403dcf8f5c76abd4dbab8726c8e4ecb5cd34
    
        selinux: use GFP_ATOMIC under spin_lock
    
        The call tree here is:
    
        sk_clone_lock()              <- takes bh_lock_sock(newsk);
        xfrm_sk_clone_policy()
        __xfrm_sk_clone_policy()
        clone_policy()               <- uses GFP_ATOMIC for allocations
        security_xfrm_policy_clone()
        security_ops->xfrm_policy_clone_security()
        selinux_xfrm_policy_clone()
    
        Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
        Cc: stable@kernel.org
        Signed-off-by: James Morris <james.l.morris@oracle.com>
    
     security/selinux/xfrm.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 58a0d4c45563fa427de311a8305207463df4b250
    Author: Lars-Peter Clausen <lars@metafoo.de>
    Date:   Sat Mar 9 15:28:44 2013 +0100
    
        Upstream commit: 8d0c2d10dd72c5292eda7a06231056a4c972e4cc
    
        ext3: Fix format string issues
    
        ext3_msg() takes the printk prefix as the second parameter and the
        format string as the third parameter. Two callers of ext3_msg omit the
        prefix and pass the format string as the second parameter and the first
        parameter to the format string as the third parameter. In both cases
        this string comes from an arbitrary source. Which means the string may
        contain format string characters, which will
        lead to undefined and potentially harmful behavior.
    
        The issue was introduced in commit 4cf46b67eb("ext3: Unify log messages
        in ext3") and is fixed by this patch.
    
        CC: stable@vger.kernel.org
        Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
        Signed-off-by: Jan Kara <jack@suse.cz>
    
     fs/ext3/super.c |    4 ++--
     1 files changed, 2 insertions(+), 2 deletions(-)
    
    commit c09d37b10288cbd2c582f6884f0247c739de7a52
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Mar 20 17:37:59 2013 -0400
    
        fix compilation
    
     fs/binfmt_elf.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    Signature-tree: cb6a52cb8e73035635760289006e2ea8cc2a4908

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 3c408149a675..b395ad73ea95 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -1603,6 +1603,11 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data)
 		/* ...but clean it before doing the actual write */
 		vcpu->arch.time_offset = data & ~(PAGE_MASK | 1);
 
+		/* Check that the address is 32-byte aligned. */
+		if (vcpu->arch.time_offset &
+				(sizeof(struct pvclock_vcpu_time_info) - 1))
+			break;
+
 		vcpu->arch.time_page =
 				gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);
 
diff --git a/drivers/gpu/drm/i915/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
index ea158f5e3d7c..17fe410057ae 100644
--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@ -907,15 +907,20 @@ validate_exec_list(struct drm_i915_gem_exec_object2 *exec,
 		   unsigned int count)
 {
 	unsigned int i;
-
+	int relocs_total = 0;
+	int relocs_max = INT_MAX / sizeof(struct drm_i915_gem_relocation_entry);
+	
 	for (i = 0; i < count; i++) {
 		char __user *ptr = (char __user *)(uintptr_t)exec[i].relocs_ptr;
 		int length; /* limited by fault_in_pages_readable() */
 
-		/* First check for malicious input causing overflow */
-		if (exec[i].relocation_count >
-		    INT_MAX / sizeof(struct drm_i915_gem_relocation_entry))
+		/* First check for malicious input causing overflow in
+		 * the worst case where we need to allocate the entire
+		 * relocation tree as a single array.
+		 */
+		if (exec[i].relocation_count > relocs_max - relocs_total)
 			return -EINVAL;
+		relocs_total += exec[i].relocation_count;
 
 		length = exec[i].relocation_count *
 			sizeof(struct drm_i915_gem_relocation_entry);
diff --git a/fs/ext3/super.c b/fs/ext3/super.c
index 922d289aeeb3..b7f314f28fa6 100644
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@ -374,7 +374,7 @@ static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)
 	return bdev;
 
 fail:
-	ext3_msg(sb, "error: failed to open journal device %s: %ld",
+	ext3_msg(sb, KERN_ERR, "error: failed to open journal device %s: %ld",
 		__bdevname(dev, b), PTR_ERR(bdev));
 
 	return NULL;
@@ -902,7 +902,7 @@ static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)
 	/*todo: use simple_strtoll with >32bit ext3 */
 	sb_block = simple_strtoul(options, &options, 0);
 	if (*options && *options != ',') {
-		ext3_msg(sb, "error: invalid sb specification: %s",
+		ext3_msg(sb, KERN_ERR, "error: invalid sb specification: %s",
 		       (char *) *data);
 		return 1;
 	}
diff --git a/security/selinux/xfrm.c b/security/selinux/xfrm.c
index 48665ecd1197..8ab295154517 100644
--- a/security/selinux/xfrm.c
+++ b/security/selinux/xfrm.c
@@ -310,7 +310,7 @@ int selinux_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,
 
 	if (old_ctx) {
 		new_ctx = kmalloc(sizeof(*old_ctx) + old_ctx->ctx_len,
-				  GFP_KERNEL);
+				  GFP_ATOMIC);
 		if (!new_ctx)
 			return -ENOMEM;
 
diff --git a/virt/kvm/ioapic.c b/virt/kvm/ioapic.c
index 3eed61eb4867..79647cde86f6 100644
--- a/virt/kvm/ioapic.c
+++ b/virt/kvm/ioapic.c
@@ -73,9 +73,12 @@ static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 			u32 redir_index = (ioapic->ioregsel - 0x10) >> 1;
 			u64 redir_content;
 
-			ASSERT(redir_index < IOAPIC_NUM_PINS);
+			if (redir_index < IOAPIC_NUM_PINS)
+				redir_content =
+					ioapic->redirtbl[redir_index].bits;
+			else
+				redir_content = ~0ULL;
 
-			redir_content = ioapic->redirtbl[redir_index].bits;
 			result = (ioapic->ioregsel & 0x1) ?
 			    (redir_content >> 32) & 0xffffffff :
 			    redir_content & 0xffffffff;
