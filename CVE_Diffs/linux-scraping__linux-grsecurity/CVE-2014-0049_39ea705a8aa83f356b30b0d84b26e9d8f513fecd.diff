linux-scraping__linux-grsecurity
commit 39ea705a8aa83f356b30b0d84b26e9d8f513fecd
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Mon Mar 3 14:48:35 2014 -0500
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Mon Mar 3 14:48:35 2014 -0500

    grsec: Apply grsecurity-3.0-3.13.5-201403031445.patch
    
    commit 4877e98529649880ac76ade11e5529403a40ea73
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Mar 3 14:42:58 2014 -0500
    
        mark 'processor' as __read_only instead of forcing constify on it
        to avoid a GCC constant propagation that will cause a NULL deref on boot
        on ARM MULTI_CPU configs
    
        Thanks to Arnaud Fontaine and Arnaud Ebalard for the report, fix is from
        the PaX Team
    
     arch/arm/include/asm/proc-fns.h |    2 +-
     arch/arm/kernel/setup.c         |    4 ++--
     2 files changed, 3 insertions(+), 3 deletions(-)
    
    commit 9c8d2926262f0345af454da45b41c6259bdc89e8
    Author: Andrew Honig <ahonig@google.com>
    Date:   Thu Feb 27 19:35:14 2014 +0100
    
        Upstream commit: a08d3b3b99efd509133946056531cdf8f3a0c09b
    
        kvm: x86: fix emulator buffer overflow (CVE-2014-0049)
    
        The problem occurs when the guest performs a pusha with the stack
        address pointing to an mmio address (or an invalid guest physical
        address) to start with, but then extending into an ordinary guest
        physical address.  When doing repeated emulated pushes
        emulator_read_write sets mmio_needed to 1 on the first one.  On a
        later push when the stack points to regular memory,
        mmio_nr_fragments is set to 0, but mmio_is_needed is not set to 0.
    
        As a result, KVM exits to userspace, and then returns to
        complete_emulated_mmio.  In complete_emulated_mmio
        vcpu->mmio_cur_fragment is incremented.  The termination condition of
        vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments is never achieved.
        The code bounces back and fourth to userspace incrementing
        mmio_cur_fragment past it's buffer.  If the guest does nothing else it
        eventually leads to a a crash on a memcpy from invalid memory address.
    
        However if a guest code can cause the vm to be destroyed in another
        vcpu with excellent timing, then kvm_clear_async_pf_completion_queue
        can be used by the guest to control the data that's pointed to by the
        call to cancel_work_item, which can be used to gain execution.
    
        Fixes: f78146b0f9230765c6315b2e14f56112513389ad
        Signed-off-by: Andrew Honig <ahonig@google.com>
        Cc: stable@vger.kernel.org (3.5+)
        Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    
     arch/x86/kvm/x86.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    Signature-tree: 9402b466355fc71531bbb37f14362078ef840498

diff --git a/arch/arm/include/asm/proc-fns.h b/arch/arm/include/asm/proc-fns.h
index bcae5f0f632d..5324c1112f3a 100644
--- a/arch/arm/include/asm/proc-fns.h
+++ b/arch/arm/include/asm/proc-fns.h
@@ -75,7 +75,7 @@ extern struct processor {
 	unsigned int suspend_size;
 	void (*do_suspend)(void *);
 	void (*do_resume)(void *);
-} __do_const processor;
+} processor;
 
 #ifndef MULTI_CPU
 extern void cpu_proc_init(void);
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d9d6071fa027..ab0c3978fd8f 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -104,7 +104,7 @@ pteval_t __supported_pte_mask __read_only;
 pmdval_t __supported_pmd_mask __read_only;
 
 #ifdef MULTI_CPU
-struct processor processor;
+struct processor processor __read_only;
 #endif
 #ifdef MULTI_TLB
 struct cpu_tlb_fns cpu_tlb __read_only;
@@ -579,7 +579,7 @@ static void __init setup_processor(void)
 	__cpu_architecture = __get_cpu_architecture();
 
 #ifdef MULTI_CPU
-	memcpy((void *)&processor, list->proc, sizeof processor);
+	processor = *list->proc;
 #endif
 #ifdef MULTI_TLB
 	cpu_tlb = *list->tlb;
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index f3c612ad795e..fa948552865c 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -6165,7 +6165,7 @@ static int complete_emulated_mmio(struct kvm_vcpu *vcpu)
 		frag->len -= len;
 	}
 
-	if (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {
+	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {
 		vcpu->mmio_needed = 0;
 
 		/* FIXME: return into emulator if single-stepping.  */
