linux-scraping__linux-grsecurity
commit 8380dcbde4470112b62169d98f27b179a7dbf0f3
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Mon Feb 2 18:55:04 2015 -0500
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Mon Feb 2 18:55:04 2015 -0500

    grsec: Apply grsecurity-3.0-3.14.31-201502021853.patch
    
    commit 664569dfd81681d647f0044290a5a123fb495acf
    Author: Eric Dumazet <edumazet@google.com>
    Date:   Wed Jan 28 05:47:11 2015 -0800
    
        tcp: ipv4: initialize unicast_sock sk_pacing_rate
    
        When I added sk_pacing_rate field, I forgot to initialize its value
        in the per cpu unicast_sock used in ip_send_unicast_reply()
    
        This means that for sch_fq users, RST packets, or ACK packets sent
        on behalf of TIME_WAIT sockets might be sent to slowly or even dropped
        once we reach the per flow limit.
    
        Signed-off-by: Eric Dumazet <edumazet@google.com>
        Fixes: 95bd09eb2750 ("tcp: TSO packets automatic sizing")
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/ipv4/ip_output.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    commit 4c8724cbaa148031c20c0545f0665a421b23858d
    Author: Florian Westphal <fw@strlen.de>
    Date:   Wed Jan 28 10:56:04 2015 +0100
    
        ppp: deflate: never return len larger than output buffer
    
        When we've run out of space in the output buffer to store more data, we
        will call zlib_deflate with a NULL output buffer until we've consumed
        remaining input.
    
        When this happens, olen contains the size the output buffer would have
        consumed iff we'd have had enough room.
    
        This can later cause skb_over_panic when ppp_generic skb_put()s
        the returned length.
    
        Reported-by: Iain Douglas <centos@1n6.org.uk>
        Signed-off-by: Florian Westphal <fw@strlen.de>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     drivers/net/ppp/ppp_deflate.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 3f088ecae87a2b7e30bf5b0a607aa1606616a703
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Feb 2 17:43:03 2015 -0500
    
        Backport fix for CVE-2015-1420:
        http://marc.info/?l=linux-kernel&m=142247707318982&w=2
    
        Though it requires CAP_DAC_READ_SEARCH and (additionally in grsec)
        cannot be performed in a chroot
    
     fs/fhandle.c |    5 +++--
     1 files changed, 3 insertions(+), 2 deletions(-)
    
    commit 8c985cbd8d7290d1e7718e3e06dcf44d4dc34712
    Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Date:   Fri Jan 23 12:01:26 2015 +0100
    
        ipv4: try to cache dst_entries which would cause a redirect
    
        Not caching dst_entries which cause redirects could be exploited by hosts
        on the same subnet, causing a severe DoS attack. This effect aggravated
        since commit f88649721268999 ("ipv4: fix dst race in sk_dst_get()").
    
        Lookups causing redirects will be allocated with DST_NOCACHE set which
        will force dst_release to free them via RCU.  Unfortunately waiting for
        RCU grace period just takes too long, we can end up with >1M dst_entries
        waiting to be released and the system will run OOM. rcuos threads cannot
        catch up under high softirq load.
    
        Attaching the flag to emit a redirect later on to the specific skb allows
        us to cache those dst_entries thus reducing the pressure on allocation
        and deallocation.
    
        This issue was discovered by Marcelo Leitner.
    
        Cc: Julian Anastasov <ja@ssi.bg>
        Signed-off-by: Marcelo Leitner <mleitner@redhat.com>
        Signed-off-by: Florian Westphal <fw@strlen.de>
        Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
        Signed-off-by: Julian Anastasov <ja@ssi.bg>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     include/net/ip.h      |   11 ++++++-----
     net/ipv4/ip_forward.c |    3 ++-
     net/ipv4/route.c      |    9 +++++----
     3 files changed, 13 insertions(+), 10 deletions(-)
    
    commit 6724fd423672930f7c5d4b53ddfa09432c9e804b
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Feb 2 16:57:54 2015 -0500
    
        Backport from PaX patch:
        - fixed cc-ldoption to work with the HJL fork of binutils, reported by Rogelio M. Serrano Jr.
    
     scripts/Kbuild.include |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit d6546cbbe8c9573fbfc1562010fb54d6a7b9294c
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Mon Feb 2 16:50:13 2015 -0500
    
        Apply fix for Xen regression reported by timevers on the forums:
        https://forums.grsecurity.net/viewtopic.php?f=1&t=4138
    
     arch/x86/xen/enlighten.c |    2 ++
     1 files changed, 2 insertions(+), 0 deletions(-)
    
    Signature-tree: e23b5a89ffca3fc3cce500e531baae867e91c75e

diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c
index be9376863107..2302db12dbe4 100644
--- a/arch/x86/xen/enlighten.c
+++ b/arch/x86/xen/enlighten.c
@@ -1452,7 +1452,9 @@ static void __ref xen_setup_gdt(int cpu)
 	pv_cpu_ops.load_gdt = xen_load_gdt_boot;
 
 	setup_stack_canary_segment(cpu);
+#ifdef CONFIG_X86_64
 	load_percpu_segment(cpu);
+#endif
 	switch_to_new_gdt(cpu);
 
 	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry;
diff --git a/drivers/net/ppp/ppp_deflate.c b/drivers/net/ppp/ppp_deflate.c
index 602c625d95d5..b5edc7f96a39 100644
--- a/drivers/net/ppp/ppp_deflate.c
+++ b/drivers/net/ppp/ppp_deflate.c
@@ -246,7 +246,7 @@ static int z_compress(void *arg, unsigned char *rptr, unsigned char *obuf,
 	/*
 	 * See if we managed to reduce the size of the packet.
 	 */
-	if (olen < isize) {
+	if (olen < isize && olen <= osize) {
 		state->stats.comp_bytes += olen;
 		state->stats.comp_packets++;
 	} else {
diff --git a/fs/fhandle.c b/fs/fhandle.c
index ac037c9e2313..2281df9f11b1 100644
--- a/fs/fhandle.c
+++ b/fs/fhandle.c
@@ -195,8 +195,9 @@ static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,
 		goto out_err;
 	}
 	/* copy the full handle */
-	if (copy_from_user(handle, ufh,
-			   sizeof(struct file_handle) +
+	*handle = f_handle;
+	if (copy_from_user(&handle->f_handle,
+			   &ufh->f_handle,
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
 		goto out_handle;
diff --git a/include/net/ip.h b/include/net/ip.h
index 7251808d0629..310a44f42cb3 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -38,11 +38,12 @@ struct inet_skb_parm {
 	struct ip_options	opt;		/* Compiled IP options		*/
 	unsigned char		flags;
 
-#define IPSKB_FORWARDED		1
-#define IPSKB_XFRM_TUNNEL_SIZE	2
-#define IPSKB_XFRM_TRANSFORMED	4
-#define IPSKB_FRAG_COMPLETE	8
-#define IPSKB_REROUTED		16
+#define IPSKB_FORWARDED		BIT(0)
+#define IPSKB_XFRM_TUNNEL_SIZE	BIT(1)
+#define IPSKB_XFRM_TRANSFORMED	BIT(2)
+#define IPSKB_FRAG_COMPLETE	BIT(3)
+#define IPSKB_REROUTED		BIT(4)
+#define IPSKB_DOREDIRECT	BIT(5)
 
 	u16			frag_max_size;
 };
diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index 1c6bd4359cbd..ecb34b5ea42f 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -178,7 +178,8 @@ int ip_forward(struct sk_buff *skb)
 	 *	We now generate an ICMP HOST REDIRECT giving the route
 	 *	we calculated.
 	 */
-	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr && !skb_sec_path(skb))
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&
+	    !skb_sec_path(skb))
 		ip_rt_send_redirect(skb);
 
 	skb->priority = rt_tos2priority(iph->tos);
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 844323b6cfb9..7c1b9accd193 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -1471,6 +1471,7 @@ static DEFINE_PER_CPU(struct inet_sock, unicast_sock) = {
 		.sk_wmem_alloc	= ATOMIC_INIT(1),
 		.sk_allocation	= GFP_ATOMIC,
 		.sk_flags	= (1UL << SOCK_USE_WRITE_QUEUE),
+		.sk_pacing_rate = ~0U,
 	},
 	.pmtudisc	= IP_PMTUDISC_WANT,
 	.uc_ttl		= -1,
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index bc101aa16788..31268ca5ec7a 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1554,11 +1554,10 @@ static int __mkroute_input(struct sk_buff *skb,
 
 	do_cache = res->fi && !itag;
 	if (out_dev == in_dev && err && IN_DEV_TX_REDIRECTS(out_dev) &&
+	    skb->protocol == htons(ETH_P_IP) &&
 	    (IN_DEV_SHARED_MEDIA(out_dev) ||
-	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res)))) {
-		flags |= RTCF_DOREDIRECT;
-		do_cache = false;
-	}
+	     inet_addr_onlink(out_dev, saddr, FIB_RES_GW(*res))))
+		IPCB(skb)->flags |= IPSKB_DOREDIRECT;
 
 	if (skb->protocol != htons(ETH_P_IP)) {
 		/* Not IP (i.e. ARP). Do not create route, if it is
@@ -2305,6 +2304,8 @@ static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,
 	r->rtm_flags	= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;
 	if (rt->rt_flags & RTCF_NOTIFY)
 		r->rtm_flags |= RTM_F_NOTIFY;
+	if (IPCB(skb)->flags & IPSKB_DOREDIRECT)
+		r->rtm_flags |= RTCF_DOREDIRECT;
 
 	if (nla_put_be32(skb, RTA_DST, dst))
 		goto nla_put_failure;
diff --git a/scripts/Kbuild.include b/scripts/Kbuild.include
index 547e15daf03d..e550fa660e37 100644
--- a/scripts/Kbuild.include
+++ b/scripts/Kbuild.include
@@ -143,7 +143,7 @@ cc-ifversion = $(shell [ $(call cc-version, $(CC)) $(1) $(2) ] && echo $(3))
 # cc-ldoption
 # Usage: ldflags += $(call cc-ldoption, -Wl$(comma)--hash-style=both)
 cc-ldoption = $(call try-run,\
-	$(CC) $(1) -nostdlib -x c /dev/null -o "$$TMP",$(1),$(2))
+	$(CC) $(1) -Wl,-r -nostdlib -x c /dev/null -o "$$TMP",$(1),$(2))
 
 # ld-option
 # Usage: LDFLAGS += $(call ld-option, -X)
