linux-scraping__linux-grsecurity
commit a5a4abc164bba33fd00eca84ebd37fbf47c2b659
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Sat Oct 25 00:28:57 2014 -0400
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Sat Oct 25 00:28:57 2014 -0400

    grsec: Apply grsecurity-3.0-3.2.63-201410250023.patch
    
    commit aa0ebeb5f62bea5736cbc2ad48383398ad2edbe8
    Author: Cesar Eduardo Barros <cesarb@cesarb.eti.br>
    Date:   Mon Nov 25 22:00:41 2013 -0200
    
        Backport OPTIMIZER_HIDE_VAR from cesarb@cesarb.eti.br
    
        Conflicts:
    
            crypto/memneq.c
            include/linux/compiler.h
    
     include/linux/compiler-gcc.h   |    3 +++
     include/linux/compiler-intel.h |    7 +++++++
     include/linux/compiler.h       |    4 ++++
     3 files changed, 14 insertions(+), 0 deletions(-)
    
    commit 33ae23dc594e91d4a7456e5c4921b49391d93f97
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Oct 24 22:14:37 2014 -0400
    
        compile fix
    
     net/ipv4/ipmr.c |    4 +---
     1 files changed, 1 insertions(+), 3 deletions(-)
    
    commit 52630e6e12591ebb415b3921b285eeabcae752f2
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Oct 24 21:53:05 2014 -0400
    
        compile fix
    
     fs/xfs/xfs_iget.c |    1 -
     1 files changed, 0 insertions(+), 1 deletions(-)
    
    commit 95b3935d5b5e01119d49aba3c2043907d505ac20
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Oct 24 21:39:40 2014 -0400
    
        add missing rcu_read_unlock() to upstream code
    
     fs/xfs/xfs_iget.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    commit 2263a7d02fa8569eb4ec15d8f5440be3157e4dc1
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Oct 24 21:38:14 2014 -0400
    
        add missing rcu_read_unlock() to upstream code
    
     net/ipv4/ipmr.c |    4 +++-
     1 files changed, 3 insertions(+), 1 deletions(-)
    
    commit 4dbd1dfaac8b2935eb0232076dbcdee22bc2c2b0
    Author: Hugh Dickins <hughd@google.com>
    Date:   Mon Mar 3 15:38:23 2014 -0800
    
        lib/radix-tree.c: swapoff tmpfs radix_tree: remember to rcu_read_unlock
    
        Running fsx on tmpfs with concurrent memhog-swapoff-swapon, lots of
    
          BUG: sleeping function called from invalid context at kernel/fork.c:606
          in_atomic(): 0, irqs_disabled(): 0, pid: 1394, name: swapoff
          1 lock held by swapoff/1394:
           #0:  (rcu_read_lock){.+.+.+}, at: [<ffffffff812520a1>] radix_tree_locate_item+0x1f/0x2b6
    
        followed by
    
          ================================================
          [ BUG: lock held when returning to user space! ]
          3.14.0-rc1 #3 Not tainted
          ------------------------------------------------
          swapoff/1394 is leaving the kernel with locks still held!
          1 lock held by swapoff/1394:
           #0:  (rcu_read_lock){.+.+.+}, at: [<ffffffff812520a1>] radix_tree_locate_item+0x1f/0x2b6
    
        after which the system recovered nicely.
    
        Whoops, I long ago forgot the rcu_read_unlock() on one unlikely branch.
    
        Fixes e504f3fdd63d ("tmpfs radix_tree: locate_item to speed up swapoff")
    
        Signed-off-by: Hugh Dickins <hughd@google.com>
        Cc: Johannes Weiner <hannes@cmpxchg.org>
        Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
        Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
     lib/radix-tree.c |    4 +++-
     1 files changed, 3 insertions(+), 1 deletions(-)
    
    commit e98b77860805307f14a4a2dd28d0c2be1a6a1fa8
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Oct 24 21:04:47 2014 -0400
    
        add missing rcu_read_unlock() to upstream code
    
     block/blk-throttle.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    commit 9b86430ca1bb41a884684c6973dd855d5cb9a9ab
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Oct 24 21:02:44 2014 -0400
    
        add missing rcu_read_unlock() to upstream code
    
     drivers/acpi/atomicio.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    commit e5f58ab0435a2de85281a5f0381ae8fc42f4cb53
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Fri Oct 24 21:02:07 2014 -0400
    
        add missing rcu_read_unlock() to upstream code
    
     drivers/acpi/atomicio.c |    1 +
     1 files changed, 1 insertions(+), 0 deletions(-)
    
    commit fc16ca66e9b6650d822767836eb118169400987c
    Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Date:   Fri Oct 17 22:55:59 2014 +0200
    
        kvm: fix excessive pages un-pinning in kvm_iommu_map error path.
    
        The third parameter of kvm_unpin_pages() when called from
        kvm_iommu_map_pages() is wrong, it should be the number of pages to un-pin
        and not the page size.
    
        This error was facilitated with an inconsistent API: kvm_pin_pages() takes
        a size, but kvn_unpin_pages() takes a number of pages, so fix the problem
        by matching the two.
    
        This was introduced by commit 350b8bd ("kvm: iommu: fix the third parameter
        of kvm_iommu_put_pages (CVE-2014-3601)"), which fixes the lack of
        un-pinning for pages intended to be un-pinned (i.e. memory leak) but
        unfortunately potentially aggravated the number of pages we un-pin that
        should have stayed pinned. As far as I understand though, the same
        practical mitigations apply.
    
        This issue was found during review of Red Hat 6.6 patches to prepare
        Ksplice rebootless updates.
    
        Thanks to Vegard for his time on a late Friday evening to help me in
        understanding this code.
    
        Fixes: 350b8bd ("kvm: iommu: fix the third parameter of... (CVE-2014-3601)")
        Cc: stable@vger.kernel.org
        Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
        Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
        Signed-off-by: Jamie Iles <jamie.iles@oracle.com>
        Reviewed-by: Sasha Levin <sasha.levin@oracle.com>
        Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    
        Conflicts:
    
            virt/kvm/iommu.c
    
     virt/kvm/iommu.c |    8 ++++----
     1 files changed, 4 insertions(+), 4 deletions(-)
    
    commit 27cf85cd00dbaf29559b9a497fefbd49e888b031
    Author: David S. Miller <davem@davemloft.net>
    Date:   Thu Oct 23 12:58:13 2014 -0700
    
        sparc64: Fix register corruption in top-most kernel stack frame during boot.
    
        Meelis Roos reported that kernels built with gcc-4.9 do not boot, we
        eventually narrowed this down to only impacting machines using
        UltraSPARC-III and derivitive cpus.
    
        The crash happens right when the first user process is spawned:
    
        [   54.451346] Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000004
        [   54.451346]
        [   54.571516] CPU: 1 PID: 1 Comm: init Not tainted 3.16.0-rc2-00211-gd7933ab #96
        [   54.666431] Call Trace:
        [   54.698453]  [0000000000762f8c] panic+0xb0/0x224
        [   54.759071]  [000000000045cf68] do_exit+0x948/0x960
        [   54.823123]  [000000000042cbc0] fault_in_user_windows+0xe0/0x100
        [   54.902036]  [0000000000404ad0] __handle_user_windows+0x0/0x10
        [   54.978662] Press Stop-A (L1-A) to return to the boot prom
        [   55.050713] ---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000004
    
        Further investigation showed that compiling only per_cpu_patch() with
        an older compiler fixes the boot.
    
        Detailed analysis showed that the function is not being miscompiled by
        gcc-4.9, but it is using a different register allocation ordering.
    
        With the gcc-4.9 compiled function, something during the code patching
        causes some of the %i* input registers to get corrupted.  Perhaps
        we have a TLB miss path into the firmware that is deep enough to
        cause a register window spill and subsequent restore when we get
        back from the TLB miss trap.
    
        Let's plug this up by doing two things:
    
        1) Stop using the firmware stack for client interface calls into
           the firmware.  Just use the kernel's stack.
    
        2) As soon as we can, call into a new function "start_early_boot()"
           to put a one-register-window buffer between the firmware's
           deepest stack frame and the top-most initial kernel one.
    
        Reported-by: Meelis Roos <mroos@linux.ee>
        Tested-by: Meelis Roos <mroos@linux.ee>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
        Conflicts:
    
            arch/sparc/include/asm/oplib_64.h
            arch/sparc/include/asm/setup.h
            arch/sparc/kernel/entry.h
    
        Conflicts:
    
            arch/sparc/include/asm/setup.h
            arch/sparc/kernel/entry.h
            arch/sparc/kernel/setup_64.c
    
     arch/sparc/include/asm/oplib_64.h |    3 +-
     arch/sparc/include/asm/setup.h    |    4 +++
     arch/sparc/kernel/entry.h         |   11 +++------
     arch/sparc/kernel/head_64.S       |   40 +++---------------------------------
     arch/sparc/kernel/hvtramp.S       |    1 -
     arch/sparc/kernel/setup_64.c      |   28 ++++++++++++++++++-------
     arch/sparc/kernel/trampoline_64.S |   12 ++++++----
     arch/sparc/prom/cif.S             |    5 +--
     arch/sparc/prom/init_64.c         |    6 ++--
     arch/sparc/prom/p1275.c           |    2 -
     10 files changed, 46 insertions(+), 66 deletions(-)
    
    commit ae29f67b96cc0744b9860cf92f14f75c651d123b
    Author: David S. Miller <davem@davemloft.net>
    Date:   Fri Oct 24 09:59:02 2014 -0700
    
        sparc64: Implement __get_user_pages_fast().
    
        It is not sufficient to only implement get_user_pages_fast(), you
        must also implement the atomic version __get_user_pages_fast()
        otherwise you end up using the weak symbol fallback implementation
        which simply returns zero.
    
        This is dangerous, because it causes the futex code to loop forever
        if transparent hugepages are supported (see get_futex_key()).
    
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     arch/sparc/mm/gup.c |   30 ++++++++++++++++++++++++++++++
     1 files changed, 30 insertions(+), 0 deletions(-)
    
    commit 15bd5778f6b3afd30e34de674ec90f0137e9fefb
    Author: Bjorn Helgaas <bhelgaas@google.com>
    Date:   Mon Oct 13 18:59:09 2014 -0600
    
        clocksource: Remove "weak" from clocksource_default_clock() declaration
    
        kernel/time/jiffies.c provides a default clocksource_default_clock()
        definition explicitly marked "weak".  arch/s390 provides its own definition
        intended to override the default, but the "weak" attribute on the
        declaration applied to the s390 definition as well, so the linker chose one
        based on link order (see 10629d711ed7 ("PCI: Remove __weak annotation from
        pcibios_get_phb_of_node decl")).
    
        Remove the "weak" attribute from the clocksource_default_clock()
        declaration so we always prefer a non-weak definition over the weak one,
        independent of link order.
    
        Fixes: f1b82746c1e9 ("clocksource: Cleanup clocksource selection")
        Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
        Acked-by: John Stultz <john.stultz@linaro.org>
        Acked-by: Ingo Molnar <mingo@kernel.org>
        CC: Daniel Lezcano <daniel.lezcano@linaro.org>
        CC: Martin Schwidefsky <schwidefsky@de.ibm.com>
    
     include/linux/clocksource.h |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 424b26633455d26d7239285884ea38185f7c0bea
    Author: Bjorn Helgaas <bhelgaas@google.com>
    Date:   Mon Oct 13 19:00:25 2014 -0600
    
        kgdb: Remove "weak" from kgdb_arch_pc() declaration
    
        kernel/debug/debug_core.c provides a default kgdb_arch_pc() definition
        explicitly marked "weak".  Several architectures provide their own
        definitions intended to override the default, but the "weak" attribute on
        the declaration applied to the arch definitions as well, so the linker
        chose one based on link order (see 10629d711ed7 ("PCI: Remove __weak
        annotation from pcibios_get_phb_of_node decl")).
    
        Remove the "weak" attribute from the declaration so we always prefer a
        non-weak definition over the weak one, independent of link order.
    
        Fixes: 688b744d8bc8 ("kgdb: fix signedness mixmatches, add statics, add declaration to header")
        Tested-by: Vineet Gupta <vgupta@synopsys.com>       # for ARC build
        Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
        Reviewed-by: Harvey Harrison <harvey.harrison@gmail.com>
    
     include/linux/kgdb.h |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit cd6d89dd9f50d38c331519ae5b5727f744679480
    Author: Daniel Borkmann <dborkman@redhat.com>
    Date:   Tue Aug 26 23:16:35 2014 -0400
    
        random: add and use memzero_explicit() for clearing data
    
        zatimend has reported that in his environment (3.16/gcc4.8.3/corei7)
        memset() calls which clear out sensitive data in extract_{buf,entropy,
        entropy_user}() in random driver are being optimized away by gcc.
    
        Add a helper memzero_explicit() (similarly as explicit_bzero() variants)
        that can be used in such cases where a variable with sensitive data is
        being cleared out in the end. Other use cases might also be in crypto
        code. [ I have put this into lib/string.c though, as it's always built-in
        and doesn't need any dependencies then. ]
    
        Fixes kernel bugzilla: 82041
    
        Reported-by: zatimend@hotmail.co.uk
        Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
        Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
        Cc: Alexey Dobriyan <adobriyan@gmail.com>
        Signed-off-by: Theodore Ts'o <tytso@mit.edu>
        Cc: stable@vger.kernel.org
    
        Conflicts:
    
            drivers/char/random.c
            include/linux/string.h
    
     drivers/char/random.c  |   10 +++++-----
     include/linux/string.h |    6 +++++-
     lib/string.c           |   16 ++++++++++++++++
     3 files changed, 26 insertions(+), 6 deletions(-)
    
    commit 1eca6943de770d5ac058934e455cec897306ea41
    Author: Li RongQing <roy.qing.li@gmail.com>
    Date:   Wed Oct 22 17:09:53 2014 +0800
    
        xfrm6: fix a potential use after free in xfrm6_policy.c
    
        pskb_may_pull() maybe change skb->data and make nh and exthdr pointer
        oboslete, so recompute the nd and exthdr
    
        Signed-off-by: Li RongQing <roy.qing.li@gmail.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     net/ipv6/xfrm6_policy.c |   11 ++++++++---
     1 files changed, 8 insertions(+), 3 deletions(-)
    
    commit 956456e7076fcfd07485e0f2684d0e5a190a3c73
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Oct 22 20:20:21 2014 -0400
    
        compile fix
    
     net/ipv4/inet_hashtables.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 120ea2af6c8332faf60d13774ec9c3794d70e425
    Author: Tomasz Bursztyka <tomasz.bursztyka@linux.intel.com>
    Date:   Thu Jun 28 02:57:49 2012 +0000
    
        netfilter: nfnetlink: fix missing rcu_read_unlock in nfnetlink_rcv_msg
    
        Bug added in commit 6b75e3e8d664a9a (netfilter: nfnetlink: add RCU in
        nfnetlink_rcv_msg())
    
        Signed-off-by: Tomasz Bursztyka <tomasz.bursztyka@linux.intel.com>
        Acked-by: Eric Dumazet <edumazet@google.com>
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    
     net/netfilter/nfnetlink.c |    4 +++-
     1 files changed, 3 insertions(+), 1 deletions(-)
    
    commit 056a85cc432d465ef8a51bb69a6b01366466e717
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Oct 22 18:36:16 2014 -0400
    
        Remove argument from gr_update_task_in_ip_table, as it's always called with 'current'
    
     grsecurity/grsec_sock.c    |    4 ++--
     net/ipv4/inet_hashtables.c |    2 +-
     2 files changed, 3 insertions(+), 3 deletions(-)
    
    commit b27761767932b4052399e4722dc3fb412e2eed24
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Oct 22 18:19:01 2014 -0400
    
        hold sighand lock while accessing ->signal
    
     fs/proc/array.c |   10 +++++++++-
     1 files changed, 9 insertions(+), 1 deletions(-)
    
    Signature-tree: 20bd38a36b79ae68584dd0e8d4b4102c79d629bc

diff --git a/arch/sparc/include/asm/oplib_64.h b/arch/sparc/include/asm/oplib_64.h
index 97a90475c314..290b0cd512d3 100644
--- a/arch/sparc/include/asm/oplib_64.h
+++ b/arch/sparc/include/asm/oplib_64.h
@@ -62,7 +62,8 @@ struct linux_mem_p1275 {
 /* You must call prom_init() before using any of the library services,
  * preferably as early as possible.  Pass it the romvec pointer.
  */
-extern void prom_init(void *cif_handler, void *cif_stack);
+void prom_init(void *cif_handler);
+void prom_init_report(void);
 
 /* Boot argument acquisition, returns the boot command line string. */
 extern char *prom_getbootargs(void);
diff --git a/arch/sparc/include/asm/setup.h b/arch/sparc/include/asm/setup.h
index 64718ba26434..a7e41783a3c5 100644
--- a/arch/sparc/include/asm/setup.h
+++ b/arch/sparc/include/asm/setup.h
@@ -21,6 +21,10 @@ extern unsigned char boot_cpu_id;
 extern unsigned char boot_cpu_id4;
 #endif
 
+#ifdef CONFIG_SPARC64
+void __init start_early_boot(void);
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _SPARC_SETUP_H */
diff --git a/arch/sparc/kernel/entry.h b/arch/sparc/kernel/entry.h
index 0c218e4c0881..f8125bcceace 100644
--- a/arch/sparc/kernel/entry.h
+++ b/arch/sparc/kernel/entry.h
@@ -59,13 +59,10 @@ struct popc_6insn_patch_entry {
 extern struct popc_6insn_patch_entry __popc_6insn_patch,
 	__popc_6insn_patch_end;
 
-extern void __init per_cpu_patch(void);
-extern void sun4v_patch_1insn_range(struct sun4v_1insn_patch_entry *,
-				    struct sun4v_1insn_patch_entry *);
-extern void sun4v_patch_2insn_range(struct sun4v_2insn_patch_entry *,
-				    struct sun4v_2insn_patch_entry *);
-extern void __init sun4v_patch(void);
-extern void __init boot_cpu_id_too_large(int cpu);
+void sun4v_patch_1insn_range(struct sun4v_1insn_patch_entry *,
+			     struct sun4v_1insn_patch_entry *);
+void sun4v_patch_2insn_range(struct sun4v_2insn_patch_entry *,
+			     struct sun4v_2insn_patch_entry *);
 extern unsigned int dcache_parity_tl1_occurred;
 extern unsigned int icache_parity_tl1_occurred;
 
diff --git a/arch/sparc/kernel/head_64.S b/arch/sparc/kernel/head_64.S
index 0d810c2f1d00..fec9fd6512e2 100644
--- a/arch/sparc/kernel/head_64.S
+++ b/arch/sparc/kernel/head_64.S
@@ -629,14 +629,12 @@ tlb_fixup_done:
 	sethi	%hi(init_thread_union), %g6
 	or	%g6, %lo(init_thread_union), %g6
 	ldx	[%g6 + TI_TASK], %g4
-	mov	%sp, %l6
 
 	wr	%g0, ASI_P, %asi
 	mov	1, %g1
 	sllx	%g1, THREAD_SHIFT, %g1
 	sub	%g1, (STACKFRAME_SZ + STACK_BIAS), %g1
 	add	%g6, %g1, %sp
-	mov	0, %fp
 
 	/* Set per-cpu pointer initially to zero, this makes
 	 * the boot-cpu use the in-kernel-image per-cpu areas
@@ -663,44 +661,14 @@ tlb_fixup_done:
 	 nop
 #endif
 
-	mov	%l6, %o1			! OpenPROM stack
 	call	prom_init
 	 mov	%l7, %o0			! OpenPROM cif handler
 
-	/* Initialize current_thread_info()->cpu as early as possible.
-	 * In order to do that accurately we have to patch up the get_cpuid()
-	 * assembler sequences.  And that, in turn, requires that we know
-	 * if we are on a Starfire box or not.  While we're here, patch up
-	 * the sun4v sequences as well.
+	/* To create a one-register-window buffer between the kernel's
+	 * initial stack and the last stack frame we use from the firmware,
+	 * do the rest of the boot from a C helper function.
 	 */
-	call	check_if_starfire
-	 nop
-	call	per_cpu_patch
-	 nop
-	call	sun4v_patch
-	 nop
-
-#ifdef CONFIG_SMP
-	call	hard_smp_processor_id
-	 nop
-	cmp	%o0, NR_CPUS
-	blu,pt	%xcc, 1f
-	 nop
-	call	boot_cpu_id_too_large
-	 nop
-	/* Not reached... */
-
-1:
-#else
-	mov	0, %o0
-#endif
-	sth	%o0, [%g6 + TI_CPU]
-
-	call	prom_init_report
-	 nop
-
-	/* Off we go.... */
-	call	start_kernel
+	call	start_early_boot
 	 nop
 	/* Not reached... */
 
diff --git a/arch/sparc/kernel/hvtramp.S b/arch/sparc/kernel/hvtramp.S
index 9365432904d6..b69d224a4fb5 100644
--- a/arch/sparc/kernel/hvtramp.S
+++ b/arch/sparc/kernel/hvtramp.S
@@ -111,7 +111,6 @@ hv_cpu_startup:
 	sllx		%g5, THREAD_SHIFT, %g5
 	sub		%g5, (STACKFRAME_SZ + STACK_BIAS), %g5
 	add		%g6, %g5, %sp
-	mov		0, %fp
 
 	call		init_irqwork_curcpu
 	 nop
diff --git a/arch/sparc/kernel/setup_64.c b/arch/sparc/kernel/setup_64.c
index a854a1c240ff..52488a58e20a 100644
--- a/arch/sparc/kernel/setup_64.c
+++ b/arch/sparc/kernel/setup_64.c
@@ -30,6 +30,7 @@
 #include <linux/cpu.h>
 #include <linux/initrd.h>
 #include <linux/module.h>
+#include <linux/start_kernel.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
@@ -174,7 +175,7 @@ char reboot_command[COMMAND_LINE_SIZE];
 
 static struct pt_regs fake_swapper_regs = { { 0, }, 0, 0, 0, 0 };
 
-void __init per_cpu_patch(void)
+static void __init per_cpu_patch(void)
 {
 	struct cpuid_patch_entry *p;
 	unsigned long ver;
@@ -266,7 +267,7 @@ void sun4v_patch_2insn_range(struct sun4v_2insn_patch_entry *start,
 	}
 }
 
-void __init sun4v_patch(void)
+static void __init sun4v_patch(void)
 {
 	extern void sun4v_hvapi_init(void);
 
@@ -316,14 +317,25 @@ static void __init popc_patch(void)
 	}
 }
 
-#ifdef CONFIG_SMP
-void __init boot_cpu_id_too_large(int cpu)
+void __init start_early_boot(void)
 {
-	prom_printf("Serious problem, boot cpu id (%d) >= NR_CPUS (%d)\n",
-		    cpu, NR_CPUS);
-	prom_halt();
+	int cpu;
+
+	check_if_starfire();
+	per_cpu_patch();
+	sun4v_patch();
+
+	cpu = hard_smp_processor_id();
+	if (cpu >= NR_CPUS) {
+		prom_printf("Serious problem, boot cpu id (%d) >= NR_CPUS (%d)\n",
+			    cpu, NR_CPUS);
+		prom_halt();
+	}
+	current_thread_info()->cpu = cpu;
+
+	prom_init_report();
+	start_kernel();
 }
-#endif
 
 /* On Ultra, we support all of the v8 capabilities. */
 unsigned long sparc64_elf_hwcap = (HWCAP_SPARC_FLUSH | HWCAP_SPARC_STBAR |
diff --git a/arch/sparc/kernel/trampoline_64.S b/arch/sparc/kernel/trampoline_64.S
index 8fa84a3897cb..3fc8ad5242e6 100644
--- a/arch/sparc/kernel/trampoline_64.S
+++ b/arch/sparc/kernel/trampoline_64.S
@@ -112,10 +112,13 @@ startup_continue:
 	brnz,pn		%g1, 1b
 	 nop
 
-	sethi		%hi(p1275buf), %g2
-	or		%g2, %lo(p1275buf), %g2
-	ldx		[%g2 + 0x10], %l2
-	add		%l2, -(192 + 128), %sp
+	/* Get onto temporary stack which will be in the locked
+	 * kernel image.
+	 */
+	sethi		%hi(tramp_stack), %g1
+	or		%g1, %lo(tramp_stack), %g1
+	add		%g1, TRAMP_STACK_SIZE, %g1
+	sub		%g1, STACKFRAME_SZ + STACK_BIAS + 256, %sp
 	flushw
 
 	/* Setup the loop variables:
@@ -397,7 +400,6 @@ after_lock_tlb:
 	sllx		%g5, THREAD_SHIFT, %g5
 	sub		%g5, (STACKFRAME_SZ + STACK_BIAS), %g5
 	add		%g6, %g5, %sp
-	mov		0, %fp
 
 	rdpr		%pstate, %o1
 	or		%o1, PSTATE_IE, %o1
diff --git a/arch/sparc/mm/gup.c b/arch/sparc/mm/gup.c
index 42c55df3aec3..20da9422c279 100644
--- a/arch/sparc/mm/gup.c
+++ b/arch/sparc/mm/gup.c
@@ -106,6 +106,36 @@ static int gup_pud_range(pgd_t pgd, unsigned long addr, unsigned long end,
 	return 1;
 }
 
+int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
+			  struct page **pages)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long addr, len, end;
+	unsigned long next, flags;
+	pgd_t *pgdp;
+	int nr = 0;
+
+	start &= PAGE_MASK;
+	addr = start;
+	len = (unsigned long) nr_pages << PAGE_SHIFT;
+	end = start + len;
+
+	local_irq_save(flags);
+	pgdp = pgd_offset(mm, addr);
+	do {
+		pgd_t pgd = *pgdp;
+
+		next = pgd_addr_end(addr, end);
+		if (pgd_none(pgd))
+			break;
+		if (!gup_pud_range(pgd, addr, next, write, pages, &nr))
+			break;
+	} while (pgdp++, addr = next, addr != end);
+	local_irq_restore(flags);
+
+	return nr;
+}
+
 int get_user_pages_fast(unsigned long start, int nr_pages, int write,
 			struct page **pages)
 {
diff --git a/arch/sparc/prom/cif.S b/arch/sparc/prom/cif.S
index 9c86b4b7d429..8050f381f518 100644
--- a/arch/sparc/prom/cif.S
+++ b/arch/sparc/prom/cif.S
@@ -11,11 +11,10 @@
 	.text
 	.globl	prom_cif_direct
 prom_cif_direct:
+	save	%sp, -192, %sp
 	sethi	%hi(p1275buf), %o1
 	or	%o1, %lo(p1275buf), %o1
-	ldx	[%o1 + 0x0010], %o2	! prom_cif_stack
-	save	%o2, -192, %sp
-	ldx	[%i1 + 0x0008], %l2	! prom_cif_handler
+	ldx	[%o1 + 0x0008], %l2	! prom_cif_handler
 	mov	%g4, %l0
 	mov	%g5, %l1
 	mov	%g6, %l3
diff --git a/arch/sparc/prom/init_64.c b/arch/sparc/prom/init_64.c
index 5016c5e20575..ffb1cc56a41e 100644
--- a/arch/sparc/prom/init_64.c
+++ b/arch/sparc/prom/init_64.c
@@ -26,13 +26,13 @@ phandle prom_chosen_node;
  * failure.  It gets passed the pointer to the PROM vector.
  */
 
-extern void prom_cif_init(void *, void *);
+extern void prom_cif_init(void *);
 
-void __init prom_init(void *cif_handler, void *cif_stack)
+void __init prom_init(void *cif_handler)
 {
 	phandle node;
 
-	prom_cif_init(cif_handler, cif_stack);
+	prom_cif_init(cif_handler);
 
 	prom_chosen_node = prom_finddevice(prom_chosen_path);
 	if (!prom_chosen_node || (s32)prom_chosen_node == -1)
diff --git a/arch/sparc/prom/p1275.c b/arch/sparc/prom/p1275.c
index d9850c2b9bf2..5bbbc23eb9b6 100644
--- a/arch/sparc/prom/p1275.c
+++ b/arch/sparc/prom/p1275.c
@@ -21,7 +21,6 @@
 struct {
 	long prom_callback;			/* 0x00 */
 	void (*prom_cif_handler)(long *);	/* 0x08 */
-	unsigned long prom_cif_stack;		/* 0x10 */
 } p1275buf;
 
 extern void prom_world(int);
@@ -53,5 +52,4 @@ void p1275_cmd_direct(unsigned long *args)
 void prom_cif_init(void *cif_handler, void *cif_stack)
 {
 	p1275buf.prom_cif_handler = (void (*)(long *))cif_handler;
-	p1275buf.prom_cif_stack = (unsigned long)cif_stack;
 }
diff --git a/block/blk-throttle.c b/block/blk-throttle.c
index 5eed6a76721d..0e8abe97874f 100644
--- a/block/blk-throttle.c
+++ b/block/blk-throttle.c
@@ -361,6 +361,7 @@ static struct throtl_grp * throtl_get_tg(struct throtl_data *td)
 	/* Group allocation failed. Account the IO to root group */
 	if (!tg) {
 		tg = td->root_tg;
+		rcu_read_unlock();
 		return tg;
 	}
 
diff --git a/drivers/acpi/atomicio.c b/drivers/acpi/atomicio.c
index cfc0cc10af39..61fdbaa6fdfa 100644
--- a/drivers/acpi/atomicio.c
+++ b/drivers/acpi/atomicio.c
@@ -286,6 +286,7 @@ static int acpi_atomic_read_mem(u64 paddr, u64 *val, u32 width)
 		break;
 #endif
 	default:
+		rcu_read_unlock();
 		return -EINVAL;
 	}
 	rcu_read_unlock();
@@ -315,6 +316,7 @@ static int acpi_atomic_write_mem(u64 paddr, u64 val, u32 width)
 		break;
 #endif
 	default:
+		rcu_read_unlock();
 		return -EINVAL;
 	}
 	rcu_read_unlock();
diff --git a/drivers/char/random.c b/drivers/char/random.c
index a86bc96ae30c..2b94e166840c 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -1056,8 +1056,8 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	 * pool while mixing, and hash one final time.
 	 */
 	sha_transform(hash.w, extract, workspace);
-	memset(extract, 0, sizeof(extract));
-	memset(workspace, 0, sizeof(workspace));
+	memzero_explicit(extract, sizeof(extract));
+	memzero_explicit(workspace, sizeof(workspace));
 
 	/*
 	 * In case the hash function has some recognizable output
@@ -1069,7 +1069,7 @@ static void extract_buf(struct entropy_store *r, __u8 *out)
 	hash.w[2] ^= rol32(hash.w[2], 16);
 
 	memcpy(out, &hash, EXTRACT_SIZE);
-	memset(&hash, 0, sizeof(hash));
+	memzero_explicit(&hash, sizeof(hash));
 }
 
 /*
@@ -1126,7 +1126,7 @@ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	memzero_explicit(tmp, sizeof(tmp));
 
 	return ret;
 }
@@ -1168,7 +1168,7 @@ static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
 	}
 
 	/* Wipe data just returned from memory */
-	memset(tmp, 0, sizeof(tmp));
+	memzero_explicit(tmp, sizeof(tmp));
 
 	return ret;
 }
diff --git a/fs/proc/array.c b/fs/proc/array.c
index 61db155fdbbf..5dec96d66585 100644
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -612,6 +612,14 @@ int proc_pid_statm(struct seq_file *m, struct pid_namespace *ns,
 #ifdef CONFIG_GRKERNSEC_PROC_IPADDR
 int proc_pid_ipaddr(struct task_struct *task, char *buffer)
 {
-	return sprintf(buffer, "%pI4\n", &task->signal->curr_ip);
+	unsigned long flags;
+	u32 curr_ip = 0;
+
+	if (lock_task_sighand(task, &flags)) {
+		curr_ip = task->signal->curr_ip;
+		unlock_task_sighand(task, &flags);
+	}
+
+	return sprintf(buffer, "%pI4\n", &curr_ip);
 }
 #endif
diff --git a/grsecurity/grsec_sock.c b/grsecurity/grsec_sock.c
index c0aef3a01d8a..e3650b67d18a 100644
--- a/grsecurity/grsec_sock.c
+++ b/grsecurity/grsec_sock.c
@@ -121,10 +121,10 @@ static struct signal_struct * gr_lookup_task_ip_table(__u32 saddr, __u32 daddr,
 
 #endif
 
-void gr_update_task_in_ip_table(struct task_struct *task, const struct inet_sock *inet)
+void gr_update_task_in_ip_table(const struct inet_sock *inet)
 {
 #ifdef CONFIG_GRKERNSEC
-	struct signal_struct *sig = task->signal;
+	struct signal_struct *sig = current->signal;
 	struct conn_table_entry *newent;
 
 	newent = kmalloc(sizeof(struct conn_table_entry), GFP_ATOMIC);
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 081147da0564..da8954333a29 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -284,7 +284,7 @@ extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 extern void clocksource_suspend(void);
 extern void clocksource_resume(void);
-extern struct clocksource * __init __weak clocksource_default_clock(void);
+extern struct clocksource * __init clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);
 
 extern void
diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 5633053ac7c2..9ac1a7a977c2 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -37,6 +37,9 @@
     __asm__ ("" : "=r"(__ptr) : "0"(ptr));		\
     (typeof(ptr)) (__ptr + (off)); })
 
+/* Make the optimizer believe the variable can be manipulated arbitrarily. */
+#define OPTIMIZER_HIDE_VAR(var) __asm__ ("" : "=r" (var) : "0" (var))
+
 #ifdef __CHECKER__
 #define __must_be_array(arr) 0
 #else
diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index cba9593c4047..1a97cac7dcb2 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -15,6 +15,7 @@
  */
 #undef barrier
 #undef RELOC_HIDE
+#undef OPTIMIZER_HIDE_VAR
 
 #define barrier() __memory_barrier()
 
@@ -23,6 +24,12 @@
      __ptr = (unsigned long) (ptr);				\
     (typeof(ptr)) (__ptr + (off)); })
 
+/* This should act as an optimization barrier on var.
+ * Given that this compiler does not have inline assembly, a compiler barrier
+ * is the best we can do.
+ */
+#define OPTIMIZER_HIDE_VAR(var) barrier()
+
 /* Intel ECC compiler doesn't support __builtin_types_compatible_p() */
 #define __must_be_array(a) 0
 
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index f4c24bff5908..92ea3aed6fec 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -186,6 +186,10 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
     (typeof(ptr)) (__ptr + (off)); })
 #endif
 
+#ifndef OPTIMIZER_HIDE_VAR
+#define OPTIMIZER_HIDE_VAR(var) barrier()
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASSEMBLY__ */
diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 5df9c195fe2a..ef363890f6cb 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -281,7 +281,7 @@ struct kgdb_io {
 
 extern struct kgdb_arch		arch_kgdb_ops;
 
-extern unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs);
+extern unsigned long kgdb_arch_pc(int exception, struct pt_regs *regs);
 
 extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
diff --git a/include/linux/string.h b/include/linux/string.h
index e033564f10ba..e43a65c89220 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -133,7 +133,7 @@ int bprintf(u32 *bin_buf, size_t size, const char *fmt, ...) __printf(3, 4);
 #endif
 
 extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
-			const void *from, size_t available);
+				       const void *from, size_t available);
 
 /**
  * strstarts - does @str start with @prefix?
@@ -144,5 +144,9 @@ static inline bool strstarts(const char *str, const char *prefix)
 {
 	return strncmp(str, prefix, strlen(prefix)) == 0;
 }
+
+size_t memweight(const void *ptr, size_t bytes);
+void memzero_explicit(void *s, size_t count);
+
 #endif
 #endif /* _LINUX_STRING_H_ */
diff --git a/lib/radix-tree.c b/lib/radix-tree.c
index e73c2fe0c787..a541641b6dff 100644
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@ -1273,8 +1273,10 @@ unsigned long radix_tree_locate_item(struct radix_tree_root *root, void *item)
 
 		node = indirect_to_ptr(node);
 		max_index = radix_tree_maxindex(node->height);
-		if (cur_index > max_index)
+		if (cur_index > max_index) {
+			rcu_read_unlock();
 			break;
+		}
 
 		cur_index = __locate(node, item, cur_index, &found_index);
 		rcu_read_unlock();
diff --git a/lib/string.c b/lib/string.c
index dc4a86341f91..40136f6f8ea3 100644
--- a/lib/string.c
+++ b/lib/string.c
@@ -583,6 +583,22 @@ void *memset(void *s, int c, size_t count)
 EXPORT_SYMBOL(memset);
 #endif
 
+/**
+ * memzero_explicit - Fill a region of memory (e.g. sensitive
+ *		      keying data) with 0s.
+ * @s: Pointer to the start of the area.
+ * @count: The size of the area.
+ *
+ * memzero_explicit() doesn't need an arch-specific version as
+ * it just invokes the one of memset() implicitly.
+ */
+void memzero_explicit(void *s, size_t count)
+{
+	memset(s, 0, count);
+	OPTIMIZER_HIDE_VAR(s);
+}
+EXPORT_SYMBOL(memzero_explicit);
+
 #ifndef __HAVE_ARCH_MEMCPY
 /**
  * memcpy - Copy one area of memory to another
diff --git a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
index 392d206f464a..a15c1887ab1f 100644
--- a/net/ipv4/inet_hashtables.c
+++ b/net/ipv4/inet_hashtables.c
@@ -25,7 +25,7 @@
 #include <net/secure_seq.h>
 #include <net/ip.h>
 
-extern void gr_update_task_in_ip_table(struct task_struct *task, const struct inet_sock *inet);
+extern void gr_update_task_in_ip_table(const struct inet_sock *inet);
 
 /*
  * Allocate and initialize a new local port bind bucket.
@@ -533,7 +533,7 @@ int __inet_hash_connect(struct inet_timewait_death_row *death_row,
 			twrefcnt += inet_twsk_bind_unhash(tw, hinfo);
 		spin_unlock(&head->lock);
 
-		gr_update_task_in_ip_table(current, inet_sk(sk));
+		gr_update_task_in_ip_table(inet_sk(sk));
 
 		if (tw) {
 			inet_twsk_deschedule(tw, death_row);
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index c88f974ba83b..df6de013319f 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -160,8 +160,10 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 		case IPPROTO_DCCP:
 			if (!onlyproto && (nh + offset + 4 < skb->data ||
 			     pskb_may_pull(skb, nh + offset + 4 - skb->data))) {
-				__be16 *ports = (__be16 *)exthdr;
+				__be16 *ports;
 
+				nh = skb_network_header(skb);
+				ports = (__be16 *)(nh + offset);
 				fl6->fl6_sport = ports[!!reverse];
 				fl6->fl6_dport = ports[!reverse];
 			}
@@ -170,8 +172,10 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 
 		case IPPROTO_ICMPV6:
 			if (!onlyproto && pskb_may_pull(skb, nh + offset + 2 - skb->data)) {
-				u8 *icmp = (u8 *)exthdr;
+				u8 *icmp;
 
+				nh = skb_network_header(skb);
+				icmp = (u8 *)(nh + offset);
 				fl6->fl6_icmp_type = icmp[0];
 				fl6->fl6_icmp_code = icmp[1];
 			}
@@ -182,8 +186,9 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 		case IPPROTO_MH:
 			if (!onlyproto && pskb_may_pull(skb, nh + offset + 3 - skb->data)) {
 				struct ip6_mh *mh;
-				mh = (struct ip6_mh *)exthdr;
 
+				nh = skb_network_header(skb);
+				mh = (struct ip6_mh *)(nh + offset);
 				fl6->fl6_mh_type = mh->ip6mh_type;
 			}
 			fl6->flowi6_proto = nexthdr;
diff --git a/net/netfilter/nfnetlink.c b/net/netfilter/nfnetlink.c
index b4f8d849480c..4ffd251f272f 100644
--- a/net/netfilter/nfnetlink.c
+++ b/net/netfilter/nfnetlink.c
@@ -170,8 +170,10 @@ static int nfnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 
 		err = nla_parse(cda, ss->cb[cb_id].attr_count,
 				attr, attrlen, ss->cb[cb_id].policy);
-		if (err < 0)
+		if (err < 0) {
+			rcu_read_unlock();
 			return err;
+		}
 
 		if (nc->call_rcu) {
 			err = nc->call_rcu(net->nfnl, skb, nlh,
diff --git a/virt/kvm/iommu.c b/virt/kvm/iommu.c
index c946700927fa..e32c93ca6446 100644
--- a/virt/kvm/iommu.c
+++ b/virt/kvm/iommu.c
@@ -43,13 +43,13 @@ static void kvm_iommu_put_pages(struct kvm *kvm,
 				gfn_t base_gfn, unsigned long npages);
 
 static pfn_t kvm_pin_pages(struct kvm *kvm, struct kvm_memory_slot *slot,
-			   gfn_t gfn, unsigned long size)
+			   gfn_t gfn, unsigned long npages)
 {
 	gfn_t end_gfn;
 	pfn_t pfn;
 
 	pfn     = gfn_to_pfn_memslot(kvm, slot, gfn);
-	end_gfn = gfn + (size >> PAGE_SHIFT);
+	end_gfn = gfn + npages;
 	gfn    += 1;
 
 	if (is_error_pfn(pfn))
@@ -117,7 +117,7 @@ int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 		 * Pin all pages we are about to map in memory. This is
 		 * important because we unmap and unpin in 4kb steps later.
 		 */
-		pfn = kvm_pin_pages(kvm, slot, gfn, page_size);
+		pfn = kvm_pin_pages(kvm, slot, gfn, page_size >> PAGE_SHIFT);
 		if (is_error_pfn(pfn)) {
 			gfn += 1;
 			continue;
@@ -129,7 +129,7 @@ int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 		if (r) {
 			printk(KERN_ERR "kvm_iommu_map_address:"
 			       "iommu failed to map pfn=%llx\n", pfn);
-			kvm_unpin_pages(kvm, pfn, page_size);
+			kvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);
 			goto unmap_pages;
 		}
 
