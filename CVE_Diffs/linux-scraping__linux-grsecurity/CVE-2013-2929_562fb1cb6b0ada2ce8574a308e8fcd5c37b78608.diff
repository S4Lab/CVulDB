linux-scraping__linux-grsecurity
commit 562fb1cb6b0ada2ce8574a308e8fcd5c37b78608
Author:     Brad Spengler <spender@grsecurity.net>
AuthorDate: Sun Dec 8 17:55:31 2013 -0500
Commit:     Mickaël Salaün <mic@digikod.net>
CommitDate: Sun Dec 8 17:55:31 2013 -0500

    grsec: Apply grsecurity-2.9.1-2.6.32.61-201312081751.patch
    
    commit c4fc49b74a456c62b3585b942501b5d63fe41cde
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Sun Dec 8 16:09:43 2013 -0500
    
        Backport of:
        If we allocate less than sizeof(struct attrlist) then we end up
        corrupting memory or doing a ZERO_PTR_SIZE dereference.
    
        This can only be triggered with CAP_SYS_ADMIN.
    
        Reported-by: Nico Golde <nico@xxxxxxxxx>
        Reported-by: Fabian Yamaguchi <fabs@xxxxxxxxx>
        Signed-off-by: Dan Carpenter <dan.carpenter@xxxxxxxxxx>
    
     fs/xfs/linux-2.6/xfs_ioctl.c   |    3 ++-
     fs/xfs/linux-2.6/xfs_ioctl32.c |    3 ++-
     2 files changed, 4 insertions(+), 2 deletions(-)
    
    commit a9dd0625d9eb28bdd465c7767a8db04ce66e17a7
    Author: Mahesh Rajashekhara <Mahesh.Rajashekhara@pmcs.com>
    Date:   Thu Oct 31 14:01:02 2013 +0530
    
        Upstream commit: b4789b8e6be3151a955ade74872822f30e8cd914
    
        aacraid: prevent invalid pointer dereference
    
        It appears that driver runs into a problem here if fibsize is too small
        because we allocate user_srbcmd with fibsize size only but later we
        access it until user_srbcmd->sg.count to copy it over to srbcmd.
    
        It is not correct to test (fibsize < sizeof(*user_srbcmd)) because this
        structure already includes one sg element and this is not needed for
        commands without data.  So, we would recommend to add the following
        (instead of test for fibsize == 0).
    
        Signed-off-by: Mahesh Rajashekhara <Mahesh.Rajashekhara@pmcs.com>
        Reported-by: Nico Golde <nico@ngolde.de>
        Reported-by: Fabian Yamaguchi <fabs@goesec.de>
        Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
     drivers/scsi/aacraid/commctrl.c |    3 ++-
     1 files changed, 2 insertions(+), 1 deletions(-)
    
    commit 07d66d9a5e832ee9faf8f50ab434a3e413f694bc
    Author: Dan Carpenter <dan.carpenter@oracle.com>
    Date:   Wed Oct 30 20:12:51 2013 +0300
    
        Upstream commit: a497e47d4aec37aaf8f13509f3ef3d1f6a717d88
    
        libertas: potential oops in debugfs
    
        If we do a zero size allocation then it will oops.  Also we can't be
        sure the user passes us a NUL terminated string so I've added a
        terminator.
    
        This code can only be triggered by root.
    
        Reported-by: Nico Golde <nico@ngolde.de>
        Reported-by: Fabian Yamaguchi <fabs@goesec.de>
        Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
        Acked-by: Dan Williams <dcbw@redhat.com>
        Signed-off-by: John W. Linville <linville@tuxdriver.com>
    
     drivers/net/wireless/libertas/debugfs.c |    6 +++++-
     1 files changed, 5 insertions(+), 1 deletions(-)
    
    commit 03d8a00f5b72b74643b1dcf506877852c1836fbd
    Author: Linus Torvalds <torvalds@linux-foundation.org>
    Date:   Mon Dec 2 11:50:37 2013 -0800
    
        Upstream commit: b65502879556d041b45104c6a35abbbba28c8f2d
    
        uio: we cannot mmap unaligned page contents
    
        In commit 7314e613d5ff ("Fix a few incorrectly checked
        [io_]remap_pfn_range() calls") the uio driver started more properly
        checking the passed-in user mapping arguments against the size of the
        actual uio driver data.
    
        That in turn exposed that some driver authors apparently didn't realize
        that mmap can only work on a page granularity, and had tried to use it
        with smaller mappings, with the new size check catching that out.
    
        So since it's not just the user mmap() arguments that can be confused,
        make the uio mmap code also verify that the uio driver has the memory
        allocated at page boundaries in order for mmap to work.  If the device
        memory isn't properly aligned, we return
    
          [ENODEV]
            The fildes argument refers to a file whose type is not supported by mmap().
    
        as per the open group documentation on mmap.
    
        Reported-by: Holger Brunck <holger.brunck@keymile.com>
        Acked-by: Greg KH <gregkh@linuxfoundation.org>
        Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
        Conflicts:
    
            drivers/uio/uio.c
    
     drivers/uio/uio.c |    5 +++++
     1 files changed, 5 insertions(+), 0 deletions(-)
    
    commit c21e0ee59db620ba05f187b07dfc0e0560bdc9fc
    Author: David S. Miller <davem@davemloft.net>
    Date:   Mon Oct 25 13:04:48 2010 -0700
    
        Upstream commit: 5202e173d7bc5ff832a4f36e66f26e00feb343c6
        Bug prevented allyesconfig builds with a slightly different config
    
        tms380tr: Use mdelay() in tms380tr_wait().
    
        This driver tries to do up to half-second udelay()
        calls, which overflows on x86-64.
    
        Reported-by: Andi Kleen <andi@firstfloor.org>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
     drivers/net/tokenring/tms380tr.c |    2 +-
     1 files changed, 1 insertions(+), 1 deletions(-)
    
    commit 70598191b243115a68f3a777893b535c147b381b
    Author: Brad Spengler <spender@grsecurity.net>
    Date:   Wed Dec 4 18:34:13 2013 -0500
    
        Backport fix for CVE-2013-2929, upstream commit:
        d049f74f2dbe71354d43d393ac3a188947811348
    
     arch/ia64/include/asm/processor.h |    2 +-
     grsecurity/grsec_sig.c            |    3 ++-
     include/linux/binfmts.h           |    3 ---
     include/linux/sched.h             |    4 ++++
     kernel/ptrace.c                   |    2 +-
     5 files changed, 8 insertions(+), 6 deletions(-)
    
    Signature-tree: 32fa1438c16113f3cdc90a4aea15e3c3632e5988

diff --git a/arch/ia64/include/asm/processor.h b/arch/ia64/include/asm/processor.h
index 3eaeedf1aef2..05309623d5d5 100644
--- a/arch/ia64/include/asm/processor.h
+++ b/arch/ia64/include/asm/processor.h
@@ -361,7 +361,7 @@ struct thread_struct {
 	regs->loadrs = 0;									\
 	regs->r8 = get_dumpable(current->mm);	/* set "don't zap registers" flag */		\
 	regs->r12 = new_sp - 16;	/* allocate 16 byte scratch area */			\
-	if (unlikely(!get_dumpable(current->mm))) {							\
+	if (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) {				\
 		/*										\
 		 * Zap scratch regs to avoid leaking bits between processes with different	\
 		 * uid/privileges.								\
diff --git a/drivers/net/tokenring/tms380tr.c b/drivers/net/tokenring/tms380tr.c
index fa152144aacf..ebecd451832a 100644
--- a/drivers/net/tokenring/tms380tr.c
+++ b/drivers/net/tokenring/tms380tr.c
@@ -1248,7 +1248,7 @@ void tms380tr_wait(unsigned long time)
 		tmp = schedule_timeout_interruptible(tmp);
 	} while(time_after(tmp, jiffies));
 #else
-	udelay(time);
+	mdelay(time / 1000);
 #endif
 	return;
 }
diff --git a/drivers/net/wireless/libertas/debugfs.c b/drivers/net/wireless/libertas/debugfs.c
index 7f66a50850b1..48f2a7a7de85 100644
--- a/drivers/net/wireless/libertas/debugfs.c
+++ b/drivers/net/wireless/libertas/debugfs.c
@@ -925,7 +925,10 @@ static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,
 	char *p2;
 	struct debug_data *d = (struct debug_data *)f->private_data;
 
-	pdata = kmalloc(cnt, GFP_KERNEL);
+	if (cnt == 0)
+		return 0;
+
+	pdata = kmalloc(cnt + 1, GFP_KERNEL);
 	if (pdata == NULL)
 		return 0;
 
@@ -934,6 +937,7 @@ static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,
 		kfree(pdata);
 		return 0;
 	}
+	pdata[cnt] = '\0';
 
 	p0 = pdata;
 	for (i = 0; i < num_of_items; i++) {
diff --git a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c
index a6a0e43bf718..ec62be5b5860 100644
--- a/drivers/scsi/aacraid/commctrl.c
+++ b/drivers/scsi/aacraid/commctrl.c
@@ -508,7 +508,8 @@ static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)
 		goto cleanup;
 	}
 
-	if (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr))) {
+	if ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||
+	    (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {
 		rcode = -EINVAL;
 		goto cleanup;
 	}
diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index d73efa7d0271..deb21b59795c 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -677,6 +677,11 @@ static int uio_mmap_physical(struct vm_area_struct *vma)
 		return -EINVAL;
 	mem = idev->info->mem + mi;
 
+	if (mem->addr & ~PAGE_MASK)
+		return -ENODEV;
+	if (vma->vm_end - vma->vm_start > mem->size)
+		return -EINVAL;
+
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
 	/*
diff --git a/fs/xfs/linux-2.6/xfs_ioctl.c b/fs/xfs/linux-2.6/xfs_ioctl.c
index 88f96f57e4fc..c34007f3d021 100644
--- a/fs/xfs/linux-2.6/xfs_ioctl.c
+++ b/fs/xfs/linux-2.6/xfs_ioctl.c
@@ -410,7 +410,8 @@ xfs_attrlist_by_handle(
 		return -XFS_ERROR(EPERM);
 	if (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))
 		return -XFS_ERROR(EFAULT);
-	if (al_hreq.buflen > XATTR_LIST_MAX)
+	if (al_hreq.buflen < sizeof(struct attrlist) ||
+	    al_hreq.buflen > XATTR_LIST_MAX)
 		return -XFS_ERROR(EINVAL);
 
 	/*
diff --git a/fs/xfs/linux-2.6/xfs_ioctl32.c b/fs/xfs/linux-2.6/xfs_ioctl32.c
index 479bd3230b64..93cf913f0ec8 100644
--- a/fs/xfs/linux-2.6/xfs_ioctl32.c
+++ b/fs/xfs/linux-2.6/xfs_ioctl32.c
@@ -362,7 +362,8 @@ xfs_compat_attrlist_by_handle(
 	if (copy_from_user(&al_hreq, arg,
 			   sizeof(compat_xfs_fsop_attrlist_handlereq_t)))
 		return -XFS_ERROR(EFAULT);
-	if (al_hreq.buflen > XATTR_LIST_MAX)
+	if (al_hreq.buflen < sizeof(struct attrlist) ||
+	    al_hreq.buflen > XATTR_LIST_MAX)
 		return -XFS_ERROR(EINVAL);
 
 	/*
diff --git a/grsecurity/grsec_sig.c b/grsecurity/grsec_sig.c
index d9d6bacb5c08..1571426b48ba 100644
--- a/grsecurity/grsec_sig.c
+++ b/grsecurity/grsec_sig.c
@@ -106,8 +106,9 @@ void gr_handle_brute_attach(unsigned long mm_flags)
 	} else {
 		const struct cred *cred = __task_cred(p), *cred2;
 		struct task_struct *tsk, *tsk2;
+		int dumpable = __get_dumpable(mm_flags);
 
-		if (!__get_dumpable(mm_flags) && cred->uid) {
+		if (dumpable != SUID_DUMP_USER && cred->uid) {
 			struct user_struct *user;
 
 			uid = cred->uid;
diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h
index 2c35c795cc10..34819e43b9c4 100644
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@ -109,9 +109,6 @@ extern int flush_old_exec(struct linux_binprm * bprm);
 extern void setup_new_exec(struct linux_binprm * bprm);
 
 extern int suid_dumpable;
-#define SUID_DUMP_DISABLE	0	/* No setuid dumping */
-#define SUID_DUMP_USER		1	/* Dump as user of process */
-#define SUID_DUMP_ROOT		2	/* Dump as root */
 
 /* Stack area protections */
 #define EXSTACK_DEFAULT   0	/* Whatever the arch defaults to */
diff --git a/include/linux/sched.h b/include/linux/sched.h
index a320221cfac3..3bdf669c4b88 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -455,6 +455,10 @@ static inline unsigned long get_mm_hiwater_vm(struct mm_struct *mm)
 extern void set_dumpable(struct mm_struct *mm, int value);
 extern int get_dumpable(struct mm_struct *mm);
 
+#define SUID_DUMP_DISABLE	0	/* No setuid dumping */
+#define SUID_DUMP_USER		1	/* Dump as user of process */
+#define SUID_DUMP_ROOT		2	/* Dump as root */
+
 /* mm flags */
 /* dumpable bits */
 #define MMF_DUMPABLE      0  /* core dump is permitted */
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 2617b8c1d1a1..5186770ff4f2 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -190,7 +190,7 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode,
 	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
-	if (!dumpable &&
+	if (dumpable != SUID_DUMP_USER &&
 	     ((!log && !capable_nolog(CAP_SYS_PTRACE)) ||
 	      (log && !capable(CAP_SYS_PTRACE))))
 		return -EPERM;
