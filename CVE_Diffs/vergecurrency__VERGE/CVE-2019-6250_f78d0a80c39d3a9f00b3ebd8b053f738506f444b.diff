vergecurrency__VERGE
commit f78d0a80c39d3a9f00b3ebd8b053f738506f444b
Author:     sunerok <justinvforvendetta@users.noreply.github.com>
AuthorDate: Sat Feb 23 19:41:27 2019 -0500
Commit:     GitHub <noreply@github.com>
CommitDate: Sat Feb 23 19:41:27 2019 -0500

    Develop (#878)
    
    * Update randomized authentication for proxy connections
    
    * Adds copyrights to torcontroller
    Resolves #867
    
    * Tor Hidden Services v3 (#872)
    
    * Initi v3 tor hidden services
    
    * Support hidden services (V3) for new nodes
    
    * Remove my laziness
    
    * Remove more logs
    
    * Add i2p support (#873)
    
    * add i2p support
    
    if using i2p wrapped daemon.
    
    it would be nice to eventually add i2pd as an option as well.
    
    * fix shmypo
    
    * Update zeromq to 4.3.1 (#874) (#875)
    
    This is related to the BTC issue
    https://github.com/bitcoin/bitcoin/pull/15188
    and CVE https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-6250
    
    * [WIP] Bugfix block submission (#877)
    
    * Remove segwits segments from block template ü•≥
    
    * Disabling Segwit components (no pre-segwit)
    
    * Remove segwit switch from code üßê
    
    * Reenable version bit calculations
    
    * Enabling Chainparams genesis block and merkle root checks
    
    * Improve header parsing and correction for block parsing with older nodes #865 (#870)
    
    * Update randomized authentication for proxy connections
    
    * Adds copyrights to torcontroller
    Resolves #867
    
    * Tor Hidden Services v3 (#872)
    
    * Initi v3 tor hidden services
    
    * Support hidden services (V3) for new nodes
    
    * Remove my laziness
    
    * Remove more logs
    
    * Add i2p support (#873)
    
    * add i2p support
    
    if using i2p wrapped daemon.
    
    it would be nice to eventually add i2pd as an option as well.
    
    * Fix testnet chain parameters
    
    * Refactor POW a bit for more readability
    
    * Include Blocksignatures as part of our generated blocks
    (also being transferred)
    
    * Fix pub-/privkey prefixes for testnet

diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index c8fcb797..3f5fc2c3 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -41,9 +41,9 @@ static CBlock CreateGenesisBlock(const char* pszTimestamp, uint32_t nTime, uint3
  * transaction cannot be spent since it did not originally exist in the
  * database.
  */
-static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion)
+static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, bool isTestnet = false)
 {
-    const char* pszTimestamp = "Name: Dogecoin Dark";
+    const char* pszTimestamp = isTestnet ? "VERGE TESTNET" : "Name: Dogecoin Dark";
     return CreateGenesisBlock(pszTimestamp, nTime, nNonce, nBits, nVersion);
 }
 
@@ -121,10 +121,10 @@ public:
         nPruneAfterHeight = 100000;
 
         genesis = CreateGenesisBlock(1412878964, 1473191, 0x1e0fffff, 1);
-        consensus.hashGenesisBlock = genesis.GetPoWHash(ALGO_SCRYPT);
-        //printf("%s", genesis.ToString().c_str());
-        //assert(genesis.hashMerkleRoot == uint256S("0x1c83275d9151711eec3aec37d829837cc3c2730b2bdfd00ec5e8e5dce675fd00"));
-        //assert(consensus.hashGenesisBlock == uint256S("0x00000fc63692467faeb20cdb3b53200dc601d75bdfa1001463304cc790d77278"));
+        consensus.hashGenesisBlock = genesis.GetHash();
+        
+        assert(genesis.hashMerkleRoot == uint256S("0x1c83275d9151711eec3aec37d829837cc3c2730b2bdfd00ec5e8e5dce675fd00"));
+        assert(consensus.hashGenesisBlock == uint256S("0x00000fc63692467faeb20cdb3b53200dc601d75bdfa1001463304cc790d77278"));
 
         // Note that of those which support the service bits prefix, most only support a subset of
         // possible options.
@@ -259,6 +259,9 @@ public:
         // KeyNote: we'll leave testnet as is for now
         strNetworkID = "test";
         consensus.nSubsidyHalvingInterval = 210000;
+        consensus.MULTI_ALGO_SWITCH_BLOCK = 340000;
+        consensus.STEALTH_TX_SWITCH_BLOCK = 1824150;
+        
         consensus.BIP34Height = 0;
         consensus.BIP65Height = 0; // 00000000007f6655f22f98e72ed80d8b06dc761d5da09df0fa1dc4be4f861eb6
         consensus.BIP66Height = 0; // 000000002104c8c45e99a8853285a3b592602a3ccde2b832481da85e9e4ba182
@@ -289,18 +292,18 @@ public:
         // By default assume that the signatures in ancestors of this block are valid.
         consensus.defaultAssumeValid = uint256S("0x65b4e101cacf3e1e4f3a9237e3a74ffd1186e595d8b78fa8ea22c21ef5bf9347"); //also genesis 
 
-        pchMessageStart[0] = 0x0b;
-        pchMessageStart[1] = 0x11;
-        pchMessageStart[2] = 0x09;
-        pchMessageStart[3] = 0x07;
+        pchMessageStart[0] = 0xcd;
+        pchMessageStart[1] = 0xf2;
+        pchMessageStart[2] = 0xc0;
+        pchMessageStart[3] = 0xef;
         nDefaultPort = 21104;
         nPruneAfterHeight = 1000;
 
-        genesis = CreateGenesisBlock(1462058066, 2, 0x1e0fffff, 1);
+        genesis = CreateGenesisBlock(1462058066, 2, 0x1e0fffff, 1, true);
         consensus.hashGenesisBlock = genesis.GetHash();
-        // printf("%s", genesis.ToString().c_str());
-        //assert(consensus.hashGenesisBlock == uint256S("0x65b4e101cacf3e1e4f3a9237e3a74ffd1186e595d8b78fa8ea22c21ef5bf9347"));
-        //assert(genesis.hashMerkleRoot == uint256S("0x768cc22f70bbcc4de26f83aca1b4ea2a7e25f0d100497ba47c7ff2d9b696414c"));
+
+        assert(consensus.hashGenesisBlock == uint256S("0x65b4e101cacf3e1e4f3a9237e3a74ffd1186e595d8b78fa8ea22c21ef5bf9347"));
+        assert(genesis.hashMerkleRoot == uint256S("0x768cc22f70bbcc4de26f83aca1b4ea2a7e25f0d100497ba47c7ff2d9b696414c"));
 
         vFixedSeeds.clear();
         vSeeds.clear();
@@ -310,9 +313,9 @@ public:
         vSeeds.emplace_back("seed.testnet.bitcoin.sprovoost.nl");
         vSeeds.emplace_back("testnet-seed.bluematt.me"); // Just a static list of stable node(s), only supports x9
 
-        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);
-        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);
-        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);
+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,115);
+        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,198);
+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,243); // 128 + PUBKEY_ADDRESS_TEST
         base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};
         base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};
 
diff --git a/src/miner.cpp b/src/miner.cpp
index 5491c85a..a302cb51 100644
--- a/src/miner.cpp
+++ b/src/miner.cpp
@@ -166,7 +166,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc
     // -promiscuousmempoolflags is used.
     // TODO: replace this with a call to main to assess validity of a mempool
     // transaction (which in most cases can be a no-op).
-    fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) && fMineWitnessTx;
+    // fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) && fMineWitnessTx;
 
     int nPackagesSelected = 0;
     int nDescendantsUpdated = 0;
@@ -179,13 +179,17 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc
 
     // Create coinbase transaction.
     CMutableTransaction coinbaseTx;
+    // vin emtpy
     coinbaseTx.vin.resize(1);
     coinbaseTx.vin[0].prevout.SetNull();
+    // vout to miner with subsidy
     coinbaseTx.vout.resize(1);
     coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;
     coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());
+
     coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;
     pblock->vtx[0] = MakeTransactionRef(std::move(coinbaseTx));
+
     pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus());
     pblocktemplate->vTxFees[0] = -nFees;
 
@@ -196,7 +200,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc
     UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);
     pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, algo, chainparams.GetConsensus());
     pblock->nNonce         = 0;
-    pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);
+    pblocktemplate->vTxSigOpsCost[0] = GetLegacySigOpCount(*pblock->vtx[0]);
 
     CValidationState state;
     if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {
diff --git a/src/net.cpp b/src/net.cpp
index f17081b9..b3f3ae3f 100644
--- a/src/net.cpp
+++ b/src/net.cpp
@@ -212,7 +212,7 @@ bool AddLocal(const CService& addr, int nScore)
 		return false;
 
     bool isTorActived = !gArgs.GetBoolArg("-without-tor", false);
-    if(isTorActived && !addr.IsTor())
+    if((isTorActived && !addr.IsTor()) && (isTorActived && !addr.IsTorV3()))
         return false;
 
     LogPrintf("AddLocal(%s,%i)\n", addr.ToString(), nScore);
diff --git a/src/netaddress.cpp b/src/netaddress.cpp
index e43e3b8a..8435ff95 100644
--- a/src/netaddress.cpp
+++ b/src/netaddress.cpp
@@ -11,6 +11,7 @@
 
 static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };
 static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};
+static const unsigned char pchGarliCat[] = {0xFD,0x60,0xDB,0x4D,0xDD,0xB5};
 
 // 0xFD + sha256("bitcoin")[0:5]
 static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };
@@ -55,15 +56,37 @@ bool CNetAddr::SetInternal(const std::string &name)
 
 bool CNetAddr::SetSpecial(const std::string &strName)
 {
-    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == ".onion") {
+    if (strName.size() > 6 && strName.substr(strName.size() - 6, 6) == ".onion") {
         std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());
-        if (vchAddr.size() != 16-sizeof(pchOnionCat))
+        // 16' length - v2 tor addresses
+        if (vchAddr.size() == 16 - sizeof(pchOnionCat)){
+            memcpy(ip, pchOnionCat, sizeof(pchOnionCat));
+            for (unsigned int i = 0; i < 16 - sizeof(pchOnionCat); i++)
+                ip[i + sizeof(pchOnionCat)] = vchAddr[i];
+            usesTorV3 = false;
+            return true;
+        }
+
+        // 56' length - v3 tor addressess
+        std::vector<unsigned char> vchAddrV3 = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());
+        if (vchAddrV3.size() == 41 - sizeof(pchOnionCat)){
+            memcpy(ip, pchOnionCat, sizeof(pchOnionCat));
+            for (unsigned int i = 0; i < 41 - sizeof(pchOnionCat); i++)
+                ip[i + sizeof(pchOnionCat)] = vchAddrV3[i];
+            usesTorV3 = true;
+            return true;
+        }
+      
+    }
+	if (strName.size()>11 && strName.substr(strName.size() - 11, 11) == ".oc.b32.i2p") {
+        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 11).c_str());
+        if (vchAddr.size() != 16-sizeof(pchGarliCat))
             return false;
-        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));
-        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)
-            ip[i + sizeof(pchOnionCat)] = vchAddr[i];
+        memcpy(ip, pchOnionCat, sizeof(pchGarliCat));
+        for (unsigned int i=0; i<16-sizeof(pchGarliCat); i++)
+            ip[i + sizeof(pchGarliCat)] = vchAddr[i];
         return true;
-    }
+	}
     return false;
 }
 
@@ -100,7 +123,7 @@ bool CNetAddr::IsIPv4() const
 
 bool CNetAddr::IsIPv6() const
 {
-    return (!IsIPv4() && !IsTor() && !IsInternal());
+    return (!IsIPv4() && !IsTor() && !IsI2P() && !IsTorV3() && !IsInternal());
 }
 
 bool CNetAddr::IsRFC1918() const
@@ -178,7 +201,17 @@ bool CNetAddr::IsRFC4843() const
 
 bool CNetAddr::IsTor() const
 {
-    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);
+    return !usesTorV3 && (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);
+}
+
+bool CNetAddr::IsTorV3() const
+{
+    return usesTorV3 && (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);
+}
+
+bool CNetAddr::IsI2P() const
+{
+    return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);
 }
 
 bool CNetAddr::IsLocal() const
@@ -236,7 +269,7 @@ bool CNetAddr::IsValid() const
 
 bool CNetAddr::IsRoutable() const
 {
-    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal() || IsInternal());
+    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && (!IsI2P() && !IsTor() && !IsTorV3())) || IsRFC4843() || IsLocal() || IsInternal());
 }
 
 bool CNetAddr::IsInternal() const
@@ -255,8 +288,11 @@ enum Network CNetAddr::GetNetwork() const
     if (IsIPv4())
         return NET_IPV4;
 
-    if (IsTor())
+    if (IsTor() || IsTorV3())
         return NET_TOR;
+	
+	if (IsI2P())
+        return NET_I2P;
 
     return NET_IPV6;
 }
@@ -265,6 +301,13 @@ std::string CNetAddr::ToStringIP() const
 {
     if (IsTor())
         return EncodeBase32(&ip[6], 10) + ".onion";
+
+	  if (IsI2P())
+        return EncodeBase32(&ip[6], 10) + ".oc.b32.i2p";
+
+    if (IsTorV3())
+        return EncodeBase32(&ip[6], 35) + ".onion";
+
     if (IsInternal())
         return EncodeBase32(ip + sizeof(g_internal_prefix), sizeof(ip) - sizeof(g_internal_prefix)) + ".internal";
     CService serv(*this, 0);
@@ -366,11 +409,17 @@ std::vector<unsigned char> CNetAddr::GetGroup() const
         vchRet.push_back(GetByte(2) ^ 0xFF);
         return vchRet;
     }
-    else if (IsTor())
+    else if (IsTor() || IsTorV3())
     {
         nClass = NET_TOR;
         nStartByte = 6;
         nBits = 4;
+    }
+	else if (IsI2P())
+    {
+        nClass = NET_I2P;
+        nStartByte = 6;
+        nBits = 4;
     }
     // for he.net, use /36 groups
     else if (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70)
@@ -452,6 +501,11 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const
         case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well
         case NET_TOR:    return REACH_PRIVATE;
         }
+	case NET_I2P:
+        switch(ourNet) {
+        default:         return REACH_DEFAULT;
+        case NET_I2P:    return REACH_PRIVATE;
+        }
     case NET_TEREDO:
         switch(ourNet) {
         default:          return REACH_DEFAULT;
@@ -467,6 +521,7 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const
         case NET_TEREDO:  return REACH_TEREDO;
         case NET_IPV6:    return REACH_IPV6_WEAK;
         case NET_IPV4:    return REACH_IPV4;
+		case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are
         case NET_TOR:     return REACH_PRIVATE; // either from Tor, or don't care about our address
         }
     }
@@ -574,7 +629,7 @@ std::string CService::ToStringPort() const
 
 std::string CService::ToStringIPPort() const
 {
-    if (IsIPv4() || IsTor() || IsInternal()) {
+    if (IsIPv4() || IsTor() || IsI2P() || IsTorV3() || IsInternal()) {
         return ToStringIP() + ":" + ToStringPort();
     } else {
         return "[" + ToStringIP() + "]:" + ToStringPort();
diff --git a/src/netaddress.h b/src/netaddress.h
index 1fbe459f..13b9557b 100644
--- a/src/netaddress.h
+++ b/src/netaddress.h
@@ -13,6 +13,7 @@
 #include <compat.h>
 #include <serialize.h>
 #include <span.h>
+#include <version.h>
 
 #include <stdint.h>
 #include <string>
@@ -24,6 +25,7 @@ enum Network
     NET_IPV4,
     NET_IPV6,
     NET_TOR,
+	NET_I2P,
     NET_INTERNAL,
 
     NET_MAX,
@@ -33,8 +35,9 @@ enum Network
 class CNetAddr
 {
     protected:
-        unsigned char ip[16]; // in network byte order
-        uint32_t scopeId{0}; // for scoped/link-local ipv6 addresses
+        unsigned char ip[41]; // in network byte order
+        bool usesTorV3 = false;
+        uint32_t scopeId; // for scoped/link-local ipv6 addresses
 
     public:
         CNetAddr();
@@ -54,11 +57,9 @@ class CNetAddr
           * Useful for mapping resolved addresses back to their source.
          */
         bool SetInternal(const std::string& name);
-
-        bool SetSpecial(const std::string &strName); // for Tor addresses
-		bool IsBindAny() const; // INADDR_ANY equivalent
+        bool SetSpecial(const std::string &strName); // for Tor & i2p addresses
         bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)
-        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)
+        bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor/i2p)
         bool IsRFC1918() const; // IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)
         bool IsRFC2544() const; // IPv4 inter-network communications (192.18.0.0/15)
         bool IsRFC6598() const; // IPv4 ISP-level NAT (100.64.0.0/10)
@@ -73,6 +74,8 @@ class CNetAddr
         bool IsRFC6052() const; // IPv6 well-known prefix (64:FF9B::/96)
         bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96)
         bool IsTor() const;
+		    bool IsI2P() const;
+        bool IsTorV3() const;
         bool IsLocal() const;
         bool IsRoutable() const;
         bool IsInternal() const;
@@ -97,7 +100,19 @@ class CNetAddr
 
         template <typename Stream, typename Operation>
         inline void SerializationOp(Stream& s, Operation ser_action) {
-            READWRITE(ip);
+            if(s.GetVersion() > TORV3_SERVICES_VERSION) {
+                READWRITE(ip);
+            } else { // backwards compatibility
+                if(ser_action.ForRead()){
+                    unsigned char compatibleIP[16];
+                    READWRITE(compatibleIP);
+                    memcpy(CNetAddr::ip, compatibleIP, sizeof(compatibleIP));
+                } else {
+                    unsigned char compatibleIP[16]; 
+                    memcpy(compatibleIP, CNetAddr::ip, sizeof(compatibleIP));
+                    READWRITE(compatibleIP);
+                }
+            }    
         }
 
         friend class CSubNet;
@@ -169,7 +184,19 @@ class CService : public CNetAddr
 
         template <typename Stream, typename Operation>
         inline void SerializationOp(Stream& s, Operation ser_action) {
-            READWRITE(ip);
+            if(s.GetVersion() >= TORV3_SERVICES_VERSION) {
+                READWRITE(ip);
+            } else {
+                if(ser_action.ForRead()){
+                    unsigned char compatibleIP[16];
+                    READWRITE(compatibleIP);
+                    memcpy(CNetAddr::ip, compatibleIP, sizeof(compatibleIP));
+                } else {
+                    unsigned char compatibleIP[16]; // backwards compatibility
+                    memcpy(compatibleIP, CNetAddr::ip, sizeof(compatibleIP));
+                    READWRITE(compatibleIP);
+                }
+            }         
             READWRITE(WrapBigEndian(port));
         }
 };
diff --git a/src/netbase.cpp b/src/netbase.cpp
index c8769147..0fa87288 100644
--- a/src/netbase.cpp
+++ b/src/netbase.cpp
@@ -43,6 +43,7 @@ enum Network ParseNetwork(std::string net) {
     if (net == "ipv4") return NET_IPV4;
     if (net == "ipv6") return NET_IPV6;
     if (net == "tor" || net == "onion")  return NET_TOR;
+	if (net == "i2p")  return NET_I2P;
     return NET_UNROUTABLE;
 }
 
@@ -52,6 +53,7 @@ std::string GetNetworkName(enum Network net) {
     case NET_IPV4: return "ipv4";
     case NET_IPV6: return "ipv6";
     case NET_TOR: return "onion";
+	case NET_I2P: return "i2p";
     default: return "";
     }
 }
@@ -597,8 +599,9 @@ bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int
     // do socks negotiation
     if (proxy.randomize_credentials) {
         ProxyCredentials random_auth;
-        static std::atomic_int counter(0);
-        random_auth.username = random_auth.password = strprintf("%i", counter++);
+        random_auth.username = GetRandomString();
+        random_auth.password = GetRandomString();
+
         if (!Socks5(strDest, (unsigned short)port, &random_auth, hSocket)) {
             return false;
         }
diff --git a/src/pow.cpp b/src/pow.cpp
index 58a7a20f..5fa66e8d 100644
--- a/src/pow.cpp
+++ b/src/pow.cpp
@@ -11,6 +11,7 @@
 #include <primitives/block.h>
 #include <uint256.h>
 #include <util/system.h>
+#include <chainparamsbase.h>
 
 unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, int algo, const Consensus::Params& params)
 {
@@ -82,15 +83,13 @@ bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&
     arith_uint256 bnTarget;
 
     bnTarget.SetCompact(nBits, &fNegative, &fOverflow);
-    // LogPrintf("%s > %s\n", params.powLimit.ToString().c_str(), bnTarget.ToString().c_str());
     // Check range
     if (fNegative || bnTarget == 0 || fOverflow || bnTarget > UintToArith256(params.powLimit))
         return false;
 
-    // LogPrintf("%s > %s\n", hash.ToString().c_str(), bnTarget.ToString().c_str());
     // Check proof of work matches claimed amount
-    if(gArgs.GetChainName() == "test"){
-        if (UintToArith256(hash) > bnTarget && hash != params.hashGenesisBlock)
+    if(gArgs.GetChainName() == CBaseChainParams::TESTNET){
+        if (hash != params.hashGenesisBlock && UintToArith256(hash) > bnTarget) 
             return false;
     } else {
         if (UintToArith256(hash) > bnTarget)
diff --git a/src/primitives/block.h b/src/primitives/block.h
index 253a476b..d2f34d16 100644
--- a/src/primitives/block.h
+++ b/src/primitives/block.h
@@ -8,8 +8,15 @@
 #define VERGE_PRIMITIVES_BLOCK_H
 
 #include <primitives/transaction.h>
+#include <script/standard.h>
+#include <key.h>
+#include <keystore.h>
 #include <serialize.h>
 #include <uint256.h>
+#include <util/strencodings.h>
+#include <util/system.h>
+
+typedef std::vector<unsigned char> valtype;
 
 enum
 {
@@ -221,7 +228,109 @@ public:
         return block;
     }
 
-    std::string ToString() const;
+    bool SignBlock(const CKeyStore& keystore)
+    {
+        std::vector<valtype> vSolutions;
+        txnouttype whichType;
+
+        for(unsigned int i = 0; i < vtx[0]->vout.size(); i++)
+        {
+            const CTxOut& txout = vtx[0]->vout[i];
+
+            if (!Solver(txout.scriptPubKey, whichType, vSolutions))
+                continue;
+
+            if (whichType == TX_PUBKEY)
+            {
+                // Sign
+                valtype& vchPubKey = vSolutions[0];
+                CKey key;
+                CPubKey pubKey(vchPubKey);
+
+                if (!keystore.GetKey(pubKey.GetID(), key)){
+                    LogPrintf("[SignBlock] Key not found for singature");
+                    continue;
+                }
+                if (key.GetPubKey() != pubKey){
+                    LogPrintf("[SignBlock] Keys not identical (generated vs found)");
+                    continue;
+                }
+                if(!key.Sign(GetHash(), vchBlockSig)){
+                    LogPrintf("[SignBlock] Could not sign block");
+                    continue;
+                }
+
+                LogPrintf("BlockSign: %s", HexStr(vchBlockSig.begin(), vchBlockSig.end()).c_str());
+                return true;
+            } else if (whichType == TX_PUBKEYHASH) {
+                // Sign
+                valtype& vchPubKey = vSolutions[0];
+                CKey key;
+                CKeyID keyID = CKeyID(uint160(vchPubKey));
+
+                if (!keystore.GetKey(keyID, key)) {
+                    LogPrintf("[SignBlock] Key not found for singature");
+                    continue;
+                }
+                if (key.GetPubKey().GetID() != keyID){
+                    LogPrintf("[SignBlock] Keys not identical (generated vs found)");
+                    continue;
+                }
+                if(!key.Sign(GetHash(), vchBlockSig)){
+                    LogPrintf("[SignBlock] Could not sign block");
+                    continue;
+                }
+
+                LogPrintf("BlockSign: %s", HexStr(vchBlockSig.begin(), vchBlockSig.end()).c_str());
+                return true;
+            } else {
+                LogPrintf("[SignBlock] Unsupported TX type (type: %i)", whichType);
+            }
+        }
+
+        LogPrintf("Sign failed\n");
+        return false;
+    }
+
+    // ppcoin: check block signature
+    bool CheckBlockSignature() const
+    {
+        uint256 genesisBlockHash = uint256S("0x00000fc63692467faeb20cdb3b53200dc601d75bdfa1001463304cc790d77278");
+        uint256 genesisTestBlockHash = uint256S("0xfe98805b5dc9006e41d3219e62e7966dbc350a83dcdc001766d8c64f18231baf");
+        if (GetHash() == (gArgs.IsArgSet("-testnet") ? genesisTestBlockHash : genesisBlockHash))
+            return vchBlockSig.empty();
+
+        std::vector<valtype> vSolutions;
+        txnouttype whichType;
+
+        // check for block signature in Proof Of Work (old shit why we have to do this.)
+        for(unsigned int i = 0; i < vtx[0]->vout.size(); i++)
+        {
+            const CTxOut& txout = vtx[0]->vout[i];
+
+            if (!Solver(txout.scriptPubKey, whichType, vSolutions))
+                return false;
+
+            if (whichType == TX_PUBKEY)
+            {
+                // Verify
+                valtype& vchPubKey = vSolutions[0];
+                CPubKey key(vchPubKey);
+                if (!key.IsFullyValid())
+                    continue;
+                if (vchBlockSig.empty())
+                    continue;
+                if(!key.Verify(GetHash(), vchBlockSig))
+                    continue;
+
+                return true;
+            }
+        }
+        
+        return false;
+    }
+
+     std::string ToString() const;
 };
 
 
diff --git a/src/qt/forms/optionsdialog.ui b/src/qt/forms/optionsdialog.ui
index 53466080..e96bd6f4 100644
--- a/src/qt/forms/optionsdialog.ui
+++ b/src/qt/forms/optionsdialog.ui
@@ -440,6 +440,29 @@
             <enum>Qt::PlainText</enum>
            </property>
           </widget>
+         </item>
+		 <item>
+          <widget class="QCheckBox" name="proxyReachI2p">
+           <property name="enabled">
+            <bool>false</bool>
+           </property>
+           <property name="toolTip">
+            <string>Shows if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>
+           </property>
+           <property name="text">
+            <string/>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QLabel" name="proxyReachI2pLabel">
+           <property name="text">
+            <string>i2p</string>
+           </property>
+           <property name="textFormat">
+            <enum>Qt::PlainText</enum>
+           </property>
+          </widget>
          </item>
          <item>
           <spacer name="horizontalSpacer_2_Network">
diff --git a/src/qt/optionsdialog.cpp b/src/qt/optionsdialog.cpp
index 752b9d71..2a67bfbc 100644
--- a/src/qt/optionsdialog.cpp
+++ b/src/qt/optionsdialog.cpp
@@ -348,6 +348,11 @@ void OptionsDialog::updateDefaultProxyNets()
     strProxy = proxy.proxy.ToStringIP() + ":" + proxy.proxy.ToStringPort();
     strDefaultProxyGUI = ui->proxyIp->text() + ":" + ui->proxyPort->text();
     (strProxy == strDefaultProxyGUI.toStdString()) ? ui->proxyReachTor->setChecked(true) : ui->proxyReachTor->setChecked(false);
+	
+	model->node().getProxy(NET_I2P, proxy);
+    strProxy = proxy.proxy.ToStringIP() + ":" + proxy.proxy.ToStringPort();
+    strDefaultProxyGUI = ui->proxyIp->text() + ":" + ui->proxyPort->text();
+    (strProxy == strDefaultProxyGUI.toStdString()) ? ui->proxyReachI2p->setChecked(true) : ui->proxyReachI2p->setChecked(false);
 }
 
 ProxyAddressValidator::ProxyAddressValidator(QObject *parent) :
diff --git a/src/random.cpp b/src/random.cpp
index 5bc0c2dc..3eee95fa 100644
--- a/src/random.cpp
+++ b/src/random.cpp
@@ -49,6 +49,9 @@
 #include <openssl/err.h>
 #include <openssl/rand.h>
 
+#include <random>
+#include <string>
+
 [[noreturn]] static void RandFailure()
 {
     LogPrintf("Failed to read randomness, aborting\n");
@@ -464,6 +467,17 @@ FastRandomContext::FastRandomContext(bool fDeterministic) : requires_seed(!fDete
     rng.SetKey(seed.begin(), 32);
 }
 
+std::string BaseCharSet("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.,-;/()%&$!?`=)");
+std::string GetRandomString() {
+    std::string charSet = BaseCharSet;
+    std::random_device randomDevice;
+    std::mt19937 generator(randomDevice());
+
+    std::shuffle(charSet.begin(), charSet.end(), generator);
+
+    return charSet.substr(0, 32);    // assumes 32 < number of characters in str
+}
+
 void RandomInit()
 {
     RDRandInit();
diff --git a/src/random.h b/src/random.h
index f528c986..ce6bfe82 100644
--- a/src/random.h
+++ b/src/random.h
@@ -150,6 +150,11 @@ void GetOSRand(unsigned char *ent32);
  */
 bool Random_SanityCheck();
 
+/**
+ * Returns an unsecure (kinda) string, with a given charset
+ **/
+std::string GetRandomString();
+
 /** Initialize the RNG. */
 void RandomInit();
 
diff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp
index 5dc4f18d..6cb914bc 100644
--- a/src/rpc/mining.cpp
+++ b/src/rpc/mining.cpp
@@ -10,6 +10,7 @@
 #include <consensus/consensus.h>
 #include <consensus/params.h>
 #include <consensus/validation.h>
+#include <wallet/wallet.h>
 #include <core_io.h>
 #include <validation.h>
 #include <key_io.h>
@@ -19,7 +20,6 @@
 #include <pow.h>
 #include <rpc/blockchain.h>
 #include <rpc/mining.h>
-#include <rpc/server.h>
 #include <shutdown.h>
 #include <txmempool.h>
 #include <util/system.h>
@@ -134,7 +134,7 @@ static UniValue getallnetworkhashps(const JSONRPCRequest& request)
     return obj;
 }
 
-UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)
+UniValue generateBlocks(const JSONRPCRequest& request, std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)
 {
     static const int nInnerLoopCount = 0x10000;
     int nHeightEnd = 0;
@@ -167,6 +167,10 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen
         if (pblock->nNonce == nInnerLoopCount) {
             continue;
         }
+
+        std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
+        CWallet* const pwallet = wallet.get();
+        pblock->SignBlock(*pwallet);
         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);
         if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))
             throw JSONRPCError(RPC_INTERNAL_ERROR, "ProcessNewBlock, block not accepted");
@@ -213,7 +217,7 @@ static UniValue generatetoaddress(const JSONRPCRequest& request)
     std::shared_ptr<CReserveScript> coinbaseScript = std::make_shared<CReserveScript>();
     coinbaseScript->reserveScript = GetScriptForDestination(destination);
 
-    return generateBlocks(coinbaseScript, nGenerate, nMaxTries, false);
+    return generateBlocks(request, coinbaseScript, nGenerate, nMaxTries, false);
 }
 
 static UniValue getmininginfo(const JSONRPCRequest& request)
@@ -521,22 +525,24 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)
         // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?
     }
 
-    const struct VBDeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];
+    // const struct VBDeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];
     // If the caller is indicating segwit support, then allow CreateNewBlock()
     // to select witness transactions, after segwit activates (otherwise
     // don't).
-    bool fSupportsSegwit = setClientRules.find(segwit_info.name) != setClientRules.end();
+    // bool fSupportsSegwit = setClientRules.find(segwit_info.name) != setClientRules.end();
 
     // Update block
     static CBlockIndex* pindexPrev;
     static int64_t nStart;
     static std::unique_ptr<CBlockTemplate> pblocktemplate;
+
     // Cache whether the last invocation was with segwit support, to avoid returning
     // a segwit-block to a non-segwit caller.
-    static bool fLastTemplateSupportsSegwit = true;
+    // static bool fLastTemplateSupportsSegwit = true;
+
     if (pindexPrev != chainActive.Tip() ||
-        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5) ||
-        fLastTemplateSupportsSegwit != fSupportsSegwit)
+        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5) /*||
+        fLastTemplateSupportsSegwit != fSupportsSegwit*/)
     {
         // Clear pindexPrev so future calls make a new block, despite any failures from here on
         pindexPrev = nullptr;
@@ -545,11 +551,11 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)
         nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();
         CBlockIndex* pindexPrevNew = chainActive.Tip();
         nStart = GetTime();
-        fLastTemplateSupportsSegwit = fSupportsSegwit;
+        // fLastTemplateSupportsSegwit = fSupportsSegwit;
 
         // Create new block
         CScript scriptDummy = CScript() << OP_TRUE;
-        pblocktemplate = BlockAssembler(Params()).CreateNewBlock(scriptDummy, ALGO, fSupportsSegwit);
+        pblocktemplate = BlockAssembler(Params()).CreateNewBlock(scriptDummy, ALGO, false /*supports segwit bool*/);
         if (!pblocktemplate)
             throw JSONRPCError(RPC_OUT_OF_MEMORY, "Out of memory");
 
@@ -565,8 +571,9 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)
     pblock->nNonce = 0;
 
     // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration
-    const bool fPreSegWit = (ThresholdState::ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));
-
+    // const bool fPreSegWit = (ThresholdState::ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));
+    const bool fPreSegWit = false;
+    
     UniValue aCaps(UniValue::VARR); aCaps.push_back("proposal");
 
     UniValue transactions(UniValue::VARR);
@@ -622,7 +629,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)
 
     UniValue aRules(UniValue::VARR);
     UniValue vbavailable(UniValue::VOBJ);
-    /*for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {
+    for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {
         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);
         ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);
         switch (state) {
@@ -661,19 +668,19 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)
                 break;
             }
         }
-    }*/
+    }
     result.pushKV("version", pindexPrev->nHeight < 3400000 ? 2 : VERSIONBITS_LAST_OLD_BLOCK_VERSION);
     result.pushKV("rules", aRules);
     result.pushKV("vbavailable", vbavailable);
     result.pushKV("vbrequired", int(0));
 
-    // if (nMaxVersionPreVB >= 2) {
-    //     // If VB is supported by the client, nMaxVersionPreVB is -1, so we won't get here
-    //     // Because BIP 34 changed how the generation transaction is serialized, we can only use version/force back to v2 blocks
-    //     // This is safe to do [otherwise-]unconditionally only because we are throwing an exception above if a non-force deployment gets activated
-    //     // Note that this can probably also be removed entirely after the first BIP9 non-force deployment (ie, probably segwit) gets activated
-    //     aMutable.push_back("version/force");
-    // }
+    if (nMaxVersionPreVB >= 2) {
+        // If VB is supported by the client, nMaxVersionPreVB is -1, so we won't get here
+        // Because BIP 34 changed how the generation transaction is serialized, we can only use version/force back to v2 blocks
+        // This is safe to do [otherwise-]unconditionally only because we are throwing an exception above if a non-force deployment gets activated
+        // Note that this can probably also be removed entirely after the first BIP9 non-force deployment (ie, probably segwit) gets activated
+        aMutable.push_back("version/force");
+    }
 
     result.pushKV("previousblockhash", pblock->hashPrevBlock.GetHex());
     result.pushKV("transactions", transactions);
@@ -701,7 +708,7 @@ static UniValue getblocktemplate(const JSONRPCRequest& request)
     result.pushKV("bits", strprintf("%08x", pblock->nBits));
     result.pushKV("height", (int64_t)(pindexPrev->nHeight+1));
 
-    if (!pblocktemplate->vchCoinbaseCommitment.empty() && fSupportsSegwit) {
+    if (!pblocktemplate->vchCoinbaseCommitment.empty()) {
         result.pushKV("default_witness_commitment", HexStr(pblocktemplate->vchCoinbaseCommitment.begin(), pblocktemplate->vchCoinbaseCommitment.end()));
     }
 
@@ -809,10 +816,22 @@ static UniValue submitblock(const JSONRPCRequest& request)
     if (!DecodeHexBlk(block, request.params[0].get_str())) {
         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block decode failed");
     }
+
+    LogPrintf("blocki\n");
+    LogPrintf("%s", block.ToString().c_str());
     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase()) {
         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block does not start with a coinbase");
     }
 
+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
+    CWallet* const pwallet = wallet.get();
+
+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {
+        return NullUniValue;
+    }
+
+    block.SignBlock(*pwallet);
+
     uint256 hash = block.GetHash();
     bool fBlockPresent = false;
     {
diff --git a/src/rpc/mining.h b/src/rpc/mining.h
index 8d462731..40201395 100644
--- a/src/rpc/mining.h
+++ b/src/rpc/mining.h
@@ -6,11 +6,12 @@
 #define BITCOIN_RPC_MINING_H
 
 #include <script/script.h>
+#include <rpc/server.h>
 
 #include <univalue.h>
 
 /** Generate blocks (mine) */
-UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript);
+UniValue generateBlocks(const JSONRPCRequest& request, std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript);
 
 /** Check bounds on a command line confirm target */
 unsigned int ParseConfirmTarget(const UniValue& value);
diff --git a/src/torcontrol.cpp b/src/torcontrol.cpp
index 1ad75423..e3718b30 100644
--- a/src/torcontrol.cpp
+++ b/src/torcontrol.cpp
@@ -504,7 +504,7 @@ void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlRe
             }
             return;
         }
-        service = LookupNumeric(std::string(service_id+".onion").c_str(), GetListenPort());
+        service = LookupNumeric(std::string(service_id + ".onion").c_str(), GetListenPort());
         LogPrintf("tor: Got service ID %s, advertising service %s\n", service_id, service.ToString());
         if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {
             LogPrint(BCLog::TOR, "tor: Cached service private key to %s\n", GetPrivateKeyFile().string());
@@ -536,12 +536,13 @@ void TorController::auth_cb(TorControlConnection& _conn, const TorControlReply&
 
         // Finally - now create the service
         if (private_key.empty()) // No private key, generate one
-            private_key = "NEW:RSA1024"; // Explicitly request RSA1024 - see issue #9214
+            private_key = "NEW:ED25519-V3";
         // Request hidden service, redirect port.
         // Note that the 'virtual' port doesn't have to be the same as our internal port, but this is just a convenient
         // choice.  TODO; refactor the shutdown sequence some day.
         _conn.Command(strprintf("ADD_ONION %s Port=%i,127.0.0.1:%i", private_key, GetListenPort(), GetListenPort()),
             boost::bind(&TorController::add_onion_cb, this, _1, _2));
+        
     } else {
         LogPrintf("tor: Authentication failed\n");
     }
diff --git a/src/torcontroller.cpp b/src/torcontroller.cpp
index f026e9f6..566645f3 100644
--- a/src/torcontroller.cpp
+++ b/src/torcontroller.cpp
@@ -1,3 +1,7 @@
+// Copyright (c) 2018-2019 The VERGE Core developers
+// Distributed under the MIT software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
 #if defined(HAVE_CONFIG_H)
 #include <config/verge-config.h>
 #endif
@@ -31,27 +35,27 @@ void run_tor() {
 
     printf("TOR thread started.\n");
     
-    /*torrc_stream.open(torrc_file.string().c_str());
-    while (getline(torrc_stream, line)) {
-        if (regex_search (line, bridge_regex)) {
-            ++bridgeNum;
-        }
-    }
-    torrc_stream.close();
-
-    if (stat("/usr/bin/obfs4proxy", &sb) == 0 && sb.st_mode & S_IXUSR) {
-        obfs4proxy_path = "/usr/bin/obfs4proxy";
-    }
-    if (stat("/usr/local/bin/obfs4proxy", &sb) == 0 && sb.st_mode & S_IXUSR) {
-        obfs4proxy_path = "/usr/local/bin/obfs4proxy";
-    }
-    if (stat("c:\\bin\\obfs4proxy.exe", &sb) == 0 && sb.st_mode & S_IXUSR) {
-        obfs4proxy_path = "c:\\bin\\obfs4proxy.exe";
-    }
-
-    if ((bridgeNum > 0) && (!obfs4proxy_path.empty())) {
-            clientTransportPlugin = "obfs4 exec " + obfs4proxy_path;
-    }*/
+    // torrc_stream.open(torrc_file.string().c_str());
+    // while (getline(torrc_stream, line)) {
+    //     if (regex_search(line, bridge_regex)) {
+    //         ++bridgeNum;
+    //     }
+    // }
+    // torrc_stream.close();
+
+    // if (stat("/usr/bin/obfs4proxy", &sb) == 0 && sb.st_mode & S_IXUSR) {
+    //     obfs4proxy_path = "/usr/bin/obfs4proxy";
+    // }
+    // if (stat("/usr/local/bin/obfs4proxy", &sb) == 0 && sb.st_mode & S_IXUSR) {
+    //     obfs4proxy_path = "/usr/local/bin/obfs4proxy";
+    // }
+    // if (stat("c:\\bin\\obfs4proxy.exe", &sb) == 0 && sb.st_mode & S_IXUSR) {
+    //     obfs4proxy_path = "c:\\bin\\obfs4proxy.exe";
+    // }
+
+    // if ((bridgeNum > 0) && (!obfs4proxy_path.empty())) {
+    //         clientTransportPlugin = "obfs4 exec " + obfs4proxy_path;
+    // }
 
     std::vector<std::string> argv;
     argv.push_back("tor");
@@ -71,12 +75,14 @@ void run_tor() {
     argv.push_back((tor_dir / "torrc").string());
     argv.push_back("--HiddenServiceDir");
     argv.push_back((tor_dir / "onion").string());
+    argv.push_back("--ControlPort");
+    argv.push_back(std::to_string(DEFAULT_TOR_CONTROL_PORT));
+    argv.push_back("--HiddenServiceVersion");
+    argv.push_back("3");
     argv.push_back("--HiddenServicePort");
     argv.push_back("21102");
     argv.push_back("--CookieAuthentication");
     argv.push_back("1");
-    argv.push_back("--ControlPort");
-    argv.push_back(std::to_string(DEFAULT_TOR_CONTROL_PORT));
 
     if(!clientTransportPlugin.empty()){
       printf("Using OBFS4.\n");
diff --git a/src/torcontroller.h b/src/torcontroller.h
index fb8f1cb2..09b96d9b 100644
--- a/src/torcontroller.h
+++ b/src/torcontroller.h
@@ -23,7 +23,7 @@
 #include <scheduler.h>
 
 /** Default Port to run tor entry node on **/
-static const unsigned int DEFAULT_TOR_PORT = 9089;
+static const unsigned int DEFAULT_TOR_PORT = 9090;
 
 /** Default Port for handling tor's control port **/
 static const unsigned int DEFAULT_TOR_CONTROL_PORT = 9051;
diff --git a/src/version.h b/src/version.h
index 1694eb5a..0ce686c8 100644
--- a/src/version.h
+++ b/src/version.h
@@ -12,6 +12,8 @@
 
 static const int PROTOCOL_VERSION = 90007;
 
+static const int TORV3_SERVICES_VERSION = 90007;
+
 //! initial proto version, to be increased after version/verack negotiation
 static const int INIT_PROTO_VERSION = 209;
 
diff --git a/src/wallet/rpcwallet.cpp b/src/wallet/rpcwallet.cpp
index 413a630c..b497c73f 100644
--- a/src/wallet/rpcwallet.cpp
+++ b/src/wallet/rpcwallet.cpp
@@ -3934,7 +3934,7 @@ UniValue generate(const JSONRPCRequest& request)
         throw JSONRPCError(RPC_INTERNAL_ERROR, "No coinbase script available");
     }
 
-    return generateBlocks(coinbase_script, num_generate, max_tries, true);
+    return generateBlocks(request, coinbase_script, num_generate, max_tries, true);
 }
 
 UniValue rescanblockchain(const JSONRPCRequest& request)
