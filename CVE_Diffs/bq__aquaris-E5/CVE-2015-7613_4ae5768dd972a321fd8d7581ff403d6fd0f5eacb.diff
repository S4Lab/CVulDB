bq__aquaris-E5
commit 4ae5768dd972a321fd8d7581ff403d6fd0f5eacb
Author:     Linus Torvalds <torvalds@linux-foundation.org>
AuthorDate: Wed Sep 30 12:48:40 2015 -0400
Commit:     John McAleely <john.mcaleely@canonical.com>
CommitDate: Fri Dec 18 22:05:04 2015 +0000

    Initialize msg/shm IPC objects before doing ipc_addid()
    
    CVE-2015-7613
    
    As reported by Dmitry Vyukov, we really shouldn't do ipc_addid() before
    having initialized the IPC object state.  Yes, we initialize the IPC
    object in a locked state, but with all the lockless RCU lookup work,
    that IPC object lock no longer means that the state cannot be seen.
    
    We already did this for the IPC semaphore code (see commit e8577d1f0329:
    "ipc/sem.c: fully initialize sem_array before making it visible") but we
    clearly forgot about msg and shm.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    (backported from commit b9a532277938798b53178d5a66af6e2915cb27cf)
    Signed-off-by: Liming Wang <liming.wang@canonical.com>
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    
    Change-Id: I549ea025d00d9e0bf4ba7baafd7196dfeb5cd76b

diff --git a/kernel/ipc/msg.c b/kernel/ipc/msg.c
index 7385de257..d6b85c3fb 100644
--- a/kernel/ipc/msg.c
+++ b/kernel/ipc/msg.c
@@ -198,15 +198,6 @@ static int newque(struct ipc_namespace *ns, struct ipc_params *params)
 		return retval;
 	}
 
-	/*
-	 * ipc_addid() locks msq
-	 */
-	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
-	if (id < 0) {
-		security_msg_queue_free(msq);
-		ipc_rcu_putref(msq);
-		return id;
-	}
 
 	msq->q_stime = msq->q_rtime = 0;
 	msq->q_ctime = get_seconds();
@@ -217,6 +208,16 @@ static int newque(struct ipc_namespace *ns, struct ipc_params *params)
 	INIT_LIST_HEAD(&msq->q_receivers);
 	INIT_LIST_HEAD(&msq->q_senders);
 
+	/*
+	 * ipc_addid() locks msq
+	 */
+	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
+	if (id < 0) {
+		security_msg_queue_free(msq);
+		ipc_rcu_putref(msq);
+		return id;
+	}
+
 	msg_unlock(msq);
 
 	return msq->q_perm.id;
diff --git a/kernel/ipc/shm.c b/kernel/ipc/shm.c
index 814712427..3ceea3ff9 100644
--- a/kernel/ipc/shm.c
+++ b/kernel/ipc/shm.c
@@ -500,12 +500,6 @@ static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
 	if (IS_ERR(file))
 		goto no_file;
 
-	id = ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);
-	if (id < 0) {
-		error = id;
-		goto no_id;
-	}
-
 	shp->shm_cprid = task_tgid_vnr(current);
 	shp->shm_lprid = 0;
 	shp->shm_atim = shp->shm_dtim = 0;
@@ -514,6 +508,13 @@ static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
 	shp->shm_nattch = 0;
 	shp->shm_file = file;
 	shp->shm_creator = current;
+
+	id = ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);
+	if (id < 0) {
+		error = id;
+		goto no_id;
+	}
+
 	/*
 	 * shmid gets reported as "inode#" in /proc/pid/maps.
 	 * proc-ps tools use this. Changing this will break them.
diff --git a/kernel/ipc/util.c b/kernel/ipc/util.c
index 75261a31d..e4c937703 100644
--- a/kernel/ipc/util.c
+++ b/kernel/ipc/util.c
@@ -264,6 +264,10 @@ int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)
 	rcu_read_lock();
 	spin_lock(&new->lock);
 
+	current_euid_egid(&euid, &egid);
+	new->cuid = new->uid = euid;
+	new->gid = new->cgid = egid;
+
 	err = idr_get_new(&ids->ipcs_idr, new, &id);
 	if (err) {
 		spin_unlock(&new->lock);
@@ -273,10 +277,6 @@ int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)
 
 	ids->in_use++;
 
-	current_euid_egid(&euid, &egid);
-	new->cuid = new->uid = euid;
-	new->gid = new->cgid = egid;
-
 	new->seq = ids->seq++;
 	if(ids->seq > ids->seq_max)
 		ids->seq = 0;
