bq__aquaris-E5
commit 173a70a1fe29b5d0e784fbeb8f153ae3a1114494
Author:     Petr Matousek <pmatouse@redhat.com>
AuthorDate: Tue Sep 23 20:22:30 2014 +0200
Commit:     John McAleely <john.mcaleely@canonical.com>
CommitDate: Fri Dec 18 21:47:04 2015 +0000

    kvm: vmx: handle invvpid vm exit gracefully
    
    On systems with invvpid instruction support (corresponding bit in
    IA32_VMX_EPT_VPID_CAP MSR is set) guest invocation of invvpid
    causes vm exit, which is currently not handled and results in
    propagation of unknown exit to userspace.
    
    Fix this by installing an invvpid vm exit handler.
    
    This is CVE-2014-3646.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Petr Matousek <pmatouse@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    (backported from commit a642fc305053cc1c6e47e4f4df327895747ab485)
    Signed-off-by: AceLan Kao <acelan.kao@canonical.com>
    
    Change-Id: I1603df95c48ec260e5435568a8bac65c567bb75a

diff --git a/kernel/arch/x86/include/asm/vmx.h b/kernel/arch/x86/include/asm/vmx.h
index b21a5724f..d76a59e19 100644
--- a/kernel/arch/x86/include/asm/vmx.h
+++ b/kernel/arch/x86/include/asm/vmx.h
@@ -280,6 +280,7 @@ enum vmcs_field {
 #define EXIT_REASON_EPT_VIOLATION       48
 #define EXIT_REASON_EPT_MISCONFIG       49
 #define EXIT_REASON_INVEPT		50
+#define EXIT_REASON_INVVPID		53
 #define EXIT_REASON_WBINVD		54
 #define EXIT_REASON_XSETBV		55
 
diff --git a/kernel/arch/x86/kvm/vmx.c b/kernel/arch/x86/kvm/vmx.c
index 3bc0b8191..3ab24e702 100644
--- a/kernel/arch/x86/kvm/vmx.c
+++ b/kernel/arch/x86/kvm/vmx.c
@@ -5627,6 +5627,12 @@ static int handle_invept(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+static int handle_invvpid(struct kvm_vcpu *vcpu)
+{
+	kvm_queue_exception(vcpu, UD_VECTOR);
+	return 1;
+}
+
 /*
  * The exit handlers return 1 if the exit was handled fully and guest execution
  * may resume.  Otherwise they set the kvm_run parameter to indicate what needs
@@ -5670,6 +5676,7 @@ static int (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {
 	[EXIT_REASON_MWAIT_INSTRUCTION]	      = handle_invalid_op,
 	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,
 	[EXIT_REASON_INVEPT]                  = handle_invept,
+	[EXIT_REASON_INVVPID]                 = handle_invvpid,
 };
 
 static const int kvm_vmx_max_exit_handlers =
@@ -5854,7 +5861,7 @@ static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)
 	case EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:
 	case EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:
 	case EXIT_REASON_VMOFF: case EXIT_REASON_VMON:
-	case EXIT_REASON_INVEPT:
+	case EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:
 		/*
 		 * VMX instructions trap unconditionally. This allows L1 to
 		 * emulate them for its L2 guest, i.e., allows 3-level nesting!
