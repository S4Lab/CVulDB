fireeye__rvmi-qemu
commit cc45995294b92d95319b4782750a3580cabdbc0c
Author:     Michael S. Tsirkin <mst@redhat.com>
AuthorDate: Thu Apr 3 19:51:14 2014 +0300
Commit:     Juan Quintela <quintela@redhat.com>
CommitDate: Mon May 5 22:15:02 2014 +0200

    virtio: out-of-bounds buffer write on invalid state load
    
    CVE-2013-4151 QEMU 1.0 out-of-bounds buffer write in
    virtio_load@hw/virtio/virtio.c
    
    So we have this code since way back when:
    
        num = qemu_get_be32(f);
    
        for (i = 0; i < num; i++) {
            vdev->vq[i].vring.num = qemu_get_be32(f);
    
    array of vqs has size VIRTIO_PCI_QUEUE_MAX, so
    on invalid input this will write beyond end of buffer.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Reviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>
    Signed-off-by: Juan Quintela <quintela@redhat.com>

diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index aeabf3a459..05f05e7c10 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -891,7 +891,8 @@ int virtio_set_features(VirtIODevice *vdev, uint32_t val)
 
 int virtio_load(VirtIODevice *vdev, QEMUFile *f)
 {
-    int num, i, ret;
+    int i, ret;
+    uint32_t num;
     uint32_t features;
     uint32_t supported_features;
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -919,6 +920,11 @@ int virtio_load(VirtIODevice *vdev, QEMUFile *f)
 
     num = qemu_get_be32(f);
 
+    if (num > VIRTIO_PCI_QUEUE_MAX) {
+        error_report("Invalid number of PCI queues: 0x%x", num);
+        return -1;
+    }
+
     for (i = 0; i < num; i++) {
         vdev->vq[i].vring.num = qemu_get_be32(f);
         if (k->has_variable_vring_alignment) {
