xen-project__xen
commit 79775f57d399afbd238566f73700e1f3da31c034
Author:     Juergen Gross <jgross@suse.com>
AuthorDate: Tue Sep 12 15:01:39 2017 +0200
Commit:     Jan Beulich <jbeulich@suse.com>
CommitDate: Tue Sep 12 15:01:39 2017 +0200

    tools/xenstore: dont unlink connection object twice
    
    A connection object of a domain with associated stubdom has two
    parents: the domain and the stubdom. When cleaning up the list of
    active domains in domain_cleanup() make sure not to unlink the
    connection twice from the same domain. This could happen when the
    domain and its stubdom are being destroyed at the same time leading
    to the domain loop being entered twice.
    
    Additionally don't use talloc_free() in this case as it will remove
    a random parent link, leading eventually to a memory leak. Use
    talloc_unlink() instead specifying the context from which the
    connection object should be removed.
    
    This is CVE-2017-14317 / XSA-233.
    
    Reported-by: Eric Chanudet <chanudete@ainfosec.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Ian Jackson <ian.jackson@eu.citrix.com>
    master commit: 562a1c0f7ef3fbf3c122c3dfa4f2ad9dd51da9fe
    master date: 2017-09-12 14:44:56 +0200

diff --git a/tools/xenstore/xenstored_domain.c b/tools/xenstore/xenstored_domain.c
index f41cf46ced..fa6655033a 100644
--- a/tools/xenstore/xenstored_domain.c
+++ b/tools/xenstore/xenstored_domain.c
@@ -221,10 +221,11 @@ static int destroy_domain(void *_domain)
 static void domain_cleanup(void)
 {
 	xc_dominfo_t dominfo;
-	struct domain *domain, *tmp;
+	struct domain *domain;
 	int notify = 0;
 
-	list_for_each_entry_safe(domain, tmp, &domains, list) {
+ again:
+	list_for_each_entry(domain, &domains, list) {
 		if (xc_domain_getinfo(*xc_handle, domain->domid, 1,
 				      &dominfo) == 1 &&
 		    dominfo.domid == domain->domid) {
@@ -236,8 +237,12 @@ static void domain_cleanup(void)
 			if (!dominfo.dying)
 				continue;
 		}
-		talloc_free(domain->conn);
-		notify = 0; /* destroy_domain() fires the watch */
+		if (domain->conn) {
+			talloc_unlink(talloc_autofree_context(), domain->conn);
+			domain->conn = NULL;
+			notify = 0; /* destroy_domain() fires the watch */
+			goto again;
+		}
 	}
 
 	if (notify)
