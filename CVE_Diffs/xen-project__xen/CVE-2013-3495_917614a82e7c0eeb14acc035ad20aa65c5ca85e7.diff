xen-project__xen
commit 917614a82e7c0eeb14acc035ad20aa65c5ca85e7
Author:     Jan Beulich <jbeulich@suse.com>
AuthorDate: Fri May 23 15:40:47 2014 +0200
Commit:     Jan Beulich <jbeulich@suse.com>
CommitDate: Fri May 23 15:40:47 2014 +0200

    VT-d: apply quirks at device setup time rather than only at boot
    
    Accessing extended config space may not be possible at boot time, e.g.
    when the memory space used by MMCFG is reserved only via ACPI tables,
    but not in the E820/UEFI memory maps (which we need Dom0 to tell us
    about). Consequently the change here still leaves the issue unaddressed
    for systems where the extended config space remains inaccessible (due
    to firmware bugs, i.e. not properly reserving the address space of
    those regions).
    
    With the respective messages now potentially getting logged more than
    once, we ought to consider whether we should issue them only if we in
    fact were required to do any masking (i.e. if the relevant mask bits
    weren't already set).
    
    This is CVE-2013-3495 / XSA-59.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
    Acked-by: Xiantao Zhang <xiantao.zhang@intel.com>
    Acked-by: Yang Zhang <yang.z.zhang@intel.com>
    master commit: 5786718fbaafbe47d72cc1512cd93de79b8fc2fa
    master date: 2014-05-20 15:53:20 +0200

diff --git a/xen/drivers/passthrough/vtd/extern.h b/xen/drivers/passthrough/vtd/extern.h
index bcfa8702d9..bd0511ee96 100644
--- a/xen/drivers/passthrough/vtd/extern.h
+++ b/xen/drivers/passthrough/vtd/extern.h
@@ -104,7 +104,7 @@ void platform_quirks_init(void);
 void vtd_ops_preamble_quirk(struct iommu* iommu);
 void vtd_ops_postamble_quirk(struct iommu* iommu);
 void me_wifi_quirk(struct domain *domain, u8 bus, u8 devfn, int map);
-void pci_vtd_quirk(struct pci_dev *pdev);
+void pci_vtd_quirk(const struct pci_dev *);
 int platform_supports_intremap(void);
 int platform_supports_x2apic(void);
 
diff --git a/xen/drivers/passthrough/vtd/iommu.c b/xen/drivers/passthrough/vtd/iommu.c
index f9a565d7c9..bb7c4443d5 100644
--- a/xen/drivers/passthrough/vtd/iommu.c
+++ b/xen/drivers/passthrough/vtd/iommu.c
@@ -1513,6 +1513,9 @@ static int domain_context_mapping(
         break;
     }
 
+    if ( !ret && devfn == pdev->devfn )
+        pci_vtd_quirk(pdev);
+
     return ret;
 }
 
@@ -1953,6 +1956,8 @@ static int intel_iommu_enable_device(struct pci_dev *pdev)
     struct acpi_drhd_unit *drhd = acpi_find_matched_drhd_unit(pdev);
     int ret = drhd ? ats_device(pdev, drhd) : -ENODEV;
 
+    pci_vtd_quirk(pdev);
+
     if ( ret <= 0 )
         return ret;
 
@@ -2026,7 +2031,6 @@ static int intel_iommu_remove_device(struct pci_dev *pdev)
 static void __init setup_dom0_device(struct pci_dev *pdev)
 {
     domain_context_mapping(pdev->domain, pdev->seg, pdev->bus, pdev->devfn);
-    pci_vtd_quirk(pdev);
 }
 
 void clear_fault_bits(struct iommu *iommu)
diff --git a/xen/drivers/passthrough/vtd/quirks.c b/xen/drivers/passthrough/vtd/quirks.c
index f300c6c6b6..0e1b062e12 100644
--- a/xen/drivers/passthrough/vtd/quirks.c
+++ b/xen/drivers/passthrough/vtd/quirks.c
@@ -389,7 +389,7 @@ void me_wifi_quirk(struct domain *domain, u8 bus, u8 devfn, int map)
  *   - This can cause system failure upon non-fatal VT-d faults
  *   - Potential security issue if malicious guest trigger VT-d faults
  */
-void __init pci_vtd_quirk(struct pci_dev *pdev)
+void pci_vtd_quirk(const struct pci_dev *pdev)
 {
     int seg = pdev->seg;
     int bus = pdev->bus;
