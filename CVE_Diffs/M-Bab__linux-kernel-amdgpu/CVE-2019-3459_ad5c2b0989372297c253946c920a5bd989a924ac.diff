M-Bab__linux-kernel-amdgpu
commit ad5c2b0989372297c253946c920a5bd989a924ac
Author:     Marcel Holtmann <marcel@holtmann.org>
AuthorDate: Tue Feb 19 18:48:56 2019 +0800
Commit:     Seth Forshee <seth.forshee@canonical.com>
CommitDate: Mon Mar 4 06:51:44 2019 -0600

    Bluetooth: Verify that l2cap_get_conf_opt provides large enough buffer
    
    The function l2cap_get_conf_opt will return L2CAP_CONF_OPT_SIZE + opt->len
    as length value. The opt->len however is in control over the remote user
    and can be used by an attacker to gain access beyond the bounds of the
    actual packet.
    
    To prevent any potential leak of heap memory, it is enough to check that
    the resulting len calculation after calling l2cap_get_conf_opt is not
    below zero. A well formed packet will always return >= 0 here and will
    end with the length value being zero after the last option has been
    parsed. In case of malformed packets messing with the opt->len field the
    length value will become negative. If that is the case, then just abort
    and ignore the option.
    
    In case an attacker uses a too short opt->len value, then garbage will
    be parsed, but that is protected by the unknown option handling and also
    the option parameter size checks.
    
    CVE-2019-3459
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    (cherry picked from commit 7c9cbd0b5e38a1672fcd137894ace3b042dfbf69 linux-next)
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Acked-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>

diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index 2a7fb517d460..f8b3d2a81a44 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -3337,6 +3337,8 @@ static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data
 
 	while (len >= L2CAP_CONF_OPT_SIZE) {
 		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
+		if (len < 0)
+			break;
 
 		hint  = type & L2CAP_CONF_HINT;
 		type &= L2CAP_CONF_MASK;
@@ -3548,6 +3550,8 @@ static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,
 
 	while (len >= L2CAP_CONF_OPT_SIZE) {
 		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
+		if (len < 0)
+			break;
 
 		switch (type) {
 		case L2CAP_CONF_MTU:
@@ -3728,6 +3732,8 @@ static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)
 
 	while (len >= L2CAP_CONF_OPT_SIZE) {
 		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
+		if (len < 0)
+			break;
 
 		switch (type) {
 		case L2CAP_CONF_RFC:
