M-Bab__linux-kernel-amdgpu
commit 5395dfb4609d6e7ae88deec3be5604ff89352209
Author:     Oleg Nesterov <oleg@redhat.com>
AuthorDate: Mon Jul 17 14:53:29 2017 +0200
Commit:     Seth Forshee <seth.forshee@canonical.com>
CommitDate: Mon Jul 24 13:36:42 2017 -0500

    mm/mmap.c: expand_downwards: don't require the gap if !vm_prev
    
    expand_stack(vma) fails if address < stack_guard_gap even if there is no
    vma->vm_prev.  I don't think this makes sense, and we didn't do this
    before the recent commit 1be7107fbe18 ("mm: larger stack guard gap,
    between vmas").
    
    We do not need a gap in this case, any address is fine as long as
    security_mmap_addr() doesn't object.
    
    This also simplifies the code, we know that address >= prev->vm_end and
    thus underflow is not possible.
    
    Link: http://lkml.kernel.org/r/20170628175258.GA24881@redhat.com
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
    CVE-2017-1000364
    
    (cherry picked from commit 32e4e6d5cbb0c0e427391635991fe65e17797af8)
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>
    Acked-by: Kleber Sacilotto de Souza <kleber.souza@canonical.com>
    Acked-by: Kamal Mostafa <kamal@canonical.com>
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>

diff --git a/mm/mmap.c b/mm/mmap.c
index 9aec6f578b75..cc248c859959 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2316,7 +2316,6 @@ int expand_downwards(struct vm_area_struct *vma,
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct vm_area_struct *prev;
-	unsigned long gap_addr;
 	int error;
 
 	address &= PAGE_MASK;
@@ -2325,15 +2324,12 @@ int expand_downwards(struct vm_area_struct *vma,
 		return error;
 
 	/* Enforce stack_guard_gap */
-	gap_addr = address - stack_guard_gap;
-	if (gap_addr > address)
-		return -ENOMEM;
 	prev = vma->vm_prev;
-	if (prev && prev->vm_end > gap_addr &&
+	/* Check that both stack segments have the same anon_vma? */
+	if (prev && !(prev->vm_flags & VM_GROWSDOWN) &&
 			(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {
-		if (!(prev->vm_flags & VM_GROWSDOWN))
+		if (address - prev->vm_end < stack_guard_gap)
 			return -ENOMEM;
-		/* Check that both stack segments have the same anon_vma? */
 	}
 
 	/* We must make sure the anon_vma is allocated. */
