arachsys__containers
commit 0cd77e776e297814f2e05db0505ae409d79e324a
Author:     Chris Webb <chris@arachsys.com>
AuthorDate: Tue Jun 23 23:46:26 2015 +0100
Commit:     Chris Webb <chris@arachsys.com>
CommitDate: Tue Jun 23 23:46:26 2015 +0100

    Disable setgroups() when run non-setuid by an unprivileged user
    
    Linux 3.19 and later do not allow unprivileged processes to write a GID
    map unless the setgroups() call has been permanently disabled by writing
    "deny" to /proc/PID/setgroups. This is a fix for CVE-2014-8989 which
    applied to strangely-configured systems where group membership implies
    more restricted permissions rather than supplementary permissions.
    
    Disable setgroups() when run non-setuid by an unprivileged user, but
    bypass this kernel restriction when run setuid. It is not worth breaking
    setgroups() for all non-root users to secure such odd configurations,
    but a warning about setuid behaviour is included in the documentation.
    
    Based on a patch contributed by Alin Dobre <alin.dobre@outlook.com>

diff --git a/README b/README
index aa7f910..5c4e2b1 100644
--- a/README
+++ b/README
@@ -241,9 +241,9 @@ only map container UID/GIDs onto the host UID/GID of that user. The
 resulting container is not very useful as it has just a single user and
 group available. (Typically only root is mapped in the container.)
 
-However, contain and pseudo can also safely be installed setuid root, and in
-this case, unprivileged users can also map onto ranges of UIDs/GIDs that
-have been delegated for their use in /etc/subuid and /etc/subgid.
+However, contain and pseudo can also be installed setuid root, and in this
+case, unprivileged users can also map onto ranges of UIDs/GIDs that have
+been delegated for their use in /etc/subuid and /etc/subgid.
 
 The format of these files is similar to /etc/passwd, /etc/group and
 /etc/shadow. Each line specifies an additional range of UIDs/GIDs allocated
@@ -263,6 +263,19 @@ proposed patches against the standard GNU/Linux Shadow package which add
 support for creating and updating these files in this format; they are
 likely to become a standard way to delegate sub-users and sub-groups.
 
+Linux 3.19 and later do not allow unprivileged processes to write a GID map
+unless the setgroups() call has been permanently disabled by writing "deny"
+to /proc/PID/setgroups. This is a fix for CVE-2014-8989 which applied to
+strangely-configured systems where group membership implies more restricted
+permissions rather than supplementary permissions.
+
+As a result, when run non-setuid by an unprivileged user, contain and pseudo
+must disable setgroups() in the container. Conversely, when installed setuid
+root, they will use their privilege to bypass this kernel restriction,
+resulting in fully-functional containers which still support setgroups().
+However, this also means that they can be used to bypass restrictions
+implemented by group membership.
+
 
 Building and installing
 -----------------------
@@ -274,6 +287,11 @@ in /bin. Alternatively, you can set DESTDIR and/or BINDIR to install in a
 different location, or strip and copy the compiled binaries into the correct
 place manually.
 
+Note that setuid contain and pseudo effectively enable unprivileged users to
+to drop supplementary group memberships using setgroups(). Consequently,
+they should NOT be installed setuid root on systems where group membership
+implies more restricted permissions rather than supplementary permissions.
+
 These utilities were developed on GNU/Linux and are not portable to other
 platforms as they rely on Linux-specific facilities such as namespaces.
 Please report any problems or bugs to Chris Webb <chris@arachsys.com>.
diff --git a/contain.c b/contain.c
index 650bbe9..dda9e7b 100644
--- a/contain.c
+++ b/contain.c
@@ -67,6 +67,8 @@ int main(int argc, char **argv) {
       error(1, errno, "fork");
     case 0:
       raise(SIGSTOP);
+      if (geteuid() != 0)
+        denysetgroups(parent);
       writemap(parent, GID, gidmap);
       writemap(parent, UID, uidmap);
 
diff --git a/contain.h b/contain.h
index 3f1ec19..914aadf 100644
--- a/contain.h
+++ b/contain.h
@@ -13,6 +13,7 @@
 
 extern char *append(char **destination, const char *format, ...);
 extern void createroot(char *src, int console, char *helper);
+extern void denysetgroups(pid_t pid);
 extern void enterroot(void);
 extern int getconsole(void);
 extern void mountproc(void);
diff --git a/map.c b/map.c
index 8110152..4a0727c 100644
--- a/map.c
+++ b/map.c
@@ -11,6 +11,19 @@
 #include <unistd.h>
 #include "contain.h"
 
+void denysetgroups(pid_t pid) {
+  char *path, *text = "deny";
+  int fd;
+
+  path = string("/proc/%d/setgroups", pid);
+  if ((fd = open(path, O_WRONLY)) < 0)
+    error(1, 0, "Failed to disable setgroups() in container");
+  else if (write(fd, text, strlen(text)) != (ssize_t) strlen(text))
+    error(1, 0, "Failed to disable setgroups() in container");
+  close(fd);
+  free(path);
+}
+
 static char *getmap(pid_t pid, int type) {
   char *line = NULL, *result = NULL, *path;
   size_t size;
diff --git a/pseudo.c b/pseudo.c
index 77f9b0e..f98a205 100644
--- a/pseudo.c
+++ b/pseudo.c
@@ -44,6 +44,8 @@ int main(int argc, char **argv) {
       error(1, errno, "fork");
     case 0:
       raise(SIGSTOP);
+      if (geteuid() != 0)
+        denysetgroups(parent);
       writemap(parent, GID, gidmap);
       writemap(parent, UID, uidmap);
       exit(0);
