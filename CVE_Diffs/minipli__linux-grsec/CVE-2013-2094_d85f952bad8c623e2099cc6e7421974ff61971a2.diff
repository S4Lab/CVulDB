minipli__linux-grsec
commit d85f952bad8c623e2099cc6e7421974ff61971a2
Author:     PaX Team <pageexec@freemail.hu>
AuthorDate: Fri May 24 07:47:37 2013 +0200
Commit:     Mathias Krause <minipli@googlemail.com>
CommitDate: Fri May 24 07:47:37 2013 +0200

    [pax] Updated to patch 3.2.45-test106
    
    Updated to pax-linux-3.2.45-test106.patch
    
    PaX Team says:
      - fixed a gcc assert in the structleak plugin, reported by Emese Revfy
      - fixed pfn extraction from pud/pgd entries, reported by ousado
      - fixed a gcc bug/feature exposed by constification, the investigation was prompted by http://rikiji.it/2013/05/10/CVE-2013-2094-x86.html

diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h
index b7543b236e1c..ee359f296d55 100644
--- a/arch/x86/include/asm/pgtable.h
+++ b/arch/x86/include/asm/pgtable.h
@@ -187,6 +187,11 @@ static inline unsigned long pud_pfn(pud_t pud)
 	return (pud_val(pud) & PTE_PFN_MASK) >> PAGE_SHIFT;
 }
 
+static inline unsigned long pgd_pfn(pgd_t pgd)
+{
+	return (pgd_val(pgd) & PTE_PFN_MASK) >> PAGE_SHIFT;
+}
+
 #define pte_page(pte)	pfn_to_page(pte_pfn(pte))
 
 static inline int pmd_large(pmd_t pte)
@@ -584,7 +589,7 @@ static inline unsigned long pud_page_vaddr(pud_t pud)
  * Currently stuck as a macro due to indirect forward reference to
  * linux/mmzone.h's __section_mem_map_addr() definition:
  */
-#define pud_page(pud)		pfn_to_page(pud_val(pud) >> PAGE_SHIFT)
+#define pud_page(pud)		pfn_to_page((pud_val(pud) & PTE_PFN_MASK) >> PAGE_SHIFT)
 
 /* Find an entry in the second-level page table.. */
 static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
@@ -624,7 +629,7 @@ static inline unsigned long pgd_page_vaddr(pgd_t pgd)
  * Currently stuck as a macro due to indirect forward reference to
  * linux/mmzone.h's __section_mem_map_addr() definition:
  */
-#define pgd_page(pgd)		pfn_to_page(pgd_val(pgd) >> PAGE_SHIFT)
+#define pgd_page(pgd)		pfn_to_page((pgd_val(pgd) & PTE_PFN_MASK) >> PAGE_SHIFT)
 
 /* to find an entry in a page-table-directory. */
 static inline unsigned long pud_index(unsigned long address)
diff --git a/fs/jfs/super.c b/fs/jfs/super.c
index ad896ca8a783..462e07de80a9 100644
--- a/fs/jfs/super.c
+++ b/fs/jfs/super.c
@@ -221,7 +221,7 @@ static const match_table_t tokens = {
 static int parse_options(char *options, struct super_block *sb, s64 *newLVSize,
 			 int *flag)
 {
-	const void *nls_map = (const void *)-1;	/* -1: no change;  NULL: none */
+	void *nls_map = (void *)-1;	/* -1: no change;  NULL: none */
 	char *p;
 	struct jfs_sb_info *sbi = JFS_SBI(sb);
 
@@ -249,7 +249,7 @@ static int parse_options(char *options, struct super_block *sb, s64 *newLVSize,
 			/* Don't do anything ;-) */
 			break;
 		case Opt_iocharset:
-			if (nls_map && nls_map != (const void *) -1)
+			if (nls_map && nls_map != (void *) -1)
 				unload_nls(nls_map);
 			if (!strcmp(args[0].from, "none"))
 				nls_map = NULL;
diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c
index 83c4bd5b2dd7..f75658c67645 100644
--- a/sound/soc/fsl/fsl_ssi.c
+++ b/sound/soc/fsl/fsl_ssi.c
@@ -608,7 +608,7 @@ static int __devinit fsl_ssi_probe(struct platform_device *pdev)
 {
 	struct fsl_ssi_private *ssi_private;
 	int ret = 0;
-	struct device_attribute *dev_attr = NULL;
+	device_attribute_no_const *dev_attr = NULL;
 	struct device_node *np = pdev->dev.of_node;
 	const char *p, *sprop;
 	const uint32_t *iprop;
diff --git a/tools/gcc/constify_plugin.c b/tools/gcc/constify_plugin.c
index bee0acb2ce5b..c17312d3226d 100644
--- a/tools/gcc/constify_plugin.c
+++ b/tools/gcc/constify_plugin.c
@@ -44,7 +44,7 @@
 int plugin_is_GPL_compatible;
 
 static struct plugin_info const_plugin_info = {
-	.version	= "201303270300",
+	.version	= "201305231310",
 	.help		= "no-constify\tturn off constification\n",
 };
 
@@ -375,6 +375,41 @@ static void finish_type(void *event_data, void *data)
 	TYPE_CONSTIFY_VISITED(type) = 1;
 }
 
+static void check_global_variables(void)
+{
+	struct varpool_node *node;
+
+#if BUILDING_GCC_VERSION <= 4007
+	for (node = varpool_nodes; node; node = node->next) {
+		tree var = node->decl;
+#else
+	FOR_EACH_VARIABLE(node) {
+		tree var = node->symbol.decl;
+#endif
+		tree type = TREE_TYPE(var);
+
+		if (TREE_CODE(type) != RECORD_TYPE && TREE_CODE(type) != UNION_TYPE)
+			continue;
+
+		if (!TYPE_READONLY(type) || !C_TYPE_FIELDS_READONLY(type))
+			continue;
+
+		if (!TYPE_CONSTIFY_VISITED(type))
+			continue;
+
+		if (DECL_EXTERNAL(var))
+			continue;
+
+		if (DECL_INITIAL(var))
+			continue;
+
+		// this works around a gcc bug/feature where uninitialized globals
+		// are moved into the .bss section regardless of any constification
+		DECL_INITIAL(var) = build_constructor(type, NULL);
+//		inform(DECL_SOURCE_LOCATION(var), "constified variable %qE moved into .rodata", var);
+	}
+}
+
 static unsigned int check_local_variables(void)
 {
 	unsigned int ret = 0;
@@ -413,15 +448,22 @@ static unsigned int check_local_variables(void)
 	return ret;
 }
 
+static unsigned int check_variables(void)
+{
+	check_global_variables();
+	return check_local_variables();
+}
+
+	unsigned int ret = 0;
 static struct gimple_opt_pass pass_local_variable = {
 	{
 		.type			= GIMPLE_PASS,
-		.name			= "check_local_variables",
+		.name			= "check_variables",
 #if BUILDING_GCC_VERSION >= 4008
 		.optinfo_flags		= OPTGROUP_NONE,
 #endif
 		.gate			= NULL,
-		.execute		= check_local_variables,
+		.execute		= check_variables,
 		.sub			= NULL,
 		.next			= NULL,
 		.static_pass_number	= 0,
diff --git a/tools/gcc/structleak_plugin.c b/tools/gcc/structleak_plugin.c
index b07fe22c11a5..4fae911ac6bd 100644
--- a/tools/gcc/structleak_plugin.c
+++ b/tools/gcc/structleak_plugin.c
@@ -138,11 +138,12 @@ static void initialize(tree var)
 	// first check if the variable is already initialized, warn otherwise
 	for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
 		gimple stmt = gsi_stmt(gsi);
-		tree rhs1 = gimple_assign_rhs1(stmt);
+		tree rhs1;
 
 		// we're looking for an assignment of a single rhs...
 		if (!gimple_assign_single_p(stmt))
 			continue;
+		rhs1 = gimple_assign_rhs1(stmt);
 #if BUILDING_GCC_VERSION >= 4007
 		// ... of a non-clobbering expression...
 		if (TREE_CLOBBER_P(rhs1))
