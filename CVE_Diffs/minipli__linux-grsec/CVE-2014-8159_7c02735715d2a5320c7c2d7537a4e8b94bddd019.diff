minipli__linux-grsec
commit 7c02735715d2a5320c7c2d7537a4e8b94bddd019
Author:     PaX Team <pageexec@freemail.hu>
AuthorDate: Mon Apr 6 18:56:41 2015 +0200
Commit:     Mathias Krause <minipli@googlemail.com>
CommitDate: Mon Apr 6 18:56:41 2015 +0200

    [pax] Updated to patch 3.2.68-test168
    
    Updated to pax-linux-3.2.68-test168.patch
    
    PaX Team says:
      - worked around incompatibility between SANITIZE and DEBUG_PAGEALLOC, reported by metarox (https://forums.grsecurity.net/viewtopic.php?f=3&t=4176)
      - fixed a crash bug with the old PAGEEXEC method and PSE, reported by Merlin
      - properly fixed CVE-2014-8159, http://seclists.org/oss-sec/2015/q1/886 and http://seclists.org/oss-sec/2015/q2/10
      - fixed some REFCOUNT false positives in the tracing ring buffer code, reported by metarox (https://forums.grsecurity.net/viewtopic.php?f=3&t=4186)
      - some more plugin porting to gcc-5

diff --git a/arch/sparc/include/asm/uaccess_32.h b/arch/sparc/include/asm/uaccess_32.h
index 07f333ded7a5..d2eec8199e1e 100644
--- a/arch/sparc/include/asm/uaccess_32.h
+++ b/arch/sparc/include/asm/uaccess_32.h
@@ -46,6 +46,7 @@
 #define __user_ok(addr, size) ({ (void)(size); (addr) < STACK_TOP; })
 #define __kernel_ok (segment_eq(get_fs(), KERNEL_DS))
 #define __access_ok(addr,size) (__user_ok((addr) & get_fs().seg,(size)))
+#define access_ok_noprefault(type, addr, size) access_ok((type), (addr), (size))
 #define access_ok(type, addr, size)					\
 	({ (void)(type); __access_ok((unsigned long)(addr), size); })
 
diff --git a/arch/sparc/include/asm/uaccess_64.h b/arch/sparc/include/asm/uaccess_64.h
index 2f65aba18df3..c55ac5e95bf7 100644
--- a/arch/sparc/include/asm/uaccess_64.h
+++ b/arch/sparc/include/asm/uaccess_64.h
@@ -54,6 +54,11 @@ static inline int __access_ok(const void __user * addr, unsigned long size)
 	return 1;
 }
 
+static inline int access_ok_noprefault(int type, const void __user * addr, unsigned long size)
+{
+	return 1;
+}
+
 static inline int access_ok(int type, const void __user * addr, unsigned long size)
 {
 	return 1;
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index ac6d8c6cd238..60561cbd87ad 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -715,6 +715,16 @@ static void __cpuinit generic_identify(struct cpuinfo_x86 *c)
 
 	setup_smep(c);
 
+#ifdef CONFIG_X86_32
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!(__supported_pte_mask & _PAGE_NX))
+		clear_cpu_cap(c, X86_FEATURE_PSE);
+#endif
+#if defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_KERNEXEC) || defined(CONFIG_PAX_MEMORY_UDEREF)
+	clear_cpu_cap(c, X86_FEATURE_SEP);
+#endif
+#endif
+
 	get_model_name(c); /* Default name */
 
 	detect_nopl(c);
@@ -787,10 +797,6 @@ static void __cpuinit identify_cpu(struct cpuinfo_x86 *c)
 	/* Filter out anything that depends on CPUID levels we don't have */
 	filter_cpuid_features(c, true);
 
-#if defined(CONFIG_X86_32) && (defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_KERNEXEC) || defined(CONFIG_PAX_MEMORY_UDEREF))
-	setup_clear_cpu_cap(X86_FEATURE_SEP);
-#endif
-
 	/* If the model name is still unset, do table lookup. */
 	if (!c->x86_model_id[0]) {
 		const char *p;
diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c
index a8445b8f2558..e43f9b9157c1 100644
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@ -928,6 +928,9 @@ ssize_t ib_uverbs_reg_mr(struct ib_uverbs_file *file,
 	if (copy_from_user(&cmd, buf, sizeof cmd))
 		return -EFAULT;
 
+	if (!access_ok_noprefault(VERIFY_READ, cmd.start, cmd.length))
+		return -EFAULT;
+
 	INIT_UDATA(&udata, buf + sizeof cmd,
 		   (unsigned long) cmd.response + sizeof resp,
 		   in_len - sizeof cmd, out_len - sizeof resp);
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index 45b218f6119c..c3a5113bdacb 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -493,7 +493,7 @@ struct ring_buffer_per_cpu {
 	local_unchecked_t		overrun;
 	local_t				entries;
 	local_t				committing;
-	local_t				commits;
+	local_unchecked_t		commits;
 	unsigned long			read;
 	unsigned long			read_bytes;
 	u64				write_stamp;
@@ -2116,7 +2116,7 @@ rb_try_to_discard(struct ring_buffer_per_cpu *cpu_buffer,
 static void rb_start_commit(struct ring_buffer_per_cpu *cpu_buffer)
 {
 	local_inc(&cpu_buffer->committing);
-	local_inc(&cpu_buffer->commits);
+	local_inc_unchecked(&cpu_buffer->commits);
 }
 
 static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer)
@@ -2128,7 +2128,7 @@ static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer)
 		return;
 
  again:
-	commits = local_read(&cpu_buffer->commits);
+	commits = local_read_unchecked(&cpu_buffer->commits);
 	/* synchronize with interrupts */
 	barrier();
 	if (local_read(&cpu_buffer->committing) == 1)
@@ -2144,7 +2144,7 @@ static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer)
 	 * updating of the commit page and the clearing of the
 	 * committing counter.
 	 */
-	if (unlikely(local_read(&cpu_buffer->commits) != commits) &&
+	if (unlikely(local_read_unchecked(&cpu_buffer->commits) != commits) &&
 	    !local_read(&cpu_buffer->committing)) {
 		local_inc(&cpu_buffer->committing);
 		goto again;
@@ -2174,7 +2174,7 @@ rb_reserve_next_event(struct ring_buffer *buffer,
 	barrier();
 	if (unlikely(ACCESS_ONCE(cpu_buffer->buffer) != buffer)) {
 		local_dec(&cpu_buffer->committing);
-		local_dec(&cpu_buffer->commits);
+		local_dec_unchecked(&cpu_buffer->commits);
 		return NULL;
 	}
 #endif
@@ -3603,7 +3603,7 @@ rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer)
 	local_set_unchecked(&cpu_buffer->overrun, 0);
 	local_set(&cpu_buffer->entries, 0);
 	local_set(&cpu_buffer->committing, 0);
-	local_set(&cpu_buffer->commits, 0);
+	local_set_unchecked(&cpu_buffer->commits, 0);
 	cpu_buffer->read = 0;
 	cpu_buffer->read_bytes = 0;
 
diff --git a/scripts/gcc-plugin.sh b/scripts/gcc-plugin.sh
index 822fa9e98989..eaa4fce87add 100644
--- a/scripts/gcc-plugin.sh
+++ b/scripts/gcc-plugin.sh
@@ -1,7 +1,7 @@
 #!/bin/sh
 srctree=$(dirname "$0")
 gccplugins_dir=$($3 -print-file-name=plugin)
-plugincc=$($1 -E - -o /dev/null -I"${srctree}"/../tools/gcc -I"${gccplugins_dir}"/include 2>&1 <<EOF
+plugincc=$($1 -E -x c++ - -o /dev/null -I"${srctree}"/../tools/gcc -I"${gccplugins_dir}"/include 2>&1 <<EOF
 #include "gcc-common.h"
 #if BUILDING_GCC_VERSION >= 4008 || defined(ENABLE_BUILD_WITH_CXX)
 #warning $2 CXX
diff --git a/security/Kconfig b/security/Kconfig
index 39350f6b7ded..fe63b4aadb79 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -489,7 +489,7 @@ menu "Miscellaneous hardening features"
 
 config PAX_MEMORY_SANITIZE
 	bool "Sanitize all freed memory"
-	depends on !HIBERNATION
+	depends on !HIBERNATION && !DEBUG_PAGEALLOC
 	help
 	  By saying Y here the kernel will erase memory pages and slab objects
 	  as soon as they are freed.  This in turn reduces the lifetime of data
diff --git a/tools/gcc/colorize_plugin.c b/tools/gcc/colorize_plugin.c
index 54461af9b183..d44bd9f2bbe2 100644
--- a/tools/gcc/colorize_plugin.c
+++ b/tools/gcc/colorize_plugin.c
@@ -102,7 +102,8 @@ struct simple_ipa_opt_pass colorize_rearm_pass = {
 #if BUILDING_GCC_VERSION >= 4008
 		.optinfo_flags		= OPTGROUP_NONE,
 #endif
-#if BUILDING_GCC_VERSION >= 4009
+#if BUILDING_GCC_VERSION >= 5000
+#elif BUILDING_GCC_VERSION == 4009
 		.has_gate		= false,
 		.has_execute		= true,
 #else
@@ -128,7 +129,11 @@ namespace {
 class colorize_rearm_pass : public simple_ipa_opt_pass {
 public:
 	colorize_rearm_pass() : simple_ipa_opt_pass(colorize_rearm_pass_data, g) {}
+#if BUILDING_GCC_VERSION >= 5000
+	virtual unsigned int execute(function *) { return execute_colorize_rearm(); }
+#else
 	unsigned int execute() { return execute_colorize_rearm(); }
+#endif
 };
 }
 
diff --git a/tools/gcc/gcc-common.h b/tools/gcc/gcc-common.h
index cd95c0774c2a..14ec22669e01 100644
--- a/tools/gcc/gcc-common.h
+++ b/tools/gcc/gcc-common.h
@@ -78,6 +78,10 @@
 #include "tree-cfgcleanup.h"
 #endif
 
+#if BUILDING_GCC_VERSION >= 4008
+#include "is-a.h"
+#endif
+
 #include "diagnostic.h"
 //#include "tree-diagnostic.h"
 #include "tree-dump.h"
@@ -120,6 +124,9 @@
 //#include "lto-streamer.h"
 #endif
 //#include "lto-compress.h"
+#if BUILDING_GCC_VERSION >= 5000
+//#include "lto-section-names.h"
+#endif
 
 //#include "expr.h" where are you...
 extern rtx emit_move_insn(rtx x, rtx y);
@@ -148,11 +155,11 @@ static inline void debug_tree(const_tree t)
 #define C_TYPE_FIELDS_READONLY(TYPE) TREE_LANG_FLAG_1(TYPE)
 
 #if BUILDING_GCC_VERSION == 4005
-#define FOR_EACH_VEC_ELT_REVERSE(T,V,I,P) for (I = VEC_length(T, (V)) - 1; VEC_iterate(T, (V), (I), (P)); (I)--)
-#define FOR_EACH_LOCAL_DECL(FUN, I, D) FOR_EACH_VEC_ELT_REVERSE(tree, (FUN)->local_decls, I, D)
+#define FOR_EACH_LOCAL_DECL(FUN, I, D) for (tree vars = (FUN)->local_decls; vars && (D = TREE_VALUE(vars)); vars = TREE_CHAIN(vars), I)
 #define DECL_CHAIN(NODE) (TREE_CHAIN(DECL_MINIMAL_CHECK(NODE)))
 #define FOR_EACH_VEC_ELT(T, V, I, P) for (I = 0; VEC_iterate(T, (V), (I), (P)); ++(I))
 #define TODO_rebuild_cgraph_edges 0
+#define SCOPE_FILE_SCOPE_P(EXP) (!(EXP))
 
 #ifndef O_BINARY
 #define O_BINARY 0
@@ -296,6 +303,7 @@ extern void dump_gimple_stmt(pretty_printer *, gimple, int, int);
 #define PROP_loops 0
 #define NODE_SYMBOL(node) (node)
 #define NODE_DECL(node) (node)->decl
+#define INSN_LOCATION(INSN) RTL_LOCATION(INSN)
 
 static inline int bb_loop_depth(const_basic_block bb)
 {
@@ -316,6 +324,13 @@ static inline bool gimple_store_p(gimple gs)
 	cgraph_create_edge_including_clones((caller), (callee), (old_call_stmt), (call_stmt), (count), (freq), (reason))
 #endif
 
+#if BUILDING_GCC_VERSION == 4007 || BUILDING_GCC_VERSION == 4008
+static inline struct cgraph_node *cgraph_alias_target(struct cgraph_node *n)
+{
+	return cgraph_alias_aliased_node(n);
+}
+#endif
+
 #if BUILDING_GCC_VERSION <= 4008
 #define ENTRY_BLOCK_PTR_FOR_FN(FN)	ENTRY_BLOCK_PTR_FOR_FUNCTION(FN)
 #define EXIT_BLOCK_PTR_FOR_FN(FN)	EXIT_BLOCK_PTR_FOR_FUNCTION(FN)
@@ -335,6 +350,11 @@ static inline const char *get_tree_code_name(enum tree_code code)
 }
 
 #define ipa_remove_stmt_references(cnode, stmt)
+typedef union gimple_statement_d gasm;
+typedef union gimple_statement_d gassign;
+typedef union gimple_statement_d gcall;
+typedef union gimple_statement_d gphi;
+typedef union gimple_statement_d greturn;
 #endif
 
 #if BUILDING_GCC_VERSION == 4008
@@ -352,6 +372,29 @@ static inline const char *get_tree_code_name(enum tree_code code)
 
 #if BUILDING_GCC_VERSION <= 4009
 #define TODO_verify_il 0
+#define AVAIL_INTERPOSABLE AVAIL_OVERWRITABLE
+#endif
+
+#if BUILDING_GCC_VERSION == 4009
+typedef struct gimple_statement_base gasm;
+typedef struct gimple_statement_base gassign;
+typedef struct gimple_statement_base gcall;
+typedef struct gimple_statement_base gphi;
+typedef struct gimple_statement_base greturn;
+#endif
+
+#if BUILDING_GCC_VERSION <= 4009
+typedef struct rtx_def rtx_insn;
+
+static inline gasm *as_a_gasm(gimple stmt)
+{
+	return stmt;
+}
+
+static inline gcall *as_a_gcall(gimple stmt)
+{
+	return stmt;
+}
 #endif
 
 #if BUILDING_GCC_VERSION >= 4009
@@ -368,8 +411,110 @@ static inline const char *get_tree_code_name(enum tree_code code)
 #define TODO_verify_stmts TODO_verify_il
 #define TODO_verify_rtl_sharing TODO_verify_il
 
+#define TREE_INT_CST_HIGH(NODE) ({ TREE_INT_CST_EXT_NUNITS(NODE) > 1 ? (unsigned HOST_WIDE_INT)TREE_INT_CST_ELT(NODE, 1) : 0; })
+
+#define INSN_DELETED_P(insn) (insn)->deleted()
+
+extern bool is_simple_builtin(tree);
+
+// symtab/cgraph related
 #define debug_cgraph_node(node) (node)->debug()
 #define cgraph_get_node(decl) cgraph_node::get(decl)
+#define cgraph_n_nodes symtab->cgraph_count
+#define cgraph_max_uid symtab->cgraph_max_uid
+
+typedef struct cgraph_node *cgraph_node_ptr;
+typedef struct cgraph_edge *cgraph_edge_p;
+
+static inline void change_decl_assembler_name(tree decl, tree name)
+{
+	symtab->change_decl_assembler_name(decl, name);
+}
+
+static inline void varpool_finalize_decl(tree decl)
+{
+	varpool_node::finalize_decl(decl);
+}
+
+static inline cgraph_node_ptr cgraph_function_node(cgraph_node_ptr node, enum availability *availability)
+{
+	return node->function_symbol(availability);
+}
+
+static inline cgraph_node_ptr cgraph_function_or_thunk_node(cgraph_node_ptr node, enum availability *availability = NULL)
+{
+	return node->ultimate_alias_target(availability);
+}
+
+static inline bool cgraph_only_called_directly_p(cgraph_node_ptr node)
+{
+	return node->only_called_directly_p();
+}
+
+static inline enum availability cgraph_function_body_availability(cgraph_node_ptr node)
+{
+	return node->get_availability();
+}
+
+static inline cgraph_node_ptr cgraph_alias_target(cgraph_node_ptr node)
+{
+	return node->get_alias_target();
+}
+
+static inline struct cgraph_node_hook_list *cgraph_add_function_insertion_hook(cgraph_node_hook hook, void *data)
+{
+	return symtab->add_cgraph_insertion_hook(hook, data);
+}
+
+static inline void cgraph_remove_function_insertion_hook(struct cgraph_node_hook_list *entry)
+{
+	symtab->remove_cgraph_insertion_hook(entry);
+}
+
+static inline struct cgraph_node_hook_list *cgraph_add_node_removal_hook(cgraph_node_hook hook, void *data)
+{
+	return symtab->add_cgraph_removal_hook(hook, data);
+}
+
+static inline void cgraph_remove_node_removal_hook(struct cgraph_node_hook_list *entry)
+{
+	symtab->remove_cgraph_removal_hook(entry);
+}
+
+static inline struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook(cgraph_2node_hook hook, void *data)
+{
+	return symtab->add_cgraph_duplication_hook(hook, data);
+}
+
+static inline void cgraph_remove_node_duplication_hook(struct cgraph_2node_hook_list *entry)
+{
+	symtab->remove_cgraph_duplication_hook(entry);
+}
+
+// gimple related
+static inline gimple gimple_build_assign_with_ops(enum tree_code subcode, tree lhs, tree op1, tree op2 MEM_STAT_DECL)
+{
+	return gimple_build_assign(lhs, subcode, op1, op2 PASS_MEM_STAT);
+}
+
+static inline gasm *as_a_gasm(gimple stmt)
+{
+	return as_a<gasm *>(stmt);
+}
+
+static inline gcall *as_a_gcall(gimple stmt)
+{
+	return as_a<gcall *>(stmt);
+}
+
+// IPA/LTO related
+#define ipa_ref_list_referring_iterate(L,I,P) (L)->referring.iterate((I), &(P))
+#define ipa_ref_list_reference_iterate(L,I,P) (L)->reference.iterate((I), &(P))
+
+static inline cgraph_node_ptr ipa_ref_referring_node(struct ipa_ref *ref)
+{
+	return dyn_cast<cgraph_node_ptr>(ref->referring);
+}
 #endif
 
 #endif
diff --git a/tools/gcc/latent_entropy_plugin.c b/tools/gcc/latent_entropy_plugin.c
index e48b3234b431..2a393576638a 100644
--- a/tools/gcc/latent_entropy_plugin.c
+++ b/tools/gcc/latent_entropy_plugin.c
@@ -23,7 +23,7 @@
 
 int plugin_is_GPL_compatible;
 
-static tree latent_entropy_decl;
+static GTY(()) tree latent_entropy_decl;
 
 static struct plugin_info latent_entropy_plugin_info = {
 	.version	= "201409101820",
@@ -368,6 +368,7 @@ static void latent_entropy_start_unit(void *gcc_data, void *user_data)
 	TREE_STATIC(latent_entropy_decl) = 1;
 	TREE_PUBLIC(latent_entropy_decl) = 1;
 	TREE_USED(latent_entropy_decl) = 1;
+	DECL_PRESERVE_P(latent_entropy_decl) = 1;
 	TREE_THIS_VOLATILE(latent_entropy_decl) = 1;
 	DECL_EXTERNAL(latent_entropy_decl) = 1;
 	DECL_ARTIFICIAL(latent_entropy_decl) = 1;
diff --git a/tools/gcc/stackleak_plugin.c b/tools/gcc/stackleak_plugin.c
index 924652b55b19..90125d649a1f 100644
--- a/tools/gcc/stackleak_plugin.c
+++ b/tools/gcc/stackleak_plugin.c
@@ -25,7 +25,8 @@ int plugin_is_GPL_compatible;
 static int track_frame_size = -1;
 static const char track_function[] = "pax_track_stack";
 static const char check_function[] = "pax_check_alloca";
-static tree track_function_decl, check_function_decl;
+static GTY(()) tree track_function_decl;
+static GTY(()) tree check_function_decl;
 static bool init_locals;
 
 static struct plugin_info stackleak_plugin_info = {
