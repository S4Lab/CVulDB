minipli__linux-grsec
commit ca80e5b5767e8a2bf0714f9797b872258e500ee6
Author:     Adrian Bunk <bunk@stusta.de>
AuthorDate: Tue May 1 01:11:29 2007 +0200
Commit:     Adrian Bunk <bunk@stusta.de>
CommitDate: Tue May 1 01:11:29 2007 +0200

    [NETLINK]: Infinite recursion in netlink (CVE-2007-1861)
    
    Reply to NETLINK_FIB_LOOKUP messages were misrouted back to kernel,
    which resulted in infinite recursion and stack overflow.
    
    The bug is present in all kernel versions since the feature appeared.
    
    The patch also makes some minimal cleanup:
    
    1. Return something consistent (-ENOENT) when fib table is missing
    2. Do not crash when queue is empty (does not happen, but yet)
    3. Put result of lookup
    
    Sergey Vlasov:
    Oops fix
    
    Signed-off-by: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Signed-off-by: Sergey Vlasov <vsu@altlinux.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index 4e3d3811dea2..5ca2af0a1c26 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -525,6 +525,12 @@ static void nl_fib_lookup(struct fib_result_nl *frn, struct fib_table *tb )
 							    .fwmark = frn->fl_fwmark,
 							    .tos = frn->fl_tos,
 							    .scope = frn->fl_scope } } };
+
+#ifdef CONFIG_IP_MULTIPLE_TABLES
+	res.r = NULL;
+#endif
+
+	frn->err = -ENOENT;
 	if (tb) {
 		local_bh_disable();
 
@@ -536,6 +542,7 @@ static void nl_fib_lookup(struct fib_result_nl *frn, struct fib_table *tb )
 			frn->nh_sel = res.nh_sel;
 			frn->type = res.type;
 			frn->scope = res.scope;
+			fib_res_put(&res);
 		}
 		local_bh_enable();
 	}
@@ -550,6 +557,9 @@ static void nl_fib_input(struct sock *sk, int len)
 	struct fib_table *tb;
 	
 	skb = skb_dequeue(&sk->sk_receive_queue);
+	if (skb == NULL)
+		return;
+
 	nlh = (struct nlmsghdr *)skb->data;
 	if (skb->len < NLMSG_SPACE(0) || skb->len < nlh->nlmsg_len ||
 	    nlh->nlmsg_len < NLMSG_LENGTH(sizeof(*frn))) {
@@ -562,7 +572,7 @@ static void nl_fib_input(struct sock *sk, int len)
 
 	nl_fib_lookup(frn, tb);
 	
-	pid = nlh->nlmsg_pid;           /*pid of sending process */
+	pid = NETLINK_CB(skb).pid;       /* pid of sending process */
 	NETLINK_CB(skb).pid = 0;         /* from kernel */
 	NETLINK_CB(skb).dst_pid = pid;
 	NETLINK_CB(skb).dst_group = 0;  /* unicast */
