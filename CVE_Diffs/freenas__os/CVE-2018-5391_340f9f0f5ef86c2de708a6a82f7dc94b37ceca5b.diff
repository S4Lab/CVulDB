freenas__os
commit 340f9f0f5ef86c2de708a6a82f7dc94b37ceca5b
Author:     kp <kp@FreeBSD.org>
AuthorDate: Mon Aug 20 14:27:37 2018 +0000
Commit:     kp <kp@FreeBSD.org>
CommitDate: Mon Aug 20 14:27:37 2018 +0000

    MFC r337969:
    
    pf: Limit the maximum number of fragments per packet
    
    Similar to the network stack issue fixed in r337782 pf did not limit the number
    of fragments per packet, which could be exploited to generate high CPU loads
    with a crafted series of packets.
    
    Limit each packet to no more than 64 fragments. This should be sufficient on
    typical networks to allow maximum-sized IP frames.
    
    This addresses the issue for both IPv4 and IPv6.
    
    Security:       CVE-2018-5391
    Sponsored by:   Klara Systems

diff --git a/sys/netpfil/pf/pf_norm.c b/sys/netpfil/pf/pf_norm.c
index f54e0383629..93f2b771a9a 100644
--- a/sys/netpfil/pf/pf_norm.c
+++ b/sys/netpfil/pf/pf_norm.c
@@ -90,8 +90,10 @@ struct pf_fragment {
 	TAILQ_ENTRY(pf_fragment) frag_next;
 	uint32_t	fr_timeout;
 	uint16_t	fr_maxlen;	/* maximum length of single fragment */
+	uint16_t	fr_entries;	/* Total number of pf_fragment entries */
 	TAILQ_HEAD(pf_fragq, pf_frent) fr_queue;
 };
+#define PF_MAX_FRENT_PER_FRAGMENT	64
 
 struct pf_fragment_tag {
 	uint16_t	ft_hdrlen;	/* header length of reassembled pkt */
@@ -376,6 +378,7 @@ pf_fillup_fragment(struct pf_fragment_cmp *key, struct pf_frent *frent,
 		*(struct pf_fragment_cmp *)frag = *key;
 		frag->fr_timeout = time_uptime;
 		frag->fr_maxlen = frent->fe_len;
+		frag->fr_entries = 0;
 		TAILQ_INIT(&frag->fr_queue);
 
 		RB_INSERT(pf_frag_tree, &V_pf_frag_tree, frag);
@@ -387,6 +390,9 @@ pf_fillup_fragment(struct pf_fragment_cmp *key, struct pf_frent *frent,
 		return (frag);
 	}
 
+	if (frag->fr_entries >= PF_MAX_FRENT_PER_FRAGMENT)
+		goto bad_fragment;
+
 	KASSERT(!TAILQ_EMPTY(&frag->fr_queue), ("!TAILQ_EMPTY()->fr_queue"));
 
 	/* Remember maximum fragment len for refragmentation. */
@@ -459,6 +465,8 @@ pf_fillup_fragment(struct pf_fragment_cmp *key, struct pf_frent *frent,
 	else
 		TAILQ_INSERT_AFTER(&frag->fr_queue, prev, frent, fr_next);
 
+	frag->fr_entries++;
+
 	return (frag);
 
 bad_fragment:
