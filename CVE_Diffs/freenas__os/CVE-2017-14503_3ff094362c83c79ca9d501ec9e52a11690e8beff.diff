freenas__os
commit 3ff094362c83c79ca9d501ec9e52a11690e8beff
Author:     mm <mm@FreeBSD.org>
AuthorDate: Sun Aug 5 14:35:30 2018 +0000
Commit:     mm <mm@FreeBSD.org>
CommitDate: Sun Aug 5 14:35:30 2018 +0000

    MFH r336801,r336854:
    
    MFH r336801 (cem):
    Cherry-pick upstream 2c8c83b9
    
    Relevant vendor changes:
      Fix issue #948: out-of-bounds read in lha_read_data_none()
    
    MFH r336854:
    Sync libarchive with vendor.
    
    Important vendor changes:
      PR #993: Chdir to -C directory for metalog processing
      OSS-Fuzz #4969: Check size of the extended time field in zip archives
      PR #973: Record informational compression level in gzip header
    
    amdbugs:        877
    Security:       CVE-2017-14503

diff --git a/contrib/libarchive/cat/bsdcat.c b/contrib/libarchive/cat/bsdcat.c
index 9c91d09cc85..bdb9c40b915 100644
--- a/contrib/libarchive/cat/bsdcat.c
+++ b/contrib/libarchive/cat/bsdcat.c
@@ -61,7 +61,7 @@ usage(FILE *stream, int eval)
 static void
 version(void)
 {
-	printf("bsdcat %s - %s\n",
+	printf("bsdcat %s - %s \n",
 	    BSDCAT_VERSION_STRING,
 	    archive_version_details());
 	exit(0);
diff --git a/contrib/libarchive/cpio/cpio.c b/contrib/libarchive/cpio/cpio.c
index 8396f1f98ce..c201ac349ec 100644
--- a/contrib/libarchive/cpio/cpio.c
+++ b/contrib/libarchive/cpio/cpio.c
@@ -499,7 +499,7 @@ long_help(void)
 static void
 version(void)
 {
-	fprintf(stdout,"bsdcpio %s - %s\n",
+	fprintf(stdout,"bsdcpio %s - %s \n",
 	    BSDCPIO_VERSION_STRING,
 	    archive_version_details());
 	exit(0);
diff --git a/contrib/libarchive/libarchive/archive_entry.c b/contrib/libarchive/libarchive/archive_entry.c
index e2ac803cfff..9aaa4bea0ea 100644
--- a/contrib/libarchive/libarchive/archive_entry.c
+++ b/contrib/libarchive/libarchive/archive_entry.c
@@ -1491,7 +1491,7 @@ archive_entry_acl_next(struct archive_entry *entry, int want_type, int *type,
  * the style of the generated ACL.
  */
 wchar_t *
-archive_entry_acl_to_text_w(struct archive_entry *entry, ssize_t *len,
+archive_entry_acl_to_text_w(struct archive_entry *entry, la_ssize_t *len,
     int flags)
 {
 	return (archive_acl_to_text_w(&entry->acl, len, flags,
@@ -1499,7 +1499,7 @@ archive_entry_acl_to_text_w(struct archive_entry *entry, ssize_t *len,
 }
 
 char *
-archive_entry_acl_to_text(struct archive_entry *entry, ssize_t *len,
+archive_entry_acl_to_text(struct archive_entry *entry, la_ssize_t *len,
     int flags)
 {
 	return (archive_acl_to_text_l(&entry->acl, len, flags, NULL));
diff --git a/contrib/libarchive/libarchive/archive_entry.h b/contrib/libarchive/libarchive/archive_entry.h
index 793e2330e52..affde257983 100644
--- a/contrib/libarchive/libarchive/archive_entry.h
+++ b/contrib/libarchive/libarchive/archive_entry.h
@@ -42,6 +42,7 @@
 
 #include <sys/types.h>
 #include <stddef.h>  /* for wchar_t */
+#include <stdint.h>
 #include <time.h>
 
 #if defined(_WIN32) && !defined(__CYGWIN__)
diff --git a/contrib/libarchive/libarchive/archive_openssl_hmac_private.h b/contrib/libarchive/libarchive/archive_openssl_hmac_private.h
index 59f95b80af8..921249bb945 100644
--- a/contrib/libarchive/libarchive/archive_openssl_hmac_private.h
+++ b/contrib/libarchive/libarchive/archive_openssl_hmac_private.h
@@ -28,7 +28,8 @@
 #include <openssl/hmac.h>
 #include <openssl/opensslv.h>
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 #include <stdlib.h> /* malloc, free */
 #include <string.h> /* memset */
 static inline HMAC_CTX *HMAC_CTX_new(void)
diff --git a/contrib/libarchive/libarchive/archive_read.c b/contrib/libarchive/libarchive/archive_read.c
index 204403e2eec..76be1446334 100644
--- a/contrib/libarchive/libarchive/archive_read.c
+++ b/contrib/libarchive/libarchive/archive_read.c
@@ -821,7 +821,7 @@ archive_read_format_capabilities(struct archive *_a)
  * DO NOT intermingle calls to this function and archive_read_data_block
  * to read a single entry body.
  */
-ssize_t
+la_ssize_t
 archive_read_data(struct archive *_a, void *buff, size_t s)
 {
 	struct archive *a = (struct archive *)_a;
diff --git a/contrib/libarchive/libarchive/archive_read_support_format_lha.c b/contrib/libarchive/libarchive/archive_read_support_format_lha.c
index b8ef4ae10ec..95c99bb1f31 100644
--- a/contrib/libarchive/libarchive/archive_read_support_format_lha.c
+++ b/contrib/libarchive/libarchive/archive_read_support_format_lha.c
@@ -701,6 +701,12 @@ archive_read_format_lha_read_header(struct archive_read *a,
 	 * Prepare variables used to read a file content.
 	 */
 	lha->entry_bytes_remaining = lha->compsize;
+	if (lha->entry_bytes_remaining < 0) {
+		archive_set_error(&a->archive,
+		    ARCHIVE_ERRNO_FILE_FORMAT,
+		    "Invalid LHa entry size");
+		return (ARCHIVE_FATAL);
+	}
 	lha->entry_offset = 0;
 	lha->entry_crc_calculated = 0;
 
diff --git a/contrib/libarchive/libarchive/archive_read_support_format_mtree.c b/contrib/libarchive/libarchive/archive_read_support_format_mtree.c
index e3bf334cabb..7c0bbaf7801 100644
--- a/contrib/libarchive/libarchive/archive_read_support_format_mtree.c
+++ b/contrib/libarchive/libarchive/archive_read_support_format_mtree.c
@@ -49,6 +49,7 @@ __FBSDID("$FreeBSD$");
 #include "archive.h"
 #include "archive_entry.h"
 #include "archive_private.h"
+#include "archive_rb.h"
 #include "archive_read_private.h"
 #include "archive_string.h"
 #include "archive_pack_dev.h"
@@ -75,8 +76,6 @@ __FBSDID("$FreeBSD$");
 #define	MTREE_HAS_OPTIONAL	0x0800
 #define	MTREE_HAS_NOCHANGE	0x1000 /* FreeBSD specific */
 
-#define	MTREE_HASHTABLE_SIZE 1024
-
 #define	MAX_LINE_LEN		(1024 * 1024)
 
 struct mtree_option {
@@ -85,13 +84,13 @@ struct mtree_option {
 };
 
 struct mtree_entry {
+	struct archive_rb_node rbnode;
+	struct mtree_entry *next_dup;
 	struct mtree_entry *next;
 	struct mtree_option *options;
 	char *name;
 	char full;
 	char used;
-	unsigned int name_hash;
-	struct mtree_entry *hashtable_next;
 };
 
 struct mtree {
@@ -104,11 +103,12 @@ struct mtree {
 	const char		*archive_format_name;
 	struct mtree_entry	*entries;
 	struct mtree_entry	*this_entry;
-	struct mtree_entry	*entry_hashtable[MTREE_HASHTABLE_SIZE];
+	struct archive_rb_tree	 entry_rbtree;
 	struct archive_string	 current_dir;
 	struct archive_string	 contents_name;
 
 	struct archive_entry_linkresolver *resolver;
+	struct archive_rb_tree rbtree;
 
 	int64_t			 cur_size;
 	char checkfs;
@@ -117,7 +117,6 @@ struct mtree {
 static int	bid_keycmp(const char *, const char *, ssize_t);
 static int	cleanup(struct archive_read *);
 static int	detect_form(struct archive_read *, int *);
-static unsigned int	hash(const char *);
 static int	mtree_bid(struct archive_read *, int);
 static int	parse_file(struct archive_read *, struct archive_entry *,
 		    struct mtree *, struct mtree_entry *, int *);
@@ -219,9 +218,30 @@ free_options(struct mtree_option *head)
 	}
 }
 
+static int
+mtree_cmp_node(const struct archive_rb_node *n1,
+    const struct archive_rb_node *n2)
+{
+	const struct mtree_entry *e1 = (const struct mtree_entry *)n1;
+	const struct mtree_entry *e2 = (const struct mtree_entry *)n2;
+
+	return (strcmp(e1->name, e2->name));
+}
+
+static int
+mtree_cmp_key(const struct archive_rb_node *n, const void *key)
+{
+	const struct mtree_entry *e = (const struct mtree_entry *)n;
+
+	return (strcmp(e->name, key));
+}
+
 int
 archive_read_support_format_mtree(struct archive *_a)
 {
+	static const struct archive_rb_tree_ops rb_ops = {
+		mtree_cmp_node, mtree_cmp_key,
+	};
 	struct archive_read *a = (struct archive_read *)_a;
 	struct mtree *mtree;
 	int r;
@@ -237,6 +257,8 @@ archive_read_support_format_mtree(struct archive *_a)
 	}
 	mtree->fd = -1;
 
+	__archive_rb_tree_init(&mtree->rbtree, &rb_ops);
+
 	r = __archive_read_register_format(a, mtree, "mtree",
            mtree_bid, archive_read_format_mtree_options, read_header, read_data, skip, NULL, cleanup, NULL, NULL);
 
@@ -875,12 +897,11 @@ process_add_entry(struct archive_read *a, struct mtree *mtree,
     struct mtree_option **global, const char *line, ssize_t line_len,
     struct mtree_entry **last_entry, int is_form_d)
 {
-	struct mtree_entry *entry, *ht_iter;
+	struct mtree_entry *entry;
 	struct mtree_option *iter;
 	const char *next, *eq, *name, *end;
 	size_t name_len, len;
 	int r, i;
-	unsigned int ht_idx;
 
 	if ((entry = malloc(sizeof(*entry))) == NULL) {
 		archive_set_error(&a->archive, errno, "Can't allocate memory");
@@ -891,8 +912,6 @@ process_add_entry(struct archive_read *a, struct mtree *mtree,
 	entry->name = NULL;
 	entry->used = 0;
 	entry->full = 0;
-	entry->name_hash = 0;
-	entry->hashtable_next = NULL;
 
 	/* Add this entry to list. */
 	if (*last_entry == NULL)
@@ -945,15 +964,17 @@ process_add_entry(struct archive_read *a, struct mtree *mtree,
 	memcpy(entry->name, name, name_len);
 	entry->name[name_len] = '\0';
 	parse_escapes(entry->name, entry);
-	entry->name_hash = hash(entry->name);
 
-	ht_idx = entry->name_hash % MTREE_HASHTABLE_SIZE;
-	if ((ht_iter = mtree->entry_hashtable[ht_idx]) != NULL) {
-		while (ht_iter->hashtable_next)
-			ht_iter = ht_iter->hashtable_next;
-		ht_iter->hashtable_next = entry;
-	} else {
-		mtree->entry_hashtable[ht_idx] = entry;
+	entry->next_dup = NULL;
+	if (entry->full) {
+		if (!__archive_rb_tree_insert_node(&mtree->rbtree, &entry->rbnode)) {
+			struct mtree_entry *alt;
+			alt = (struct mtree_entry *)__archive_rb_tree_find_node(
+			    &mtree->rbtree, entry->name);
+			while (alt->next_dup)
+				alt = alt->next_dup;
+			alt->next_dup = entry;
+		}
 	}
 
 	for (iter = *global; iter != NULL; iter = iter->next) {
@@ -1148,14 +1169,13 @@ parse_file(struct archive_read *a, struct archive_entry *entry,
 		 * with pathname canonicalization, which is a very
 		 * tricky subject.)
 		 */
-		for (mp = mentry->hashtable_next; mp != NULL; mp = mp->hashtable_next) {
-			if (mp->full && !mp->used
-					&& mentry->name_hash == mp->name_hash
-					&& strcmp(mentry->name, mp->name) == 0) {
+		mp = (struct mtree_entry *)__archive_rb_tree_find_node(
+		    &mtree->rbtree, mentry->name);
+		for (; mp; mp = mp->next_dup) {
+			if (mp->full && !mp->used) {
 				/* Later lines override earlier ones. */
 				mp->used = 1;
-				r1 = parse_line(a, entry, mtree, mp,
-				    &parsed_kws);
+				r1 = parse_line(a, entry, mtree, mp, &parsed_kws);
 				if (r1 < r)
 					r = r1;
 			}
@@ -1989,19 +2009,3 @@ readline(struct archive_read *a, struct mtree *mtree, char **start,
 		find_off = u - mtree->line.s;
 	}
 }
-
-static unsigned int
-hash(const char *p)
-{
-	/* A 32-bit version of Peter Weinberger's (PJW) hash algorithm,
-	   as used by ELF for hashing function names. */
-	unsigned g, h = 0;
-	while (*p != '\0') {
-		h = (h << 4) + *p++;
-		if ((g = h & 0xF0000000) != 0) {
-			h ^= g >> 24;
-			h &= 0x0FFFFFFF;
-		}
-	}
-	return h;
-}
diff --git a/contrib/libarchive/libarchive/archive_read_support_format_zip.c b/contrib/libarchive/libarchive/archive_read_support_format_zip.c
index 490d4d590f8..1a540279242 100644
--- a/contrib/libarchive/libarchive/archive_read_support_format_zip.c
+++ b/contrib/libarchive/libarchive/archive_read_support_format_zip.c
@@ -511,7 +511,13 @@ process_extra(struct archive_read *a, const char *p, size_t extra_length, struct
 		case 0x5455:
 		{
 			/* Extended time field "UT". */
-			int flags = p[offset];
+			int flags;
+			if (datasize == 0) {
+				archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				    "Incomplete extended time field");
+				return ARCHIVE_FAILED;
+			}
+			flags = p[offset];
 			offset++;
 			datasize--;
 			/* Flag bits indicate which dates are present. */
diff --git a/contrib/libarchive/libarchive/archive_virtual.c b/contrib/libarchive/libarchive/archive_virtual.c
index 81d2481a0eb..ee663d6cfac 100644
--- a/contrib/libarchive/libarchive/archive_virtual.c
+++ b/contrib/libarchive/libarchive/archive_virtual.c
@@ -124,13 +124,13 @@ archive_write_finish_entry(struct archive *a)
 	return ((a->vtable->archive_write_finish_entry)(a));
 }
 
-ssize_t
+la_ssize_t
 archive_write_data(struct archive *a, const void *buff, size_t s)
 {
 	return ((a->vtable->archive_write_data)(a, buff, s));
 }
 
-ssize_t
+la_ssize_t
 archive_write_data_block(struct archive *a, const void *buff, size_t s,
     la_int64_t o)
 {
diff --git a/contrib/libarchive/libarchive/archive_write_add_filter_gzip.c b/contrib/libarchive/libarchive/archive_write_add_filter_gzip.c
index 04eb06c1c06..e4b3435e420 100644
--- a/contrib/libarchive/libarchive/archive_write_add_filter_gzip.c
+++ b/contrib/libarchive/libarchive/archive_write_add_filter_gzip.c
@@ -226,7 +226,12 @@ archive_compressor_gzip_open(struct archive_write_filter *f)
 		data->compressed[7] = (uint8_t)(t>>24)&0xff;
 	} else
 		memset(&data->compressed[4], 0, 4);
-	data->compressed[8] = 0; /* No deflate options */
+    if (data->compression_level == 9)
+	    data->compressed[8] = 2;
+    else if(data->compression_level == 1)
+	    data->compressed[8] = 4;
+    else
+	    data->compressed[8] = 0;
 	data->compressed[9] = 3; /* OS=Unix */
 	data->stream.next_out += 10;
 	data->stream.avail_out -= 10;
diff --git a/contrib/libarchive/libarchive/archive_write_set_format_ar.c b/contrib/libarchive/libarchive/archive_write_set_format_ar.c
index cbd02fafa3f..eab27682951 100644
--- a/contrib/libarchive/libarchive/archive_write_set_format_ar.c
+++ b/contrib/libarchive/libarchive/archive_write_set_format_ar.c
@@ -180,7 +180,7 @@ archive_write_ar_header(struct archive_write *a, struct archive_entry *entry)
 	}
 
 	memset(buff, ' ', 60);
-	strncpy(&buff[AR_fmag_offset], "`\n", 2);
+	memcpy(&buff[AR_fmag_offset], "`\n", 2);
 
 	if (strcmp(pathname, "/") == 0 ) {
 		/* Entry is archive symbol table in GNU format */
@@ -189,7 +189,7 @@ archive_write_ar_header(struct archive_write *a, struct archive_entry *entry)
 	}
 	if (strcmp(pathname, "__.SYMDEF") == 0) {
 		/* Entry is archive symbol table in BSD format */
-		strncpy(buff + AR_name_offset, "__.SYMDEF", 9);
+		memcpy(buff + AR_name_offset, "__.SYMDEF", 9);
 		goto stat;
 	}
 	if (strcmp(pathname, "//") == 0) {
@@ -225,7 +225,7 @@ archive_write_ar_header(struct archive_write *a, struct archive_entry *entry)
 		 * actually 15 bytes.
 		 */
 		if (strlen(filename) <= 15) {
-			strncpy(&buff[AR_name_offset], 
+			memcpy(&buff[AR_name_offset],
 			    filename, strlen(filename));
 			buff[AR_name_offset + strlen(filename)] = '/';
 		} else {
@@ -248,7 +248,7 @@ archive_write_ar_header(struct archive_write *a, struct archive_entry *entry)
 				return (ARCHIVE_FATAL);
 			}
 
-			strncpy(se, filename, strlen(filename));
+			memcpy(se, filename, strlen(filename));
 			strcpy(se + strlen(filename), "/\n");
 
 			ss = strstr(ar->strtab, se);
@@ -285,11 +285,11 @@ archive_write_ar_header(struct archive_write *a, struct archive_entry *entry)
 		 * archive header.
 		 */
 		if (strlen(filename) <= 16 && strchr(filename, ' ') == NULL) {
-			strncpy(&buff[AR_name_offset], filename, strlen(filename));
+			memcpy(&buff[AR_name_offset], filename, strlen(filename));
 			buff[AR_name_offset + strlen(filename)] = ' ';
 		}
 		else {
-			strncpy(buff + AR_name_offset, "#1/", 3);
+			memcpy(buff + AR_name_offset, "#1/", 3);
 			if (format_decimal(strlen(filename),
 			    buff + AR_name_offset + 3,
 			    AR_name_size - 3)) {
diff --git a/contrib/libarchive/libarchive/test/test_sparse_basic.c b/contrib/libarchive/libarchive/test/test_sparse_basic.c
index 9d45f0fedc1..58d53a94e07 100644
--- a/contrib/libarchive/libarchive/test/test_sparse_basic.c
+++ b/contrib/libarchive/libarchive/test/test_sparse_basic.c
@@ -118,13 +118,26 @@ create_sparse_file(const char *path, const struct sparse *s)
 	assert(handle != INVALID_HANDLE_VALUE);
 	assert(DeviceIoControl(handle, FSCTL_SET_SPARSE, NULL, 0,
 	    NULL, 0, &dmy, NULL) != 0);
+
+	size_t offsetSoFar = 0;
+
 	while (s->type != END) {
 		if (s->type == HOLE) {
-			LARGE_INTEGER distance;
-
-			distance.QuadPart = s->size;
-			assert(SetFilePointerEx(handle, distance,
-			    NULL, FILE_CURRENT) != 0);
+			LARGE_INTEGER fileOffset, beyondOffset, distanceToMove;
+			fileOffset.QuadPart = offsetSoFar;
+			beyondOffset.QuadPart = offsetSoFar + s->size;
+			distanceToMove.QuadPart = s->size;
+
+			FILE_ZERO_DATA_INFORMATION zeroInformation;
+			zeroInformation.FileOffset = fileOffset;
+			zeroInformation.BeyondFinalZero = beyondOffset;
+
+			DWORD bytesReturned;
+			assert(SetFilePointerEx(handle, distanceToMove,
+				NULL, FILE_CURRENT) != 0);
+			assert(SetEndOfFile(handle) != 0);
+			assert(DeviceIoControl(handle, FSCTL_SET_ZERO_DATA, &zeroInformation,
+				sizeof(FILE_ZERO_DATA_INFORMATION), NULL, 0, &bytesReturned, NULL) != 0);
 		} else {
 			DWORD w, wr;
 			size_t size;
@@ -139,6 +152,7 @@ create_sparse_file(const char *path, const struct sparse *s)
 				size -= wr;
 			}
 		}
+		offsetSoFar += s->size;
 		s++;
 	}
 	assertEqualInt(CloseHandle(handle), 1);
@@ -484,10 +498,15 @@ DEFINE_TEST(test_sparse_basic)
 	 * on all platform.
 	 */
 	const struct sparse sparse_file0[] = {
+		// 0             // 1024
 		{ DATA,	 1024 }, { HOLE,   2048000 },
+		// 2049024       // 2051072
 		{ DATA,	 2048 }, { HOLE,   2048000 },
+		// 4099072       // 4103168
 		{ DATA,	 4096 }, { HOLE,  20480000 },
+		// 24583168      // 24591360
 		{ DATA,	 8192 }, { HOLE, 204800000 },
+		// 229391360     // 229391361
 		{ DATA,     1 }, { END,	0 }
 	};
 	const struct sparse sparse_file1[] = {
diff --git a/contrib/libarchive/libarchive/test/test_write_filter_gzip.c b/contrib/libarchive/libarchive/test/test_write_filter_gzip.c
index 7bbdb1232a9..935fb51f514 100644
--- a/contrib/libarchive/libarchive/test/test_write_filter_gzip.c
+++ b/contrib/libarchive/libarchive/test/test_write_filter_gzip.c
@@ -39,6 +39,7 @@ DEFINE_TEST(test_write_filter_gzip)
 	struct archive* a;
 	char *buff, *data;
 	size_t buffsize, datasize;
+	unsigned char *rbuff;
 	char path[16];
 	size_t used1, used2;
 	int i, r, use_prog = 0;
@@ -58,6 +59,7 @@ DEFINE_TEST(test_write_filter_gzip)
 
 	/*
 	 * Write a 100 files and read them all back.
+	 * Use default compression level (6).
 	 */
 	assert((a = archive_write_new()) != NULL);
 	assertEqualIntA(a, ARCHIVE_OK, archive_write_set_format_ustar(a));
@@ -93,6 +95,14 @@ DEFINE_TEST(test_write_filter_gzip)
 	assertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));
 	assertEqualInt(ARCHIVE_OK, archive_write_free(a));
 
+	/* Basic gzip header tests */
+	rbuff = (unsigned char *)buff;
+	assertEqualInt(rbuff[0], 0x1f);
+	assertEqualInt(rbuff[1], 0x8b);
+	assertEqualInt(rbuff[2], 0x08);
+	assertEqualInt(rbuff[3], 0x00);
+	assertEqualInt(rbuff[8], 0); /* RFC 1952 flag for compression level 6 */
+
 	assert((a = archive_read_new()) != NULL);
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
 	r = archive_read_support_filter_gzip(a);
@@ -116,7 +126,7 @@ DEFINE_TEST(test_write_filter_gzip)
 
 	/*
 	 * Repeat the cycle again, this time setting some compression
-	 * options.
+	 * options. Compression level is 9.
 	 */
 	assert((a = archive_write_new()) != NULL);
 	assertEqualIntA(a, ARCHIVE_OK, archive_write_set_format_ustar(a));
@@ -150,6 +160,14 @@ DEFINE_TEST(test_write_filter_gzip)
 	assertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));
 	assertEqualInt(ARCHIVE_OK, archive_write_free(a));
 
+	/* Basic gzip header tests */
+	rbuff = (unsigned char *)buff;
+	assertEqualInt(rbuff[0], 0x1f);
+	assertEqualInt(rbuff[1], 0x8b);
+	assertEqualInt(rbuff[2], 0x08);
+	assertEqualInt(rbuff[3], 0x00);
+	assertEqualInt(rbuff[8], 2); /* RFC 1952 flag for compression level 9 */
+
 	/* Curiously, this test fails; the test data above compresses
 	 * better at default compression than at level 9. */
 	/*
@@ -181,7 +199,7 @@ DEFINE_TEST(test_write_filter_gzip)
 	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
 
 	/*
-	 * Repeat again, with much lower compression.
+	 * Repeat again, with compression level 1
 	 */
 	assert((a = archive_write_new()) != NULL);
 	assertEqualIntA(a, ARCHIVE_OK, archive_write_set_format_ustar(a));
@@ -213,6 +231,14 @@ DEFINE_TEST(test_write_filter_gzip)
 	    (int)used2, (int)used1);
 	assert(used2 > used1);
 
+	/* Basic gzip header tests */
+	rbuff = (unsigned char *)buff;
+	assertEqualInt(rbuff[0], 0x1f);
+	assertEqualInt(rbuff[1], 0x8b);
+	assertEqualInt(rbuff[2], 0x08);
+	assertEqualInt(rbuff[3], 0x00);
+	assertEqualInt(rbuff[8], 4); /* RFC 1952 flag for compression level 1 */
+
 	assert((a = archive_read_new()) != NULL);
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
 	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_all(a));
diff --git a/contrib/libarchive/libarchive/test/test_write_filter_zstd.c b/contrib/libarchive/libarchive/test/test_write_filter_zstd.c
index 5637aa5e29b..da3c806671a 100644
--- a/contrib/libarchive/libarchive/test/test_write_filter_zstd.c
+++ b/contrib/libarchive/libarchive/test/test_write_filter_zstd.c
@@ -125,7 +125,7 @@ DEFINE_TEST(test_write_filter_zstd)
 	assertEqualIntA(a, ARCHIVE_OK,
 	    archive_write_set_filter_option(a, NULL, "compression-level", "9"));
 	assertEqualIntA(a, ARCHIVE_OK,
-	    archive_write_set_filter_option(a, NULL, "compression-level", "15"));
+	    archive_write_set_filter_option(a, NULL, "compression-level", "6"));
 	assertEqualIntA(a, ARCHIVE_OK, archive_write_open_memory(a, buff, buffsize, &used2));
 	for (i = 0; i < 100; i++) {
 		sprintf(path, "file%03d", i);
@@ -140,7 +140,7 @@ DEFINE_TEST(test_write_filter_zstd)
 	assertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));
 	assertEqualInt(ARCHIVE_OK, archive_write_free(a));
 
-	failure("compression-level=15 wrote %d bytes, default wrote %d bytes",
+	failure("compression-level=6 wrote %d bytes, default wrote %d bytes",
 	    (int)used2, (int)used1);
 	assert(used2 < used1);
 
diff --git a/contrib/libarchive/tar/bsdtar.c b/contrib/libarchive/tar/bsdtar.c
index e22e1d27285..23636eec923 100644
--- a/contrib/libarchive/tar/bsdtar.c
+++ b/contrib/libarchive/tar/bsdtar.c
@@ -920,7 +920,7 @@ usage(void)
 static void
 version(void)
 {
-	printf("bsdtar %s - %s\n",
+	printf("bsdtar %s - %s \n",
 	    BSDTAR_VERSION_STRING,
 	    archive_version_details());
 	exit(0);
diff --git a/contrib/libarchive/tar/test/test_option_C_mtree.c b/contrib/libarchive/tar/test/test_option_C_mtree.c
new file mode 100644
index 00000000000..caf8044bf93
--- /dev/null
+++ b/contrib/libarchive/tar/test/test_option_C_mtree.c
@@ -0,0 +1,73 @@
+/*-
+ * Copyright (c) 2018 The FreeBSD Foundation
+ * All rights reserved.
+ * 
+ * This software was developed by Arshan Khanifar <arshankhanifar@gmail.com>
+ * under sponsorship from the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "test.h"
+__FBSDID("$FreeBSD$");
+
+DEFINE_TEST(test_option_C_mtree)
+{
+	char *p0;
+	size_t s;
+	int r;
+	p0 = NULL;
+	char *content = "./foo type=file uname=root gname=root mode=0755\n";
+	char *filename = "output.tar";
+
+	/* an absolute path to mtree file */ 
+	char *mtree_file = "/METALOG.mtree";	
+	char *absolute_path = malloc(strlen(testworkdir) + strlen(mtree_file) + 1);
+	strcpy(absolute_path, testworkdir);
+	strcat(absolute_path, mtree_file );
+	
+	/* Create an archive using an mtree file. */
+	assertMakeFile(absolute_path, 0777, content);
+	assertMakeDir("bar", 0775);
+	assertMakeFile("bar/foo", 0777, "abc");
+
+	r = systemf("%s -cf %s -C bar \"@%s\" >step1.out 2>step1.err", testprog, filename, absolute_path);
+
+	failure("Error invoking %s -cf %s -C bar @%s", testprog, filename, absolute_path);
+	assertEqualInt(r, 0);
+	assertEmptyFile("step1.out");
+	assertEmptyFile("step1.err");
+
+	/* Do validation of the constructed archive. */
+
+	p0 = slurpfile(&s, "output.tar");
+	if (!assert(p0 != NULL))
+		goto done;
+	if (!assert(s >= 2048))
+		goto done;
+	assertEqualMem(p0 + 0, "./foo", 5);
+	assertEqualMem(p0 + 512, "abc", 3);
+	assertEqualMem(p0 + 1024, "\0\0\0\0\0\0\0\0", 8);
+	assertEqualMem(p0 + 1536, "\0\0\0\0\0\0\0\0", 8);
+done:
+	free(p0);
+}
+
+
diff --git a/contrib/libarchive/tar/test/test_option_fflags.c b/contrib/libarchive/tar/test/test_option_fflags.c
index 77a4e3e19f0..f223feb1906 100644
--- a/contrib/libarchive/tar/test/test_option_fflags.c
+++ b/contrib/libarchive/tar/test/test_option_fflags.c
@@ -25,6 +25,10 @@
 #include "test.h"
 __FBSDID("$FreeBSD$");
 
+#if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__BORLANDC__)
+#define chmod _chmod
+#endif
+
 static void
 clear_fflags(const char *pathname)
 {
diff --git a/contrib/libarchive/tar/write.c b/contrib/libarchive/tar/write.c
index 4c9bb65c85f..ccd47c41ed0 100644
--- a/contrib/libarchive/tar/write.c
+++ b/contrib/libarchive/tar/write.c
@@ -503,7 +503,7 @@ write_archive(struct archive *a, struct bsdtar *bsdtar)
 			}
 			set_chdir(bsdtar, arg);
 		} else {
-			if (*arg != '/' && (arg[0] != '@' || arg[1] != '/'))
+			if (*arg != '/')
 				do_chdir(bsdtar); /* Handle a deferred -C */
 			if (*arg == '@') {
 				if (append_archive_filename(bsdtar, a,
diff --git a/contrib/libarchive/test_utils/test_main.c b/contrib/libarchive/test_utils/test_main.c
index 2bed99462a7..028b4a67902 100644
--- a/contrib/libarchive/test_utils/test_main.c
+++ b/contrib/libarchive/test_utils/test_main.c
@@ -2115,7 +2115,7 @@ void assertVersion(const char *prog, const char *base)
 	int r;
 	char *p, *q;
 	size_t s;
-	unsigned int prog_len = strlen(base);
+	size_t prog_len = strlen(base);
 
 	r = systemf("%s --version >version.stdout 2>version.stderr", prog);
 	if (r != 0)
diff --git a/usr.bin/tar/tests/Makefile b/usr.bin/tar/tests/Makefile
index 7fba6e077f9..60344d8e109 100644
--- a/usr.bin/tar/tests/Makefile
+++ b/usr.bin/tar/tests/Makefile
@@ -40,6 +40,7 @@ TESTS_SRCS=	\
 	test_help.c				\
 	test_leading_slash.c			\
 	test_missing_file.c			\
+	test_option_C_mtree.c			\
 	test_option_C_upper.c			\
 	test_option_H_upper.c			\
 	test_option_L_upper.c			\
