freenas__os
commit 282d17bf4b021cbee621d435f9b0f2722208585c
Author:     kp <kp@FreeBSD.org>
AuthorDate: Fri Aug 17 15:00:10 2018 +0000
Commit:     kp <kp@FreeBSD.org>
CommitDate: Fri Aug 17 15:00:10 2018 +0000

    pf: Limit the maximum number of fragments per packet
    
    Similar to the network stack issue fixed in r337782 pf did not limit the number
    of fragments per packet, which could be exploited to generate high CPU loads
    with a crafted series of packets.
    
    Limit each packet to no more than 64 fragments. This should be sufficient on
    typical networks to allow maximum-sized IP frames.
    
    This addresses the issue for both IPv4 and IPv6.
    
    MFC after:      3 days
    Security:       CVE-2018-5391
    Sponsored by:   Klara Systems

diff --git a/sys/netpfil/pf/pf_norm.c b/sys/netpfil/pf/pf_norm.c
index 5e8598e9758..f5ef31de06a 100644
--- a/sys/netpfil/pf/pf_norm.c
+++ b/sys/netpfil/pf/pf_norm.c
@@ -91,8 +91,10 @@ struct pf_fragment {
 	TAILQ_ENTRY(pf_fragment) frag_next;
 	uint32_t	fr_timeout;
 	uint16_t	fr_maxlen;	/* maximum length of single fragment */
+	uint16_t	fr_entries;	/* Total number of pf_fragment entries */
 	TAILQ_HEAD(pf_fragq, pf_frent) fr_queue;
 };
+#define PF_MAX_FRENT_PER_FRAGMENT	64
 
 struct pf_fragment_tag {
 	uint16_t	ft_hdrlen;	/* header length of reassembled pkt */
@@ -384,6 +386,7 @@ pf_fillup_fragment(struct pf_fragment_cmp *key, struct pf_frent *frent,
 		*(struct pf_fragment_cmp *)frag = *key;
 		frag->fr_timeout = time_uptime;
 		frag->fr_maxlen = frent->fe_len;
+		frag->fr_entries = 0;
 		TAILQ_INIT(&frag->fr_queue);
 
 		RB_INSERT(pf_frag_tree, &V_pf_frag_tree, frag);
@@ -395,6 +398,9 @@ pf_fillup_fragment(struct pf_fragment_cmp *key, struct pf_frent *frent,
 		return (frag);
 	}
 
+	if (frag->fr_entries >= PF_MAX_FRENT_PER_FRAGMENT)
+		goto bad_fragment;
+
 	KASSERT(!TAILQ_EMPTY(&frag->fr_queue), ("!TAILQ_EMPTY()->fr_queue"));
 
 	/* Remember maximum fragment len for refragmentation. */
@@ -467,6 +473,8 @@ pf_fillup_fragment(struct pf_fragment_cmp *key, struct pf_frent *frent,
 	else
 		TAILQ_INSERT_AFTER(&frag->fr_queue, prev, frent, fr_next);
 
+	frag->fr_entries++;
+
 	return (frag);
 
 bad_fragment:
