freenas__os
commit 7b79756a3316a1596697ebd819de83a3262c49a4
Author:     bz <bz@ccf9f872-aa2e-dd11-9fc8-001c23d0bc1f>
AuthorDate: Fri Apr 1 14:13:49 2011 +0000
Commit:     bz <bz@ccf9f872-aa2e-dd11-9fc8-001c23d0bc1f>
CommitDate: Fri Apr 1 14:13:49 2011 +0000

    Do not allow recursive RFC3173 IPComp payload.
    
    Reviewed by:    Tavis Ormandy (taviso cmpxchg8b.com)
    MFC after:      5 days
    Security:       CVE-2011-1547
    
    
    git-svn-id: svn+ssh://svn.freebsd.org/base/head@220247 ccf9f872-aa2e-dd11-9fc8-001c23d0bc1f

diff --git a/sys/netipsec/xform_ipcomp.c b/sys/netipsec/xform_ipcomp.c
index 5b2032a31cd..41381e7dbc2 100644
--- a/sys/netipsec/xform_ipcomp.c
+++ b/sys/netipsec/xform_ipcomp.c
@@ -142,8 +142,29 @@ ipcomp_input(struct mbuf *m, struct secasvar *sav, int skip, int protoff)
 	struct tdb_crypto *tc;
 	struct cryptodesc *crdc;
 	struct cryptop *crp;
+	struct ipcomp *ipcomp;
+	caddr_t addr;
 	int hlen = IPCOMP_HLENGTH;
 
+	/*
+	 * Check that the next header of the IPComp is not IPComp again, before
+	 * doing any real work.  Given it is not possible to do double
+	 * compression it means someone is playing tricks on us.
+	 */
+	if (m->m_len < skip + hlen && (m = m_pullup(m, skip + hlen)) == NULL) {
+		V_ipcompstat.ipcomps_hdrops++;		/*XXX*/
+		DPRINTF(("%s: m_pullup failed\n", __func__));
+		return (ENOBUFS);
+	}
+	addr = (caddr_t) mtod(m, struct ip *) + skip;
+	ipcomp = (struct ipcomp *)addr;
+	if (ipcomp->comp_nxt == IPPROTO_IPCOMP) {
+		m_freem(m);
+		V_ipcompstat.ipcomps_pdrops++;	/* XXX have our own stats? */
+		DPRINTF(("%s: recursive compression detected\n", __func__));
+		return (EINVAL);
+	}
+
 	/* Get crypto descriptors */
 	crp = crypto_getreq(1);
 	if (crp == NULL) {
