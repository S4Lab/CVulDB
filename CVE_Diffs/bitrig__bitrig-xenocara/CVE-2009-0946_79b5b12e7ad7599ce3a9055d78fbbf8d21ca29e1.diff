bitrig__bitrig-xenocara
commit 79b5b12e7ad7599ce3a9055d78fbbf8d21ca29e1
Author:     matthieu <matthieu@cvs.openbsd.org>
AuthorDate: Mon Apr 27 07:11:18 2009 +0000
Commit:     matthieu <matthieu@cvs.openbsd.org>
CommitDate: Mon Apr 27 07:11:18 2009 +0000

    Fixes for CVE-2009-0946 from freetype2 git repository:
    Multiple integer overflows in FreeType 2.3.9 and earlier allow remote
    attackers to execute arbitrary code via vectors related to large values
    in certain inputs in (1) smooth/ftsmooth.c, (2) sfnt/ttcmap.c,
    and (3) cff/cffload.c.
    Plus one additional fix for malformed compressed data.

diff --git a/lib/freetype/ChangeLog b/lib/freetype/ChangeLog
index f33d64306..54e839c42 100644
--- a/lib/freetype/ChangeLog
+++ b/lib/freetype/ChangeLog
@@ -1,3 +1,37 @@
+2009-03-20  Werner Lemberg  <wl@gnu.org>
+	    Tavis Ormandy <taviso@google.com>
+
+	Fix validation for various cmap table formats.
+
+	* src/sfnt/ttcmap.c (tt_cmap8_validate, tt_cmap10_validate,
+	tt_cmap12_validate): Check `length' correctly.
+	(tt_cmap_14_validate): Check `length' and `numMappings' correctly.
+
+2009-03-20  Werner Lemberg  <wl@gnu.org>
+
+	Protect against too large glyphs.
+
+	Problem reported by Tavis Ormandy <taviso@google.com>.
+
+	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Don't allow
+	`width' or `pitch' to be larger than 0xFFFF.
+
+2009-03-20  Werner Lemberg  <wl@gnu.org>
+
+	Protect against malformed compressed data.
+
+	* src/lsw/ftzopen.c (ft_lzwstate_io): Test whether `state->prefix' is
+	zero.
+
+2009-03-20  Werner Lemberg  <wl@gnu.org>
+
+	Protect against invalid SID values in CFFs.
+
+	Problem reported by Tavis Ormandy <taviso@google.com>.
+
+	* src/cff/cffload.c (cff_charset_load): Reject SID values larger
+	than 64999.
+
 2009-03-12  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.3.9 released.
diff --git a/lib/freetype/src/cff/cffload.c b/lib/freetype/src/cff/cffload.c
index 22163fb75..24b899d17 100644
--- a/lib/freetype/src/cff/cffload.c
+++ b/lib/freetype/src/cff/cffload.c
@@ -842,7 +842,20 @@
             goto Exit;
 
           for ( j = 1; j < num_glyphs; j++ )
-            charset->sids[j] = FT_GET_USHORT();
+          {
+            FT_UShort sid = FT_GET_USHORT();
+
+
+            /* this constant is given in the CFF specification */
+            if ( sid < 65000 )
+              charset->sids[j] = sid;
+            else
+            {
+              FT_ERROR(( "cff_charset_load:"
+                         " invalid SID value %d set to zero\n", sid ));
+              charset->sids[j] = 0;
+            }
+          }
 
           FT_FRAME_EXIT();
         }
@@ -875,6 +888,20 @@
                 goto Exit;
             }
 
+            /* check whether the range contains at least one valid glyph; */
+            /* the constant is given in the CFF specification             */
+            if ( glyph_sid >= 65000 ) {
+              FT_ERROR(( "cff_charset_load: invalid SID range\n" ));
+              error = CFF_Err_Invalid_File_Format;
+              goto Exit;
+            }
+
+            /* try to rescue some of the SIDs if `nleft' is too large */
+            if ( nleft > 65000 - 1 || glyph_sid >= 65000 - nleft ) {
+              FT_ERROR(( "cff_charset_load: invalid SID range trimmed\n" ));
+              nleft = 65000 - 1 - glyph_sid;
+            }
+
             /* Fill in the range of sids -- `nleft + 1' glyphs. */
             for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )
               charset->sids[j] = glyph_sid;
diff --git a/lib/freetype/src/lzw/ftzopen.c b/lib/freetype/src/lzw/ftzopen.c
index a9d25c5fa..c0483de62 100644
--- a/lib/freetype/src/lzw/ftzopen.c
+++ b/lib/freetype/src/lzw/ftzopen.c
@@ -8,7 +8,7 @@
 /*  be used to parse compressed PCF fonts, as found with many X11 server   */
 /*  distributions.                                                         */
 /*                                                                         */
-/*  Copyright 2005, 2006 by David Turner.                                  */
+/*  Copyright 2005, 2006, 2007 by David Turner.                            */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
 /*  modified, and distributed under the terms of the FreeType project      */
@@ -23,55 +23,84 @@
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_DEBUG_H
 
-  /* refill input buffer, return 0 on success, or -1 if eof */
+
   static int
   ft_lzwstate_refill( FT_LzwState  state )
   {
-    int  result = -1;
+    FT_ULong  count;
 
 
-    if ( !state->in_eof )
-    {
-      FT_ULong  count = FT_Stream_TryRead( state->source,
-                                           state->in_buff,
-                                           sizeof ( state->in_buff ) );
+    if ( state->in_eof )
+      return -1;
 
-      state->in_cursor = state->in_buff;
-      state->in_limit  = state->in_buff + count;
-      state->in_eof    = FT_BOOL( count < sizeof ( state->in_buff ) );
+    count = FT_Stream_TryRead( state->source,
+                               state->buf_tab,
+                               state->num_bits );  /* WHY? */
 
-      if ( count > 0 )
-        result = 0;
-    }
-    return result;
+    state->buf_size   = (FT_UInt)count;
+    state->buf_total += count;
+    state->in_eof     = FT_BOOL( count < state->num_bits );
+    state->buf_offset = 0;
+    state->buf_size   = ( state->buf_size << 3 ) - ( state->num_bits - 1 );
+
+    if ( count == 0 )  /* end of file */
+      return -1;
+
+    return 0;
   }
 
 
-  /* return new code of 'num_bits', or -1 if eof */
   static FT_Int32
-  ft_lzwstate_get_code( FT_LzwState  state,
-                        FT_UInt      num_bits )
+  ft_lzwstate_get_code( FT_LzwState  state )
   {
-    FT_Int32   result   = -1;
-    FT_UInt32  pad      = state->pad;
-    FT_UInt    pad_bits = state->pad_bits;
+    FT_UInt   num_bits = state->num_bits;
+    FT_Int    offset   = state->buf_offset;
+    FT_Byte*  p;
+    FT_Int    result;
 
 
-    while ( num_bits > pad_bits )
+    if ( state->buf_clear                    ||
+         offset >= state->buf_size           ||
+         state->free_ent >= state->free_bits )
     {
-      if ( state->in_cursor >= state->in_limit &&
-           ft_lzwstate_refill( state ) < 0     )
-        goto Exit;
+      if ( state->free_ent >= state->free_bits )
+      {
+        state->num_bits  = ++num_bits;
+        state->free_bits = state->num_bits < state->max_bits
+                           ? (FT_UInt)( ( 1UL << num_bits ) - 256 )
+                           : state->max_free + 1;
+      }
+
+      if ( state->buf_clear )
+      {
+        state->num_bits  = num_bits = LZW_INIT_BITS;
+        state->free_bits = (FT_UInt)( ( 1UL << num_bits ) - 256 );
+        state->buf_clear = 0;
+      }
+
+      if ( ft_lzwstate_refill( state ) < 0 )
+        return -1;
 
-      pad      |= (FT_UInt32)(*state->in_cursor++) << pad_bits;
-      pad_bits += 8;
+      offset = 0;
     }
 
-    result          = (FT_Int32)( pad & LZW_MASK( num_bits ) );
-    state->pad_bits = pad_bits - num_bits;
-    state->pad      = pad >> num_bits;
+    state->buf_offset = offset + num_bits;
+
+    p         = &state->buf_tab[offset >> 3];
+    offset   &= 7;
+    result    = *p++ >> offset;
+    offset    = 8 - offset;
+    num_bits -= offset;
+
+    if ( num_bits >= 8 )
+    {
+      result   |= *p++ << offset;
+      offset   += 8;
+      num_bits -= 8;
+    }
+    if ( num_bits > 0 )
+      result |= ( *p & LZW_MASK( num_bits ) ) << offset;
 
-  Exit:
     return result;
   }
 
@@ -146,15 +175,14 @@
   FT_LOCAL_DEF( void )
   ft_lzwstate_reset( FT_LzwState  state )
   {
-    state->in_cursor = state->in_buff;
-    state->in_limit  = state->in_buff;
-    state->in_eof    = 0;
-    state->pad_bits  = 0;
-    state->pad       = 0;
-
-    state->stack_top = 0;
-    state->num_bits  = LZW_INIT_BITS;
-    state->phase     = FT_LZW_PHASE_START;
+    state->in_eof     = 0;
+    state->buf_offset = 0;
+    state->buf_size   = 0;
+    state->buf_clear  = 0;
+    state->buf_total  = 0;
+    state->stack_top  = 0;
+    state->num_bits   = LZW_INIT_BITS;
+    state->phase      = FT_LZW_PHASE_START;
   }
 
 
@@ -196,13 +224,13 @@
   }
 
 
-#define FTLZW_STACK_PUSH( c )                          \
-  FT_BEGIN_STMNT                                       \
-    if ( state->stack_top >= state->stack_size &&      \
-         ft_lzwstate_stack_grow( state ) < 0   )       \
-      goto Eof;                                        \
-                                                       \
-    state->stack[ state->stack_top++ ] = (FT_Byte)(c); \
+#define FTLZW_STACK_PUSH( c )                        \
+  FT_BEGIN_STMNT                                     \
+    if ( state->stack_top >= state->stack_size &&    \
+         ft_lzwstate_stack_grow( state ) < 0   )     \
+      goto Eof;                                      \
+                                                     \
+    state->stack[state->stack_top++] = (FT_Byte)(c); \
   FT_END_STMNT
 
 
@@ -213,8 +241,6 @@
   {
     FT_ULong  result = 0;
 
-    FT_UInt  num_bits = state->num_bits;
-    FT_UInt  free_ent = state->free_ent;
     FT_UInt  old_char = state->old_char;
     FT_UInt  old_code = state->old_code;
     FT_UInt  in_code  = state->in_code;
@@ -243,15 +269,16 @@
         if ( state->max_bits > LZW_MAX_BITS )
           goto Eof;
 
-        num_bits = LZW_INIT_BITS;
-        free_ent = ( state->block_mode ? LZW_FIRST : LZW_CLEAR ) - 256;
+        state->num_bits = LZW_INIT_BITS;
+        state->free_ent = ( state->block_mode ? LZW_FIRST
+                                              : LZW_CLEAR ) - 256;
         in_code  = 0;
 
-        state->free_bits = num_bits < state->max_bits
-                           ? (FT_UInt)( ( 1UL << num_bits ) - 256 )
+        state->free_bits = state->num_bits < state->max_bits
+                           ? (FT_UInt)( ( 1UL << state->num_bits ) - 256 )
                            : state->max_free + 1;
 
-        c = ft_lzwstate_get_code( state, num_bits );
+        c = ft_lzwstate_get_code( state );
         if ( c < 0 )
           goto Eof;
 
@@ -274,7 +301,7 @@
 
 
       NextCode:
-        c = ft_lzwstate_get_code( state, num_bits );
+        c = ft_lzwstate_get_code( state );
         if ( c < 0 )
           goto Eof;
 
@@ -282,14 +309,10 @@
 
         if ( code == LZW_CLEAR && state->block_mode )
         {
-          free_ent = ( LZW_FIRST - 1 ) - 256; /* why not LZW_FIRST-256 ? */
-          num_bits = LZW_INIT_BITS;
-
-          state->free_bits = num_bits < state->max_bits
-                             ? (FT_UInt)( ( 1UL << num_bits ) - 256 )
-                             : state->max_free + 1;
-
-          c = ft_lzwstate_get_code( state, num_bits );
+          /* why not LZW_FIRST-256 ? */
+          state->free_ent  = ( LZW_FIRST - 1 ) - 256;
+          state->buf_clear = 1;
+          c = ft_lzwstate_get_code( state );
           if ( c < 0 )
             goto Eof;
 
@@ -301,7 +324,7 @@
         if ( code >= 256U )
         {
           /* special case for KwKwKwK */
-          if ( code - 256U >= free_ent )
+          if ( code - 256U >= state->free_ent )
           {
             FTLZW_STACK_PUSH( old_char );
             code = old_code;
@@ -309,6 +332,9 @@
 
           while ( code >= 256U )
           {
+            if ( !state->prefix )
+              goto Eof;
+
             FTLZW_STACK_PUSH( state->suffix[code - 256] );
             code = state->prefix[code - 256];
           }
@@ -335,25 +361,18 @@
         }
 
         /* now create new entry */
-        if ( free_ent < state->max_free )
+        if ( state->free_ent < state->max_free )
         {
-          if ( free_ent >= state->prefix_size       &&
-               ft_lzwstate_prefix_grow( state ) < 0 )
+          if ( state->free_ent >= state->prefix_size &&
+               ft_lzwstate_prefix_grow( state ) < 0  )
             goto Eof;
 
-          FT_ASSERT( free_ent < state->prefix_size );
+          FT_ASSERT( state->free_ent < state->prefix_size );
 
-          state->prefix[free_ent] = (FT_UShort)old_code;
-          state->suffix[free_ent] = (FT_Byte)  old_char;
+          state->prefix[state->free_ent] = (FT_UShort)old_code;
+          state->suffix[state->free_ent] = (FT_Byte)  old_char;
 
-          if ( ++free_ent == state->free_bits )
-          {
-            num_bits++;
-
-            state->free_bits = num_bits < state->max_bits
-                               ? (FT_UInt)( ( 1UL << num_bits ) - 256 )
-                               : state->max_free + 1;
-          }
+          state->free_ent += 1;
         }
 
         old_code = in_code;
@@ -367,8 +386,6 @@
     }
 
   Exit:
-    state->num_bits = num_bits;
-    state->free_ent = free_ent;
     state->old_code = old_code;
     state->old_char = old_char;
     state->in_code  = in_code;
diff --git a/lib/freetype/src/sfnt/ttcmap.c b/lib/freetype/src/sfnt/ttcmap.c
index 683039153..1bd2ce7a5 100644
--- a/lib/freetype/src/sfnt/ttcmap.c
+++ b/lib/freetype/src/sfnt/ttcmap.c
@@ -1635,7 +1635,7 @@
       FT_INVALID_TOO_SHORT;
 
     length = TT_NEXT_ULONG( p );
-    if ( table + length > valid->limit || length < 8208 )
+    if ( length > (FT_UInt32)( valid->limit - table ) || length < 8192 + 16 )
       FT_INVALID_TOO_SHORT;
 
     is32       = table + 12;
@@ -1863,7 +1863,8 @@
     p      = table + 16;
     count  = TT_NEXT_ULONG( p );
 
-    if ( table + length > valid->limit || length < 20 + count * 2 )
+    if ( length > (FT_ULong)( valid->limit - table ) ||
+         length < 20 + count * 2                     )
       FT_INVALID_TOO_SHORT;
 
     /* check glyph indices */
@@ -2048,7 +2049,8 @@
     p          = table + 12;
     num_groups = TT_NEXT_ULONG( p );
 
-    if ( table + length > valid->limit || length < 16 + 12 * num_groups )
+    if ( length > (FT_ULong)( valid->limit - table ) ||
+         length < 16 + 12 * num_groups               )
       FT_INVALID_TOO_SHORT;
 
     /* check groups, they must be in increasing order */
@@ -2429,7 +2431,8 @@
     FT_ULong  num_selectors = TT_NEXT_ULONG( p );
 
 
-    if ( table + length > valid->limit || length < 10 + 11 * num_selectors )
+    if ( length > (FT_ULong)( valid->limit - table ) ||
+         length < 10 + 11 * num_selectors            )
       FT_INVALID_TOO_SHORT;
 
     /* check selectors, they must be in increasing order */
@@ -2491,7 +2494,7 @@
           FT_ULong  i, lastUni = 0;
 
 
-          if ( ndp + numMappings * 4 > valid->limit )
+          if ( numMappings * 4 > (FT_ULong)( valid->limit - ndp ) )
             FT_INVALID_TOO_SHORT;
 
           for ( i = 0; i < numMappings; ++i )
diff --git a/lib/freetype/src/smooth/ftsmooth.c b/lib/freetype/src/smooth/ftsmooth.c
index a6db5048d..cacc490e8 100644
--- a/lib/freetype/src/smooth/ftsmooth.c
+++ b/lib/freetype/src/smooth/ftsmooth.c
@@ -153,7 +153,7 @@
       slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
     }
 
-    /* allocate new one, depends on pixel format */
+    /* allocate new one */
     pitch = width;
     if ( hmul )
     {
@@ -194,6 +194,13 @@
 
 #endif
 
+    if ( pitch > 0xFFFF || height > 0xFFFF )
+    {
+      FT_ERROR(( "ft_smooth_render_generic: glyph too large: %d x %d\n",
+                 width, height ));
+      return Smooth_Err_Raster_Overflow;
+    }
+
     bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;
     bitmap->num_grays  = 256;
     bitmap->width      = width;
