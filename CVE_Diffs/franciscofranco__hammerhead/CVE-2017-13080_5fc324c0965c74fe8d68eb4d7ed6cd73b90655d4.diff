franciscofranco__hammerhead
commit 5fc324c0965c74fe8d68eb4d7ed6cd73b90655d4
Author:     Johannes Berg <johannes.berg@intel.com>
AuthorDate: Tue Sep 5 14:54:54 2017 +0200
Commit:     Francisco Franco <franciscofranco.1990@gmail.com>
CommitDate: Tue Nov 7 05:46:18 2017 +0000

    mac80211: accept key reinstall without changing anything
    
    When a key is reinstalled we can reset the replay counters
    etc. which can lead to nonce reuse and/or replay detection
    being impossible, breaking security properties, as described
    in the "KRACK attacks".
    
    In particular, CVE-2017-13080 applies to GTK rekeying that
    happened in firmware while the host is in D3, with the second
    part of the attack being done after the host wakes up. In
    this case, the wpa_supplicant mitigation isn't sufficient
    since wpa_supplicant doesn't know the GTK material.
    
    In case this happens, simply silently accept the new key
    coming from userspace but don't take any action on it since
    it's the same key; this keeps the PN replay counters intact.
    
    Change-Id: I7576ed8c8df85a767ebf15e74a642063eb34d0f5
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Francisco Franco <franciscofranco.1990@gmail.com>

diff --git a/net/mac80211/key.c b/net/mac80211/key.c
index 5bb600d93d7..cebe30315d9 100644
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@ -3,6 +3,7 @@
  * Copyright 2005-2006, Devicescape Software, Inc.
  * Copyright 2006-2007	Jiri Benc <jbenc@suse.cz>
  * Copyright 2007-2008	Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2015-2017	Intel Deutschland GmbH
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -452,9 +453,6 @@ int ieee80211_key_link(struct ieee80211_key *key,
 
 	pairwise = key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE;
 	idx = key->conf.keyidx;
-	key->local = sdata->local;
-	key->sdata = sdata;
-	key->sta = sta;
 
 	if (sta) {
 		/*
@@ -491,6 +489,21 @@ int ieee80211_key_link(struct ieee80211_key *key,
 	else
 		old_key = key_mtx_dereference(sdata->local, sdata->keys[idx]);
 
+	/*
+	 * Silently accept key re-installation without really installing the
+	 * new version of the key to avoid nonce reuse or replay issues.
+	 */
+	if (old_key && key->conf.keylen == old_key->conf.keylen &&
+	    !memcmp(key->conf.key, old_key->conf.key, key->conf.keylen)) {
+		ieee80211_key_free_unused(key);
+		ret = 0;
+		goto out;
+	}
+
+	key->local = sdata->local;
+	key->sdata = sdata;
+	key->sta = sta;
+
 	increment_tailroom_need_count(sdata);
 
 	__ieee80211_key_replace(sdata, sta, pairwise, old_key, key);
@@ -500,6 +513,7 @@ int ieee80211_key_link(struct ieee80211_key *key,
 
 	ret = ieee80211_key_enable_hw_accel(key);
 
+ out:
 	mutex_unlock(&sdata->local->key_mtx);
 
 	return ret;
