franciscofranco__Shamu
commit a44b92163636069af36e01cde27024f60da4f131
Author:     Francisco Franco <franciscofranco.1990@gmail.com>
AuthorDate: Tue Aug 16 13:06:26 2016 +0000
Commit:     Francisco Franco <franciscofranco.1990@gmail.com>
CommitDate: Tue Aug 16 14:42:55 2016 +0000

    tcp: make challenge acks less predictable (CVE-2016-5696)
    
    Yue Cao claims that current host rate limiting of challenge ACKS
    (RFC 5961) could leak enough information to allow a patient attacker
    to hijack TCP sessions. He will soon provide details in an academic
    paper.
    
    This patch increases the default limit from 100 to 1000, and adds
    some randomization so that the attacker can no longer hijack
    sessions without spending a considerable amount of probes.
    
    Based on initial analysis and patch from Linus.
    
    Note that we also have per socket rate limiting, so it is tempting
    to remove the host limit in the future.
    
    v2: randomize the count of challenge acks per second, not the period.
    
    Fixes: 282f23c ("tcp: implement RFC 5961 3.2")
    Reported-by: Yue Cao <ycao009@ucr.edu>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Acked-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Francisco Franco <franciscofranco.1990@gmail.com>

diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index fc51b17858a..4c24cb0c2bc 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -87,7 +87,7 @@ int sysctl_tcp_adv_win_scale __read_mostly = 1;
 EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);
 
 /* rfc5961 challenge ack rate limiting */
-int sysctl_tcp_challenge_ack_limit = 100;
+int sysctl_tcp_challenge_ack_limit = 1000;
 
 int sysctl_tcp_stdurg __read_mostly;
 int sysctl_tcp_rfc1337 __read_mostly;
@@ -3289,12 +3289,19 @@ static void tcp_send_challenge_ack(struct sock *sk)
 	static u32 challenge_timestamp;
 	static unsigned int challenge_count;
 	u32 now = jiffies / HZ;
+	u32 count;
 
 	if (now != challenge_timestamp) {
+		u32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;
+
 		challenge_timestamp = now;
-		challenge_count = 0;
+		WRITE_ONCE(challenge_count, half +
+			prandom_u32_max(sysctl_tcp_challenge_ack_limit));
 	}
-	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
+
+	count = READ_ONCE(challenge_count);
+	if (count > 0) {
+		WRITE_ONCE(challenge_count, count - 1);
 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 		tcp_send_ack(sk);
 	}
