franciscofranco__Shamu
commit c9a590fb465340d96ca497cd1416609aff5eb874
Author:     Ben Hutchings <ben@decadent.org.uk>
AuthorDate: Sat Feb 13 02:34:52 2016 +0000
Commit:     Elektroschmock <elektroschmock78@googlemail.com>
CommitDate: Wed Oct 4 21:07:03 2017 +0200

    pipe: Fix buffer offset after partially failed read
    
    Quoting the RHEL advisory:
    
    > It was found that the fix for CVE-2015-1805 incorrectly kept buffer
    > offset and buffer length in sync on a failed atomic read, potentially
    > resulting in a pipe buffer state corruption. A local, unprivileged user
    > could use this flaw to crash the system or leak kernel memory to user
    > space. (CVE-2016-0774, Moderate)
    
    The same flawed fix was applied to stable branches from 2.6.32.y to
    3.14.y inclusive, and I was able to reproduce the issue on 3.2.y.
    We need to give pipe_iov_copy_to_user() a separate offset variable
    and only update the buffer offset if it succeeds.
    
    References: https://rhn.redhat.com/errata/RHSA-2016-0103.html
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Willy Tarreau <w@1wt.eu>

diff --git a/fs/pipe.c b/fs/pipe.c
index 14b58f9f26f..50267e6ba68 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -400,7 +400,8 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			const struct pipe_buf_operations *ops = buf->ops;
 			void *addr;
 			size_t chars = buf->len, remaining;
-			int error, atomic, offset;
+			int error, atomic;
+			int offset;
 
 			if (chars > total_len)
 				chars = total_len;
