Canonical-kernel__Ubuntu-kernel
commit 736679184527387a6a0d69a0dd24d84f1b9c0476
Author:     Andy Lutomirski <luto@amacapital.net>
AuthorDate: Wed Jul 2 14:52:55 2014 -0700
Commit:     Luis Henriques <luis.henriques@canonical.com>
CommitDate: Fri Jul 4 10:51:41 2014 +0100

    x86_64,ptrace: Enforce RIP <= TASK_SIZE_MAX (CVE-2014-4699)
    
    Don't allow ptrace to set RIP to a value that couldn't happen by
    ordinary control flow. There are CPU bugs^Wfeatures that can have
    interesting effects if RIP is non-canonical.
    
    I didn't make the corresponding x86_32 change, since x86_32 has no
    concept of canonical addresses.
    
    putreg32 doesn't need this fix: value is only 32 bits, so it can't
    be non-canonical.
    
    Fixes CVE-2014-4699.  There are arguably still bugs here, but this
    fixes the major issue.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    CVE-2014-4699
    BugLink: http://bugs.launchpad.net/bugs/1337339
    Acked-by: Andy Whitcroft <apw@canonical.com>
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c
index 9ee178713059..b3f801b3876b 100644
--- a/arch/x86/kernel/ptrace.c
+++ b/arch/x86/kernel/ptrace.c
@@ -450,6 +450,20 @@ static int putreg(struct task_struct *child,
 		if (child->thread.gs != value)
 			return do_arch_prctl(child, ARCH_SET_GS, value);
 		return 0;
+
+	case offsetof(struct user_regs_struct,ip):
+		/*
+		 * Protect against any attempt to set ip to an
+		 * impossible address.  There are dragons lurking if the
+		 * address is noncanonical.  (This explicitly allows
+		 * setting ip to TASK_SIZE_MAX, because user code can do
+		 * that all by itself by running off the end of its
+		 * address space.
+		 */
+		if (value > TASK_SIZE_MAX)
+			return -EIO;
+		break;
+
 #endif
 	}
 
