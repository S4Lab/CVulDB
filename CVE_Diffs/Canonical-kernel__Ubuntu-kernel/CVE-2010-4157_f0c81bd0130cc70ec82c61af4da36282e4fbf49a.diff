Canonical-kernel__Ubuntu-kernel
commit f0c81bd0130cc70ec82c61af4da36282e4fbf49a
Author:     Dan Carpenter <error27@gmail.com>
AuthorDate: Wed Feb 2 12:27:33 2011 +0000
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Wed Feb 9 14:30:36 2011 -0800

    gdth: integer overflow in ioctl, CVE-2010-4157
    
    gdth_ioctl_alloc() takes the size variable as an int.
    copy_from_user() takes the size variable as an unsigned long.
    gen.data_len and gen.sense_len are unsigned longs.
    On x86_64 longs are 64 bit and ints are 32 bit.
    
    We could pass in a very large number and the allocation would truncate
    the size to 32 bits and allocate a small buffer.  Then when we do the
    copy_from_user(), it would result in a memory corruption.
    
    CC: stable@kernel.org
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
    
    CVE-2010-4157
    BugLink: http://bugs.launchpad.net/bugs/711797
    (cherry picked from commit f63ae56e4e97fb12053590e41a4fa59e7daa74a4)
    Acked-by: Tim Gardner <tim.gardner@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Andy Whitcroft <apw@canonical.com>

diff --git a/drivers/scsi/gdth.c b/drivers/scsi/gdth.c
index e427165f1634..1fb18087ab3b 100644
--- a/drivers/scsi/gdth.c
+++ b/drivers/scsi/gdth.c
@@ -4185,6 +4185,14 @@ static int ioc_general(void __user *arg, char *cmnd)
     ha = gdth_find_ha(gen.ionode);
     if (!ha)
         return -EFAULT;
+
+    if (gen.data_len > INT_MAX)
+        return -EINVAL;
+    if (gen.sense_len > INT_MAX)
+        return -EINVAL;
+    if (gen.data_len + gen.sense_len > INT_MAX)
+        return -EINVAL;
+
     if (gen.data_len + gen.sense_len != 0) {
         if (!(buf = gdth_ioctl_alloc(ha, gen.data_len + gen.sense_len,
                                      FALSE, &paddr)))
