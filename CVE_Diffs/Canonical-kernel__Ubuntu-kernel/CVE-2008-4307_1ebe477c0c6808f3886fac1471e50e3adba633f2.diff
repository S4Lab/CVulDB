Canonical-kernel__Ubuntu-kernel
commit 1ebe477c0c6808f3886fac1471e50e3adba633f2
Author:     Trond Myklebust <Trond.Myklebust@netapp.com>
AuthorDate: Tue Apr 1 20:26:52 2008 -0400
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Mon Mar 16 18:40:43 2009 +0100

    NFS: Remove the buggy lock-if-signalled case from do_setlk()
    
    CVE-2008-4307
    
    Both NLM and NFSv4 should be able to clean up adequately in the case where
    the user interrupts the RPC call...
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index b3bb89f7d5d2..ea82f1dfcf9b 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -578,17 +578,9 @@ static int do_setlk(struct file *filp, int cmd, struct file_lock *fl)
 
 	lock_kernel();
 	/* Use local locking if mounted with "-onolock" */
-	if (!(NFS_SERVER(inode)->flags & NFS_MOUNT_NONLM)) {
+	if (!(NFS_SERVER(inode)->flags & NFS_MOUNT_NONLM))
 		status = NFS_PROTO(inode)->lock(filp, cmd, fl);
-		/* If we were signalled we still need to ensure that
-		 * we clean up any state on the server. We therefore
-		 * record the lock call as having succeeded in order to
-		 * ensure that locks_remove_posix() cleans it out when
-		 * the process exits.
-		 */
-		if (status == -EINTR || status == -ERESTARTSYS)
-			do_vfs_lock(filp, fl);
-	} else
+	else
 		status = do_vfs_lock(filp, fl);
 	unlock_kernel();
 	if (status < 0)
