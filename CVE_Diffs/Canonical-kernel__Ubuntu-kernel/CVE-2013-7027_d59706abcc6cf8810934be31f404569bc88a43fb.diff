Canonical-kernel__Ubuntu-kernel
commit d59706abcc6cf8810934be31f404569bc88a43fb
Author:     Johannes Berg <johannes.berg@intel.com>
AuthorDate: Thu Jan 16 17:01:03 2014 +0000
Commit:     Tim Gardner <tim.gardner@canonical.com>
CommitDate: Thu Jan 16 10:53:10 2014 -0700

    wireless: radiotap: fix parsing buffer overrun
    
    CVE-2013-7027
    BugLink: http://bugs.launchpad.net/bugs/1260622
    
    When parsing an invalid radiotap header, the parser can overrun
    the buffer that is passed in because it doesn't correctly check
     1) the minimum radiotap header size
     2) the space for extended bitmaps
    
    The first issue doesn't affect any in-kernel user as they all
    check the minimum size before calling the radiotap function.
    The second issue could potentially affect the kernel if an skb
    is passed in that consists only of the radiotap header with a
    lot of extended bitmaps that extend past the SKB. In that case
    a read-only buffer overrun by at most 4 bytes is possible.
    
    Fix this by adding the appropriate checks to the parser.
    
    Cc: stable@vger.kernel.org
    Reported-by: Evan Huus <eapache@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    (back ported from commit f5563318ff1bde15b10e736e97ffce13be08bc1a)
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/net/wireless/radiotap.c b/net/wireless/radiotap.c
index f591871a7b4f..4c4c8bd6e2be 100644
--- a/net/wireless/radiotap.c
+++ b/net/wireless/radiotap.c
@@ -54,6 +54,10 @@ int ieee80211_radiotap_iterator_init(
     struct ieee80211_radiotap_header *radiotap_header,
     int max_length)
 {
+	/* check the radiotap header can actually be present */
+	if (max_length < sizeof(struct ieee80211_radiotap_header))
+		return -EINVAL;
+
 	/* Linux only supports version 0 radiotap format */
 	if (radiotap_header->it_version)
 		return -EINVAL;
@@ -83,7 +87,8 @@ int ieee80211_radiotap_iterator_init(
 			 */
 
 			if (((ulong)iterator->arg -
-			     (ulong)iterator->rtheader) > iterator->max_length)
+			     (ulong)iterator->rtheader +
+			     sizeof(uint32_t)) > iterator->max_length)
 				return -EINVAL;
 		}
 
