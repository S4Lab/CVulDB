Canonical-kernel__Ubuntu-kernel
commit a971883708bcb8c0c69e9193daed1fe41c1a650f
Author:     Linus Torvalds <torvalds@linux-foundation.org>
AuthorDate: Thu Oct 28 15:40:55 2010 +0000
Commit:     Paolo Pisati <paolo.pisati@canonical.com>
CommitDate: Thu Jun 9 15:48:38 2011 +0200

    net: fix rds_iovec page count overflow, CVE-2010-3865
    
    BugLink: http://bugs.launchpad.net/bugs/709153
    
    CVE-2010-3865
    
    As reported by Thomas Pollet, the rdma page counting can overflow.  We
    get the rdma sizes in 64-bit unsigned entities, but then limit it to
    UINT_MAX bytes and shift them down to pages (so with a possible "+1" for
    an unaligned address).
    
    So each individual page count fits comfortably in an 'unsigned int' (not
    even close to overflowing into signed), but as they are added up, they
    might end up resulting in a signed return value. Which would be wrong.
    
    Catch the case of tot_pages turning negative, and return the appropriate
    error code.
    
    Reported-by: Thomas Pollet <thomas.pollet@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Andy Grover <andy.grover@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (backported from commit 1b1f693d7ad6d193862dcb1118540a030c5e761f upstream)
    [v2: nr is unsigned in the old code]
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>
    Acked-by: Tim Gardner <tim.gardner@canonical.com>
    Acked-by: Brad Figg <brad.figg@canonical.com>
    Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>

diff --git a/net/rds/rdma.c b/net/rds/rdma.c
index 8dc83d2caa58..aa3befb9c044 100644
--- a/net/rds/rdma.c
+++ b/net/rds/rdma.c
@@ -473,6 +473,17 @@ static struct rds_rdma_op *rds_rdma_prepare(struct rds_sock *rs,
 
 		max_pages = max(nr, max_pages);
 		nr_pages += nr;
+
+		/*
+		 * nr for one entry in limited to (UINT_MAX>>PAGE_SHIFT)+1
+		 * so nr_pages cannot overflow without becoming bigger than
+		 * INT_MAX first. If nr cannot overflow then max_pages should
+		 * be ok.
+		 */
+		if (nr_pages > INT_MAX) {
+			ret = -EINVAL;
+			goto out;
+		}
 	}
 
 	pages = kcalloc(max_pages, sizeof(struct page *), GFP_KERNEL);
