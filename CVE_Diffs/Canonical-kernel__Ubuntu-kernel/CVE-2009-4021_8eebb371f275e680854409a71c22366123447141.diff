Canonical-kernel__Ubuntu-kernel
commit 8eebb371f275e680854409a71c22366123447141
Author:     Anand V. Avati <avati@gluster.com>
AuthorDate: Thu Oct 22 06:24:52 2009 -0700
Commit:     Leann Ogasawara <leann.ogasawara@canonical.com>
CommitDate: Sun Jan 24 12:09:55 2010 -0800

    fuse: prevent fuse_put_request on invalid pointer
    
    CVE-2009-4021
    
    commit f60311d5f7670d9539b424e4ed8b5c0872fc9e83 upstream
    
    fuse_direct_io() has a loop where requests are allocated in each
    iteration. if allocation fails, the loop is broken out and follows
    into an unconditional fuse_put_request() on that invalid pointer.
    
    Signed-off-by: Anand V. Avati <avati@gluster.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: stable@kernel.org
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 18d9d12b6488..08c4fc36bda7 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -679,7 +679,8 @@ static ssize_t fuse_direct_io(struct file *file, const char __user *buf,
 				break;
 		}
 	}
-	fuse_put_request(fc, req);
+	if (!IS_ERR(req))
+		fuse_put_request(fc, req);
 	if (res > 0) {
 		if (write) {
 			spin_lock(&fc->lock);
