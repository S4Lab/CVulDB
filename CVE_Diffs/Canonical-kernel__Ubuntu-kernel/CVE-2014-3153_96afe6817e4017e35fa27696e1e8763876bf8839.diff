Canonical-kernel__Ubuntu-kernel
commit 96afe6817e4017e35fa27696e1e8763876bf8839
Author:     Thomas Gleixner <tglx@linutronix.de>
AuthorDate: Tue Jun 3 12:27:06 2014 +0000
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Wed Jun 4 14:51:46 2014 -0700

    futex: Validate atomic acquisition in futex_lock_pi_atomic()
    
    We need to protect the atomic acquisition in the kernel against rogue
    user space which sets the user space futex to 0, so the kernel side
    acquisition succeeds while there is existing state in the kernel
    associated to the real owner.
    
    Verify whether the futex has waiters associated with kernel state. If
    it has, return -EINVAL. The state is corrupted already, so no point in
    cleaning it up. Subsequent calls will fail as well. Not our problem.
    
    [ tglx: Use futex_top_waiter() and explain why we do not need to try
            restoring the already corrupted user space state. ]
    
    CVE-2014-3153
    
    BugLink: http://bugs.launchpad.net/bugs/1326367
    
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Will Drewry <wad@chromium.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Johansen <john.johansen@canonical.com>

diff --git a/kernel/futex.c b/kernel/futex.c
index 69e440086b0c..f2dc3fa8d200 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -742,10 +742,18 @@ retry:
 		return -EDEADLK;
 
 	/*
-	 * Surprise - we got the lock. Just return to userspace:
+	 * Surprise - we got the lock, but we do not trust user space at all.
 	 */
-	if (unlikely(!curval))
-		return 1;
+	if (unlikely(!curval)) {
+		/*
+		 * We verify whether there is kernel state for this
+		 * futex. If not, we can safely assume, that the 0 ->
+		 * TID transition is correct. If state exists, we do
+		 * not bother to fixup the user space state as it was
+		 * corrupted already.
+		 */
+		return futex_top_waiter(hb, key) ? -EINVAL : 1;
+	}
 
 	uval = curval;
 
