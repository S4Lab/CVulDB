Canonical-kernel__Ubuntu-kernel
commit 50ccc42fe835c8970f733fa2ee42183f448460ed
Author:     Jesse Brandeburg <jesse.brandeburg@intel.com>
AuthorDate: Tue Jan 19 14:15:38 2010 +0000
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue Mar 9 17:54:48 2010 +0100

    e1000: enhance frame fragment detection
    
    CVE-2009-4536
    
    Originally From: Neil Horman <nhorman@tuxdriver.com>
    Modified by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    
    Hey all-
            A security discussion was recently given:
    http://events.ccc.de/congress/2009/Fahrplan//events/3596.en.html
    And a patch that I submitted awhile back was brought up.  Apparently some of
    their testing revealed that they were able to force a buffer fragment in e1000
    in which the trailing fragment was greater than 4 bytes.  As a result the
    fragment check I introduced failed to detect the fragement and a partial
    invalid frame was passed up into the network stack.  I've written this patch
    to correct it.  I'm in the process of testing it now, but it makes good
    logical sense to me.  Effectively it maintains a per-adapter state variable
    which detects a non-EOP frame, and discards it and subsequent non-EOP frames
    leading up to _and_ _including_ the next positive-EOP frame (as it is by
    definition the last fragment).  This should prevent any and all partial frames
    from entering the network stack from e1000.
    
    Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (cherry-picked from commit 40a14deaf411592b57cb0720f0e8004293ab9865 upstream)
    Signed-off-by: Surbhi Palande <surbhi.palande@canonical.com>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/drivers/net/e1000/e1000.h b/drivers/net/e1000/e1000.h
index 3b840283a9c3..72d8b632fc9e 100644
--- a/drivers/net/e1000/e1000.h
+++ b/drivers/net/e1000/e1000.h
@@ -343,6 +343,8 @@ struct e1000_adapter {
 	boolean_t quad_port_a;
 	unsigned long flags;
 	uint32_t eeprom_wol;
+
+	bool discarding;
 };
 
 enum e1000_state_t {
diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index 1131e052bcc8..e7325e2cc54f 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -4181,13 +4181,22 @@ e1000_clean_rx_irq(struct e1000_adapter *adapter,
 
 		length = le16_to_cpu(rx_desc->length);
 		/* !EOP means multiple descriptors were used to store a single
-		 * packet, also make sure the frame isn't just CRC only */
-		if (unlikely(!(status & E1000_RXD_STAT_EOP) || (length <= 4))) {
+		 * packet, if thats the case we need to toss it.  In fact, we
+		 * to toss every packet with the EOP bit clear and the next
+		 * frame that _does_ have the EOP bit set, as it is by
+		 * definition only a frame fragment
+		 */
+		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
+			adapter->discarding = true;
+
+		if (adapter->discarding) {
 			/* All receives must fit into a single buffer */
 			E1000_DBG("%s: Receive packet consumed multiple"
 				  " buffers\n", netdev->name);
 			/* recycle */
 			buffer_info->skb = skb;
+			if (status & E1000_RXD_STAT_EOP)
+				adapter->discarding = false;
 			goto next_desc;
 		}
 
