Canonical-kernel__Ubuntu-kernel
commit d432093e467fee69385850409db58cdf552c873c
Author:     Linus Torvalds <torvalds@linux-foundation.org>
AuthorDate: Tue Feb 16 12:35:07 2010 -0800
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue May 25 14:08:52 2010 +0200

    USB: usbfs: properly clean up the as structure on error paths
    
    CVE-2010-1083
    
    I notice that the processcompl_compat() function seems to be leaking the
    'struct async *as' in the error paths.
    
    I think that the calling convention is fundamentally buggered. The
    caller is the one that did the "reap_as()" to get the as thing, the
    caller should be the one to free it too.
    
    Freeing it in the caller also means that it very clearly always gets
    freed, and avoids the need for any "free in the error case too".
    
    From: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Marcus Meissner <meissner@suse.de>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    (cherry-picked from commit ddeee0b2eec2a51b0712b04de4b39e7bec892a53 upstream)
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 1f4f6d02fe25..e0576555ea33 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1152,8 +1152,6 @@ static int processcompl(struct async *as, void __user * __user *arg)
 		}
 	}
 
-	free_async(as);
-
 	if (put_user(addr, (void __user * __user *)arg))
 		return -EFAULT;
 	return 0;
@@ -1184,8 +1182,11 @@ static struct async* reap_as(struct dev_state *ps)
 static int proc_reapurb(struct dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
-	if (as)
-		return processcompl(as, (void __user * __user *)arg);
+	if (as) {
+		int retval = processcompl(as, (void __user * __user *)arg);
+		free_async(as);
+		return retval;
+	}
 	if (signal_pending(current))
 		return -EINTR;
 	return -EIO;
@@ -1193,11 +1194,16 @@ static int proc_reapurb(struct dev_state *ps, void __user *arg)
 
 static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)
 {
+	int retval;
 	struct async *as;
 
-	if (!(as = async_getcompleted(ps)))
-		return -EAGAIN;
-	return processcompl(as, (void __user * __user *)arg);
+	as = async_getcompleted(ps);
+	retval = -EAGAIN;
+	if (as) {
+		retval = processcompl(as, (void __user * __user *)arg);
+		free_async(as);
+	}
+	return retval;
 }
 
 #ifdef CONFIG_COMPAT
@@ -1266,7 +1272,6 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 		}
 	}
 
-	free_async(as);
 	if (put_user(ptr_to_compat(addr), (u32 __user *)arg))
 		return -EFAULT;
 	return 0;
@@ -1275,8 +1280,11 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 static int proc_reapurb_compat(struct dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
-	if (as)
-		return processcompl_compat(as, (void __user * __user *)arg);
+	if (as) {
+		int retval = processcompl_compat(as, (void __user * __user *)arg);
+		free_async(as);
+		return retval;
+	}
 	if (signal_pending(current))
 		return -EINTR;
 	return -EIO;
@@ -1284,11 +1292,16 @@ static int proc_reapurb_compat(struct dev_state *ps, void __user *arg)
 
 static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)
 {
+	int retval;
 	struct async *as;
 
-	if (!(as = async_getcompleted(ps)))
-		return -EAGAIN;
-	return processcompl_compat(as, (void __user * __user *)arg);
+	retval = -EAGAIN;
+	as = async_getcompleted(ps);
+	if (as) {
+		retval = processcompl_compat(as, (void __user * __user *)arg);
+		free_async(as);
+	}
+	return retval;
 }
 
 #endif
