Canonical-kernel__Ubuntu-kernel
commit 9e28627d35c068fb5a4dd4230fe4863ce05076e4
Author:     Leann Ogasawara <leann.ogasawara@canonical.com>
AuthorDate: Tue Jan 19 15:57:13 2010 -0800
Commit:     Leann Ogasawara <leann.ogasawara@canonical.com>
CommitDate: Sun Jan 24 12:09:58 2010 -0800

    UBUNTU: [Upstream] e1000: enhance frame fragment detection
    
    CVE-2009-4536
    
    OriginalAuthor: Neil Horman <nhorman@redhat.com>
    OriginalLocation: http://marc.info/?l=linux-netdev&m=126203101730472&w=2
    
    A security discussion was recently given:
    http://events.ccc.de/congress/2009/Fahrplan//events/3596.en.html
    And a patch that was submitted awhile back was brought up.  Apparently
    some of their testing revealed that they were able to force a buffer
    fragment in e1000 in which the trailing fragment was greater than 4
    bytes.  As a result the fragment check introduced failed to detect the
    fragement and a partial invalid frame was passed up into the network
    stack.  This patch corrects it.  Neil is in the process of testing it
    now, but it makes good logical sense to him.  Effectively it maintains a
    per-adapter state variable which detects a non-EOP frame, and discards
    it and subsequent non-EOP frames leading up to _and_ _including_ the
    next positive-EOP frame (as it is by definition the last fragment).
    This should prevent any and all partial frames from entering the network
    stack from e1000
    
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/drivers/net/e1000/e1000.h b/drivers/net/e1000/e1000.h
index 3b840283a9c3..b22c527c68e5 100644
--- a/drivers/net/e1000/e1000.h
+++ b/drivers/net/e1000/e1000.h
@@ -348,7 +348,8 @@ struct e1000_adapter {
 enum e1000_state_t {
 	__E1000_TESTING,
 	__E1000_RESETTING,
-	__E1000_DOWN
+	__E1000_DOWN,
+	__E1000_DISCARDING
 };
 
 extern char e1000_driver_name[];
diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index 1131e052bcc8..acab510567e8 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -4181,13 +4181,22 @@ e1000_clean_rx_irq(struct e1000_adapter *adapter,
 
 		length = le16_to_cpu(rx_desc->length);
 		/* !EOP means multiple descriptors were used to store a single
-		 * packet, also make sure the frame isn't just CRC only */
-		if (unlikely(!(status & E1000_RXD_STAT_EOP) || (length <= 4))) {
+		 * packet, if thats the case we need to toss it.  In fact, we
+		 * to toss every packet with the EOP bit clear and the next
+		 * frame that _does_ have the EOP bit set, as it is by
+		 * definition only a frame fragment
+		 */
+		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
+			set_bit(__E1000_DISCARDING, &adapter->flags);
+
+		if (test_bit(__E1000_DISCARDING, &adapter->flags)) {
 			/* All receives must fit into a single buffer */
 			E1000_DBG("%s: Receive packet consumed multiple"
 				  " buffers\n", netdev->name);
 			/* recycle */
 			buffer_info->skb = skb;
+			if (status & E1000_RXD_STAT_EOP)
+				clear_bit(__E1000_DISCARDING, &adapter->flags);
 			goto next_desc;
 		}
 
