Canonical-kernel__Ubuntu-kernel
commit d01d9589af705d664b0fb811f8bee2465f17c209
Author:     Stefan Bader <stefan.bader@canonical.com>
AuthorDate: Mon Jun 15 21:11:52 2009 +0200
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Mon Jun 15 21:11:52 2009 +0200

    UBUNTU: cifs: backport buffer size fixes for CIFSGetDFSRefer()
    
    CVE-2009-1633
    
    This backports the changes from commit 968460ebd8006d55661dec0fb86712b40d71c413
    
      There is a possibility for the path_name and node_name buffers to
      overflow if they contain charcters that are >2 bytes in the local
      charset. Resize the buffer allocation so to avoid this possibility.
    
    However that change, too, had a flaw that it would use the length of the source
    to terminate the destination. That has been fixed in the stable update:
    
        commit 9381701c0f0722ffc1dab1c55ecd48f6d0b5be6f 2.6.29.y
    
        Relevant commits 968460ebd8006d55661dec0fb86712b40d71c413 and
        066ce6899484d9026acd6ba3a8dbbedb33d7ae1b. Minimal hunks to fix buffer
        size and fix an existing problem pointed out by Guenter Kukuk that length
        of src is used for NULL termination of dst.
    
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 9e8a6bef029a..ebe716d90e31 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -4026,9 +4026,15 @@ getDFSRetry:
 				   not fall off end PDU */
 			}
 			/* BB add check for name_len bigger than bcc */
-			*targetUNCs =
-				kmalloc(name_len+1+(*number_of_UNC_in_array),
-					GFP_KERNEL);
+			if (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE) {
+				*targetUNCs = kmalloc((4 * name_len + 2) +
+						      (*number_of_UNC_in_array),
+						      GFP_KERNEL);
+			} else {
+				*targetUNCs = kmalloc(name_len + 1 +
+						      (*number_of_UNC_in_array),
+						      GFP_KERNEL);
+			}
 			if (*targetUNCs == NULL) {
 				rc = -ENOMEM;
 				goto GetDFSRefExit;
@@ -4042,18 +4048,21 @@ getDFSRetry:
 				temp = ((char *)referrals) +
 					  le16_to_cpu(referrals->DfsPathOffset);
 				if (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE) {
-					cifs_strfromUCS_le(*targetUNCs,
-							  (__le16 *) temp,
-							  name_len,
-							  nls_codepage);
+					int l;
+
+					l = cifs_strfromUCS_le(*targetUNCs,
+							       (__le16 *) temp,
+							       name_len,
+							       nls_codepage);
+					(*targetUNCs)[l + 1] = 0;
 				} else {
-					strncpy(*targetUNCs, temp, name_len);
+					strlcpy(*targetUNCs, temp,
+						name_len + 1);
 				}
 				/*  BB update target_uncs pointers */
 				referrals++;
 			}
 			temp = *targetUNCs;
-			temp[name_len] = 0;
 		}
 
 	}
