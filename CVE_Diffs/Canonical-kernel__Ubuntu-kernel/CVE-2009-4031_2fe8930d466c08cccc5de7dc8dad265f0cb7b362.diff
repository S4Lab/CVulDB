Canonical-kernel__Ubuntu-kernel
commit 2fe8930d466c08cccc5de7dc8dad265f0cb7b362
Author:     Avi Kivity <avi@redhat.com>
AuthorDate: Tue Nov 24 15:20:15 2009 +0200
Commit:     Leann Ogasawara <leann.ogasawara@canonical.com>
CommitDate: Sun Jan 24 12:09:56 2010 -0800

    KVM: x86 emulator: limit instructions to 15 bytes
    
    CVE-2009-4031
    
    commit eb3c79e64a70fb8f7473e30fa07e89c1ecc2c9bb upstream (manually
    applied)
    
    While we are never normally passed an instruction that exceeds 15 bytes,
    smp games can cause us to attempt to interpret one, which will cause
    large latencies in non-preempt hosts.
    
    Cc: stable@kernel.org
    Signed-off-by: Avi Kivity <avi@redhat.com>
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/arch/x86/kvm/x86_emulate.c b/arch/x86/kvm/x86_emulate.c
index f59ed93f5d24..26882838f14f 100644
--- a/arch/x86/kvm/x86_emulate.c
+++ b/arch/x86/kvm/x86_emulate.c
@@ -541,6 +541,9 @@ static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,
 {
 	int rc = 0;
 
+	/* x86 instructions are limited to 15 bytes. */
+	if (eip + size - ctxt->decode.eip_orig > 15)
+		return X86EMUL_UNHANDLEABLE;
 	eip += ctxt->cs_base;
 	while (size--) {
 		rc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);
@@ -833,7 +836,7 @@ x86_decode_insn(struct x86_emulate_ctxt *ctxt, struct x86_emulate_ops *ops)
 	/* Shadow copy of register state. Committed on successful emulation. */
 
 	memset(c, 0, sizeof(struct decode_cache));
-	c->eip = ctxt->vcpu->arch.rip;
+	c->eip = c->eip_orig = ctxt->vcpu->arch.rip;
 	memcpy(c->regs, ctxt->vcpu->arch.regs, sizeof c->regs);
 
 	switch (mode) {
diff --git a/include/asm-x86/kvm_x86_emulate.h b/include/asm-x86/kvm_x86_emulate.h
index 7db91b9bdcd4..3979ac4c06af 100644
--- a/include/asm-x86/kvm_x86_emulate.h
+++ b/include/asm-x86/kvm_x86_emulate.h
@@ -127,7 +127,7 @@ struct decode_cache {
 	unsigned long *override_base;
 	unsigned int d;
 	unsigned long regs[NR_VCPU_REGS];
-	unsigned long eip;
+	unsigned long eip, eip_orig;
 	/* modrm */
 	u8 modrm;
 	u8 modrm_mod;
