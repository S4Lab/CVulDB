Canonical-kernel__Ubuntu-kernel
commit f1f01f1d66b4a3e07638aecd77ab13261bd5b6d2
Author:     Jeff Layton <jlayton@redhat.com>
AuthorDate: Tue Oct 25 17:12:26 2011 +0100
Commit:     Herton Ronaldo Krzesinski <herton.krzesinski@canonical.com>
CommitDate: Mon Nov 7 21:52:27 2011 -0200

    cifs: clean up cifs_find_smb_ses (try #2), CVE-2011-1585
    
    This patch replaces the earlier patch by the same name. The only
    difference is that MAX_PASSWORD_SIZE has been increased to attempt to
    match the limits that windows enforces.
    
    Do a better job of matching sessions by authtype. Matching by username
    for a Kerberos session is incorrect, and anonymous sessions need special
    handling.
    
    Also, in the case where we do match by username, we also need to match
    by password. That ensures that someone else doesn't "borrow" an existing
    session without needing to know the password.
    
    Finally, passwords can be longer than 16 bytes. Bump MAX_PASSWORD_SIZE
    to 512 to match the size that the userspace mount helper allows.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Steve French <sfrench@us.ibm.com>
    
    (cherry picked from commit 4ff67b720c02c36e54d55b88c2931879b7db1cd2)
    CVE-2011-1585
    BugLink: http://bugs.launchpad.net/bugs/869208
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index a88479ceaad5..43177fe4edf8 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -34,7 +34,7 @@
 #define MAX_SHARE_SIZE  64	/* used to be 20, this should still be enough */
 #define MAX_USERNAME_SIZE 32	/* 32 is to allow for 15 char names + null
 				   termination then *2 for unicode versions */
-#define MAX_PASSWORD_SIZE 16
+#define MAX_PASSWORD_SIZE 512  /* max for windows seems to be 256 wide chars */
 
 #define CIFS_MIN_RCV_POOL 4
 
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index aa92c97ae00a..7a509b6c6e45 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -1591,17 +1591,27 @@ out_err:
 }
 
 static struct cifsSesInfo *
-cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)
+cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)
 {
-	struct list_head *tmp;
 	struct cifsSesInfo *ses;
 
 	write_lock(&cifs_tcp_ses_lock);
-	list_for_each(tmp, &server->smb_ses_list) {
-		ses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);
-		if (strncmp(ses->userName, username, MAX_USERNAME_SIZE))
-			continue;
-
+	list_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {
+		switch (server->secType) {
+		case Kerberos:
+			if (vol->linux_uid != ses->linux_uid)
+				continue;
+			break;
+		default:
+			/* anything else takes username/password */
+			if (strncmp(ses->userName, vol->username,
+				    MAX_USERNAME_SIZE))
+				continue;
+			if (strlen(vol->username) != 0 &&
+			    strncmp(ses->password, vol->password,
+				    MAX_PASSWORD_SIZE))
+				continue;
+		}
 		++ses->ses_count;
 		write_unlock(&cifs_tcp_ses_lock);
 		return ses;
@@ -1643,7 +1653,7 @@ cifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)
 
 	xid = GetXid();
 
-	ses = cifs_find_smb_ses(server, volume_info->username);
+	ses = cifs_find_smb_ses(server, volume_info);
 	if (ses) {
 		cFYI(1, "Existing smb sess found (status=%d)", ses->status);
 
