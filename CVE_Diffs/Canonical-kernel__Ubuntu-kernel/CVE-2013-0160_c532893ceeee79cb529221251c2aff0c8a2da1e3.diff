Canonical-kernel__Ubuntu-kernel
commit c532893ceeee79cb529221251c2aff0c8a2da1e3
Author:     Eric Paris <eparis@redhat.com>
AuthorDate: Fri Jan 24 14:17:21 2014 +0000
Commit:     rtg <tim.gardner@canonical.com>
CommitDate: Mon Jan 27 12:47:22 2014 +0000

    vfs: introduce FMODE_NONOTIFY
    
    CVE-2013-0160
    
    BugLink: http://bugs.launchpad.net/bugs/1097680
    
    This is a new f_mode which can only be set by the kernel.  It indicates
    that the fd was opened by fanotify and should not cause future fanotify
    events.  This is needed to prevent fanotify livelock.  An example of
    obvious livelock is from fanotify close events.
    
    Process A closes file1
    This creates a close event for file1.
    fanotify opens file1 for Listener X
    Listener X deals with the event and closes its fd for file1.
    This creates a close event for file1.
    fanotify opens file1 for Listener X
    Listener X deals with the event and closes its fd for file1.
    This creates a close event for file1.
    fanotify opens file1 for Listener X
    Listener X deals with the event and closes its fd for file1.
    notice a pattern?
    
    The fix is to add the FMODE_NONOTIFY bit to the open filp done by the kernel
    for fanotify.  Thus when that file is used it will not generate future
    events.
    
    This patch simply defines the bit.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    (back ported from commit ecf081d1a73b077916f514f2ec744ded32b88ca1)
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Acked-by: Andy Whitcroft <andy.whitcroft@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/include/asm-generic/fcntl.h b/include/asm-generic/fcntl.h
index 495dc8af4044..c8ba13423887 100644
--- a/include/asm-generic/fcntl.h
+++ b/include/asm-generic/fcntl.h
@@ -3,8 +3,17 @@
 
 #include <linux/types.h>
 
+/*
+ * FMODE_EXEC is 0x20
+ * FMODE_NONOTIFY is 0x800000
+ * These cannot be used by userspace O_* until internal and external open
+ * flags are split.
+ * -Eric Paris
+ */
+
 /* open/fcntl - O_SYNC is only implemented on blocks devices and on files
    located on an ext2 file system */
+
 #define O_ACCMODE	00000003
 #define O_RDONLY	00000000
 #define O_WRONLY	00000001
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 719f43a295cf..42f714f98cd8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -91,6 +91,9 @@ struct inodes_stat_t {
 /* Expect random access pattern */
 #define FMODE_RANDOM		((__force fmode_t)4096)
 
+/* File was opened by fanotify and shouldn't generate fanotify events */
+#define FMODE_NONOTIFY		((__force fmode_t)8388608)
+
 /*
  * The below are the various read and write types that we support. Some of
  * them include behavioral modifiers that send information down to the
diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
index 36357a443a6b..33a89fc22121 100644
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -192,10 +192,12 @@ static inline void fsnotify_access(struct file *file)
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_IN_ISDIR;
 
-	inotify_inode_queue_event(inode, mask, 0, NULL, NULL);
+	if (!(file->f_mode & FMODE_NONOTIFY)) {
+		inotify_inode_queue_event(inode, mask, 0, NULL, NULL);
 
-	fsnotify_parent(dentry, mask);
-	fsnotify(inode, mask, file, FSNOTIFY_EVENT_FILE, NULL, 0);
+		fsnotify_parent(dentry, mask);
+		fsnotify(inode, mask, file, FSNOTIFY_EVENT_FILE, NULL, 0);
+	}
 }
 
 /*
@@ -210,10 +212,12 @@ static inline void fsnotify_modify(struct file *file)
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_IN_ISDIR;
 
-	inotify_inode_queue_event(inode, mask, 0, NULL, NULL);
+	if (!(file->f_mode & FMODE_NONOTIFY)) {
+		inotify_inode_queue_event(inode, mask, 0, NULL, NULL);
 
-	fsnotify_parent(dentry, mask);
-	fsnotify(inode, mask, file, FSNOTIFY_EVENT_FILE, NULL, 0);
+		fsnotify_parent(dentry, mask);
+		fsnotify(inode, mask, file, FSNOTIFY_EVENT_FILE, NULL, 0);
+	}
 }
 
 /*
@@ -228,10 +232,12 @@ static inline void fsnotify_open(struct file *file)
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_IN_ISDIR;
 
-	inotify_inode_queue_event(inode, mask, 0, NULL, NULL);
+	if (!(file->f_mode & FMODE_NONOTIFY)) {
+		inotify_inode_queue_event(inode, mask, 0, NULL, NULL);
 
-	fsnotify_parent(dentry, mask);
-	fsnotify(inode, mask, file, FSNOTIFY_EVENT_FILE, NULL, 0);
+		fsnotify_parent(dentry, mask);
+		fsnotify(inode, mask, file, FSNOTIFY_EVENT_FILE, NULL, 0);
+	}
 }
 
 /*
@@ -247,10 +253,12 @@ static inline void fsnotify_close(struct file *file)
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_IN_ISDIR;
 
-	inotify_inode_queue_event(inode, mask, 0, NULL, NULL);
+	if (!(file->f_mode & FMODE_NONOTIFY)) {
+		inotify_inode_queue_event(inode, mask, 0, NULL, NULL);
 
-	fsnotify_parent(dentry, mask);
-	fsnotify(inode, mask, file, FSNOTIFY_EVENT_FILE, NULL, 0);
+		fsnotify_parent(dentry, mask);
+		fsnotify(inode, mask, file, FSNOTIFY_EVENT_FILE, NULL, 0);
+	}
 }
 
 /*
