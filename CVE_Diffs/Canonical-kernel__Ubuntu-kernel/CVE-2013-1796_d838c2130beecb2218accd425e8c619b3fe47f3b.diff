Canonical-kernel__Ubuntu-kernel
commit d838c2130beecb2218accd425e8c619b3fe47f3b
Author:     Andy Honig <ahonig@google.com>
AuthorDate: Mon Mar 11 09:34:52 2013 -0700
Commit:     Tim Gardner <tim.gardner@canonical.com>
CommitDate: Fri Apr 5 06:24:54 2013 -0600

    KVM: x86: fix for buffer overflow in handling of MSR_KVM_SYSTEM_TIME (CVE-2013-1796)
    
    CVE-2013-1796
    
    BugLink: http://bugs.launchpad.net/bugs/1158254
    
    If the guest sets the GPA of the time_page so that the request to update the
    time straddles a page then KVM will write onto an incorrect page.  The
    write is done byusing kmap atomic to get a pointer to the page for the time
    structure and then performing a memcpy to that page starting at an offset
    that the guest controls.  Well behaved guests always provide a 32-byte aligned
    address, however a malicious guest could use this to corrupt host kernel
    memory.
    
    Tested: Tested against kvmclock unit test.
    
    Signed-off-by: Andrew Honig <ahonig@google.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    
    (cherry picked from commit c300aa64ddf57d9c5d9c898a64b36877345dd4a9)
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index a52bd56b5c2a..3fee18203ffe 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -1635,6 +1635,11 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data)
 		/* ...but clean it before doing the actual write */
 		vcpu->arch.time_offset = data & ~(PAGE_MASK | 1);
 
+		/* Check that the address is 32-byte aligned. */
+		if (vcpu->arch.time_offset &
+				(sizeof(struct pvclock_vcpu_time_info) - 1))
+			break;
+
 		vcpu->arch.time_page =
 				gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);
 
