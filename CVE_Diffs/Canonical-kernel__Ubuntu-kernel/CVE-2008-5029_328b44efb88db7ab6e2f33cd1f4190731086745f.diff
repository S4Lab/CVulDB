Canonical-kernel__Ubuntu-kernel
commit 328b44efb88db7ab6e2f33cd1f4190731086745f
Author:     David Miller <davem@davemloft.net>
AuthorDate: Thu Nov 6 00:37:40 2008 -0800
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Thu Nov 20 09:43:46 2008 +0100

    net: Fix recursive descent in __scm_destroy().
    
    CVE-2008-5029
    
    __scm_destroy() walks the list of file descriptors in the scm_fp_list
    pointed to by the scm_cookie argument.
    
    Those, in turn, can close sockets and invoke __scm_destroy() again.
    
    There is nothing which limits how deeply this can occur.
    
    The idea for how to fix this is from Linus.  Basically, we do all of
    the fput()s at the top level by collecting all of the scm_fp_list
    objects hit by an fput().  Inside of the initial __scm_destroy() we
    keep running the list until it is empty.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/debian/binary-custom.d/openvz/patchset/0001-2.6.24-ovz002.patch b/debian/binary-custom.d/openvz/patchset/0001-2.6.24-ovz002.patch
index 0aa174b49fa3..d10d0c99671f 100644
--- a/debian/binary-custom.d/openvz/patchset/0001-2.6.24-ovz002.patch
+++ b/debian/binary-custom.d/openvz/patchset/0001-2.6.24-ovz002.patch
@@ -28446,9 +28446,9 @@ index 9011f20..71ed87f 100644
  	 */
  	struct pipe_inode_info *splice_pipe;
 @@ -1183,6 +1224,16 @@ struct task_struct {
- 	int latency_record_count;
  	struct latency_record latency_record[LT_SAVECOUNT];
  #endif
+ 	struct list_head	*scm_work_list;
 +#ifdef CONFIG_BEANCOUNTERS
 +	struct task_beancounter task_bc;
 +#endif
diff --git a/debian/binary-custom.d/rt/patchset/0325-print-might-sleep-hack.patch b/debian/binary-custom.d/rt/patchset/0325-print-might-sleep-hack.patch
index 080a84e29650..7beecd449977 100644
--- a/debian/binary-custom.d/rt/patchset/0325-print-might-sleep-hack.patch
+++ b/debian/binary-custom.d/rt/patchset/0325-print-might-sleep-hack.patch
@@ -23,7 +23,7 @@ Index: ubuntu-hardy/include/linux/sched.h
 ===================================================================
 --- ubuntu-hardy.orig/include/linux/sched.h	2008-02-27 11:46:55.000000000 +0100
 +++ ubuntu-hardy/include/linux/sched.h	2008-02-27 11:47:41.000000000 +0100
-@@ -1292,12 +1292,25 @@
+@@ -1296,6 +1296,13 @@ struct task_struct {
  	int make_it_fail;
  #endif
  	struct prop_local_single dirties;
@@ -37,7 +37,8 @@ Index: ubuntu-hardy/include/linux/sched.h
  #ifdef CONFIG_LATENCYTOP
  	int latency_record_count;
  	struct latency_record latency_record[LT_SAVECOUNT];
- #endif
+@@ -1303,6 +1310,12 @@ struct task_struct {
+ 	struct list_head	*scm_work_list;
  };
  
 +#ifdef CONFIG_PREEMPT_RT
diff --git a/include/linux/sched.h b/include/linux/sched.h
index dc2f4fac327a..fb8fbd789673 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1187,6 +1187,7 @@ struct task_struct {
 	int latency_record_count;
 	struct latency_record latency_record[LT_SAVECOUNT];
 #endif
+	struct list_head	*scm_work_list;
 };
 
 /*
diff --git a/include/net/scm.h b/include/net/scm.h
index 06df126103ca..33e9986beb86 100644
--- a/include/net/scm.h
+++ b/include/net/scm.h
@@ -14,8 +14,9 @@
 
 struct scm_fp_list
 {
-	int		count;
-	struct file	*fp[SCM_MAX_FD];
+	struct list_head	list;
+	int			count;
+	struct file		*fp[SCM_MAX_FD];
 };
 
 struct scm_cookie
diff --git a/net/core/scm.c b/net/core/scm.c
index 10f5c65f6a47..ab242cc1acca 100644
--- a/net/core/scm.c
+++ b/net/core/scm.c
@@ -75,6 +75,7 @@ static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)
 		if (!fpl)
 			return -ENOMEM;
 		*fplp = fpl;
+		INIT_LIST_HEAD(&fpl->list);
 		fpl->count = 0;
 	}
 	fpp = &fpl->fp[fpl->count];
@@ -106,9 +107,25 @@ void __scm_destroy(struct scm_cookie *scm)
 
 	if (fpl) {
 		scm->fp = NULL;
-		for (i=fpl->count-1; i>=0; i--)
-			fput(fpl->fp[i]);
-		kfree(fpl);
+		if (current->scm_work_list) {
+			list_add_tail(&fpl->list, current->scm_work_list);
+		} else {
+			LIST_HEAD(work_list);
+
+			current->scm_work_list = &work_list;
+
+			list_add(&fpl->list, &work_list);
+			while (!list_empty(&work_list)) {
+				fpl = list_first_entry(&work_list, struct scm_fp_list, list);
+
+				list_del(&fpl->list);
+				for (i=fpl->count-1; i>=0; i--)
+					fput(fpl->fp[i]);
+				kfree(fpl);
+			}
+
+			current->scm_work_list = NULL;
+		}
 	}
 }
 
@@ -284,6 +301,7 @@ struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
 
 	new_fpl = kmalloc(sizeof(*fpl), GFP_KERNEL);
 	if (new_fpl) {
+		INIT_LIST_HEAD(&new_fpl->list);
 		for (i=fpl->count-1; i>=0; i--)
 			get_file(fpl->fp[i]);
 		memcpy(new_fpl, fpl, sizeof(*fpl));
