Canonical-kernel__Ubuntu-kernel
commit 58aa276c17982d485ce628a32373a2934aa57b36
Author:     Jesse Brandeburg <jesse.brandeburg@intel.com>
AuthorDate: Tue Jan 19 14:15:38 2010 +0000
Commit:     Andy Whitcroft <apw@canonical.com>
CommitDate: Mon Mar 1 18:59:25 2010 +0000

    e1000: enhance frame fragment detection
    
    CVE-2009-4536
    
    Originally From: Neil Horman <nhorman@tuxdriver.com>
    Modified by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    
    Hey all-
            A security discussion was recently given:
    http://events.ccc.de/congress/2009/Fahrplan//events/3596.en.html
    And a patch that I submitted awhile back was brought up.  Apparently some of
    their testing revealed that they were able to force a buffer fragment in e1000
    in which the trailing fragment was greater than 4 bytes.  As a result the
    fragment check I introduced failed to detect the fragement and a partial
    invalid frame was passed up into the network stack.  I've written this patch
    to correct it.  I'm in the process of testing it now, but it makes good
    logical sense to me.  Effectively it maintains a per-adapter state variable
    which detects a non-EOP frame, and discards it and subsequent non-EOP frames
    leading up to _and_ _including_ the next positive-EOP frame (as it is by
    definition the last fragment).  This should prevent any and all partial frames
    from entering the network stack from e1000.
    
    Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (cherry-picked from commit 40a14deaf411592b57cb0720f0e8004293ab9865 upstream)
    Signed-off-by: Surbhi Palande <surbhi.palande@canonical.com>
    Signed-off-by: Andy Whitcroft <apw@canonical.com>

diff --git a/drivers/net/e1000/e1000.h b/drivers/net/e1000/e1000.h
index 42e2b7e21c29..4a2ee85d49a4 100644
--- a/drivers/net/e1000/e1000.h
+++ b/drivers/net/e1000/e1000.h
@@ -326,6 +326,8 @@ struct e1000_adapter {
 	/* for ioport free */
 	int bars;
 	int need_ioport;
+
+	bool discarding;
 };
 
 enum e1000_state_t {
diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index 09945824a6df..1a23f168bebd 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -3809,13 +3809,22 @@ static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
 
 		length = le16_to_cpu(rx_desc->length);
 		/* !EOP means multiple descriptors were used to store a single
-		 * packet, also make sure the frame isn't just CRC only */
-		if (unlikely(!(status & E1000_RXD_STAT_EOP) || (length <= 4))) {
+		 * packet, if thats the case we need to toss it.  In fact, we
+		 * to toss every packet with the EOP bit clear and the next
+		 * frame that _does_ have the EOP bit set, as it is by
+		 * definition only a frame fragment
+		 */
+		if (unlikely(!(status & E1000_RXD_STAT_EOP)))
+			adapter->discarding = true;
+
+		if (adapter->discarding) {
 			/* All receives must fit into a single buffer */
 			E1000_DBG("%s: Receive packet consumed multiple"
 				  " buffers\n", netdev->name);
 			/* recycle */
 			buffer_info->skb = skb;
+			if (status & E1000_RXD_STAT_EOP)
+				adapter->discarding = false;
 			goto next_desc;
 		}
 
