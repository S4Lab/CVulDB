Canonical-kernel__Ubuntu-kernel
commit d93d3b048cb2067409ed1e56463ba45816f53967
Author:     Linus Torvalds <torvalds@linux-foundation.org>
AuthorDate: Tue Feb 2 12:37:44 2010 -0800
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Wed Mar 10 17:09:22 2010 +0100

    Fix 'flush_old_exec()/setup_new_exec()' split
    
    CVE-2010-0307
    
    Commit 221af7f87b9 ("Split 'flush_old_exec' into two functions") split
    the function at the point of no return - ie right where there were no
    more error cases to check.  That made sense from a technical standpoint,
    but when we then also combined it with the actual personality setting
    going in between flush_old_exec() and setup_new_exec(), it needs to be a
    bit more careful.
    
    In particular, we need to make sure that we really flush the old
    personality bits in the 'flush' stage, rather than later in the 'setup'
    stage, since otherwise we might be flushing the _new_ personality state
    that we're just setting up.
    
    So this moves the flags and personality flushing (and 'flush_thread()',
    which is the arch-specific function that generally resets lazy FP state
    etc) of the old process into flush_old_exec(), so that it doesn't affect
    any state that execve() is setting up for the new process environment.
    
    This was reported by Michal Simek as breaking his Microblaze qemu
    environment.
    
    Reported-and-tested-by: Michal Simek <michal.simek@petalogix.com>
    Cc: Peter Anvin <hpa@zytor.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    (cherry-picked from commit 7ab02af428c2d312c0cf8fb0b01cc1eb21131a3d upstream)
    Signed-off-by: Surbhi Palande <surbhi.palande@canonical.com>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/fs/exec.c b/fs/exec.c
index 57b06fc64699..25db3e94a4a8 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -994,6 +994,9 @@ int flush_old_exec(struct linux_binprm * bprm)
 	bprm->mm = NULL;		/* We're using it now */
 	put_files_struct(files);
 
+	current->flags &= ~PF_RANDOMIZE;
+	flush_thread();
+
 	return 0;
 
 mmap_failed:
@@ -1032,9 +1035,6 @@ void setup_new_exec(struct linux_binprm * bprm)
 	tcomm[i] = '\0';
 	set_task_comm(current, tcomm);
 
-	current->flags &= ~PF_RANDOMIZE;
-	flush_thread();
-
 	/* Set the new mm task size. We have to do that late because it may
 	 * depend on TIF_32BIT which is only updated in flush_thread() on
 	 * some architectures like powerpc
