Canonical-kernel__Ubuntu-kernel
commit ae9883ee8e9ca0c87042d70e7a220700dd5534ba
Author:     Mathias Krause <minipli@googlemail.com>
AuthorDate: Wed Aug 15 11:31:53 2012 +0000
Commit:     Tim Gardner <tim.gardner@canonical.com>
CommitDate: Tue Mar 26 11:31:32 2013 -0600

    llc: fix info leak via getsockname()
    
    CVE-2012-6542
    
    BugLink: http://bugs.launchpad.net/bugs/1156743
    
    The LLC code wrongly returns 0, i.e. "success", when the socket is
    zapped. Together with the uninitialized uaddrlen pointer argument from
    sys_getsockname this leads to an arbitrary memory leak of up to 128
    bytes kernel stack via the getsockname() syscall.
    
    Return an error instead when the socket is zapped to prevent the info
    leak. Also remove the unnecessary memset(0). We don't directly write to
    the memory pointed by uaddr but memcpy() a local structure at the end of
    the function that is properly initialized.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (cherry picked from commit 3592aaeb80290bda0f2cf0b5456c97bfc638b192)
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c
index 2da8d14c28ce..606b6adac1ca 100644
--- a/net/llc/af_llc.c
+++ b/net/llc/af_llc.c
@@ -912,14 +912,13 @@ static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
 	struct sockaddr_llc sllc;
 	struct sock *sk = sock->sk;
 	struct llc_sock *llc = llc_sk(sk);
-	int rc = 0;
+	int rc = -EBADF;
 
 	memset(&sllc, 0, sizeof(sllc));
 	lock_sock(sk);
 	if (sock_flag(sk, SOCK_ZAPPED))
 		goto out;
 	*uaddrlen = sizeof(sllc);
-	memset(uaddr, 0, *uaddrlen);
 	if (peer) {
 		rc = -ENOTCONN;
 		if (sk->sk_state != TCP_ESTABLISHED)
