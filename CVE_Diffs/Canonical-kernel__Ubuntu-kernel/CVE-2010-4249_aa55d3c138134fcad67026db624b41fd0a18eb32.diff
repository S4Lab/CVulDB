Canonical-kernel__Ubuntu-kernel
commit aa55d3c138134fcad67026db624b41fd0a18eb32
Author:     Eric Dumazet <eric.dumazet@gmail.com>
AuthorDate: Mon Jul 4 17:22:41 2011 +0100
Commit:     Herton Ronaldo Krzesinski <herton.krzesinski@canonical.com>
CommitDate: Mon Jul 18 12:29:35 2011 -0300

    af_unix: limit unix_tot_inflight CVE-2010-4249
    
    CVE-2010-4249
    
    BugLink: http://bugs.launchpad.net/bugs/769182
    
    commit upstream 9915672d41273f5b77f1b3c29b391ffb7732b84b
    
    Vegard Nossum found a unix socket OOM was possible, posting an exploit
    program.
    
    My analysis is we can eat all LOWMEM memory before unix_gc() being
    called from unix_release_sock(). Moreover, the thread blocked in
    unix_gc() can consume huge amount of time to perform cleanup because of
    huge working set.
    
    One way to handle this is to have a sensible limit on unix_tot_inflight,
    tested from wait_for_unix_gc() and to force a call to unix_gc() if this
    limit is hit.
    
    This solves the OOM and also reduce overall latencies, and should not
    slowdown normal workloads.
    
    Reported-by: Vegard Nossum <vegard.nossum@gmail.com>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Brad Figg <brad.figg@canonical.com>
    Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>
    Acked-by: Andy Whitcroft <apw@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Andy Whitcroft <apw@canonical.com>

diff --git a/net/unix/garbage.c b/net/unix/garbage.c
index 07499a5d34cc..dc2cb6192424 100644
--- a/net/unix/garbage.c
+++ b/net/unix/garbage.c
@@ -269,9 +269,16 @@ static void inc_inflight_move_tail(struct unix_sock *u)
 }
 
 static bool gc_in_progress = false;
+#define UNIX_INFLIGHT_TRIGGER_GC 16000
 
 void wait_for_unix_gc(void)
 {
+	/*
+	 * If number of inflight sockets is insane,
+	 * force a garbage collect right now.
+	 */
+	if (unix_tot_inflight > UNIX_INFLIGHT_TRIGGER_GC && !gc_in_progress)
+		unix_gc();
 	wait_event(unix_gc_wait, gc_in_progress == false);
 }
 
