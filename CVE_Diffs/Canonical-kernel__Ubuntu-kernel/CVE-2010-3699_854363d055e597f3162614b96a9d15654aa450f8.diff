Canonical-kernel__Ubuntu-kernel
commit 854363d055e597f3162614b96a9d15654aa450f8
Author:     Tim Gardner <tim.gardner@canonical.com>
AuthorDate: Thu Jan 27 08:33:51 2011 -0700
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Wed Feb 9 14:30:32 2011 -0800

    UBUNTU: xen unified block-device I/O interface back end can orphan devices, CVE-2010-3699
    
    BugLink: http://bugs.launchpad.net/bugs/708019
    
    CVE-2010-3699
    
    Excerpted from http://rhn.redhat.com/errata/RHSA-2011-0004.html:
    
    "A flaw was found in the Xenbus code for the unified block-device I/O
    interface back end. A privileged guest user could use this flaw to cause a
    denial of service on the host system running the Xen hypervisor."
    
    Most of this patch was developed from http://xenbits.xensource.com/linux-2.6.18-xen.hg?rev/59f097ef181b.
    A careful comparision of the patch and the actual contents of http://xenbits.xensource.com/linux-2.6.18-xen.hg
    showed that part of the original patch introduced a regression as can be seen from the Mercurial log.
    I've not implemented that piece of the patch.
    
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Acked-by: John Johansen <john.johansen@canonical.com>

diff --git a/debian/binary-custom.d/xen/patchset/020-xen-CVE-2010-3699.patch b/debian/binary-custom.d/xen/patchset/020-xen-CVE-2010-3699.patch
new file mode 100644
index 000000000000..2f5b718838ac
--- /dev/null
+++ b/debian/binary-custom.d/xen/patchset/020-xen-CVE-2010-3699.patch
@@ -0,0 +1,155 @@
+diff --git a/drivers/xen/blkback/xenbus.c b/drivers/xen/blkback/xenbus.c
+index f9feb43..1611d7a 100644
+--- a/drivers/xen/blkback/xenbus.c
++++ b/drivers/xen/blkback/xenbus.c
+@@ -362,6 +362,11 @@ static void frontend_changed(struct xenbus_device *dev,
+ 		if (dev->state == XenbusStateConnected)
+ 			break;
+ 
++		/* Enforce precondition before potential leak point.
++		 * blkif_disconnect() is idempotent.
++		 */
++		blkif_disconnect(be->blkif);
++
+ 		err = connect_ring(be);
+ 		if (err)
+ 			break;
+@@ -379,6 +384,7 @@ static void frontend_changed(struct xenbus_device *dev,
+ 			break;
+ 		/* fall through if not online */
+ 	case XenbusStateUnknown:
++		/* implies blkif_disconnect() via blkback_remove() */
+ 		device_unregister(&dev->dev);
+ 		break;
+ 
+diff --git a/drivers/xen/blktap/xenbus.c b/drivers/xen/blktap/xenbus.c
+index f9e3159..7114610 100644
+--- a/drivers/xen/blktap/xenbus.c
++++ b/drivers/xen/blktap/xenbus.c
+@@ -326,6 +326,21 @@ static void tap_backend_changed(struct xenbus_watch *watch,
+ 	tap_update_blkif_status(be->blkif);
+ }
+ 
++
++static void tap_blkif_disconnect(blkif_t *blkif)
++{
++	if (blkif->xenblkd) {
++		kthread_stop(blkif->xenblkd);
++		blkif->xenblkd = NULL;
++	}
++
++        atomic_dec(&blkif->refcnt);
++        wait_event(blkif->waiting_to_free, atomic_read(&blkif->refcnt) == 0);
++        atomic_inc(&blkif->refcnt);
++        
++        tap_blkif_unmap(blkif);
++}
++
+ /**
+  * Callback received when the frontend's state changes.
+  */
+@@ -354,6 +369,11 @@ static void tap_frontend_changed(struct xenbus_device *dev,
+ 		if (dev->state == XenbusStateConnected)
+ 			break;
+ 
++		/* Enforce precondition before potential leak point.
++		 * tap_blkif_disconnect() is idempotent.
++		 */
++		tap_blkif_disconnect(be->blkif);
++
+ 		err = connect_ring(be);
+ 		if (err)
+ 			break;
+@@ -361,10 +381,7 @@ static void tap_frontend_changed(struct xenbus_device *dev,
+ 		break;
+ 
+ 	case XenbusStateClosing:
+-		if (be->blkif->xenblkd) {
+-			kthread_stop(be->blkif->xenblkd);
+-			be->blkif->xenblkd = NULL;
+-		}
++		tap_blkif_disconnect(be->blkif);
+ 		xenbus_switch_state(dev, XenbusStateClosing);
+ 		break;
+ 
+@@ -374,6 +391,9 @@ static void tap_frontend_changed(struct xenbus_device *dev,
+ 			break;
+ 		/* fall through if not online */
+ 	case XenbusStateUnknown:
++		/* Implies the effects of tap_blkif_disconnect() via
++		 * blktap_remove().
++		 */
+ 		device_unregister(&dev->dev);
+ 		break;
+ 
+diff --git a/drivers/xen/netback/xenbus.c b/drivers/xen/netback/xenbus.c
+index b55005c..a9af461 100644
+--- a/drivers/xen/netback/xenbus.c
++++ b/drivers/xen/netback/xenbus.c
+@@ -32,6 +32,7 @@
+ static int connect_rings(struct backend_info *);
+ static void connect(struct backend_info *);
+ static void backend_create_netif(struct backend_info *be);
++static void netback_disconnect(struct device *);
+ 
+ static int netback_remove(struct xenbus_device *dev)
+ {
+@@ -39,15 +40,22 @@ static int netback_remove(struct xenbus_device *dev)
+ 
+ 	netback_remove_accelerators(be, dev);
+ 
+-	if (be->netif) {
+-		netif_disconnect(be->netif);
+-		be->netif = NULL;
+-	}
++	netback_disconnect(&dev->dev);
+ 	kfree(be);
+ 	dev->dev.driver_data = NULL;
+ 	return 0;
+ }
+ 
++static void netback_disconnect(struct device *xbdev_dev)
++{
++        struct backend_info *be = xbdev_dev->driver_data;
++ 
++        if (be && be->netif) {
++                kobject_uevent(&xbdev_dev->kobj, KOBJ_OFFLINE);
++                netif_disconnect(be->netif);
++                be->netif = NULL;
++        }
++}
+ 
+ /**
+  * Entry point to this code when a new device is created.  Allocate the basic
+@@ -225,16 +233,17 @@ static void frontend_changed(struct xenbus_device *dev,
+ 		break;
+ 
+ 	case XenbusStateConnected:
++		if (dev->state == XenbusStateConnected)
++			break;
++
++		/* backend_create_netif() is idempotent */
+ 		backend_create_netif(be);
+ 		if (be->netif)
+ 			connect(be);
+ 		break;
+ 
+ 	case XenbusStateClosing:
+-		if (be->netif) {
+-			netif_disconnect(be->netif);
+-			be->netif = NULL;
+-		}
++		netback_disconnect(&dev->dev);
+ 		xenbus_switch_state(dev, XenbusStateClosing);
+ 		break;
+ 
+@@ -244,8 +253,7 @@ static void frontend_changed(struct xenbus_device *dev,
+ 			break;
+ 		/* fall through if not online */
+ 	case XenbusStateUnknown:
+-		if (be->netif != NULL)
+-			kobject_uevent(&dev->dev.kobj, KOBJ_OFFLINE);
++		/* implies netback_disconnect() via netback_remove() */
+ 		device_unregister(&dev->dev);
+ 		break;
+ 
