Canonical-kernel__Ubuntu-kernel
commit e06ea12ced820114ecee57d16b041dd2c2dac037
Author:     Linus Torvalds <torvalds@linux-foundation.org>
AuthorDate: Fri Aug 13 09:49:20 2010 -0700
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue Aug 17 15:27:32 2010 +0200

    x86: don't send SIGBUS for kernel page faults
    
    CVE-2010-2240
    
    It's wrong for several reasons, but the most direct one is that the
    fault may be for the stack accesses to set up a previous SIGBUS.  When
    we have a kernel exception, the kernel exception handler does all the
    fixups, not some user-level signal handler.
    
    Even apart from the nested SIGBUS issue, it's also wrong to give out
    kernel fault addresses in the signal handler info block, or to send a
    SIGBUS when a system call already returns EFAULT.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    (cherry-picked from commit 96054569190bdec375fe824e48ca1f4e3b53dd36 upstream)
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index bfae139182ff..736bc8dfe88b 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -807,8 +807,10 @@ do_sigbus(struct pt_regs *regs, unsigned long error_code, unsigned long address)
 	up_read(&mm->mmap_sem);
 
 	/* Kernel mode? Handle exceptions or die: */
-	if (!(error_code & PF_USER))
+	if (!(error_code & PF_USER)) {
 		no_context(regs, error_code, address);
+		return;
+	}
 
 	/* User-space => ok to do another page fault: */
 	if (is_prefetch(regs, error_code, address))
