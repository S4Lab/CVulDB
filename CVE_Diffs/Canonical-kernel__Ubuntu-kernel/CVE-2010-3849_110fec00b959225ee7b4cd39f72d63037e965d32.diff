Canonical-kernel__Ubuntu-kernel
commit 110fec00b959225ee7b4cd39f72d63037e965d32
Author:     Nelson Elhage <nelhage@ksplice.com>
AuthorDate: Mon Feb 28 10:40:54 2011 -0800
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Wed Mar 16 09:45:51 2011 -0700

    do_exit(): make sure that we run with get_fs() == USER_DS, CVE-2010-4258
    
    BugLink: http://bugs.launchpad.net/bugs/723945
    
    CVE-2010-4258
    
    If a user manages to trigger an oops with fs set to KERNEL_DS, fs is not
    otherwise reset before do_exit().  do_exit may later (via mm_release in
    fork.c) do a put_user to a user-controlled address, potentially allowing
    a user to leverage an oops into a controlled write into kernel memory.
    
    This is only triggerable in the presence of another bug, but this
    potentially turns a lot of DoS bugs into privilege escalations, so it's
    worth fixing.  I have proof-of-concept code which uses this bug along
    with CVE-2010-3849 to write a zero to an arbitrary kernel address, so
    I've tested that this is not theoretical.
    
    A more logical place to put this fix might be when we know an oops has
    occurred, before we call do_exit(), but that would involve changing
    every architecture, in multiple places.
    
    Let's just stick it in do_exit instead.
    
    [akpm@linux-foundation.org: update code comment]
    Signed-off-by: Nelson Elhage <nelhage@ksplice.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Brad Figg <brad.figg@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Acked-by: Andy Whitcroft <andy.whitcroft@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/kernel/exit.c b/kernel/exit.c
index 7248df91bc09..a22a2fef3dbb 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -933,6 +933,15 @@ fastcall NORET_TYPE void do_exit(long code)
 		ptrace_notify((PTRACE_EVENT_EXIT << 8) | SIGTRAP);
 	}
 
+	/*
+	 * If do_exit is called because this processes oopsed, it's possible
+	 * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before
+	 * continuing. Amongst other possible reasons, this is to prevent
+	 * mm_release()->clear_child_tid() from writing to a user-controlled
+	 * kernel address.
+	 */
+	set_fs(USER_DS);
+
 	/*
 	 * We're taking recursive faults here in do_exit. Safest is to just
 	 * leave this task alone and wait for reboot.
