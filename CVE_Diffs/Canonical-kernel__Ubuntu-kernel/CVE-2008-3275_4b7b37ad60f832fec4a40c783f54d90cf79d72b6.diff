Canonical-kernel__Ubuntu-kernel
commit 4b7b37ad60f832fec4a40c783f54d90cf79d72b6
Author:     Miklos Szeredi <mszeredi@suse.cz>
AuthorDate: Wed Jul 2 21:30:15 2008 +0200
Commit:     Kees Cook <kees@outflux.net>
CommitDate: Tue Aug 5 13:11:33 2008 -0700

    (CVE-2008-3275) vfs: fix lookup on deleted directory
    
    [linux-2.6: d70b67c8bc72ee23b55381bd6a884f4796692f77]
    
    Lookup can install a child dentry for a deleted directory.  This keeps
    the directory dentry alive, and the inode pinned in the cache and on
    disk, even after all external references have gone away.
    
    This isn't a big problem normally, since memory pressure or umount
    will clear out the directory dentry and its children, releasing the
    inode.  But for UBIFS this causes problems because its orphan area can
    overflow.
    
    Fix this by returning ENOENT for all lookups on a S_DEAD directory
    before creating a child dentry.
    
    Thanks to Zoltan Sogor for noticing this while testing UBIFS, and
    Artem for the excellent analysis of the problem and testing.
    
    Reported-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Tested-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Kees Cook <kees.cook@canonical.com>

diff --git a/fs/namei.c b/fs/namei.c
index 842c53269b1e..bc46762df7ca 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -510,7 +510,14 @@ static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, s
 	 */
 	result = d_lookup(parent, name);
 	if (!result) {
-		struct dentry * dentry = d_alloc(parent, name);
+		struct dentry *dentry;
+
+		/* Don't create child dentry for a dead directory. */
+		result = ERR_PTR(-ENOENT);
+		if (IS_DEADDIR(dir))
+			goto out_unlock;
+
+		dentry = d_alloc(parent, name);
 		result = ERR_PTR(-ENOMEM);
 		if (dentry) {
 			result = dir->i_op->lookup(dir, dentry, nd);
@@ -519,6 +526,7 @@ static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, s
 			else
 				result = dentry;
 		}
+out_unlock:
 		mutex_unlock(&dir->i_mutex);
 		return result;
 	}
@@ -1314,7 +1322,14 @@ struct dentry *__lookup_hash(struct qstr *name, struct dentry *base, struct name
 
 	dentry = cached_lookup(base, name, nd);
 	if (!dentry) {
-		struct dentry *new = d_alloc(base, name);
+		struct dentry *new;
+
+		/* Don't create child dentry for a dead directory. */
+		dentry = ERR_PTR(-ENOENT);
+		if (IS_DEADDIR(inode))
+			goto out;
+
+		new = d_alloc(base, name);
 		dentry = ERR_PTR(-ENOMEM);
 		if (!new)
 			goto out;
