Canonical-kernel__Ubuntu-kernel
commit 93409f9f8ff4afa03427a5dec11b0799668b6a44
Author:     Goldwyn Rodrigues <rgoldwyn@gmail.com>
AuthorDate: Tue Apr 26 09:00:12 2011 -0700
Commit:     Paolo Pisati <paolo.pisati@canonical.com>
CommitDate: Wed Jun 1 14:52:21 2011 +0200

    Treat writes as new when holes span across page boundaries, CVE-2011-0463
    
    BugLink: http://bugs.launchpad.net/bugs/770483
    
    CVE-2011-0463
    
    When a hole spans across page boundaries, the next write forces
    a read of the block. This could end up reading existing garbage
    data from the disk in ocfs2_map_page_blocks. This leads to
    non-zero holes. In order to avoid this, mark the writes as new
    when the holes span across page boundaries.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.de>
    Signed-off-by: jlbec <jlbec@evilplan.org>
    
    (cherry-pick of commit 272b62c1f0f6f742046e45b50b6fec98860208a0)
    Signed-off-by: Brad Figg <brad.figg@canonical.com>
    Acked-by: Leann Ogasawara <leann.ogasawara@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>

diff --git a/fs/ocfs2/aops.c b/fs/ocfs2/aops.c
index 356e976772bf..8b401813f37c 100644
--- a/fs/ocfs2/aops.c
+++ b/fs/ocfs2/aops.c
@@ -1034,6 +1034,12 @@ static int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,
 	ocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,
 					&cluster_start, &cluster_end);
 
+	/* treat the write as new if the a hole/lseek spanned across
+	 * the page boundary.
+	 */
+	new = new | ((i_size_read(inode) <= page_offset(page)) &&
+			(page_offset(page) <= user_pos));
+
 	if (page == wc->w_target_page) {
 		map_from = user_pos & (PAGE_CACHE_SIZE - 1);
 		map_to = map_from + user_len;
