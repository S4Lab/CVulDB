Canonical-kernel__Ubuntu-kernel
commit 1bfa7c5ecbf99ab9ccd83b0530f5fec23bc14c8f
Author:     Stefan Bader <stefan.bader@canonical.com>
AuthorDate: Tue Aug 24 09:48:51 2010 +0000
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Wed Aug 25 12:54:02 2010 +0000

    UBUNTU: mm: Use helper to find real vma with stack guard page
    
    CVE-2010-2240
    BugLink: http://bugs.launchpad.net/bugs/620994
    
    In both cases (mlock and /proc/<pid>/maps) only a vma that has no
    previous vma which is a continuation, will really contain the guard
    page. And only then adjustments should be made.
    
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 135a8632ded9..d20b58878e37 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -155,7 +155,7 @@ static int show_map_internal(struct seq_file *m, void *v, struct mem_size_stats
 
 	/* We don't show the stack guard page in /proc/maps */
 	start = vma->vm_start;
-	if (vma->vm_flags & VM_GROWSDOWN)
+	if (stack_guard_page(vma, start))
 		start += PAGE_SIZE;
 
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08lx %02x:%02x %lu %n",
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 15f624c1a9d0..ef0960434f83 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1071,6 +1071,28 @@ static inline unsigned long vma_pages(struct vm_area_struct *vma)
 	return (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 }
 
+static inline int stack_guard_page(struct vm_area_struct *vma,
+	unsigned long addr)
+{
+	struct vm_area_struct *prev;
+
+	/* No need to look further if addr is not the start of a stack vma */
+	if (!(vma->vm_flags & VM_GROWSDOWN) || vma->vm_start != addr)
+		return 0;
+
+	prev = find_vma(vma->vm_mm, addr - PAGE_SIZE);
+
+	/*
+	 * Only if there is no previous vma that is a continuation of this
+	 * vma, the current vma includes the guard page.
+	 */
+	if (!prev || !(prev->vm_flags & VM_GROWSDOWN) ||
+	    prev->vm_end != vma->vm_start)
+		return 1;
+
+	return 0;
+}
+
 pgprot_t vm_get_page_prot(unsigned long vm_flags);
 struct vm_area_struct *find_extend_vma(struct mm_struct *, unsigned long addr);
 struct page *vmalloc_to_page(void *addr);
diff --git a/mm/mlock.c b/mm/mlock.c
index 7de65b96cb3b..5700fec12e12 100644
--- a/mm/mlock.c
+++ b/mm/mlock.c
@@ -77,9 +77,8 @@ success:
 			 *  We don't try to access the guard page of a stack
 			 *  vma
 			 */
-			if (vma->vm_flags & VM_GROWSDOWN)
-				if (start == vma->vm_start)
-					start += PAGE_SIZE;
+			if (stack_guard_page(vma, start))
+				start += PAGE_SIZE;
 
 			ret = make_pages_present(start, end);
 		}
