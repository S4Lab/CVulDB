Canonical-kernel__Ubuntu-kernel
commit 1ba5059e010a56d3fc77097a171b1d8ed1704ef9
Author:     Eric Sandeen <sandeen@redhat.com>
AuthorDate: Mon Feb 20 17:53:01 2012 -0500
Commit:     Luis Henriques <luis.henriques@canonical.com>
CommitDate: Mon Apr 23 14:05:04 2012 +0100

    jbd2: clear BH_Delay & BH_Unwritten in journal_unmap_buffer
    
    journal_unmap_buffer()'s zap_buffer: code clears a lot of buffer head
    state ala discard_buffer(), but does not touch _Delay or _Unwritten as
    discard_buffer() does.
    
    This can be problematic in some areas of the ext4 code which assume
    that if they have found a buffer marked unwritten or delay, then it's
    a live one.  Perhaps those spots should check whether it is mapped
    as well, but if jbd2 is going to tear down a buffer, let's really
    tear it down completely.
    
    Without this I get some fsx failures on sub-page-block filesystems
    up until v3.2, at which point 4e96b2dbbf1d7e81f22047a50f862555a6cb87cb
    and 189e868fa8fdca702eb9db9d8afc46b5cb9144c9 make the failures go
    away, because buried within that large change is some more flag
    clearing.  I still think it's worth doing in jbd2, since
    ->invalidatepage leads here directly, and it's the right place
    to clear away these flags.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: stable@vger.kernel.org
    
    BugLink: http://bugs.launchpad.net/bugs/929781
    CVE-2011-4086
    
    (cherry-picked from 15291164b22a357cb211b618adfef4fa82fc0de3 upstream)
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>
    Acked-by: Herton Krzesinski <herton.krzesinski@canonical.com>
    Acked-by: Leann Ogasawara <leann.ogasawara@canonical.com>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c
index 1d1191050f99..82bb21353a73 100644
--- a/fs/jbd2/transaction.c
+++ b/fs/jbd2/transaction.c
@@ -1899,6 +1899,8 @@ zap_buffer_unlocked:
 	clear_buffer_mapped(bh);
 	clear_buffer_req(bh);
 	clear_buffer_new(bh);
+	clear_buffer_delay(bh);
+	clear_buffer_unwritten(bh);
 	bh->b_bdev = NULL;
 	return may_free;
 }
