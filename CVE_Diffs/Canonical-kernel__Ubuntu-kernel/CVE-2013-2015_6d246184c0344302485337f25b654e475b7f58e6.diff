Canonical-kernel__Ubuntu-kernel
commit 6d246184c0344302485337f25b654e475b7f58e6
Author:     Theodore Ts'o <tytso@mit.edu>
AuthorDate: Thu Dec 27 01:42:50 2012 -0500
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Thu Oct 17 11:49:38 2013 -0700

    ext4: avoid hang when mounting non-journal filesystems with orphan list
    
    BugLink: http://bugs.launchpad.net/bugs/1241093
    
    commit 0e9a9a1ad619e7e987815d20262d36a2f95717ca upstream.
    
    When trying to mount a file system which does not contain a journal,
    but which does have a orphan list containing an inode which needs to
    be truncated, the mount call with hang forever in
    ext4_orphan_cleanup() because ext4_orphan_del() will return
    immediately without removing the inode from the orphan list, leading
    to an uninterruptible loop in kernel code which will busy out one of
    the CPU's on the system.
    
    This can be trivially reproduced by trying to mount the file system
    found in tests/f_orphan_extents_inode/image.gz from the e2fsprogs
    source tree.  If a malicious user were to put this on a USB stick, and
    mount it on a Linux desktop which has automatic mounts enabled, this
    could be considered a potential denial of service attack.  (Not a big
    deal in practice, but professional paranoids worry about such things,
    and have even been known to allocate CVE numbers for such problems.)
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Reviewed-by: Zheng Liu <wenqing.lz@taobao.com>
    Cc: Jan Kara <jack@suse.cz>
    [ js: This is a fix for CVE-2013-2015. ]
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Brad Figg <brad.figg@canonical.com>

diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 43a35db86bf5..27a99f7ae390 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -2432,7 +2432,8 @@ int ext4_orphan_del(handle_t *handle, struct inode *inode)
 	int err = 0;
 
 	/* ext4_handle_valid() assumes a valid handle_t pointer */
-	if (handle && !ext4_handle_valid(handle))
+	if (handle && !ext4_handle_valid(handle) &&
+	    !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS))
 		return 0;
 
 	mutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);
