Canonical-kernel__Ubuntu-kernel
commit 4935e91f02ef1f28a440c9e6669861244ddb5602
Author:     Konstantin Khlebnikov <k.khlebnikov@samsung.com>
AuthorDate: Fri May 9 15:35:09 2014 +0100
Commit:     Luis Henriques <luis.henriques@canonical.com>
CommitDate: Thu May 22 15:50:31 2014 +0100

    ipc/msg: fix race around refcount
    
    In older kernels (before v3.10) ipc_rcu_hdr->refcount was non-atomic int.
    There was possuble double-free bug: do_msgsnd() calls ipc_rcu_putref() under
    msq->q_perm->lock and RCU, while freequeue() calls it while it holds only
    'rw_mutex', so there is no sinchronization between them. Two function
    decrements '2' non-atomically, they both can get '0' as result.
    
    do_msgsnd()                                     freequeue()
    
    msq = msg_lock_check(ns, msqid);
    ...
    ipc_rcu_getref(msq);
    msg_unlock(msq);
    schedule();
                                                    (caller locks spinlock)
                                                    expunge_all(msq, -EIDRM);
                                                    ss_wakeup(&msq->q_senders, 1);
                                                    msg_rmid(ns, msq);
                                                    msg_unlock(msq);
    ipc_lock_by_ptr(&msq->q_perm);
    ipc_rcu_putref(msq);                            ipc_rcu_putref(msq);
    < both may get get --(...)->refcount == 0 >
    
    This patch locks ipc_lock and RCU around ipc_rcu_putref in freequeue.
    ( RCU protects memory for spin_unlock() )
    
    Similar bugs might be in other users of ipc_rcu_putref().
    
    In the mainline this has been fixed in v3.10 indirectly in commmit
    6062a8dc0517bce23e3c2f7d2fea5e22411269a3
    ("ipc,sem: fine grained locking for semtimedop") by Rik van Riel.
    That commit optimized locking and converted refcount into atomic.
    
    I'm not sure that anybody should care about this bug: it's very-very unlikely
    and no longer exists in actual mainline. I've found this just by looking into
    the code, probably this never happens in real life.
    
    Signed-off-by: Konstantin Khlebnikov <k.khlebnikov@samsung.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    (cherry picked from 91182754daa6ca26dd2e97ee0b0f6e9e37d33324 3.2.y)
    CVE-2013-4483
    BugLink: http://bugs.launchpad.net/bugs/1248713
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Acked-by: Andy Whitcroft <andy.whitcroft@canonical.com>
    Acked-by: Brad Figg <brad.figg@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/ipc/msg.c b/ipc/msg.c
index 5fa44c9bd8e7..c48f821a7047 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -296,7 +296,9 @@ static void freeque(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)
 	}
 	atomic_sub(msq->q_cbytes, &ns->msg_bytes);
 	security_msg_queue_free(msq);
+	ipc_lock_by_ptr(&msq->q_perm);
 	ipc_rcu_putref(msq);
+	ipc_unlock(&msq->q_perm);
 }
 
 /*
