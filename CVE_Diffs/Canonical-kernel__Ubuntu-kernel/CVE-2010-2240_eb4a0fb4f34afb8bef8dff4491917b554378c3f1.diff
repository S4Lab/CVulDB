Canonical-kernel__Ubuntu-kernel
commit eb4a0fb4f34afb8bef8dff4491917b554378c3f1
Author:     Linus Torvalds <torvalds@linux-foundation.org>
AuthorDate: Thu Aug 12 17:54:33 2010 -0700
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue Aug 17 12:43:43 2010 +0200

    mm: keep a guard page below a grow-down stack segment
    
    CVE-2010-2240
    
    This is a rather minimally invasive patch to solve the problem of the
    user stack growing into a memory mapped area below it.  Whenever we fill
    the first page of the stack segment, expand the segment down by one
    page.
    
    Now, admittedly some odd application might _want_ the stack to grow down
    into the preceding memory mapping, and so we may at some point need to
    make this a process tunable (some people might also want to have more
    than a single page of guarding), but let's try the minimal approach
    first.
    
    Tested with trivial application that maps a single page just below the
    stack, and then starts recursing.  Without this, we will get a SIGSEGV
    _after_ the stack has smashed the mapping.  With this patch, we'll get a
    nice SIGBUS just as the stack touches the page just above the mapping.
    
    Requested-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    (cherry-picked from commit 320b2b8de12698082609ebbc1a17165727f4c893 upstream)
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/mm/memory.c b/mm/memory.c
index b19d122ab274..478b9c37b21f 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2174,6 +2174,26 @@ out_nomap:
 	return ret;
 }
 
+/*
+ * This is like a special single-page "expand_downwards()",
+ * except we must first make sure that 'address-PAGE_SIZE'
+ * doesn't hit another vma.
+ *
+ * The "find_vma()" will do the right thing even if we wrap
+ */
+static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)
+{
+	address &= PAGE_MASK;
+	if ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {
+		address -= PAGE_SIZE;
+		if (find_vma(vma->vm_mm, address) != vma)
+			return -ENOMEM;
+
+		expand_stack(vma, address);
+	}
+	return 0;
+}
+
 /*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
@@ -2187,6 +2207,9 @@ static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 	spinlock_t *ptl;
 	pte_t entry;
 
+	if (check_stack_guard_page(vma, address) < 0)
+		return VM_FAULT_SIGBUS;
+
 	/* Allocate our own private page. */
 	pte_unmap(page_table);
 
