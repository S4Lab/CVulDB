Canonical-kernel__Ubuntu-kernel
commit 8eaacd3164a31cd3d2812f40e0ed7a8141559073
Author:     Leann Ogasawara <leann.ogasawara@canonical.com>
AuthorDate: Thu Oct 8 07:18:16 2009 -0700
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Wed Oct 14 17:22:39 2009 +0200

    capabilities: move cap_file_mmap to commoncap.c
    
    CVE-2009-2695
    
    commit 9c0d90103c7e0eb6e638e5b649e9f6d8d9c1b4b3 upstream
    
    Currently we duplicate the mmap_min_addr test in cap_file_mmap and in
    security_file_mmap if !CONFIG_SECURITY.  This patch moves cap_file_mmap
    into commoncap.c and then calls that function directly from
    security_file_mmap ifndef CONFIG_SECURITY like all of the other
    capability
    checks are done.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/include/linux/security.h b/include/linux/security.h
index f5acf41b8934..36ef302a8ffb 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -60,6 +60,9 @@ extern int cap_inode_setxattr(struct dentry *dentry, struct vfsmount *mnt, char
 extern int cap_inode_removexattr(struct dentry *dentry, struct vfsmount *mnt, char *name, struct file *file);
 extern int cap_inode_need_killpriv(struct dentry *dentry);
 extern int cap_inode_killpriv(struct dentry *dentry);
+extern int cap_file_mmap(struct file *file, unsigned long reqprot,
+			unsigned long prot, unsigned long flags,
+			unsigned long addr, unsigned long addr_only);
 extern int cap_task_post_setuid (uid_t old_ruid, uid_t old_euid, uid_t old_suid, int flags);
 extern void cap_task_reparent_to_init (struct task_struct *p);
 extern int cap_task_setscheduler (struct task_struct *p, int policy, struct sched_param *lp);
diff --git a/security/commoncap.c b/security/commoncap.c
index e9f9889ed65b..c5797413ebd6 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -569,3 +569,32 @@ int cap_vm_enough_memory(struct mm_struct *mm, long pages)
 	return __vm_enough_memory(mm, pages, cap_sys_admin);
 }
 
+/*
+ * cap_file_mmap - check if able to map given addr
+ * @file: unused
+ * @reqprot: unused
+ * @prot: unused
+ * @flags: unused
+ * @addr: address attempting to be mapped
+ * @addr_only: unused
+ *
+ * If the process is attempting to map memory below mmap_min_addr they need
+ * CAP_SYS_RAWIO.  The other parameters to this function are unused by the
+ * capability security module.  Returns 0 if this mapping should be allowed
+ * -EPERM if not.
+ */
+int cap_file_mmap(struct file *file, unsigned long reqprot,
+		unsigned long prot, unsigned long flags,
+		unsigned long addr, unsigned long addr_only)
+{
+	int ret = 0;
+
+	if (addr < mmap_min_addr) {
+		ret = cap_capable(current, CAP_SYS_RAWIO);
+		/* set PF_SUPERPRIV if it turns out we allow the low mmap */
+		if (ret == 0)
+			current->flags |= PF_SUPERPRIV;
+	}
+	return ret;
+}
+
