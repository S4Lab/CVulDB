Canonical-kernel__Ubuntu-kernel
commit 917464ae723c687f3d92e8078926be4f43413815
Author:     Dan Rosenberg <dan.j.rosenberg@gmail.com>
AuthorDate: Mon Jul 19 16:58:20 2010 -0400
Commit:     Leann Ogasawara <leann.ogasawara@canonical.com>
CommitDate: Tue Nov 30 20:26:40 2010 -0800

    Btrfs: fix checks in BTRFS_IOC_CLONE_RANGE
    
    CVE-2010-2537
    CVE-2010-2538
    
    1.  The BTRFS_IOC_CLONE and BTRFS_IOC_CLONE_RANGE ioctls should check
    whether the donor file is append-only before writing to it.
    
    2.  The BTRFS_IOC_CLONE_RANGE ioctl appears to have an integer
    overflow that allows a user to specify an out-of-bounds range to copy
    from the source file (if off + len wraps around).  I haven't been able
    to successfully exploit this, but I'd imagine that a clever attacker
    could use this to read things he shouldn't.  Even if it's not
    exploitable, it couldn't hurt to be safe.
    
    Signed-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>
    cc: stable@kernel.org
    Signed-off-by: Chris Mason <chris.mason@oracle.com>
    (cherry picked from commit 2ebc3464781ad24474abcbd2274e6254689853b5)
    
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index 582785b13bb0..2e47b2d36325 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -895,7 +895,7 @@ static long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
 	 */
 
 	/* the destination must be opened for writing */
-	if (!(file->f_mode & FMODE_WRITE))
+	if (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))
 		return -EINVAL;
 
 	ret = mnt_want_write(file->f_path.mnt);
@@ -948,7 +948,7 @@ static long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
 
 	/* determine range to clone */
 	ret = -EINVAL;
-	if (off >= src->i_size || off + len > src->i_size)
+	if (off + len > src->i_size || off + len < off)
 		goto out_unlock;
 	if (len == 0)
 		olen = len = src->i_size - off;
