Canonical-kernel__Ubuntu-kernel
commit a2ae629e17c68054a6b1356875d53b886a313a16
Author:     Kees Cook <keescook@chromium.org>
AuthorDate: Tue Nov 12 15:11:17 2013 -0800
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Mon Jan 6 11:29:15 2014 -0800

    exec/ptrace: fix get_dumpable() incorrect tests
    
    BugLink: http://bugs.launchpad.net/bugs/1266546
    
    commit d049f74f2dbe71354d43d393ac3a188947811348 upstream.
    
    The get_dumpable() return value is not boolean.  Most users of the
    function actually want to be testing for non-SUID_DUMP_USER(1) rather than
    SUID_DUMP_DISABLE(0).  The SUID_DUMP_ROOT(2) is also considered a
    protected state.  Almost all places did this correctly, excepting the two
    places fixed in this patch.
    
    Wrong logic:
        if (dumpable == SUID_DUMP_DISABLE) { /* be protective */ }
            or
        if (dumpable == 0) { /* be protective */ }
            or
        if (!dumpable) { /* be protective */ }
    
    Correct logic:
        if (dumpable != SUID_DUMP_USER) { /* be protective */ }
            or
        if (dumpable != 1) { /* be protective */ }
    
    Without this patch, if the system had set the sysctl fs/suid_dumpable=2, a
    user was able to ptrace attach to processes that had dropped privileges to
    that user.  (This may have been partially mitigated if Yama was enabled.)
    
    The macros have been moved into the file that declares get/set_dumpable(),
    which means things like the ia64 code can see them too.
    
    CVE-2013-2929
    
    Reported-by: Vasily Kulikov <segoon@openwall.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    [bwh: Backported to 3.2: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Brad Figg <brad.figg@canonical.com>

diff --git a/arch/ia64/include/asm/processor.h b/arch/ia64/include/asm/processor.h
index d9f397fae03e..fba7696368d4 100644
--- a/arch/ia64/include/asm/processor.h
+++ b/arch/ia64/include/asm/processor.h
@@ -320,7 +320,7 @@ struct thread_struct {
 	regs->loadrs = 0;									\
 	regs->r8 = get_dumpable(current->mm);	/* set "don't zap registers" flag */		\
 	regs->r12 = new_sp - 16;	/* allocate 16 byte scratch area */			\
-	if (unlikely(!get_dumpable(current->mm))) {							\
+	if (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) {	\
 		/*										\
 		 * Zap scratch regs to avoid leaking bits between processes with different	\
 		 * uid/privileges.								\
diff --git a/fs/exec.c b/fs/exec.c
index 60b68d8589ad..25a52322ef59 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -2044,6 +2044,12 @@ static int __get_dumpable(unsigned long mm_flags)
 	return (ret >= 2) ? 2 : ret;
 }
 
+/*
+ * This returns the actual value of the suid_dumpable flag. For things
+ * that are using this for checking for privilege transitions, it must
+ * test against SUID_DUMP_USER rather than treating it as a boolean
+ * value.
+ */
 int get_dumpable(struct mm_struct *mm)
 {
 	return __get_dumpable(mm->flags);
diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h
index acd8d4bf161c..d337419e9e32 100644
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@ -112,9 +112,6 @@ extern void setup_new_exec(struct linux_binprm * bprm);
 extern void would_dump(struct linux_binprm *, struct file *);
 
 extern int suid_dumpable;
-#define SUID_DUMP_DISABLE	0	/* No setuid dumping */
-#define SUID_DUMP_USER		1	/* Dump as user of process */
-#define SUID_DUMP_ROOT		2	/* Dump as root */
 
 /* Stack area protections */
 #define EXSTACK_DEFAULT   0	/* Whatever the arch defaults to */
diff --git a/include/linux/sched.h b/include/linux/sched.h
index a007ca39ecb5..9d0ed9c990ac 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -410,6 +410,10 @@ static inline void arch_pick_mmap_layout(struct mm_struct *mm) {}
 extern void set_dumpable(struct mm_struct *mm, int value);
 extern int get_dumpable(struct mm_struct *mm);
 
+#define SUID_DUMP_DISABLE	0	/* No setuid dumping */
+#define SUID_DUMP_USER		1	/* Dump as user of process */
+#define SUID_DUMP_ROOT		2	/* Dump as root */
+
 /* mm flags */
 /* dumpable bits */
 #define MMF_DUMPABLE      0  /* core dump is permitted */
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index f71db7cc4ab7..2d5889da1d1f 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -246,7 +246,8 @@ ok:
 	smp_rmb();
 	if (task->mm)
 		dumpable = get_dumpable(task->mm);
-	if (!dumpable && !task_ns_capable(task, CAP_SYS_PTRACE))
+	if (dumpable != SUID_DUMP_USER &&
+	    !task_ns_capable(task, CAP_SYS_PTRACE))
 		return -EPERM;
 
 	return security_ptrace_access_check(task, mode);
