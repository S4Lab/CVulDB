Canonical-kernel__Ubuntu-kernel
commit ec20e1f43d20a46398de07a4ef98b5cad887799f
Author:     Luis Henriques <luis.henriques@canonical.com>
AuthorDate: Mon Jul 14 16:29:09 2014 +0100
Commit:     Luis Henriques <luis.henriques@canonical.com>
CommitDate: Mon Jul 14 16:34:56 2014 +0100

    l2tp: Privilege escalation in ppp over l2tp sockets
    
    The l2tp call-down to udp_prot.[gs]etsockopt() is entirely broken, as
    reported by Sasha, since the socket in question isn't an ip socket, so
    when the IP code does either
    
            struct udp_sock *up = udp_sk(sk);
    or
            struct inet_sock *inet = inet_sk(sk);
    
    it basically gets random contents and accesses random kernel memory as a
    result.
    
    The suggested patch is trivial, and presumed to not break anything (since
    the random udp_sock/inet_sock accesses couldn't really do anything
    useful).
    
    This is CVE-2014-4943: an unprivileged user to kernel privilege escalation
    when CONFIG_PPPOL2TP is enabled.
    
    Signed-off-by: Marc Deslauriers <marc.deslauriers@canonical.com>
    Acked-by: Andy Whitcroft <andy.whitcroft@canonical.com>
    CVE-2014-4943
    BugLink: http://bugs.launchpad.net/bugs/1341472
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

diff --git a/drivers/net/pppol2tp.c b/drivers/net/pppol2tp.c
index 4cdc1cf9fb0f..4c8f019e7b9a 100644
--- a/drivers/net/pppol2tp.c
+++ b/drivers/net/pppol2tp.c
@@ -2190,7 +2190,7 @@ static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,
 	int err;
 
 	if (level != SOL_PPPOL2TP)
-		return udp_prot.setsockopt(sk, level, optname, optval, optlen);
+		return -EINVAL;
 
 	if (optlen < sizeof(int))
 		return -EINVAL;
@@ -2314,7 +2314,7 @@ static int pppol2tp_getsockopt(struct socket *sock, int level,
 	int err;
 
 	if (level != SOL_PPPOL2TP)
-		return udp_prot.getsockopt(sk, level, optname, optval, optlen);
+		return -EINVAL;
 
 	if (get_user(len, (int __user *) optlen))
 		return -EFAULT;
