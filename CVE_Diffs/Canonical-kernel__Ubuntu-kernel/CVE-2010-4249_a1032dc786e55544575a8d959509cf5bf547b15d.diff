Canonical-kernel__Ubuntu-kernel
commit a1032dc786e55544575a8d959509cf5bf547b15d
Author:     Eric Dumazet <eric.dumazet@gmail.com>
AuthorDate: Wed Nov 24 09:15:27 2010 -0800
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Thu Jan 6 10:06:55 2011 -0800

    af_unix: limit unix_tot_inflight
    
    CVE-2010-4249
    
    Vegard Nossum found a unix socket OOM was possible, posting an exploit
    program.
    
    My analysis is we can eat all LOWMEM memory before unix_gc() being
    called from unix_release_sock(). Moreover, the thread blocked in
    unix_gc() can consume huge amount of time to perform cleanup because of
    huge working set.
    
    One way to handle this is to have a sensible limit on unix_tot_inflight,
    tested from wait_for_unix_gc() and to force a call to unix_gc() if this
    limit is hit.
    
    This solves the OOM and also reduce overall latencies, and should not
    slowdown normal workloads.
    
    Reported-by: Vegard Nossum <vegard.nossum@gmail.com>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Brad Figg <brad.figg@canonical.com>

diff --git a/net/unix/garbage.c b/net/unix/garbage.c
index 19c17e4a0c8b..736e6f94c282 100644
--- a/net/unix/garbage.c
+++ b/net/unix/garbage.c
@@ -269,9 +269,16 @@ static void inc_inflight_move_tail(struct unix_sock *u)
 }
 
 static bool gc_in_progress = false;
+#define UNIX_INFLIGHT_TRIGGER_GC 16000
 
 void wait_for_unix_gc(void)
 {
+	/*
+	 * If number of inflight sockets is insane,
+	 * force a garbage collect right now.
+	 */
+	if (unix_tot_inflight > UNIX_INFLIGHT_TRIGGER_GC && !gc_in_progress)
+		unix_gc();
 	wait_event(unix_gc_wait, gc_in_progress == false);
 }
 
