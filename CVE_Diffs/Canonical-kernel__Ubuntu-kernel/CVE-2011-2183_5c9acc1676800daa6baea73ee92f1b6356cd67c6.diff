Canonical-kernel__Ubuntu-kernel
commit 5c9acc1676800daa6baea73ee92f1b6356cd67c6
Author:     Hugh Dickins <hughd@google.com>
AuthorDate: Fri Oct 14 17:48:45 2011 +0200
Commit:     Tim Gardner <tim.gardner@canonical.com>
CommitDate: Sat Oct 15 04:43:09 2011 -0600

    ksm: fix NULL pointer dereference in scan_get_next_rmap_item() - CVE-2011-2183
    
    Andrea Righi reported a case where an exiting task can race against
    ksmd::scan_get_next_rmap_item (http://lkml.org/lkml/2011/6/1/742) easily
    triggering a NULL pointer dereference in ksmd.
    
    ksm_scan.mm_slot == &ksm_mm_head with only one registered mm
    
    CPU 1 (__ksm_exit)              CPU 2 (scan_get_next_rmap_item)
                                    list_empty() is false
    lock                            slot == &ksm_mm_head
    list_del(slot->mm_list)
    (list now empty)
    unlock
                                    lock
                                    slot = list_entry(slot->mm_list.next)
                                    (list is empty, so slot is still ksm_mm_head)
                                    unlock
                                    slot->mm == NULL ... Oops
    
    Close this race by revalidating that the new slot is not simply the list
    head again.
    
    Andrea's test case:
    
    int main(int argc, char **argv)
    {
            void *ptr;
    
            if (posix_memalign(&ptr, getpagesize(), BUFSIZE) < 0) {
                    perror("posix_memalign");
                    exit(1);
            }
            if (madvise(ptr, BUFSIZE, MADV_MERGEABLE) < 0) {
                    perror("madvise");
                    exit(1);
            }
            *(char *)NULL = 0;
    
            return 0;
    }
    
    Reported-by: Andrea Righi <andrea@betterlinux.com>
    Tested-by: Andrea Righi <andrea@betterlinux.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
    CVE-2011-2183
    
    (cherry picked from commit 2b472611a32a72f4a118c069c2d62a1a3f087afd)
    
    BugLink: http://bugs.launchpad.net/bugs/869227
    
    Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Acked-by: Herton Krzesinski <herton.krzesinski@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/mm/ksm.c b/mm/ksm.c
index c2b2a94f9d67..37e176cf254e 100644
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -1314,6 +1314,12 @@ static struct rmap_item *scan_get_next_rmap_item(struct page **page)
 		slot = list_entry(slot->mm_list.next, struct mm_slot, mm_list);
 		ksm_scan.mm_slot = slot;
 		spin_unlock(&ksm_mmlist_lock);
+		/*
+		 * Although we tested list_empty() above, a racing __ksm_exit
+		 * of the last mm on the list may have removed it since then.
+		 */
+		if (slot == &ksm_mm_head)
+			return NULL;
 next_mm:
 		ksm_scan.address = 0;
 		ksm_scan.rmap_list = &slot->rmap_list;
