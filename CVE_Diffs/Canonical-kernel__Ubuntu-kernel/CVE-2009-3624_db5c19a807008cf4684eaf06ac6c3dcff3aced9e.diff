Canonical-kernel__Ubuntu-kernel
commit db5c19a807008cf4684eaf06ac6c3dcff3aced9e
Author:     David Howells <dhowells@redhat.com>
AuthorDate: Thu Oct 15 10:14:35 2009 +0100
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Wed Dec 2 10:54:16 2009 +0100

    KEYS: get_instantiation_keyring() should inc the keyring refcount in all cases
    
    CVE-2009-3624
    
    The destination keyring specified to request_key() and co. is made available to
    the process that instantiates the key (the slave process started by
    /sbin/request-key typically).  This is passed in the request_key_auth struct as
    the dest_keyring member.
    
    keyctl_instantiate_key and keyctl_negate_key() call get_instantiation_keyring()
    to get the keyring to attach the newly constructed key to at the end of
    instantiation.  This may be given a specific keyring into which a link will be
    made later, or it may be asked to find the keyring passed to request_key().  In
    the former case, it returns a keyring with the refcount incremented by
    lookup_user_key(); in the latter case, it returns the keyring from the
    request_key_auth struct - and does _not_ increment the refcount.
    
    The latter case will eventually result in an oops when the keyring prematurely
    runs out of references and gets destroyed.  The effect may take some time to
    show up as the key is destroyed lazily.
    
    To fix this, the keyring returned by get_instantiation_keyring() must always
    have its refcount incremented, no matter where it comes from.
    
    This can be tested by setting /etc/request-key.conf to:
    
    create  *       test:*          *               |/bin/false %u %g %d %{user:_display}
    negate  *       *               *               /bin/keyctl negate %k 10 @u
    
    and then doing:
    
            keyctl add user _display aaaaaaaa @u
            while keyctl request2 user test:x test:x @u &&
            keyctl list @u;
            do
                    keyctl request2 user test:x test:x @u;
                    sleep 31;
                    keyctl list @u;
            done
    
    which will oops eventually.  Changing the negate line to have @u rather than
    %S at the end is important as that forces the latter case by passing a special
    keyring ID rather than an actual keyring ID.
    
    Reported-by: Alexander Zangerl <az@bond.edu.au>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Alexander Zangerl <az@bond.edu.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    (cherry picked from commit 21279cfa107af07ef985539ac0de2152b9cba5f5)
    
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index 7f09fb897d2b..667aecd0fe52 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -860,7 +860,7 @@ static long get_instantiation_keyring(key_serial_t ringid,
 	/* otherwise specify the destination keyring recorded in the
 	 * authorisation key (any KEY_SPEC_*_KEYRING) */
 	if (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {
-		*_dest_keyring = rka->dest_keyring;
+		*_dest_keyring = key_get(rka->dest_keyring);
 		return 0;
 	}
 
