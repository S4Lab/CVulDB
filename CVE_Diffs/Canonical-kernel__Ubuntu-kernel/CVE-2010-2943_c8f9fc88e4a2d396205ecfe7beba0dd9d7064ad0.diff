Canonical-kernel__Ubuntu-kernel
commit c8f9fc88e4a2d396205ecfe7beba0dd9d7064ad0
Author:     Dave Chinner <dchinner@redhat.com>
AuthorDate: Thu Jun 24 11:15:47 2010 +1000
Commit:     Leann Ogasawara <leann.ogasawara@canonical.com>
CommitDate: Wed Dec 1 08:54:29 2010 -0800

    xfs: rename XFS_IGET_BULKSTAT to XFS_IGET_UNTRUSTED
    
    CVE-2010-2943
    
    Inode numbers may come from somewhere external to the filesystem
    (e.g. file handles, bulkstat information) and so are inherently
    untrusted. Rename the flag we use for these lookups to make it
    obvious we are doing a lookup of an untrusted inode number and need
    to verify it completely before trying to read it from disk.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    (backported from commit 1920779e67cbf5ea8afef317777c5bf2b8096188)
    
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/fs/xfs/xfs_ialloc.c b/fs/xfs/xfs_ialloc.c
index 5c456231883f..f37e9353fb53 100644
--- a/fs/xfs/xfs_ialloc.c
+++ b/fs/xfs/xfs_ialloc.c
@@ -1236,8 +1236,11 @@ xfs_dilocate(
 	if (agno >= mp->m_sb.sb_agcount || agbno >= mp->m_sb.sb_agblocks ||
 	    ino != XFS_AGINO_TO_INO(mp, agno, agino)) {
 #ifdef DEBUG
-		/* no diagnostics for bulkstat, ino comes from userspace */
-		if (flags & XFS_IMAP_BULKSTAT)
+		/*
+		 * Don't output diagnostic information for untrusted inodes
+		 * as they can be invalid without implying corruption.
+		 */
+		if (flags & XFS_IGET_UNTRUSTED)
 			return XFS_ERROR(EINVAL);
 		if (agno >= mp->m_sb.sb_agcount) {
 			xfs_fs_cmn_err(CE_ALERT, mp,
@@ -1273,7 +1276,7 @@ xfs_dilocate(
 	 * inodes in stale state on disk. Hence we have to do a btree lookup
 	 * in all cases where an untrusted inode number is passed.
 	 */
-	if (flags & XFS_IGET_BULKSTAT) {
+	if (flags & XFS_IGET_UNTRUSTED) {
 		error = xfs_imap_lookup(mp, tp, agno, agino, agbno,
 					&chunk_agbno, &offset_agbno, flags);
 		if (error)
diff --git a/fs/xfs/xfs_iget.c b/fs/xfs/xfs_iget.c
index fb69ef180b27..e61a34871c15 100644
--- a/fs/xfs/xfs_iget.c
+++ b/fs/xfs/xfs_iget.c
@@ -228,7 +228,7 @@ finish_inode:
 	 * a new vnode for it. This should also initialize i_ino and i_mount.
 	 */
 	error = xfs_iread(mp, tp, ino, &ip, bno,
-			  (flags & XFS_IGET_BULKSTAT) ? XFS_IMAP_BULKSTAT : 0);
+			  (flags & XFS_IGET_UNTRUSTED) ? XFS_IMAP_BULKSTAT : 0);
 	if (error) {
 		xfs_put_perag(mp, pag);
 		return error;
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 344948082819..66f209e3b3c6 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -344,7 +344,7 @@ xfs_itobp(
 		if (unlikely(XFS_TEST_ERROR(!di_ok, mp,
 						XFS_ERRTAG_ITOBP_INOTOBP,
 						XFS_RANDOM_ITOBP_INOTOBP))) {
-			if (imap_flags & XFS_IMAP_BULKSTAT) {
+			if (imap_flags & XFS_IGET_UNTRUSTED) {
 				xfs_trans_brelse(tp, bp);
 				return XFS_ERROR(EINVAL);
 			}
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index e5aff929cc65..49e52c4ca31d 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -500,7 +500,7 @@ xfs_iflags_test_and_clear(xfs_inode_t *ip, unsigned short flags)
  * Flags for xfs_iget()
  */
 #define XFS_IGET_CREATE		0x1
-#define XFS_IGET_BULKSTAT	0x2
+#define XFS_IGET_UNTRUSTED	0x2
 
 /*
  * xfs_iget.c prototypes.
diff --git a/fs/xfs/xfs_itable.c b/fs/xfs/xfs_itable.c
index 9fc4c2886529..6a60153cacb7 100644
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@ -63,7 +63,7 @@ xfs_bulkstat_one_iget(
 	int		error;
 
 	error = xfs_iget(mp, NULL, ino,
-			 XFS_IGET_BULKSTAT, XFS_ILOCK_SHARED, &ip, bno);
+			 XFS_IGET_UNTRUSTED, XFS_ILOCK_SHARED, &ip, bno);
 	if (error) {
 		*stat = BULKSTAT_RV_NOTHING;
 		return error;
