Canonical-kernel__Ubuntu-kernel
commit 98405ef0bc2af2605007f8fb5e8986e9fb7de5a9
Author:     Roland McGrath <roland@redhat.com>
AuthorDate: Fri Feb 27 19:03:24 2009 -0800
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Wed Mar 18 17:37:16 2009 +0100

    x86-64: syscall-audit: fix 32/64 syscall hole
    
    CVE-2009-0834
    
    commit ccbe495caa5e604b04d5a31d7459a6f6a76a756c upstream
    
    On x86-64, a 32-bit process (TIF_IA32) can switch to 64-bit mode with
    ljmp, and then use the "syscall" instruction to make a 64-bit system
    call.  A 64-bit process make a 32-bit system call with int $0x80.
    
    In both these cases, audit_syscall_entry() will use the wrong system
    call number table and the wrong system call argument registers.  This
    could be used to circumvent a syscall audit configuration that filters
    based on the syscall numbers or argument details.
    
    Signed-off-by: Roland McGrath <roland@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/arch/x86/kernel/ptrace_64.c b/arch/x86/kernel/ptrace_64.c
index 607085f3f08a..964d607c277c 100644
--- a/arch/x86/kernel/ptrace_64.c
+++ b/arch/x86/kernel/ptrace_64.c
@@ -585,6 +585,12 @@ static void syscall_trace(struct pt_regs *regs)
 	}
 }
 
+#if defined CONFIG_IA32_EMULATION
+# define IS_IA32	is_compat_task()
+#else
+# define IS_IA32	0
+#endif
+
 asmlinkage void syscall_trace_enter(struct pt_regs *regs)
 {
 	/* do the secure computing check first */
@@ -595,7 +601,7 @@ asmlinkage void syscall_trace_enter(struct pt_regs *regs)
 		syscall_trace(regs);
 
 	if (unlikely(current->audit_context)) {
-		if (test_thread_flag(TIF_IA32)) {
+		if (IS_IA32) {
 			audit_syscall_entry(AUDIT_ARCH_I386,
 					    regs->orig_rax,
 					    regs->rbx, regs->rcx,
