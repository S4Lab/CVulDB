Canonical-kernel__Ubuntu-kernel
commit b5c05fd73228da3f22c1407a913cb2f08c0ef22c
Author:     Gleb Natapov <gleb@redhat.com>
AuthorDate: Thu Dec 12 21:20:08 2013 +0100
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Tue Feb 11 09:33:57 2014 -0800

    KVM: x86: fix guest-initiated crash with x2apic (CVE-2013-6376)
    
    BugLink: http://bugs.launchpad.net/bugs/1278969
    
    commit 17d68b763f09a9ce824ae23eb62c9efc57b69271 upstream.
    
    A guest can cause a BUG_ON() leading to a host kernel crash.
    When the guest writes to the ICR to request an IPI, while in x2apic
    mode the following things happen, the destination is read from
    ICR2, which is a register that the guest can control.
    
    kvm_irq_delivery_to_apic_fast uses the high 16 bits of ICR2 as the
    cluster id.  A BUG_ON is triggered, which is a protection against
    accessing map->logical_map with an out-of-bounds access and manages
    to avoid that anything really unsafe occurs.
    
    The logic in the code is correct from real HW point of view. The problem
    is that KVM supports only one cluster with ID 0 in clustered mode, but
    the code that has the bug does not take this into account.
    
    Reported-by: Lars Bull <larsbull@google.com>
    Signed-off-by: Gleb Natapov <gleb@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Kamal Mostafa <kamal@canonical.com>
    Signed-off-by: Brad Figg <brad.figg@canonical.com>

diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index b8a559b40d50..360aed5ddcc7 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -167,6 +167,8 @@ static inline u16 apic_logical_id(struct kvm_apic_map *map, u32 ldr)
 	return ldr & map->lid_mask;
 }
 
+#define KVM_X2APIC_CID_BITS 0
+
 static void recalculate_apic_map(struct kvm *kvm)
 {
 	struct kvm_apic_map *new, *old = NULL;
@@ -204,7 +206,8 @@ static void recalculate_apic_map(struct kvm *kvm)
 		if (apic_x2apic_mode(apic)) {
 			new->ldr_bits = 32;
 			new->cid_shift = 16;
-			new->cid_mask = new->lid_mask = 0xffff;
+			new->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;
+			new->lid_mask = 0xffff;
 		} else if (kvm_apic_sw_enabled(apic) &&
 				!new->cid_mask /* flat mode */ &&
 				kvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {
