Canonical-kernel__Ubuntu-kernel
commit cb9bd9588e28401ba2d566e813746232bb8fa38b
Author:     Clément Lecigne <clement.lecigne@netasq.com>
AuthorDate: Thu Feb 12 16:59:09 2009 -0800
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue Mar 17 21:34:41 2009 +0100

    net: 4 bytes kernel memory disclosure in SO_BSDCOMPAT gsopt try #2
    
    CVE-2009-0676
    
    commit df0bca049d01c0ee94afb7cd5dfd959541e6c8da upstream
    
    In function sock_getsockopt() located in net/core/sock.c, optval v.val
    is not correctly initialized and directly returned in userland in case
    we have SO_BSDCOMPAT option set.
    
    This dummy code should trigger the bug:
    
    int main(void)
    {
            unsigned char buf[4] = { 0, 0, 0, 0 };
            int len;
            int sock;
            sock = socket(33, 2, 2);
            getsockopt(sock, 1, SO_BSDCOMPAT, &buf, &len);
            printf("%x%x%x%x\n", buf[0], buf[1], buf[2], buf[3]);
            close(sock);
    }
    
    Here is a patch that fix this bug by initalizing v.val just after its
    declaration.
    
    Signed-off-by: Clément Lecigne <clement.lecigne@netasq.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/net/core/sock.c b/net/core/sock.c
index c519b439b8b1..b0e5208b18d3 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -691,6 +691,8 @@ int sock_getsockopt(struct socket *sock, int level, int optname,
 	if (len < 0)
 		return -EINVAL;
 
+	v.val = 0;
+
 	switch(optname) {
 	case SO_DEBUG:
 		v.val = sock_flag(sk, SOCK_DBG);
