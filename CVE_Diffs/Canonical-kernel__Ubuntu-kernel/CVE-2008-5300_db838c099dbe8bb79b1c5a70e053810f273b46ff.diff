Canonical-kernel__Ubuntu-kernel
commit db838c099dbe8bb79b1c5a70e053810f273b46ff
Author:     dann frazier <dannf@hp.com>
AuthorDate: Sat Jan 17 16:01:36 2009 +0100
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Sat Jan 17 16:01:41 2009 +0100

    net: Fix soft lockups/OOM issues w/ unix garbage collector
    
    CVE-2008-5300
    
    commit 5f23b734963ec7eaa3ebcd9050da0c9b7d143dd3 upstream
    
    This is an implementation of David Miller's suggested fix in:
      https://bugzilla.redhat.com/show_bug.cgi?id=470201
    
    It has been updated to use wait_event() instead of
    wait_event_interruptible().
    
    Paraphrasing the description from the above report, it makes sendmsg()
    block while UNIX garbage collection is in progress. This avoids a
    situation where child processes continue to queue new FDs over a
    AF_UNIX socket to a parent which is in the exit path and running
    garbage collection on these FDs. This contention can result in soft
    lockups and oom-killing of unrelated processes.
    
    Signed-off-by: dann frazier <dannf@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/debian/binary-custom.d/openvz/patchset/0001-2.6.24-ovz002.patch b/debian/binary-custom.d/openvz/patchset/0001-2.6.24-ovz002.patch
index 6d4bdae625a6..3b8ce584afba 100644
--- a/debian/binary-custom.d/openvz/patchset/0001-2.6.24-ovz002.patch
+++ b/debian/binary-custom.d/openvz/patchset/0001-2.6.24-ovz002.patch
@@ -31767,10 +31767,10 @@ Index: kernel/include/net/af_unix.h
 ===================================================================
 --- kernel.orig/include/net/af_unix.h	2008-11-24 14:08:46.000000000 +0100
 +++ kernel/include/net/af_unix.h	2008-11-24 15:47:46.000000000 +0100
-@@ -9,6 +9,7 @@
- extern void unix_inflight(struct file *fp);
+@@ -10,6 +10,7 @@
  extern void unix_notinflight(struct file *fp);
  extern void unix_gc(void);
+ extern void wait_for_unix_gc(void);
 +extern void unix_destruct_fds(struct sk_buff *skb);
  
  #define UNIX_HASH_SIZE	256
@@ -91410,10 +91410,10 @@ Index: kernel/net/unix/garbage.c
 ===================================================================
 --- kernel.orig/net/unix/garbage.c	2008-11-24 14:08:46.000000000 +0100
 +++ kernel/net/unix/garbage.c	2008-11-24 15:47:46.000000000 +0100
-@@ -80,6 +80,7 @@
- #include <linux/file.h>
+@@ -81,6 +81,7 @@
  #include <linux/proc_fs.h>
  #include <linux/mutex.h>
+ #include <linux/wait.h>
 +#include <linux/module.h>
  
  #include <net/sock.h>
diff --git a/include/net/af_unix.h b/include/net/af_unix.h
index 5dbb79569c7e..6fd48b891733 100644
--- a/include/net/af_unix.h
+++ b/include/net/af_unix.h
@@ -9,6 +9,7 @@
 extern void unix_inflight(struct file *fp);
 extern void unix_notinflight(struct file *fp);
 extern void unix_gc(void);
+extern void wait_for_unix_gc(void);
 
 #define UNIX_HASH_SIZE	256
 
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 82a60bd93855..ef5805fb8370 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -1351,6 +1351,7 @@ static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
 
 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
+	wait_for_unix_gc();
 	err = scm_send(sock, msg, siocb->scm);
 	if (err < 0)
 		return err;
@@ -1503,6 +1504,7 @@ static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
 
 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
+	wait_for_unix_gc();
 	err = scm_send(sock, msg, siocb->scm);
 	if (err < 0)
 		return err;
diff --git a/net/unix/garbage.c b/net/unix/garbage.c
index e1be3313196c..07499a5d34cc 100644
--- a/net/unix/garbage.c
+++ b/net/unix/garbage.c
@@ -80,6 +80,7 @@
 #include <linux/file.h>
 #include <linux/proc_fs.h>
 #include <linux/mutex.h>
+#include <linux/wait.h>
 
 #include <net/sock.h>
 #include <net/af_unix.h>
@@ -91,6 +92,7 @@
 static LIST_HEAD(gc_inflight_list);
 static LIST_HEAD(gc_candidates);
 static DEFINE_SPINLOCK(unix_gc_lock);
+static DECLARE_WAIT_QUEUE_HEAD(unix_gc_wait);
 
 unsigned int unix_tot_inflight;
 
@@ -266,12 +268,16 @@ static void inc_inflight_move_tail(struct unix_sock *u)
 		list_move_tail(&u->link, &gc_candidates);
 }
 
-/* The external entry point: unix_gc() */
+static bool gc_in_progress = false;
 
-void unix_gc(void)
+void wait_for_unix_gc(void)
 {
-	static bool gc_in_progress = false;
+	wait_event(unix_gc_wait, gc_in_progress == false);
+}
 
+/* The external entry point: unix_gc() */
+void unix_gc(void)
+{
 	struct unix_sock *u;
 	struct unix_sock *next;
 	struct sk_buff_head hitlist;
@@ -376,6 +382,7 @@ void unix_gc(void)
 	/* All candidates should have been detached by now. */
 	BUG_ON(!list_empty(&gc_candidates));
 	gc_in_progress = false;
+	wake_up(&unix_gc_wait);
 
  out:
 	spin_unlock(&unix_gc_lock);
