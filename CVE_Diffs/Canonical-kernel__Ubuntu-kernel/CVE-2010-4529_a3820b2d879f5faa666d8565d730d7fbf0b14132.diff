Canonical-kernel__Ubuntu-kernel
commit a3820b2d879f5faa666d8565d730d7fbf0b14132
Author:     Dan Rosenberg <drosenberg@vsecurity.com>
AuthorDate: Wed Dec 22 13:58:27 2010 +0000
Commit:     Paolo Pisati <paolo.pisati@canonical.com>
CommitDate: Thu Jun 9 16:43:44 2011 +0200

    irda: prevent integer underflow in IRLMP_ENUMDEVICES, CVE-2010-4529
    
    BugLink: http://bugs.launchpad.net/bugs/737823
    
    If the user-provided len is less than the expected offset, the
    IRLMP_ENUMDEVICES getsockopt will do a copy_to_user() with a very large
    size value.  While this isn't be a security issue on x86 because it will
    get caught by the access_ok() check, it may leak large amounts of kernel
    heap on other architectures.  In any event, this patch fixes it.
    
    CVE-2010-4529
    Signed-off-by: Dan Rosenberg <drosenberg@vsecurity.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (backport of upstream commit fdac1e0697356ac212259f2147aa60c72e334861)
    
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>
    Acked-by: Tim Gardner <tim.gardner@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>

diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c
index ad882687c5e1..a93afad40aa4 100644
--- a/net/irda/af_irda.c
+++ b/net/irda/af_irda.c
@@ -2164,6 +2164,14 @@ static int irda_getsockopt(struct socket *sock, int level, int optname,
 
 	switch (optname) {
 	case IRLMP_ENUMDEVICES:
+
+		/* Offset to first device entry */
+		offset = sizeof(struct irda_device_list) -
+			sizeof(struct irda_device_info);
+
+		if (len < offset)
+			return -EINVAL;
+
 		/* Ask lmp for the current discovery log */
 		discoveries = irlmp_get_discoveries(&list.len, self->mask.word,
 						    self->nslots);
@@ -2173,15 +2181,9 @@ static int irda_getsockopt(struct socket *sock, int level, int optname,
 		err = 0;
 
 		/* Write total list length back to client */
-		if (copy_to_user(optval, &list,
-				 sizeof(struct irda_device_list) -
-				 sizeof(struct irda_device_info)))
+		if (copy_to_user(optval, &list, offset))
 			err = -EFAULT;
 
-		/* Offset to first device entry */
-		offset = sizeof(struct irda_device_list) -
-			sizeof(struct irda_device_info);
-
 		/* Copy the list itself - watch for overflow */
 		if(list.len > 2048)
 		{
