Canonical-kernel__Ubuntu-kernel
commit 086b2ecc8c95d8696848113392feea56d2f758b2
Author:     Stefan Bader <stefan.bader@canonical.com>
AuthorDate: Tue Nov 4 20:22:17 2008 +0100
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Wed Nov 5 09:28:39 2008 +0100

    UBUNTU: ndiswrapper: Prevent buffer overflow if nickname is IW_ESSID_MAX_SIZE characters long.
    
    OriginalAuthor: Anders Kaseorg
    OriginalLocation: http://ndiswrapper.svn.sourceforge.net/viewvc/ndiswrapper?view=rev&revision=2672
    Bug: #275860
    CVE-2008-4395
    
    The bug was reported and patch submitted by Anders Kaseorg. This patch is
    slightly different from that, and includes a few other miscellaneous
    changes that have been pending in pgiri's tree.
    
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/ubuntu/misc/ndiswrapper/iw_ndis.c b/ubuntu/misc/ndiswrapper/iw_ndis.c
index 6856e3c2ac37..31c947986492 100644
--- a/ubuntu/misc/ndiswrapper/iw_ndis.c
+++ b/ubuntu/misc/ndiswrapper/iw_ndis.c
@@ -47,12 +47,6 @@ int set_essid(struct wrap_ndis_device *wnd, const char *ssid, int ssid_len)
 	req.length = ssid_len;
 	if (ssid_len)
 		memcpy(&req.essid, ssid, ssid_len);
-	DBG_BLOCK(2) {
-		char buf[NDIS_ESSID_MAX_SIZE+1];
-		memcpy(buf, ssid, ssid_len);
-		buf[ssid_len] = 0;
-		TRACE2("ssid = '%s'", buf);
-	}
 
 	res = mp_set(wnd, OID_802_11_SSID, &req, sizeof(req));
 	if (res) {
@@ -127,7 +121,6 @@ static int iw_get_essid(struct net_device *dev, struct iw_request_info *info,
 		EXIT2(return -EOPNOTSUPP);
 	}
 	memcpy(extra, req.essid, req.length);
-	extra[req.length] = 0;
 	if (req.length > 0)
 		wrqu->essid.flags  = 1;
 	else
@@ -1000,10 +993,10 @@ static int iw_set_nick(struct net_device *dev, struct iw_request_info *info,
 {
 	struct wrap_ndis_device *wnd = netdev_priv(dev);
 
-	if (wrqu->data.length > IW_ESSID_MAX_SIZE || wrqu->data.length <= 0)
+	if (wrqu->data.length >= IW_ESSID_MAX_SIZE || wrqu->data.length <= 0)
 		return -EINVAL;
-	memset(wnd->nick, 0, sizeof(wnd->nick));
 	memcpy(wnd->nick, extra, wrqu->data.length);
+	wnd->nick[wrqu->data.length] = 0;
 	return 0;
 }
 
diff --git a/ubuntu/misc/ndiswrapper/ndis.h b/ubuntu/misc/ndiswrapper/ndis.h
index 76848fb86de3..8aab1040e563 100644
--- a/ubuntu/misc/ndiswrapper/ndis.h
+++ b/ubuntu/misc/ndiswrapper/ndis.h
@@ -877,7 +877,7 @@ struct wrap_ndis_device {
 	struct timer_list iw_stats_timer;
 	unsigned long scan_timestamp;
 	struct encr_info encr_info;
-	char nick[IW_ESSID_MAX_SIZE];
+	char nick[IW_ESSID_MAX_SIZE + 1];
 	struct ndis_essid essid;
 	struct auth_encr_capa capa;
 	enum ndis_infrastructure_mode infrastructure_mode;
diff --git a/ubuntu/misc/ndiswrapper/ntoskernel.c b/ubuntu/misc/ndiswrapper/ntoskernel.c
index 747c4b7f2c8f..58c9bc78b129 100644
--- a/ubuntu/misc/ndiswrapper/ntoskernel.c
+++ b/ubuntu/misc/ndiswrapper/ntoskernel.c
@@ -422,12 +422,12 @@ static void timer_proc(unsigned long data)
 	BUG_ON(wrap_timer->wrap_timer_magic != WRAP_TIMER_MAGIC);
 	BUG_ON(nt_timer->wrap_timer_magic != WRAP_TIMER_MAGIC);
 #endif
-	kdpc = nt_timer->kdpc;
-	if (kdpc)
-		queue_kdpc(kdpc);
 	KeSetEvent((struct nt_event *)nt_timer, 0, FALSE);
 	if (wrap_timer->repeat)
 		mod_timer(&wrap_timer->timer, jiffies + wrap_timer->repeat);
+	kdpc = nt_timer->kdpc;
+	if (kdpc)
+		queue_kdpc(kdpc);
 	TIMEREXIT(return);
 }
 
@@ -564,11 +564,10 @@ wstdcall BOOLEAN WIN_FUNC(KeCancelTimer,1)
 #ifdef TIMER_DEBUG
 	BUG_ON(wrap_timer->wrap_timer_magic != WRAP_TIMER_MAGIC);
 #endif
-	TIMERTRACE("canceling timer %p(%p)", wrap_timer, nt_timer);
 	/* disable timer before deleting so if it is periodic timer, it
 	 * won't be re-armed after deleting */
 	wrap_timer->repeat = 0;
-	ret = del_timer(&wrap_timer->timer);
+	ret = del_timer_sync(&wrap_timer->timer);
 	/* the documentation for KeCancelTimer suggests the DPC is
 	 * deqeued, but actually DPC is left to run */
 	if (ret)
diff --git a/ubuntu/misc/ndiswrapper/proc.c b/ubuntu/misc/ndiswrapper/proc.c
index c53ab969dd66..7f7b1aae35ad 100644
--- a/ubuntu/misc/ndiswrapper/proc.c
+++ b/ubuntu/misc/ndiswrapper/proc.c
@@ -97,10 +97,8 @@ static int procfs_read_ndis_encr(char *page, char **start, off_t off,
 	p += sprintf(p, "\n");
 
 	res = mp_query(wnd, OID_802_11_SSID, &essid, sizeof(essid));
-	if (!res) {
-		essid.essid[essid.length] = '\0';
-		p += sprintf(p, "essid=%s\n", essid.essid);
-	}
+	if (!res)
+		p += sprintf(p, "essid=%.*s\n", essid.length + 1, essid.essid);
 	res = mp_query_int(wnd, OID_802_11_ENCRYPTION_STATUS, &encr_status);
 	if (!res) {
 		typeof(&wnd->encr_info.keys[0]) tx_key;
