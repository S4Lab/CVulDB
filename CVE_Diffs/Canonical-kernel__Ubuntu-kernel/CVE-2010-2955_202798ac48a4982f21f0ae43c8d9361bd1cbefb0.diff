Canonical-kernel__Ubuntu-kernel
commit 202798ac48a4982f21f0ae43c8d9361bd1cbefb0
Author:     Johannes Berg <johannes.berg@intel.com>
AuthorDate: Fri Sep 24 11:37:21 2010 -0500
Commit:     Steve Conklin <sconklin@canonical.com>
CommitDate: Wed Oct 6 18:15:55 2010 +0100

    wireless extensions: fix kernel heap content leak
    
    CVE-2010-2955
    
    Upstream-commit: 42da2f948d949efd0111309f5827bf0298bcc9a4
    
    For application to Ubuntu Karmic, the cfg80211 bug
    wasn't present, so only the second patch from the
    upstream commit was applied.
    
    Original commit message:
    
    Wireless extensions have an unfortunate, undocumented
    requirement which requires drivers to always fill
    iwp->length when returning a successful status. When
    a driver doesn't do this, it leads to a kernel heap
    content leak when userspace offers a larger buffer
    than would have been necessary.
    
    Arguably, this is a driver bug, as it should, if it
    returns 0, fill iwp->length, even if it separately
    indicated that the buffer contents was not valid.
    
    However, we can also at least avoid the memory content
    leak if the driver doesn't do this by setting the iwp
    length to max_tokens, which then reflects how big the
    buffer is that the driver may fill, regardless of how
    big the userspace buffer is.
    
    To illustrate the point, this patch also fixes a
    corresponding cfg80211 bug (since this requirement
    isn't documented nor was ever pointed out by anyone
    during code review, I don't trust all drivers nor
    all cfg80211 handlers to implement it correctly).
    
    Cc: stable@kernel.org [all the way back]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Steve Conklin <sconklin@canonical.com>

diff --git a/net/wireless/wext.c b/net/wireless/wext.c
index 252c2010c2e2..528afde9031d 100644
--- a/net/wireless/wext.c
+++ b/net/wireless/wext.c
@@ -829,6 +829,22 @@ static int ioctl_standard_iw_point(struct iw_point *iwp, unsigned int cmd,
 		}
 	}
 
+	if (IW_IS_GET(cmd) && !(descr->flags & IW_DESCR_FLAG_NOMAX)) {
+		/*
+		 * If this is a GET, but not NOMAX, it means that the extra
+		 * data is not bounded by userspace, but by max_tokens. Thus
+		 * set the length to max_tokens. This matches the extra data
+		 * allocation.
+		 * The driver should fill it with the number of tokens it
+		 * provided, and it may check iwp->length rather than having
+		 * knowledge of max_tokens. If the driver doesn't change the
+		 * iwp->length, this ioctl just copies back max_token tokens
+		 * filled with zeroes. Hopefully the driver isn't claiming
+		 * them to be valid data.
+		 */
+		iwp->length = descr->max_tokens;
+	}
+
 	err = handler(dev, info, (union iwreq_data *) iwp, extra);
 
 	iwp->length += essid_compat;
