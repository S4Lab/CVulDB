Canonical-kernel__Ubuntu-kernel
commit 300c94e51afcd754d19f81e14d2e80354e17aedf
Author:     Leann Ogasawara <leann.ogasawara@canonical.com>
AuthorDate: Thu Nov 18 14:53:30 2010 -0800
Commit:     Leann Ogasawara <leann.ogasawara@canonical.com>
CommitDate: Sun Nov 21 11:44:42 2010 -0800

    UBUNTU: SAUCE: AF_ECONET prevent kernel stack overflow
    
    CVE-2010-3848
    
    If CONFIG_ECONET_AUNUDP, the function declares a variable-length array
    of iovec's on the stack:
    
    static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,
                              struct msghdr *msg, size_t len)
    {
            ...
            ...
            struct iovec iov[msg->msg_iovlen+1];
            ...
    
    "msg->msg_iovlen" is a user-controlled value <= 1024; 1024 'struct
    iovec's is enough to overflow the kernel stack and clobber the
    'thread_info' struct on either 32- or 64-bit systems with or without
    CONFIG_4KSTACKS.
    
    The code populates 'iov' with user-controlled values, so this is almost
    certainly exploitable for privesc.
    
    This patch has yet to be submitted upstream, hence marking it as SAUCE
    for now.
    
    OriginalAuthor: Phil Blundell <philb@gnu.org>
    
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/net/econet/af_econet.c b/net/econet/af_econet.c
index f0bbc57926cd..7de888be7337 100644
--- a/net/econet/af_econet.c
+++ b/net/econet/af_econet.c
@@ -41,6 +41,7 @@
 #include <linux/rcupdate.h>
 #include <linux/bitops.h>
 #include <linux/mutex.h>
+#include <linux/vmalloc.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -275,12 +276,14 @@ static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,
 #endif
 #ifdef CONFIG_ECONET_AUNUDP
 	struct msghdr udpmsg;
-	struct iovec iov[msg->msg_iovlen+1];
+	struct iovec iov[2];
 	struct aunhdr ah;
 	struct sockaddr_in udpdest;
 	__kernel_size_t size;
 	int i;
 	mm_segment_t oldfs;
+	size_t userlen = 0;
+	char *userbuf, *userptr;
 #endif
 
 	/*
@@ -445,27 +448,42 @@ static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,
 
 	/* tack our header on the front of the iovec */
 	size = sizeof(struct aunhdr);
-	/*
-	 * XXX: that is b0rken.  We can't mix userland and kernel pointers
-	 * in iovec, since on a lot of platforms copy_from_user() will
-	 * *not* work with the kernel and userland ones at the same time,
-	 * regardless of what we do with set_fs().  And we are talking about
-	 * econet-over-ethernet here, so "it's only ARM anyway" doesn't
-	 * apply.  Any suggestions on fixing that code?		-- AV
-	 */
 	iov[0].iov_base = (void *)&ah;
 	iov[0].iov_len = size;
 	for (i = 0; i < msg->msg_iovlen; i++) {
 		void __user *base = msg->msg_iov[i].iov_base;
 		size_t len = msg->msg_iov[i].iov_len;
-		/* Check it now since we switch to KERNEL_DS later. */
+
 		if (!access_ok(VERIFY_READ, base, len)) {
-			mutex_unlock(&econet_mutex);
-			return -EFAULT;
+			err = -EFAULT;
+			goto error;
 		}
-		iov[i+1].iov_base = base;
-		iov[i+1].iov_len = len;
-		size += len;
+		userlen += len;
+	}
+
+	if (userlen > 32768) {
+		err = -E2BIG;
+		goto error;
+	}
+
+	userbuf = vmalloc(userlen);
+	if (userbuf == NULL) {
+		err = -ENOMEM;
+		goto error;
+	}
+
+	iov[1].iov_base = userbuf;
+	iov[1].iov_len = userlen;
+	userptr = userbuf;
+
+	for (i = 0; i < msg->msg_iovlen; i++) {
+		void __user *base = msg->msg_iov[i].iov_base;
+		size_t len = msg->msg_iov[i].iov_len;
+
+		if (copy_from_user(userptr, base, len))
+			return -EFAULT;
+
+		userptr += len;
 	}
 
 	/* Get a skbuff (no data, just holds our cb information) */
@@ -473,6 +491,7 @@ static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,
 				       msg->msg_flags & MSG_DONTWAIT,
 				       &err)) == NULL) {
 		mutex_unlock(&econet_mutex);
+		vfree(userbuf);
 		return err;
 	}
 
@@ -498,9 +517,12 @@ static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,
 	oldfs = get_fs(); set_fs(KERNEL_DS);	/* More privs :-) */
 	err = sock_sendmsg(udpsock, &udpmsg, size);
 	set_fs(oldfs);
+
+	vfree(userbuf);
 #else
 	err = -EPROTOTYPE;
 #endif
+	error:
 	mutex_unlock(&econet_mutex);
 
 	return err;
