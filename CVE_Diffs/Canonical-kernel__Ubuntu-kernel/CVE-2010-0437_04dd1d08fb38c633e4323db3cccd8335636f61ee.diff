Canonical-kernel__Ubuntu-kernel
commit 04dd1d08fb38c633e4323db3cccd8335636f61ee
Author:     Neil Horman <nhorman@tuxdriver.com>
AuthorDate: Tue Sep 9 13:51:35 2008 -0700
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue May 25 14:08:54 2010 +0200

    ipv6: Fix OOPS in ip6_dst_lookup_tail().
    
    CVE-2010-0437
    
    This fixes kernel bugzilla 11469: "TUN with 1024 neighbours:
    ip6_dst_lookup_tail NULL crash"
    
    dst->neighbour is not necessarily hooked up at this point
    in the processing path, so blindly dereferencing it is
    the wrong thing to do.  This NULL check exists in other
    similar paths and this case was just an oversight.
    
    Also fix the completely wrong and confusing indentation
    here while we're at it.
    
    Based upon a patch by Evgeniy Polyakov.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (backported from commit e550dfb0c2c31b6363aa463a035fc9f8dcaa3c9b upstream)
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 5b4095b30c4e..ad21ba8eeaa2 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -898,38 +898,30 @@ static int ip6_dst_lookup_tail(struct sock *sk,
 	}
 
 #ifdef CONFIG_IPV6_OPTIMISTIC_DAD
-		/*
-		 * Here if the dst entry we've looked up
-		 * has a neighbour entry that is in the INCOMPLETE
-		 * state and the src address from the flow is
-		 * marked as OPTIMISTIC, we release the found
-		 * dst entry and replace it instead with the
-		 * dst entry of the nexthop router
-		 */
-		if (!((*dst)->neighbour->nud_state & NUD_VALID)) {
-			struct inet6_ifaddr *ifp;
-			struct flowi fl_gw;
-			int redirect;
-
-			ifp = ipv6_get_ifaddr(&fl->fl6_src, (*dst)->dev, 1);
-
-			redirect = (ifp && ifp->flags & IFA_F_OPTIMISTIC);
-			if (ifp)
-				in6_ifa_put(ifp);
-
-			if (redirect) {
-				/*
-				 * We need to get the dst entry for the
-				 * default router instead
-				 */
-				dst_release(*dst);
-				memcpy(&fl_gw, fl, sizeof(struct flowi));
-				memset(&fl_gw.fl6_dst, 0, sizeof(struct in6_addr));
-				*dst = ip6_route_output(sk, &fl_gw);
-				if ((err = (*dst)->error))
-					goto out_err_release;
-			}
+	if ((*dst)->neighbour && !((*dst)->neighbour->nud_state & NUD_VALID)) {
+		struct inet6_ifaddr *ifp;
+		struct flowi fl_gw;
+		int redirect;
+
+		ifp = ipv6_get_ifaddr(&fl->fl6_src, (*dst)->dev, 1);
+
+		redirect = (ifp && ifp->flags & IFA_F_OPTIMISTIC);
+		if (ifp)
+			in6_ifa_put(ifp);
+
+		if (redirect) {
+			/*
+			 * We need to get the dst entry for the
+			 * default router instead
+			 */
+			dst_release(*dst);
+			memcpy(&fl_gw, fl, sizeof(struct flowi));
+			memset(&fl_gw.fl6_dst, 0, sizeof(struct in6_addr));
+			*dst = ip6_route_output(sk, &fl_gw);
+			if ((err = (*dst)->error))
+				goto out_err_release;
 		}
+	}
 #endif
 
 	return 0;
