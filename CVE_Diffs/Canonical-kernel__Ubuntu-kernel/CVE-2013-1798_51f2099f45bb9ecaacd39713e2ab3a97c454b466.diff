Canonical-kernel__Ubuntu-kernel
commit 51f2099f45bb9ecaacd39713e2ab3a97c454b466
Author:     Andy Honig <ahonig@google.com>
AuthorDate: Wed Feb 20 14:49:16 2013 -0800
Commit:     Tim Gardner <tim.gardner@canonical.com>
CommitDate: Tue Apr 9 09:40:40 2013 -0600

    KVM: Fix bounds checking in ioapic indirect register reads (CVE-2013-1798)
    
    CVE-2013-1798
    
    BugLink: http://bugs.launchpad.net/bugs/1158262
    
    If the guest specifies a IOAPIC_REG_SELECT with an invalid value and follows
    that with a read of the IOAPIC_REG_WINDOW KVM does not properly validate
    that request.  ioapic_read_indirect contains an
    ASSERT(redir_index < IOAPIC_NUM_PINS), but the ASSERT has no effect in
    non-debug builds.  In recent kernels this allows a guest to cause a kernel
    oops by reading invalid memory.  In older kernels (pre-3.3) this allows a
    guest to read from large ranges of host memory.
    
    Tested: tested against apic unit tests.
    
    Signed-off-by: Andrew Honig <ahonig@google.com>
    Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
    (cherry picked from commit a2c118bfab8bc6b8bb213abfc35201e441693d55)
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/virt/kvm/ioapic.c b/virt/kvm/ioapic.c
index 3eed61eb4867..79647cde86f6 100644
--- a/virt/kvm/ioapic.c
+++ b/virt/kvm/ioapic.c
@@ -73,9 +73,12 @@ static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 			u32 redir_index = (ioapic->ioregsel - 0x10) >> 1;
 			u64 redir_content;
 
-			ASSERT(redir_index < IOAPIC_NUM_PINS);
+			if (redir_index < IOAPIC_NUM_PINS)
+				redir_content =
+					ioapic->redirtbl[redir_index].bits;
+			else
+				redir_content = ~0ULL;
 
-			redir_content = ioapic->redirtbl[redir_index].bits;
 			result = (ioapic->ioregsel & 0x1) ?
 			    (redir_content >> 32) & 0xffffffff :
 			    redir_content & 0xffffffff;
