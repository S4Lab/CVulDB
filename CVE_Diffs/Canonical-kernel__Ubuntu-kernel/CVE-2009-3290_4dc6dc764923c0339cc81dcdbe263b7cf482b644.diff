Canonical-kernel__Ubuntu-kernel
commit 4dc6dc764923c0339cc81dcdbe263b7cf482b644
Author:     Leann Ogasawara <leann.ogasawara@canonical.com>
AuthorDate: Fri Oct 9 11:37:35 2009 -0700
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Wed Oct 14 17:22:55 2009 +0200

    KVM: x86: Disallow hypercalls for guest callers in rings > 0
    
    CVE-2009-3290
    
    commit 07708c4af1346ab1521b26a202f438366b7bcffd upstream
    
    This also requires a partial backport of commit
    2e4d2653497856b102c90153f970c9e344ba96c6 upstream in order to add
    functionality to get the cpl of vcpu.
    
    So far unprivileged guest callers running in ring 3 can issue, e.g., MMU
    hypercalls. Normally, such callers cannot provide any hand-crafted MMU
    command structure as it has to be passed by its physical address, but
    they can still crash the guest kernel by passing random addresses.
    
    To close the hole, this patch considers hypercalls valid only if issued
    from guest ring 0. This may still be relaxed on a per-hypercall base in
    the future once required.
    
    Cc: stable@kernel.org
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Avi Kivity <avi@redhat.com>
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 661b2284f7ae..c2973ad3e09d 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -1388,6 +1388,20 @@ static void vmx_get_segment(struct kvm_vcpu *vcpu,
 	var->unusable = (ar >> 16) & 1;
 }
 
+static int vmx_get_cpl(struct kvm_vcpu *vcpu)
+{
+	struct kvm_segment kvm_seg;
+
+	if (!(vcpu->arch.cr0 & X86_CR0_PE)) /* if real mode */
+		return 0;
+
+	if (vmx_get_rflags(vcpu) & X86_EFLAGS_VM) /* if virtual 8086 */
+		return 3;
+
+	vmx_get_segment(vcpu, &kvm_seg, VCPU_SREG_CS);
+	return kvm_seg.selector & 3;
+}
+
 static u32 vmx_segment_access_rights(struct kvm_segment *var)
 {
 	u32 ar;
@@ -2658,6 +2672,7 @@ static struct kvm_x86_ops vmx_x86_ops = {
 	.get_segment_base = vmx_get_segment_base,
 	.get_segment = vmx_get_segment,
 	.set_segment = vmx_set_segment,
+	.get_cpl = vmx_get_cpl,
 	.get_cs_db_l_bits = vmx_get_cs_db_l_bits,
 	.decache_cr4_guest_bits = vmx_decache_cr4_guest_bits,
 	.set_cr0 = vmx_set_cr0,
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index cedd49fef570..2732d1b0d9d5 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -2394,6 +2394,11 @@ int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)
 		a3 &= 0xFFFFFFFF;
 	}
 
+	if (kvm_x86_ops->get_cpl(vcpu) != 0) {
+		ret = -KVM_EPERM;
+		goto out;
+	}
+
 	switch (nr) {
 	case KVM_HC_VAPIC_POLL_IRQ:
 		ret = 0;
@@ -2402,6 +2407,7 @@ int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)
 		ret = -KVM_ENOSYS;
 		break;
 	}
+out:
 	vcpu->arch.regs[VCPU_REGS_RAX] = ret;
 	kvm_x86_ops->decache_regs(vcpu);
 	++vcpu->stat.hypercalls;
diff --git a/include/asm-x86/kvm_host.h b/include/asm-x86/kvm_host.h
index 024b57c743b7..cf6d16aa7b36 100644
--- a/include/asm-x86/kvm_host.h
+++ b/include/asm-x86/kvm_host.h
@@ -373,6 +373,7 @@ struct kvm_x86_ops {
 	u64 (*get_segment_base)(struct kvm_vcpu *vcpu, int seg);
 	void (*get_segment)(struct kvm_vcpu *vcpu,
 			    struct kvm_segment *var, int seg);
+	int (*get_cpl)(struct kvm_vcpu *vcpu);
 	void (*set_segment)(struct kvm_vcpu *vcpu,
 			    struct kvm_segment *var, int seg);
 	void (*get_cs_db_l_bits)(struct kvm_vcpu *vcpu, int *db, int *l);
diff --git a/include/linux/kvm_para.h b/include/linux/kvm_para.h
index 5497aac0d2f8..7e96b1de05c6 100644
--- a/include/linux/kvm_para.h
+++ b/include/linux/kvm_para.h
@@ -11,6 +11,7 @@
 
 /* Return values for hypercalls */
 #define KVM_ENOSYS		1000
+#define KVM_EPERM		EPERM
 
 #define KVM_HC_VAPIC_POLL_IRQ            1
 
