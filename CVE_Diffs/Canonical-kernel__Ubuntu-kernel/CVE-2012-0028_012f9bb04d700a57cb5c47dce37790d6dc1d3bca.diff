Canonical-kernel__Ubuntu-kernel
commit 012f9bb04d700a57cb5c47dce37790d6dc1d3bca
Author:     Peter Zijlstra <peterz@infradead.org>
AuthorDate: Wed Feb 8 19:14:18 2012 +0000
Commit:     Tim Gardner <tim.gardner@canonical.com>
CommitDate: Mon Feb 13 07:45:59 2012 -0700

    futex: Nullify robust lists after cleanup
    
    The robust list pointers of user space held futexes are kept intact
    over an exec() call. When the exec'ed task exits exit_robust_list() is
    called with the stale pointer. The risk of corruption is minimal, but
    still it is incorrect to keep the pointers valid. Actually glibc
    should uninstall the robust list before calling exec() but we have to
    deal with it anyway.
    
    Nullify the pointers after [compat_]exit_robust_list() has been
    called.
    
    Reported-by: Anirban Sinha <ani@anirban.org>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <new-submission>
    Cc: stable@kernel.org
    
    (cherry picked from commit fc6b177dee33365ccb29fe6d2092223cf8d679f9)
    CVE-2012-0028
    BugLink: http://bugs.launchpad.net/bugs/927889
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Acked-by: Stefan Bader <stefan.bader@canonical.com>
    Acked-by: Herton Krzesinski <herton.krzesinski@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/debian/binary-custom.d/openvz/src/kernel/fork.c b/debian/binary-custom.d/openvz/src/kernel/fork.c
index 8059fa316012..196a8c2e9b70 100644
--- a/debian/binary-custom.d/openvz/src/kernel/fork.c
+++ b/debian/binary-custom.d/openvz/src/kernel/fork.c
@@ -495,11 +495,15 @@ void mm_release(struct task_struct *tsk, struct mm_struct *mm)
 
 	/* Get rid of any futexes when releasing the mm */
 #ifdef CONFIG_FUTEX
-	if (unlikely(tsk->robust_list))
+	if (unlikely(tsk->robust_list)) {
 		exit_robust_list(tsk);
+		tsk->robust_list = NULL;
+	}
 #ifdef CONFIG_COMPAT
-	if (unlikely(tsk->compat_robust_list))
+	if (unlikely(tsk->compat_robust_list)) {
 		compat_exit_robust_list(tsk);
+		tsk->compat_robust_list = NULL;
+	}
 #endif
 #endif
 
diff --git a/debian/binary-custom.d/xen/src/kernel/fork.c b/debian/binary-custom.d/xen/src/kernel/fork.c
index 3106adb03efd..5b3e5e2b04d4 100644
--- a/debian/binary-custom.d/xen/src/kernel/fork.c
+++ b/debian/binary-custom.d/xen/src/kernel/fork.c
@@ -461,11 +461,15 @@ void mm_release(struct task_struct *tsk, struct mm_struct *mm)
 
 	/* Get rid of any futexes when releasing the mm */
 #ifdef CONFIG_FUTEX
-	if (unlikely(tsk->robust_list))
+	if (unlikely(tsk->robust_list)) {
 		exit_robust_list(tsk);
+		tsk->robust_list = NULL;
+	}
 #ifdef CONFIG_COMPAT
-	if (unlikely(tsk->compat_robust_list))
+	if (unlikely(tsk->compat_robust_list)) {
 		compat_exit_robust_list(tsk);
+		tsk->compat_robust_list = NULL;
+	}
 #endif
 #endif
 
diff --git a/kernel/fork.c b/kernel/fork.c
index 3106adb03efd..5b3e5e2b04d4 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -461,11 +461,15 @@ void mm_release(struct task_struct *tsk, struct mm_struct *mm)
 
 	/* Get rid of any futexes when releasing the mm */
 #ifdef CONFIG_FUTEX
-	if (unlikely(tsk->robust_list))
+	if (unlikely(tsk->robust_list)) {
 		exit_robust_list(tsk);
+		tsk->robust_list = NULL;
+	}
 #ifdef CONFIG_COMPAT
-	if (unlikely(tsk->compat_robust_list))
+	if (unlikely(tsk->compat_robust_list)) {
 		compat_exit_robust_list(tsk);
+		tsk->compat_robust_list = NULL;
+	}
 #endif
 #endif
 
