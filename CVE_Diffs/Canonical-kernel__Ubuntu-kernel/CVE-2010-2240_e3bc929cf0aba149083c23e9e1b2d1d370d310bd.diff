Canonical-kernel__Ubuntu-kernel
commit e3bc929cf0aba149083c23e9e1b2d1d370d310bd
Author:     Greg Kroah-Hartman <gregkh@suse.de>
AuthorDate: Fri Aug 13 09:49:20 2010 -0700
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue Aug 17 18:26:38 2010 +0200

    x86: don't send SIGBUS for kernel page faults
    
    CVE-2010-2240
    
    Based on commit 96054569190bdec375fe824e48ca1f4e3b53dd36 upstream,
    authored by Linus Torvalds.
    
    This is my backport to the .27 kernel tree, hopefully preserving
    the same functionality.
    
    Original commit message:
      It's wrong for several reasons, but the most direct one is that the
      fault may be for the stack accesses to set up a previous SIGBUS.  When
      we have a kernel exception, the kernel exception handler does all the
      fixups, not some user-level signal handler.
    
      Even apart from the nested SIGBUS issue, it's also wrong to give out
      kernel fault addresses in the signal handler info block, or to send a
      SIGBUS when a system call already returns EFAULT.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    (picked from pending stable queue for 2.6.27.y)
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/arch/x86/mm/fault_32.c b/arch/x86/mm/fault_32.c
index a2273d44aa27..a3a421547898 100644
--- a/arch/x86/mm/fault_32.c
+++ b/arch/x86/mm/fault_32.c
@@ -302,6 +302,7 @@ fastcall void __kprobes do_page_fault(struct pt_regs *regs,
 	unsigned long address;
 	int write, si_code;
 	int fault;
+	int should_exit_no_context = 0;
 
 	/*
 	 * We can fault from pretty much anywhere, with unknown IRQ state.
@@ -587,6 +588,9 @@ no_context:
 	bust_spinlocks(0);
 	do_exit(SIGKILL);
 
+	if (should_exit_no_context)
+		return;
+
 /*
  * We ran out of memory, or some other thing happened to us that made
  * us unable to handle the page fault gracefully.
@@ -607,8 +611,10 @@ do_sigbus:
 	up_read(&mm->mmap_sem);
 
 	/* Kernel mode? Handle exceptions or die */
-	if (!(error_code & 4))
+	if (!(error_code & 4)) {
+		should_exit_no_context = 1;
 		goto no_context;
+	}
 
 	/* User space => ok to do another page fault */
 	if (is_prefetch(regs, address, error_code))
diff --git a/arch/x86/mm/fault_64.c b/arch/x86/mm/fault_64.c
index 0e26230669ca..afcd12f8f461 100644
--- a/arch/x86/mm/fault_64.c
+++ b/arch/x86/mm/fault_64.c
@@ -301,6 +301,7 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
 	unsigned long address;
 	const struct exception_table_entry *fixup;
 	int write, fault;
+	int should_exit_no_context = 0;
 	unsigned long flags;
 	siginfo_t info;
 
@@ -548,6 +549,9 @@ no_context:
 	oops_end(flags);
 	do_exit(SIGKILL);
 
+	if (should_exit_no_context)
+		return;
+
 /*
  * We ran out of memory, or some other thing happened to us that made
  * us unable to handle the page fault gracefully.
@@ -567,8 +571,10 @@ do_sigbus:
 	up_read(&mm->mmap_sem);
 
 	/* Kernel mode? Handle exceptions or die */
-	if (!(error_code & PF_USER))
+	if (!(error_code & PF_USER)) {
+		should_exit_no_context = 1;
 		goto no_context;
+	}
 
 	tsk->thread.cr2 = address;
 	tsk->thread.error_code = error_code;
