Canonical-kernel__Ubuntu-kernel
commit f39822eb457760a36cf52315910701f0fd021572
Author:     Luis Henriques <luis.henriques@canonical.com>
AuthorDate: Mon Jul 14 08:55:27 2014 +0100
Commit:     Luis Henriques <luis.henriques@canonical.com>
CommitDate: Mon Jul 14 16:08:21 2014 +0100

    l2tp: Privilege escalation in ppp over l2tp sockets
    
    The l2tp call-down to udp_prot.[gs]etsockopt() is entirely broken, as
    reported by Sasha, since the socket in question isn't an ip socket, so
    when the IP code does either
    
            struct udp_sock *up = udp_sk(sk);
    or
            struct inet_sock *inet = inet_sk(sk);
    
    it basically gets random contents and accesses random kernel memory as a
    result.
    
    The suggested patch is trivial, and presumed to not break anything (since
    the random udp_sock/inet_sock accesses couldn't really do anything
    useful).
    
    This is CVE-2014-4943: an unprivileged user to kernel privilege escalation
    when CONFIG_PPPOL2TP is enabled.
    
    Signed-off-by: Marc Deslauriers <marc.deslauriers@canonical.com>
    Acked-by: Andy Whitcroft <andy.whitcroft@canonical.com>
    CVE-2014-4943
    BugLink: http://bugs.launchpad.net/bugs/1341472
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c
index e0f0934d6c39..437fb5974b6c 100644
--- a/net/l2tp/l2tp_ppp.c
+++ b/net/l2tp/l2tp_ppp.c
@@ -1351,7 +1351,7 @@ static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,
 	int err;
 
 	if (level != SOL_PPPOL2TP)
-		return udp_prot.setsockopt(sk, level, optname, optval, optlen);
+		return -EINVAL;
 
 	if (optlen < sizeof(int))
 		return -EINVAL;
@@ -1477,7 +1477,7 @@ static int pppol2tp_getsockopt(struct socket *sock, int level,
 	struct pppol2tp_session *ps;
 
 	if (level != SOL_PPPOL2TP)
-		return udp_prot.getsockopt(sk, level, optname, optval, optlen);
+		return -EINVAL;
 
 	if (get_user(len, (int __user *) optlen))
 		return -EFAULT;
