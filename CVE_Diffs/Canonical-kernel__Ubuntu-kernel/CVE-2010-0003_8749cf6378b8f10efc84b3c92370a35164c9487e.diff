Canonical-kernel__Ubuntu-kernel
commit 8749cf6378b8f10efc84b3c92370a35164c9487e
Author:     Andi Kleen <andi@firstfloor.org>
AuthorDate: Fri Jan 8 14:42:52 2010 -0800
Commit:     Leann Ogasawara <leann.ogasawara@canonical.com>
CommitDate: Sun Jan 24 12:10:00 2010 -0800

    kernel/signal.c: fix kernel information leak with print-fatal-signals=1
    
    CVE-2010-0003
    
    When print-fatal-signals is enabled it's possible to dump any memory
    reachable by the kernel to the log by simply jumping to that address from
    user space.
    
    Or crash the system if there's some hardware with read side effects.
    
    The fatal signals handler will dump 16 bytes at the execution address,
    which is fully controlled by ring 3.
    
    In addition when something jumps to a unmapped address there will be up to
    16 additional useless page faults, which might be potentially slow (and at
    least is not very efficient)
    
    Fortunately this option is off by default and only there on i386.
    
    But fix it by checking for kernel addresses and also stopping when there's
    a page fault.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    (cherry picked from commit b45c6e76bc2c72f6426c14bed64fdcbc9bf37cb0)
    
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/kernel/signal.c b/kernel/signal.c
index 3dbeb603a5e3..57a9776c4a67 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -739,7 +739,8 @@ static void print_fatal_signal(struct pt_regs *regs, int signr)
 		for (i = 0; i < 16; i++) {
 			unsigned char insn;
 
-			__get_user(insn, (unsigned char *)(regs->eip + i));
+			if (get_user(insn, (unsigned char *)(regs->eip + i)))
+				break;
 			printk("%02x ", insn);
 		}
 	}
