Canonical-kernel__Ubuntu-kernel
commit 8f3c3547006158baa1a1232da66381fe72f5450d
Author:     Jason Wang <jasowang@redhat.com>
AuthorDate: Fri Sep 7 12:02:33 2012 -0600
Commit:     Luis Henriques <luis.henriques@canonical.com>
CommitDate: Mon Sep 24 10:19:39 2012 +0100

    net: sock: validate data_len before allocating skb in sock_alloc_send_pskb()
    
    CVE-2012-2136
    
    BugLink: http://bugs.launchpad.net/bugs/1006622
    
    We need to validate the number of pages consumed by data_len, otherwise frags
    array could be overflowed by userspace. So this patch validate data_len and
    return -EMSGSIZE when data_len may occupies more frags than MAX_SKB_FRAGS.
    
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    (cherry picked from commit cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc)
    
    Xen applied cleanly, but openvz required some back porting.
    
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Acked-by: Colin King <colin.king@canonical.com>
    Acked-by: Herton Krzesinski <herton.krzesinski@canonical.com>

diff --git a/debian/binary-custom.d/openvz/src/net/core/sock.c b/debian/binary-custom.d/openvz/src/net/core/sock.c
index b66126b349aa..46f0afc10f2d 100644
--- a/debian/binary-custom.d/openvz/src/net/core/sock.c
+++ b/debian/binary-custom.d/openvz/src/net/core/sock.c
@@ -1267,6 +1267,11 @@ struct sk_buff *sock_alloc_send_skb2(struct sock *sk, unsigned long size,
 	gfp_t gfp_mask;
 	long timeo;
 	int err;
+	int npages = (size + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+
+	err = -EMSGSIZE;
+	if (npages > MAX_SKB_FRAGS)
+		goto failure;
 
 	gfp_mask = sk->sk_allocation;
 	if (gfp_mask & __GFP_WAIT)
diff --git a/debian/binary-custom.d/xen/src/net/core/sock.c b/debian/binary-custom.d/xen/src/net/core/sock.c
index b0e5208b18d3..a39b6aa04f79 100644
--- a/debian/binary-custom.d/xen/src/net/core/sock.c
+++ b/debian/binary-custom.d/xen/src/net/core/sock.c
@@ -1233,6 +1233,11 @@ static struct sk_buff *sock_alloc_send_pskb(struct sock *sk,
 	gfp_t gfp_mask;
 	long timeo;
 	int err;
+	int npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+
+	err = -EMSGSIZE;
+	if (npages > MAX_SKB_FRAGS)
+		goto failure;
 
 	gfp_mask = sk->sk_allocation;
 	if (gfp_mask & __GFP_WAIT)
@@ -1251,14 +1256,12 @@ static struct sk_buff *sock_alloc_send_pskb(struct sock *sk,
 		if (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
 			skb = alloc_skb(header_len, gfp_mask);
 			if (skb) {
-				int npages;
 				int i;
 
 				/* No pages, we're done... */
 				if (!data_len)
 					break;
 
-				npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 				skb->truesize += data_len;
 				skb_shinfo(skb)->nr_frags = npages;
 				for (i = 0; i < npages; i++) {
diff --git a/net/core/sock.c b/net/core/sock.c
index b0e5208b18d3..a39b6aa04f79 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -1233,6 +1233,11 @@ static struct sk_buff *sock_alloc_send_pskb(struct sock *sk,
 	gfp_t gfp_mask;
 	long timeo;
 	int err;
+	int npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+
+	err = -EMSGSIZE;
+	if (npages > MAX_SKB_FRAGS)
+		goto failure;
 
 	gfp_mask = sk->sk_allocation;
 	if (gfp_mask & __GFP_WAIT)
@@ -1251,14 +1256,12 @@ static struct sk_buff *sock_alloc_send_pskb(struct sock *sk,
 		if (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
 			skb = alloc_skb(header_len, gfp_mask);
 			if (skb) {
-				int npages;
 				int i;
 
 				/* No pages, we're done... */
 				if (!data_len)
 					break;
 
-				npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 				skb->truesize += data_len;
 				skb_shinfo(skb)->nr_frags = npages;
 				for (i = 0; i < npages; i++) {
