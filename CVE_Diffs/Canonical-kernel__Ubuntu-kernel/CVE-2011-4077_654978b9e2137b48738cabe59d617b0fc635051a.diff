Canonical-kernel__Ubuntu-kernel
commit 654978b9e2137b48738cabe59d617b0fc635051a
Author:     Carlos Maiolino <cmaiolino@redhat.com>
AuthorDate: Mon Nov 21 16:50:55 2011 +0000
Commit:     Brad Figg <brad.figg@canonical.com>
CommitDate: Mon Nov 28 09:45:45 2011 -0800

    xfs: Fix possible memory corruption in xfs_readlink, CVE-2011-4077
    
    Fixes a possible memory corruption when the link is larger than
    MAXPATHLEN and XFS_DEBUG is not enabled. This also remove the
    S_ISLNK assert, since the inode mode is checked previously in
    xfs_readlink_by_handle() and via VFS.
    
    Updated to address concerns raised by Ben Hutchings about the loose
    attention paid to 32- vs 64-bit values, and the lack of handling a
    potentially negative pathlen value:
     - Changed type of "pathlen" to be xfs_fsize_t, to match that of
       ip->i_d.di_size
     - Added checking for a negative pathlen to the too-long pathlen
       test, and generalized the message that gets reported in that case
       to reflect the change
    As a result, if a negative pathlen were encountered, this function
    would return EFSCORRUPTED (and would fail an assertion for a debug
    build)--just as would a too-long pathlen.
    
    Signed-off-by: Alex Elder <aelder@sgi.com>
    Signed-off-by: Carlos Maiolino <cmaiolino@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    
    (backported from commit b52a360b2aa1c59ba9970fb0f52bbb093fcc7a24)
    CVE-2011-4077
    BugLink: http://bugs.launchpad.net/bugs/887298
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Acked-by: Herton Krzesinski <herton.krzesinski@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>

diff --git a/fs/xfs/xfs_vnodeops.c b/fs/xfs/xfs_vnodeops.c
index d8e6f8cd6f0c..24804ad6400c 100644
--- a/fs/xfs/xfs_vnodeops.c
+++ b/fs/xfs/xfs_vnodeops.c
@@ -535,7 +535,7 @@ xfs_readlink(
 	char		*link)
 {
 	xfs_mount_t	*mp = ip->i_mount;
-	int		pathlen;
+	xfs_fsize_t	pathlen;
 	int		error = 0;
 
 	trace_xfs_readlink(ip);
@@ -545,13 +545,19 @@ xfs_readlink(
 
 	xfs_ilock(ip, XFS_ILOCK_SHARED);
 
-	ASSERT((ip->i_d.di_mode & S_IFMT) == S_IFLNK);
-	ASSERT(ip->i_d.di_size <= MAXPATHLEN);
-
 	pathlen = ip->i_d.di_size;
 	if (!pathlen)
 		goto out;
 
+	if (pathlen < 0 || pathlen > MAXPATHLEN) {
+		cmn_err(CE_ALERT, "%s: inode (%llu) bad symlink length (%lld)",
+			 __func__, (unsigned long long) ip->i_ino,
+			 (long long) pathlen);
+		ASSERT(0);
+		return XFS_ERROR(EFSCORRUPTED);
+	}
+
+
 	if (ip->i_df.if_flags & XFS_IFINLINE) {
 		memcpy(link, ip->i_df.if_u1.if_data, pathlen);
 		link[pathlen] = '\0';
