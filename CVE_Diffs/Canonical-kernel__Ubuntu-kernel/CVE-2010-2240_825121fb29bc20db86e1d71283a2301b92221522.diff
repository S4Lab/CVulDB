Canonical-kernel__Ubuntu-kernel
commit 825121fb29bc20db86e1d71283a2301b92221522
Author:     Linus Torvalds <torvalds@linux-foundation.org>
AuthorDate: Sun Aug 15 11:35:52 2010 -0700
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue Aug 17 12:43:49 2010 +0200

    mm: fix up some user-visible effects of the stack guard page
    
    CVE-2010-2240
    
    This commit makes the stack guard page somewhat less visible to user
    space. It does this by:
    
     - not showing the guard page in /proc/<pid>/maps
    
       It looks like lvm-tools will actually read /proc/self/maps to figure
       out where all its mappings are, and effectively do a specialized
       "mlockall()" in user space.  By not showing the guard page as part of
       the mapping (by just adding PAGE_SIZE to the start for grows-up
       pages), lvm-tools ends up not being aware of it.
    
     - by also teaching the _real_ mlock() functionality not to try to lock
       the guard page.
    
       That would just expand the mapping down to create a new guard page,
       so there really is no point in trying to lock it in place.
    
    It would perhaps be nice to show the guard page specially in
    /proc/<pid>/maps (or at least mark grow-down segments some way), but
    let's not open ourselves up to more breakage by user space from programs
    that depends on the exact deails of the 'maps' file.
    
    Special thanks to Henrique de Moraes Holschuh for diving into lvm-tools
    source code to see what was going on with the whole new warning.
    
    Reported-and-tested-by: Fran√ßois Valenduc <francois.valenduc@tvcablenet.be
    Reported-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    (cherry-picked from commit d7824370e26325c881b665350ce64fb0a4fde24a upstream)
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 8043a3eab52c..135a8632ded9 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -140,6 +140,7 @@ static int show_map_internal(struct seq_file *m, void *v, struct mem_size_stats
 	struct file *file = vma->vm_file;
 	int flags = vma->vm_flags;
 	unsigned long ino = 0;
+	unsigned long start;
 	dev_t dev = 0;
 	int len;
 
@@ -152,8 +153,13 @@ static int show_map_internal(struct seq_file *m, void *v, struct mem_size_stats
 		ino = inode->i_ino;
 	}
 
+	/* We don't show the stack guard page in /proc/maps */
+	start = vma->vm_start;
+	if (vma->vm_flags & VM_GROWSDOWN)
+		start += PAGE_SIZE;
+
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08lx %02x:%02x %lu %n",
-			vma->vm_start,
+			start,
 			vma->vm_end,
 			flags & VM_READ ? 'r' : '-',
 			flags & VM_WRITE ? 'w' : '-',
diff --git a/mm/mlock.c b/mm/mlock.c
index 7b2656055d6a..7de65b96cb3b 100644
--- a/mm/mlock.c
+++ b/mm/mlock.c
@@ -72,8 +72,17 @@ success:
 	pages = (end - start) >> PAGE_SHIFT;
 	if (newflags & VM_LOCKED) {
 		pages = -pages;
-		if (!(newflags & VM_IO))
+		if (!(newflags & VM_IO)) {
+			/*
+			 *  We don't try to access the guard page of a stack
+			 *  vma
+			 */
+			if (vma->vm_flags & VM_GROWSDOWN)
+				if (start == vma->vm_start)
+					start += PAGE_SIZE;
+
 			ret = make_pages_present(start, end);
+		}
 	}
 
 	mm->locked_vm -= pages;
