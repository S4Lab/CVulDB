Canonical-kernel__Ubuntu-kernel
commit 94cbdfd687e7af4eddf5b88452cf068c03ad79b5
Author:     Vlad Yasevich <vladislav.yasevich@hp.com>
AuthorDate: Mon Oct 4 13:56:17 2010 -0700
Commit:     Steve Conklin <sconklin@canonical.com>
CommitDate: Wed Oct 6 16:08:56 2010 +0100

    sctp: Do not reset the packet during sctp_packet_config().
    
    CVE-2010-3432
    
    This is a backport of upstream commit:
        4bdab43323b459900578b200a4b8cf9713ac8fab
    
    sctp_packet_config() is called when getting the packet ready
    for appending of chunks.  The function should not touch the
    current state, since it's possible to ping-pong between two
    transports when sending, and that can result packet corruption
    followed by skb overlfow crash.
    
    Reported-by: Thomas Dreibholz <dreibh@iem.uni-due.de>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Brad Figg <brad.figg@canonical.com>

diff --git a/net/sctp/output.c b/net/sctp/output.c
index 847639d542c0..40cced1890fe 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -65,6 +65,17 @@
 static sctp_xmit_t sctp_packet_append_data(struct sctp_packet *packet,
 					   struct sctp_chunk *chunk);
 
+static void sctp_packet_reset(struct sctp_packet *packet)
+{
+	packet->size = packet->overhead;
+	packet->has_cookie_echo = 0;
+	packet->has_sack = 0;
+	packet->has_data = 0;
+	packet->has_auth = 0;
+	packet->ipfragok = 0;
+	packet->auth = NULL;
+}
+
 /* Config a packet.
  * This appears to be a followup set of initializations.
  */
@@ -77,12 +88,6 @@ struct sctp_packet *sctp_packet_config(struct sctp_packet *packet,
 			  packet, vtag);
 
 	packet->vtag = vtag;
-	packet->has_cookie_echo = 0;
-	packet->has_sack = 0;
-	packet->has_auth = 0;
-	packet->has_data = 0;
-	packet->ipfragok = 0;
-	packet->auth = NULL;
 
 	if (ecn_capable && sctp_packet_empty(packet)) {
 		chunk = sctp_get_ecne_prepend(packet->transport->asoc);
@@ -120,15 +125,9 @@ struct sctp_packet *sctp_packet_init(struct sctp_packet *packet,
 	}
 	overhead += sizeof(struct sctphdr);
 	packet->overhead = overhead;
-	packet->size = overhead;
+	sctp_packet_reset(packet);
 	packet->vtag = 0;
-	packet->has_cookie_echo = 0;
-	packet->has_sack = 0;
-	packet->has_auth = 0;
-	packet->has_data = 0;
-	packet->ipfragok = 0;
 	packet->malloced = 0;
-	packet->auth = NULL;
 	return packet;
 }
 
@@ -587,7 +586,7 @@ int sctp_packet_transmit(struct sctp_packet *packet)
 		(*tp->af_specific->sctp_xmit)(nskb, tp, 1);
 
 out:
-	packet->size = packet->overhead;
+	sctp_packet_reset(packet);
 	return err;
 no_route:
 	kfree_skb(nskb);
