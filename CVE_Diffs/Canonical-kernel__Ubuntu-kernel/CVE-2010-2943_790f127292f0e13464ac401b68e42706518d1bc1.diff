Canonical-kernel__Ubuntu-kernel
commit 790f127292f0e13464ac401b68e42706518d1bc1
Author:     Dave Chinner <dchinner@redhat.com>
AuthorDate: Tue Aug 24 11:42:30 2010 +1000
Commit:     Leann Ogasawara <leann.ogasawara@canonical.com>
CommitDate: Tue Nov 30 20:26:47 2010 -0800

    xfs: fix untrusted inode number lookup
    
    CVE-2010-2943
    
    Commit 7124fe0a5b619d65b739477b3b55a20bf805b06d ("xfs: validate untrusted inode
    numbers during lookup") changes the inode lookup code to do btree lookups for
    untrusted inode numbers. This change made an invalid assumption about the
    alignment of inodes and hence incorrectly calculated the first inode in the
    cluster. As a result, some inode numbers were being incorrectly considered
    invalid when they were actually valid.
    
    The issue was not picked up by the xfstests suite because it always runs fsr
    and dump (the two utilities that utilise the bulkstat interface) on cache hot
    inodes and hence the lookup code in the cold cache path was not sufficiently
    exercised to uncover this intermittent problem.
    
    Fix the issue by relaxing the btree lookup criteria and then checking if the
    record returned contains the inode number we are lookup for. If it we get an
    incorrect record, then the inode number is invalid.
    
    Cc: <stable@kernel.org>
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    (backported from commit 4536f2ad8b330453d7ebec0746c4374eadd649b1)
    
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/fs/xfs/xfs_ialloc.c b/fs/xfs/xfs_ialloc.c
index 12b96de16ede..a2f7c3b114bd 100644
--- a/fs/xfs/xfs_ialloc.c
+++ b/fs/xfs/xfs_ialloc.c
@@ -1208,7 +1208,6 @@ xfs_imap_lookup(
 {
 	struct xfs_btree_cur	*cur;
 	struct xfs_buf		*agbp;
-	xfs_agino_t		startino;
 	xfs_inofree_t		chunk_free; /* mask of free inodes in chunk */
 	xfs_agino_t		chunk_agino; /* first agino in inode chunk */
 	__int32_t		chunk_cnt; /* count of free inodes in chunk */
@@ -1227,13 +1226,13 @@ xfs_imap_lookup(
 	}
 
 	/*
-	 * derive and lookup the exact inode record for the given agino. If the
-	 * record cannot be found, then it's an invalid inode number and we
-	 * should abort.
+	 * Lookup the inode record for the given agino. If the record cannot be
+	 * found, then it's an invalid inode number and we should abort. Once
+	 * we have a record, we need to ensure it contains the inode number
+	 * we are looking up.
 	 */
 	cur = xfs_inobt_init_cursor(mp, tp, agbp, agno);
-	startino = agino & ~(XFS_IALLOC_INODES(mp) - 1);
-	error = xfs_inobt_lookup_le(cur, startino, 0, 0, &i);
+	error = xfs_inobt_lookup_le(cur, agino, 0, 0, &i);
 	if (!error) {
 		if (i)
 			error = xfs_inobt_get_rec(cur, &chunk_agino, &chunk_cnt,
@@ -1247,6 +1246,11 @@ xfs_imap_lookup(
 	if (error)
 		return error;
 
+	/* check that the returned record contains the required inode */
+	if (chunk_agino > agino ||
+	    chunk_agino + XFS_IALLOC_INODES(mp) <= agino)
+		return EINVAL;
+
 	/* for untrusted inodes check it is allocated first */
 	if ((flags & XFS_IGET_UNTRUSTED) &&
 	    (chunk_free & XFS_INOBT_MASK(agino - chunk_agino)))
