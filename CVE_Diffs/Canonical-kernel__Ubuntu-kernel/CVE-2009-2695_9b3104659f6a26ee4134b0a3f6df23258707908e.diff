Canonical-kernel__Ubuntu-kernel
commit 9b3104659f6a26ee4134b0a3f6df23258707908e
Author:     Leann Ogasawara <leann.ogasawara@canonical.com>
AuthorDate: Sun Oct 11 10:18:19 2009 -0700
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Wed Oct 14 17:22:44 2009 +0200

    security/SELinux: seperate lsm specific mmap_min_addr
    
    CVE-2009-2695
    
    commit 788084aba2ab7348257597496befcbccabdc98a3 upstream
    
    Currently SELinux enforcement of controls on the ability to map low memory
    is determined by the mmap_min_addr tunable.  This patch causes SELinux to
    ignore the tunable and instead use a seperate Kconfig option specific to how
    much space the LSM should protect.
    
    The tunable will now only control the need for CAP_SYS_RAWIO and SELinux
    permissions will always protect the amount of low memory designated by
    CONFIG_LSM_MMAP_MIN_ADDR.
    
    This allows users who need to disable the mmap_min_addr controls (usual reason
    being they run WINE as a non-root user) to do so and still have SELinux
    controls preventing confined domains (like a web server) from being able to
    map some area of low memory.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>

diff --git a/debian/config/amd64/config b/debian/config/amd64/config
index 4c26bb233a6e..1384aef77b64 100644
--- a/debian/config/amd64/config
+++ b/debian/config/amd64/config
@@ -517,6 +517,7 @@ CONFIG_DECNET_NF_GRABULATOR=m
 # CONFIG_DEFAULT_CUBIC is not set
 # CONFIG_DEFAULT_HTCP is not set
 CONFIG_DEFAULT_IO_DELAY_TYPE=1
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_RELATIME=y
 CONFIG_DEFAULT_RELATIME_VAL=1
@@ -1421,6 +1422,7 @@ CONFIG_LOCK_KERNEL=y
 # CONFIG_LOGO is not set
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_LP_CONSOLE is not set
+CONFIG_LSM_MMAP_MIN_ADDR=0
 CONFIG_LXT_PHY=m
 CONFIG_LZO_COMPRESS=m
 CONFIG_LZO_DECOMPRESS=m
diff --git a/debian/config/hppa/config b/debian/config/hppa/config
index 5e88f9049e45..088963347af0 100644
--- a/debian/config/hppa/config
+++ b/debian/config/hppa/config
@@ -267,6 +267,7 @@ CONFIG_DEFAULT_CUBIC=y
 # CONFIG_DEFAULT_DEADLINE is not set
 # CONFIG_DEFAULT_HTCP is not set
 CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_RELATIME=y
 CONFIG_DEFAULT_RELATIME_VAL=1
diff --git a/debian/config/i386/config b/debian/config/i386/config
index 17e8f1f169b3..67b29b24aa4d 100644
--- a/debian/config/i386/config
+++ b/debian/config/i386/config
@@ -268,6 +268,7 @@ CONFIG_DECNET=m
 # CONFIG_DEFAULT_CUBIC is not set
 # CONFIG_DEFAULT_HTCP is not set
 CONFIG_DEFAULT_IO_DELAY_TYPE=1
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_RELATIME=y
 CONFIG_DEFAULT_RELATIME_VAL=1
@@ -639,6 +640,7 @@ CONFIG_LOCKD_V4=y
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_LP_CONSOLE is not set
 # CONFIG_LSF is not set
+CONFIG_LSM_MMAP_MIN_ADDR=0
 # CONFIG_M386 is not set
 # CONFIG_M586MMX is not set
 # CONFIG_M586TSC is not set
diff --git a/debian/config/ia64/config b/debian/config/ia64/config
index c814d74bcb48..ddabc24bacfe 100644
--- a/debian/config/ia64/config
+++ b/debian/config/ia64/config
@@ -427,6 +427,7 @@ CONFIG_DEFAULT_CUBIC=y
 # CONFIG_DEFAULT_DEADLINE is not set
 # CONFIG_DEFAULT_HTCP is not set
 CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_RELATIME=y
 CONFIG_DEFAULT_RELATIME_VAL=1
@@ -1210,6 +1211,7 @@ CONFIG_LOCK_KERNEL=y
 # CONFIG_LOGO is not set
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_LP_CONSOLE is not set
+CONFIG_LSM_MMAP_MIN_ADDR=0
 CONFIG_LXT_PHY=m
 CONFIG_LZO_COMPRESS=m
 CONFIG_LZO_DECOMPRESS=m
diff --git a/debian/config/powerpc/config b/debian/config/powerpc/config
index 48a6fd0a84df..4780fb2ba151 100644
--- a/debian/config/powerpc/config
+++ b/debian/config/powerpc/config
@@ -438,6 +438,7 @@ CONFIG_DEFAULT_CFQ=y
 # CONFIG_DEFAULT_DEADLINE is not set
 # CONFIG_DEFAULT_HTCP is not set
 CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_RELATIME=y
 CONFIG_DEFAULT_RELATIME_VAL=1
@@ -1174,6 +1175,7 @@ CONFIG_LOCKD_V4=y
 # CONFIG_LOGO is not set
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_LP_CONSOLE is not set
+CONFIG_LSM_MMAP_MIN_ADDR=0
 CONFIG_LXT_PHY=m
 CONFIG_LZO_COMPRESS=m
 CONFIG_LZO_DECOMPRESS=m
diff --git a/debian/config/sparc/config b/debian/config/sparc/config
index 95277c0a8a0b..49d157073b0a 100644
--- a/debian/config/sparc/config
+++ b/debian/config/sparc/config
@@ -328,6 +328,7 @@ CONFIG_DEFAULT_CUBIC=y
 # CONFIG_DEFAULT_DEADLINE is not set
 # CONFIG_DEFAULT_HTCP is not set
 CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_RELATIME=y
 CONFIG_DEFAULT_RELATIME_VAL=1
@@ -884,6 +885,7 @@ CONFIG_LOCKD_V4=y
 # CONFIG_LOGO is not set
 CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_LP_CONSOLE is not set
+CONFIG_LSM_MMAP_MIN_ADDR=0
 CONFIG_LXT_PHY=m
 CONFIG_MAC80211=m
 # CONFIG_MAC80211_DEBUG is not set
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 1b7b95c67aca..15f624c1a9d0 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -513,21 +513,6 @@ static inline void set_page_links(struct page *page, enum zone_type zone,
 	set_page_section(page, pfn_to_section_nr(pfn));
 }
 
-/*
- * If a hint addr is less than mmap_min_addr change hint to be as
- * low as possible but still greater than mmap_min_addr
- */
-static inline unsigned long round_hint_to_min(unsigned long hint)
-{
-#ifdef CONFIG_SECURITY
-	hint &= PAGE_MASK;
-	if (((void *)hint != NULL) &&
-	    (hint < mmap_min_addr))
-		return PAGE_ALIGN(mmap_min_addr);
-#endif
-	return hint;
-}
-
 /*
  * Some inline functions in vmstat.h depend on page_zone()
  */
diff --git a/include/linux/security.h b/include/linux/security.h
index 36ef302a8ffb..10c9b2aa07e0 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -28,6 +28,7 @@
 #include <linux/resource.h>
 #include <linux/sem.h>
 #include <linux/shm.h>
+#include <linux/mm.h> /* PAGE_ALIGN */
 #include <linux/msg.h>
 #include <linux/sched.h>
 #include <linux/key.h>
@@ -87,6 +88,7 @@ extern int cap_netlink_send(struct sock *sk, struct sk_buff *skb);
 extern int cap_netlink_recv(struct sk_buff *skb, int cap);
 
 extern unsigned long mmap_min_addr;
+extern unsigned long dac_mmap_min_addr;
 /*
  * Values used in the task_security_ops calls
  */
@@ -115,6 +117,22 @@ struct request_sock;
 
 #ifdef CONFIG_SECURITY
 
+/*
+ * If a hint addr is less than mmap_min_addr change hint to be as
+ * low as possible but still greater than mmap_min_addr
+ */
+static inline unsigned long round_hint_to_min(unsigned long hint)
+{
+	hint &= PAGE_MASK;
+	if (((void *)hint != NULL) &&
+	    (hint < mmap_min_addr))
+		return PAGE_ALIGN(mmap_min_addr);
+	return hint;
+}
+
+extern int mmap_min_addr_handler(struct ctl_table *table, int write, struct file *filp,
+				void __user *buffer, size_t *lenp, loff_t *ppos);
+
 /**
  * struct security_operations - main security structure
  *
diff --git a/mm/Kconfig b/mm/Kconfig
index 9ef97417a0b9..fe37b3488697 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -193,3 +193,21 @@ config NR_QUICK
 config VIRT_TO_BUS
 	def_bool y
 	depends on !ARCH_NO_VIRT_TO_BUS
+
+config DEFAULT_MMAP_MIN_ADDR
+        int "Low address space to protect from user allocation"
+        default 4096
+        help
+          This is the portion of low virtual memory which should be protected
+          from userspace allocation.  Keeping a user from writing to low pages
+          can help reduce the impact of kernel NULL pointer bugs.
+
+          For most ia64, ppc64 and x86 users with lots of address space
+          a value of 65536 is reasonable and should cause no problems.
+          On arm and other archs it should not be higher than 32768.
+          Programs which use vm86 functionality or have some need to map
+          this low address space will need CAP_SYS_RAWIO or disable this
+          protection by setting the value to 0.
+
+          This value can be changed after boot using the
+          /proc/sys/vm/mmap_min_addr tunable.
diff --git a/security/Kconfig b/security/Kconfig
index d0df9a422aa3..8dffa7ff9fee 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -103,6 +103,22 @@ config SECURITY_ROOTPLUG
 	  
 	  If you are unsure how to answer this question, answer N.
 
+config LSM_MMAP_MIN_ADDR
+	int "Low address space for LSM to from user allocation"
+	depends on SECURITY && SECURITY_SELINUX
+	default 65535
+	help
+	  This is the portion of low virtual memory which should be protected
+	  from userspace allocation.  Keeping a user from writing to low pages
+	  can help reduce the impact of kernel NULL pointer bugs.
+
+	  For most ia64, ppc64 and x86 users with lots of address space
+	  a value of 65536 is reasonable and should cause no problems.
+	  On arm and other archs it should not be higher than 32768.
+	  Programs which use vm86 functionality or have some need to map
+	  this low address space will need the permission specific to the
+	  systems running LSM.
+
 source security/selinux/Kconfig
 source security/apparmor/Kconfig
 
diff --git a/security/Makefile b/security/Makefile
index 03a35df7d6a7..c5a17dd77d77 100644
--- a/security/Makefile
+++ b/security/Makefile
@@ -10,6 +10,8 @@ ifneq ($(CONFIG_SECURITY),y)
 obj-y		+= commoncap.o
 endif
 
+obj-y		+= min_addr.o
+
 # Object file lists
 obj-$(CONFIG_SECURITY)			+= security.o dummy.o inode.o
 # Must precede capability.o in order to stack properly.
diff --git a/security/min_addr.c b/security/min_addr.c
new file mode 100644
index 000000000000..14cc7b3b8d03
--- /dev/null
+++ b/security/min_addr.c
@@ -0,0 +1,49 @@
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/security.h>
+#include <linux/sysctl.h>
+
+/* amount of vm to protect from userspace access by both DAC and the LSM*/
+unsigned long mmap_min_addr;
+/* amount of vm to protect from userspace using CAP_SYS_RAWIO (DAC) */
+unsigned long dac_mmap_min_addr = CONFIG_DEFAULT_MMAP_MIN_ADDR;
+/* amount of vm to protect from userspace using the LSM = CONFIG_LSM_MMAP_MIN_ADDR */
+
+/*
+ * Update mmap_min_addr = max(dac_mmap_min_addr, CONFIG_LSM_MMAP_MIN_ADDR)
+ */
+static void update_mmap_min_addr(void)
+{
+#ifdef CONFIG_LSM_MMAP_MIN_ADDR
+	if (dac_mmap_min_addr > CONFIG_LSM_MMAP_MIN_ADDR)
+		mmap_min_addr = dac_mmap_min_addr;
+	else
+		mmap_min_addr = CONFIG_LSM_MMAP_MIN_ADDR;
+#else
+	mmap_min_addr = dac_mmap_min_addr;
+#endif
+}
+
+/*
+ * sysctl handler which just sets dac_mmap_min_addr = the new value and then
+ * calls update_mmap_min_addr() so non MAP_FIXED hints get rounded properly
+ */
+int mmap_min_addr_handler(struct ctl_table *table, int write, struct file *filp,
+			  void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	int ret;
+
+	ret = proc_doulongvec_minmax(table, write, filp, buffer, lenp, ppos);
+
+	update_mmap_min_addr();
+
+	return ret;
+}
+
+int __init init_mmap_min_addr(void)
+{
+	update_mmap_min_addr();
+
+	return 0;
+}
+pure_initcall(init_mmap_min_addr);
diff --git a/security/security.c b/security/security.c
index 707f350f4017..74f645ffafdd 100644
--- a/security/security.c
+++ b/security/security.c
@@ -23,7 +23,6 @@ extern struct security_operations dummy_security_ops;
 extern void security_fixup_ops(struct security_operations *ops);
 
 struct security_operations *security_ops;	/* Initialized to NULL */
-unsigned long mmap_min_addr;		/* 0 means no protection */
 
 static inline int verify(struct security_operations *ops)
 {
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index cf094f915887..88ed4b0c39ca 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -2607,7 +2607,7 @@ static int selinux_file_mmap(struct file *file, unsigned long reqprot,
 	 * at bad behaviour/exploit that we always want to get the AVC, even
 	 * if DAC would have also denied the operation.
 	 */
-	if (addr < mmap_min_addr) {
+	if (addr < CONFIG_LSM_MMAP_MIN_ADDR) {
 		rc = avc_has_perm(sid, sid, SECCLASS_MEMPROTECT,
 				  MEMPROTECT__MMAP_ZERO, NULL);
 		if (rc)
