Canonical-kernel__Ubuntu-kernel
commit 185b803597c89aab8d98cbf232b57bdb7a4d9228
Author:     Abhijith Das <adas@redhat.com>
AuthorDate: Fri May 7 17:50:18 2010 -0400
Commit:     Stefan Bader <stefan.bader@canonical.com>
CommitDate: Tue Jul 20 17:32:37 2010 +0200

    GFS2: Fix writing to non-page aligned gfs2_quota structures
    
    CVE-2010-1436
    
    This is the upstream fix for this bug. This patch differs
    from the RHEL5 fix (Red Hat bz #555754) which simply writes to the 8-byte
    value field of the quota. In upstream quota code, we're
    required to write the entire quota (88 bytes) which can be split
    across a page boundary. We check for such quotas, and read/write
    the two parts from/to the corresponding pages holding these parts.
    
    With this patch, I don't see the bug anymore using the reproducer
    in Red Hat bz 555754. I successfully ran a couple of simple tests/mounts/
    umounts and it doesn't seem like this patch breaks anything else.
    
    Signed-off-by: Abhi Das <adas@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    (backported from commit 7e619bc3e6252dc746f64ac3b486e784822e9533 upstream)
    Signed-off-by: Stefan Bader <stefan.bader@canonical.com>

diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index 2e9b9326bfc9..aecdc0daf81c 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -654,15 +654,27 @@ static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,
 	unsigned blocksize, iblock, pos;
 	struct buffer_head *bh;
 	struct page *page;
-	void *kaddr;
-	char *ptr;
-	struct gfs2_quota_host qp;
+	void *kaddr, *ptr;
+	struct gfs2_quota q;
 	s64 value;
-	int err = -EIO;
+	int err, nbytes;
 
 	if (gfs2_is_stuffed(ip))
 		gfs2_unstuff_dinode(ip, NULL);
-	
+
+	memset(&q, 0, sizeof(struct gfs2_quota));
+	err = gfs2_internal_read(ip, NULL, (char *)&q, &loc, sizeof(q));
+	if (err < 0)
+		return err;
+
+	value = be64_to_cpu(q.qu_value) + change;
+	q.qu_value = cpu_to_be64(value);
+
+	/* Write the quota into the quota file on disk */
+	err = -EIO;
+	ptr = &q;
+	nbytes = sizeof(struct gfs2_quota);
+get_a_page:
 	page = grab_cache_page(mapping, index);
 	if (!page)
 		return -ENOMEM;
@@ -685,6 +697,11 @@ static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,
 		gfs2_block_map(inode, iblock, bh, 1);
 		if (!buffer_mapped(bh))
 			goto unlock;
+		/* If it's a newly allocated disk block for quota, zero it */
+		if (buffer_new(bh)) {
+			memset(bh->b_data, 0, bh->b_size);
+			set_buffer_uptodate(bh);
+		}
 	}
 
 	if (PageUptodate(page))
@@ -700,18 +717,31 @@ static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,
 	gfs2_trans_add_bh(ip->i_gl, bh, 0);
 
 	kaddr = kmap_atomic(page, KM_USER0);
-	ptr = kaddr + offset;
-	gfs2_quota_in(&qp, ptr);
-	qp.qu_value += change;
-	value = qp.qu_value;
-	gfs2_quota_out(&qp, ptr);
+	if (offset + sizeof(struct gfs2_quota) > PAGE_CACHE_SIZE)
+		nbytes = PAGE_CACHE_SIZE - offset;
+	memcpy(kaddr + offset, ptr, nbytes);
 	flush_dcache_page(page);
 	kunmap_atomic(kaddr, KM_USER0);
-	err = 0;
+	unlock_page(page);
+	page_cache_release(page);
+
+	/* If quota straddles page boundary, we need to update the rest of the
+	 * quota at the beginning of the next page */
+	if (offset != 0) { /* first page, offset is closer to PAGE_CACHE_SIZE */
+		ptr = ptr + nbytes;
+		nbytes = sizeof(struct gfs2_quota) - nbytes;
+		offset = 0;
+		index++;
+		goto get_a_page;
+	}
+
 	qd->qd_qb.qb_magic = cpu_to_be32(GFS2_MAGIC);
 	qd->qd_qb.qb_value = cpu_to_be64(value);
 	((struct gfs2_quota_lvb*)(qd->qd_gl->gl_lvb))->qb_magic = cpu_to_be32(GFS2_MAGIC);
 	((struct gfs2_quota_lvb*)(qd->qd_gl->gl_lvb))->qb_value = cpu_to_be64(value);
+
+	return 0;
+
 unlock:
 	unlock_page(page);
 	page_cache_release(page);
