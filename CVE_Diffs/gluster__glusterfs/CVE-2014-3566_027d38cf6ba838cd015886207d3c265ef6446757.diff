gluster__glusterfs
commit 027d38cf6ba838cd015886207d3c265ef6446757
Author:     Niels de Vos <ndevos@redhat.com>
AuthorDate: Mon Oct 27 13:57:44 2014 +0100
Commit:     Niels de Vos <ndevos@redhat.com>
CommitDate: Tue Oct 28 08:49:41 2014 -0700

    socket: disallow CBC cipher modes
    
    This is related to CVE-2014-3566 a.k.a. POODLE.
    
            http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-3566
    
    POODLE is specific to CBC cipher modes in SSLv3.  Because there is no
    way to prevent SSLv3 fallback on a system with an unpatched version of
    OpenSSL, users of such systems can only be protected by disallowing CBC
    modes.  The default cipher-mode specification in our code has been
    changed accordingly.  Users can still set their own cipher modes if they
    wish.  To support them, the ssl-authz.t test script provides an example
    of how to combine the CBC exclusion with other criteria in a script.
    
    Cherry picked from commit 378a0a19d95e552220d71b13be685f4772c576cd:
    > Change-Id: Ib1fa547082fbb7de9df94ffd182b1800d6e354e5
    > BUG: 1155328
    > Signed-off-by: Jeff Darcy <jdarcy@redhat.com>
    > Reviewed-on: http://review.gluster.org/8962
    > Tested-by: Gluster Build System <jenkins@build.gluster.com>
    > Reviewed-by: Kaleb KEITHLEY <kkeithle@redhat.com>
    > Reviewed-by: Vijay Bellur <vbellur@redhat.com>
    
    ssl-auth.t has been modified to not set the auth.ssl-allow option. This
    option is not available in the 3.5 branch.
    
    Change-Id: Ib1fa547082fbb7de9df94ffd182b1800d6e354e5
    BUG: 1157661
    Signed-off-by: Niels de Vos <ndevos@redhat.com>
    Reviewed-on: http://review.gluster.org/8979
    Reviewed-by: Kaleb KEITHLEY <kkeithle@redhat.com>
    Reviewed-by: Jeff Darcy <jdarcy@redhat.com>
    Tested-by: Gluster Build System <jenkins@build.gluster.com>

diff --git a/rpc/rpc-transport/socket/src/socket.c b/rpc/rpc-transport/socket/src/socket.c
index 7b1beac09..a00202e47 100644
--- a/rpc/rpc-transport/socket/src/socket.c
+++ b/rpc/rpc-transport/socket/src/socket.c
@@ -45,6 +45,72 @@
 #define SSL_CA_LIST_OPT     "transport.socket.ssl-ca-list"
 #define OWN_THREAD_OPT      "transport.socket.own-thread"
 
+/*
+ * This list was derived by taking the cipher list "HIGH:!SSLv2" (the previous
+ * default) and excluding CBC entries to mitigate the "POODLE" attack.  It
+ * should be re-evaluated in light of each future vulnerability, as those are
+ * discovered.
+ */
+static char *default_cipher_list =
+        "ECDHE-RSA-AES256-GCM-SHA384:"
+        "ECDHE-ECDSA-AES256-GCM-SHA384:"
+        "ECDHE-RSA-AES256-SHA384:"
+        "ECDHE-ECDSA-AES256-SHA384:"
+        "ECDHE-RSA-AES256-SHA:"
+        "ECDHE-ECDSA-AES256-SHA:"
+        "DHE-DSS-AES256-GCM-SHA384:"
+        "DHE-RSA-AES256-GCM-SHA384:"
+        "DHE-RSA-AES256-SHA256:"
+        "DHE-DSS-AES256-SHA256:"
+        "DHE-RSA-AES256-SHA:"
+        "DHE-DSS-AES256-SHA:"
+        "DHE-RSA-CAMELLIA256-SHA:"
+        "DHE-DSS-CAMELLIA256-SHA:"
+        "AECDH-AES256-SHA:"
+        "ADH-AES256-GCM-SHA384:"
+        "ADH-AES256-SHA256:"
+        "ADH-AES256-SHA:"
+        "ADH-CAMELLIA256-SHA:"
+        "ECDH-RSA-AES256-GCM-SHA384:"
+        "ECDH-ECDSA-AES256-GCM-SHA384:"
+        "ECDH-RSA-AES256-SHA384:"
+        "ECDH-ECDSA-AES256-SHA384:"
+        "ECDH-RSA-AES256-SHA:"
+        "ECDH-ECDSA-AES256-SHA:"
+        "AES256-GCM-SHA384:"
+        "AES256-SHA256:"
+        "AES256-SHA:"
+        "CAMELLIA256-SHA:"
+        "ECDHE-RSA-AES128-GCM-SHA256:"
+        "ECDHE-ECDSA-AES128-GCM-SHA256:"
+        "ECDHE-RSA-AES128-SHA256:"
+        "ECDHE-ECDSA-AES128-SHA256:"
+        "ECDHE-RSA-AES128-SHA:"
+        "ECDHE-ECDSA-AES128-SHA:"
+        "DHE-DSS-AES128-GCM-SHA256:"
+        "DHE-RSA-AES128-GCM-SHA256:"
+        "DHE-RSA-AES128-SHA256:"
+        "DHE-DSS-AES128-SHA256:"
+        "DHE-RSA-AES128-SHA:"
+        "DHE-DSS-AES128-SHA:"
+        "DHE-RSA-CAMELLIA128-SHA:"
+        "DHE-DSS-CAMELLIA128-SHA:"
+        "AECDH-AES128-SHA:"
+        "ADH-AES128-GCM-SHA256:"
+        "ADH-AES128-SHA256:"
+        "ADH-AES128-SHA:"
+        "ADH-CAMELLIA128-SHA:"
+        "ECDH-RSA-AES128-GCM-SHA256:"
+        "ECDH-ECDSA-AES128-GCM-SHA256:"
+        "ECDH-RSA-AES128-SHA256:"
+        "ECDH-ECDSA-AES128-SHA256:"
+        "ECDH-RSA-AES128-SHA:"
+        "ECDH-ECDSA-AES128-SHA:"
+        "AES128-GCM-SHA256:"
+        "AES128-SHA256:"
+        "AES128-SHA:"
+        "CAMELLIA128-SHA";      /* no colon for last entry */
+
 /* TBD: do automake substitutions etc. (ick) to set these. */
 #if !defined(DEFAULT_CERT_PATH)
 #define DEFAULT_CERT_PATH   "/etc/ssl/glusterfs.pem"
@@ -3402,6 +3468,7 @@ socket_init (rpc_transport_t *this)
         uint32_t          keepalive = 0;
         uint32_t          backlog = 0;
 	int               session_id = 0;
+        char             *cipher_list = default_cipher_list;
 
         if (this->private) {
                 gf_log_callingfn (this->name, GF_LOG_ERROR,
@@ -3599,7 +3666,7 @@ socket_init (rpc_transport_t *this)
 		priv->ssl_ctx = SSL_CTX_new(priv->ssl_meth);
 
                 if (SSL_CTX_set_cipher_list(priv->ssl_ctx,
-                                            "HIGH:-SSLv2") == 0) {
+                                            cipher_list) == 0) {
                         gf_log(this->name,GF_LOG_ERROR,
                                "failed to find any valid ciphers");
                         goto err;
diff --git a/tests/features/ssl-authz.t b/tests/features/ssl-authz.t
new file mode 100755
index 000000000..a00c07a13
--- /dev/null
+++ b/tests/features/ssl-authz.t
@@ -0,0 +1,75 @@
+#!/bin/bash
+
+. $(dirname $0)/../include.rc
+. $(dirname $0)/../volume.rc
+
+ping_file () {
+        echo hello > $1 2> /dev/null
+}
+for d in /etc/ssl /etc/openssl /usr/local/etc/openssl ; do
+        if test -d $d ; then
+                SSL_BASE=$d
+                break
+        fi
+done
+SSL_KEY=$SSL_BASE/glusterfs.key
+SSL_CERT=$SSL_BASE/glusterfs.pem
+SSL_CA=$SSL_BASE/glusterfs.ca
+
+cleanup;
+rm -f $SSL_BASE/glusterfs.*
+mkdir -p $B0/1
+mkdir -p $M0
+
+TEST glusterd
+TEST pidof glusterd
+TEST $CLI volume info;
+
+# Construct a cipher list that excludes CBC because of POODLE.
+# http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-3566
+#
+# Since this is a bit opaque, here's what it does:
+#	(1) Get the ciphers matching a normal cipher-list spec
+#	(2) Delete any colon-separated entries containing "CBC"
+#	(3) Collapse adjacent colons from deleted entries
+#	(4) Remove colons at the beginning or end
+function valid_ciphers {
+	openssl ciphers 'HIGH:!SSLv2' | sed	\
+		-e '/[^:]*CBC[^:]*/s///g'	\
+		-e '/::*/s//:/g'		\
+		-e '/^:/s///'			\
+		-e '/:$/s///'
+}
+
+TEST openssl genrsa -out $SSL_KEY 1024
+TEST openssl req -new -x509 -key $SSL_KEY -subj /CN=Anyone -out $SSL_CERT
+ln $SSL_CERT $SSL_CA
+
+TEST $CLI volume create $V0 $H0:$B0/1
+TEST $CLI volume set $V0 server.ssl on
+TEST $CLI volume set $V0 client.ssl on
+#EST $CLI volume set $V0 ssl.cipher-list $(valid_ciphers)
+#EST $CLI volume set $V0 auth.ssl-allow Anyone
+TEST $CLI volume start $V0
+
+# This mount should WORK.
+TEST glusterfs --volfile-server=$H0 --volfile-id=$V0 $M0
+TEST ping_file $M0/before
+EXPECT_WITHIN $UMOUNT_TIMEOUT "Y" force_umount $M0
+
+# Change the authorized user name.  Note that servers don't pick up changes
+# automagically like clients do, so we have to stop/start ourselves.
+TEST $CLI volume stop $V0
+#EST $CLI volume set $V0 auth.ssl-allow NotYou
+TEST $CLI volume start $V0
+
+# This mount should FAIL because the identity given by our certificate does not
+# match the allowed user.  In other words, authentication works (they know who
+# we are) but authorization doesn't (we're not the right person).
+#EST $GFS --volfile-server=$H0 --volfile-id=$V0 $M0
+
+# Looks like /*/bin/glusterfs isn't returning error status correctly (again).
+# Actually try doing something to get a real error.
+#EST ! ping_file $M0/after
+
+cleanup;
