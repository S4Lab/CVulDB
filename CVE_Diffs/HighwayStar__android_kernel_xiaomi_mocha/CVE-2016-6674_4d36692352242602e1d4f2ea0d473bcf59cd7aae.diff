HighwayStar__android_kernel_xiaomi_mocha
commit 4d36692352242602e1d4f2ea0d473bcf59cd7aae
Author:     Gagan Grover <ggrover@nvidia.com>
AuthorDate: Tue Nov 15 01:22:08 2016 +0530
Commit:     Vitaliy Tomin <highwaystar.ru@gmail.com>
CommitDate: Mon Jun 5 21:29:51 2017 +0800

    binder: Fix Elevation of privilege vulnerability in system_server
    
    The usage of weak references instead of strong references in Binder
    can potentially lead to a use-after-free vulnerability in
    system_server. The fix is designed to no longer allow weak references
    in cases where strong references are needed.
    
    CVE-2016-6674 A-30445380
    
    Bug 1812688
    
    Change-Id: Ic4e028e8f1f6ae4b1ff562127f87a4a15d0a0999
    Signed-off-by: Gagan Grover <ggrover@nvidia.com>
    Reviewed-on: http://git-master/r/1252938
    Reviewed-by: Bharat Nihalani <bnihalani@nvidia.com>

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index 2b3b35d6f18..adc87828df3 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -1007,7 +1007,7 @@ static int binder_dec_node(struct binder_node *node, int strong, int internal)
 
 
 static struct binder_ref *binder_get_ref(struct binder_proc *proc,
-					 uint32_t desc)
+					 uint32_t desc, bool need_strong_ref)
 {
 	struct rb_node *n = proc->refs_by_desc.rb_node;
 	struct binder_ref *ref;
@@ -1015,12 +1015,16 @@ static struct binder_ref *binder_get_ref(struct binder_proc *proc,
 	while (n) {
 		ref = rb_entry(n, struct binder_ref, rb_node_desc);
 
-		if (desc < ref->desc)
+		if (desc < ref->desc) {
 			n = n->rb_left;
-		else if (desc > ref->desc)
+		} else if (desc > ref->desc) {
 			n = n->rb_right;
-		else
+		} else if (need_strong_ref && !ref->strong) {
+			binder_user_error("tried to use weak ref as strong ref\n");
+			return NULL;
+		} else {
 			return ref;
+		}
 	}
 	return NULL;
 }
@@ -1290,7 +1294,8 @@ static void binder_transaction_buffer_release(struct binder_proc *proc,
 		} break;
 		case BINDER_TYPE_HANDLE:
 		case BINDER_TYPE_WEAK_HANDLE: {
-			struct binder_ref *ref = binder_get_ref(proc, fp->handle);
+			struct binder_ref *ref = binder_get_ref(proc, fp->handle,
+						fp->type == BINDER_TYPE_HANDLE);
 
 			if (ref == NULL) {
 				pr_warn("transaction release %d bad handle %d\n",
@@ -1385,7 +1390,7 @@ static void binder_transaction(struct binder_proc *proc,
 		if (tr->target.handle) {
 			struct binder_ref *ref;
 
-			ref = binder_get_ref(proc, tr->target.handle);
+			ref = binder_get_ref(proc, tr->target.handle, true);
 			if (ref == NULL) {
 				binder_user_error("%d:%d got transaction to invalid handle\n",
 					proc->pid, thread->pid);
@@ -1592,8 +1597,8 @@ static void binder_transaction(struct binder_proc *proc,
 		} break;
 		case BINDER_TYPE_HANDLE:
 		case BINDER_TYPE_WEAK_HANDLE: {
-			struct binder_ref *ref = binder_get_ref(proc, fp->handle);
-
+			struct binder_ref *ref = binder_get_ref(proc, fp->handle,
+						fp->type == BINDER_TYPE_HANDLE);
 			if (ref == NULL) {
 				binder_user_error("%d:%d got transaction with invalid handle, %d\n",
 						proc->pid,
@@ -1800,7 +1805,9 @@ static int binder_thread_write(struct binder_proc *proc,
 						ref->desc);
 				}
 			} else
-				ref = binder_get_ref(proc, target);
+				ref = binder_get_ref(proc, target,
+						     cmd == BC_ACQUIRE ||
+						     cmd == BC_RELEASE);
 			if (ref == NULL) {
 				binder_user_error("%d:%d refcount change on invalid ref %d\n",
 					proc->pid, thread->pid, target);
@@ -1996,7 +2003,7 @@ static int binder_thread_write(struct binder_proc *proc,
 			if (get_user(cookie, (binder_uintptr_t __user *)ptr))
 				return -EFAULT;
 			ptr += sizeof(binder_uintptr_t);
-			ref = binder_get_ref(proc, target);
+			ref = binder_get_ref(proc, target, false);
 			if (ref == NULL) {
 				binder_user_error("%d:%d %s invalid ref %d\n",
 					proc->pid, thread->pid,
