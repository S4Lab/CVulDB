chaos__pdsh
commit 6296e82cc3b399b38ec0bea2b846c96a1de5cb9e
Author:     Mark A. Grondona <mgrondona@llnl.gov>
AuthorDate: Thu Sep 2 18:01:06 2010 +0000
Commit:     Mark A. Grondona <mgrondona@llnl.gov>
CommitDate: Thu Sep 2 18:01:06 2010 +0000

    Update libltdl
    
    Update libltdl to version with fix for CVE-2009-3736.
    (Though pdsh most likely wasn't vulnerable to this bug libtool bug)

diff --git a/ChangeLog b/ChangeLog
index 5588f0c..493db58 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,8 @@
+2010-03-16  Mark Grondona <mgrondona@llnl.gov>
+
+	* src/pdsh/ltdl.c, src/pdsh/ltdl.h :
+	  Update libltdl from latest RHEL5.4 libtool.
+
 2009-09-29  Mark Grondona <mgrondona@llnl.gov>
 
 	* : tag pdsh-2.20.
diff --git a/src/pdsh/ltdl.c b/src/pdsh/ltdl.c
index 820bd30..3f08a75 100644
--- a/src/pdsh/ltdl.c
+++ b/src/pdsh/ltdl.c
@@ -1,5 +1,5 @@
 /* ltdl.c -- system independent dlopen wrapper
-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2004, 2005  Free Software Foundation, Inc.
    Originally by Thomas Tanner <tanner@ffii.org>
    This file is part of GNU Libtool.
 
@@ -20,8 +20,8 @@ Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-02111-1307  USA
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301  USA
 
 */
 
@@ -37,8 +37,14 @@ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 #  include <stdio.h>
 #endif
 
+/* Include the header defining malloc.  On K&R C compilers,
+   that's <malloc.h>, on ANSI C and ISO C compilers, that's <stdlib.h>.  */
 #if HAVE_STDLIB_H
 #  include <stdlib.h>
+#else
+#  if HAVE_MALLOC_H
+#    include <malloc.h>
+#  endif
 #endif
 
 #if HAVE_STRING_H
@@ -53,10 +59,6 @@ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 #  include <ctype.h>
 #endif
 
-#if HAVE_MALLOC_H
-#  include <malloc.h>
-#endif
-
 #if HAVE_MEMORY_H
 #  include <memory.h>
 #endif
@@ -65,20 +67,52 @@ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 #  include <errno.h>
 #endif
 
-#if HAVE_DIRENT_H
+
+#ifndef __WINDOWS__
+#  ifdef __WIN32__
+#    define __WINDOWS__
+#  endif
+#endif
+
+
+#undef LT_USE_POSIX_DIRENT
+#ifdef HAVE_CLOSEDIR
+#  ifdef HAVE_OPENDIR
+#    ifdef HAVE_READDIR
+#      ifdef HAVE_DIRENT_H
+#        define LT_USE_POSIX_DIRENT
+#      endif /* HAVE_DIRENT_H */
+#    endif /* HAVE_READDIR */
+#  endif /* HAVE_OPENDIR */
+#endif /* HAVE_CLOSEDIR */
+
+
+#undef LT_USE_WINDOWS_DIRENT_EMULATION
+#ifndef LT_USE_POSIX_DIRENT
+#  ifdef __WINDOWS__
+#    define LT_USE_WINDOWS_DIRENT_EMULATION
+#  endif /* __WINDOWS__ */
+#endif /* LT_USE_POSIX_DIRENT */
+
+
+#ifdef LT_USE_POSIX_DIRENT
 #  include <dirent.h>
 #  define LT_D_NAMLEN(dirent) (strlen((dirent)->d_name))
 #else
-#  define dirent direct
-#  define LT_D_NAMLEN(dirent) ((dirent)->d_namlen)
-#  if HAVE_SYS_NDIR_H
-#    include <sys/ndir.h>
-#  endif
-#  if HAVE_SYS_DIR_H
-#    include <sys/dir.h>
-#  endif
-#  if HAVE_NDIR_H
-#    include <ndir.h>
+#  ifdef LT_USE_WINDOWS_DIRENT_EMULATION
+#    define LT_D_NAMLEN(dirent) (strlen((dirent)->d_name))
+#  else
+#    define dirent direct
+#    define LT_D_NAMLEN(dirent) ((dirent)->d_namlen)
+#    if HAVE_SYS_NDIR_H
+#      include <sys/ndir.h>
+#    endif
+#    if HAVE_SYS_DIR_H
+#      include <sys/dir.h>
+#    endif
+#    if HAVE_NDIR_H
+#      include <ndir.h>
+#    endif
 #  endif
 #endif
 
@@ -118,7 +152,28 @@ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 #  define LT_READTEXT_MODE "r"
 #endif
 
+#ifdef LT_USE_WINDOWS_DIRENT_EMULATION
+
+#include <windows.h>
+
+#define dirent lt_dirent
+#define DIR lt_DIR
+
+struct dirent
+{
+  char d_name[2048];
+  int  d_namlen;
+};
+
+typedef struct _DIR
+{
+  HANDLE hSearch;
+  WIN32_FIND_DATA Win32FindData;
+  BOOL firsttime;
+  struct dirent file_info;
+} DIR;
 
+#endif /* LT_USE_WINDOWS_DIRENT_EMULATION */
 
 
 /* --- MANIFEST CONSTANTS --- */
@@ -158,7 +213,8 @@ static char   *lt_estrdup	LT_PARAMS((const char *str));
 static lt_ptr lt_emalloc	LT_PARAMS((size_t size));
 static lt_ptr lt_erealloc	LT_PARAMS((lt_ptr addr, size_t size));
 
-static lt_ptr rpl_realloc	LT_PARAMS((lt_ptr ptr, size_t size));
+/* static lt_ptr rpl_realloc	LT_PARAMS((lt_ptr ptr, size_t size)); */
+#define rpl_realloc realloc
 
 /* These are the pointers that can be changed by the caller:  */
 LT_GLOBAL_DATA lt_ptr (*lt_dlmalloc)	LT_PARAMS((size_t size))
@@ -183,7 +239,7 @@ LT_GLOBAL_DATA void   (*lt_dlfree)	LT_PARAMS((lt_ptr ptr))
 #else
 
 #define LT_DLMALLOC(tp, n)	((tp *) lt_dlmalloc ((n) * sizeof(tp)))
-#define LT_DLREALLOC(tp, p, n)	((tp *) rpl_realloc ((p), (n) * sizeof(tp)))
+#define LT_DLREALLOC(tp, p, n)	((tp *) lt_dlrealloc ((p), (n) * sizeof(tp)))
 #define LT_DLFREE(p)						\
 	LT_STMT_START { if (p) (p) = (lt_dlfree (p), (lt_ptr) 0); } LT_STMT_END
 
@@ -209,7 +265,7 @@ static char *
 strdup(str)
      const char *str;
 {
-  char *tmp = NULL;
+  char *tmp = 0;
 
   if (str)
     {
@@ -238,9 +294,9 @@ strcmp (str1, str2)
 {
   if (str1 == str2)
     return 0;
-  if (str1 == NULL)
+  if (str1 == 0)
     return -1;
-  if (str2 == NULL)
+  if (str2 == 0)
     return 1;
 
   for (;*str1 && *str2; ++str1, ++str2)
@@ -294,7 +350,7 @@ strrchr(str, ch)
      const char *str;
      int ch;
 {
-  const char *p, *q = NULL;
+  const char *p, *q = 0;
 
   for (p = str; *p != LT_EOS_CHAR; ++p)
     {
@@ -329,11 +385,13 @@ memcpy (dest, src, size)
      const lt_ptr src;
      size_t size;
 {
-  size_t i = 0;
+  const char *	s = src;
+  char *	d = dest;
+  size_t	i = 0;
 
   for (i = 0; i < size; ++i)
     {
-      dest[i] = src[i];
+      d[i] = s[i];
     }
 
   return dest;
@@ -353,17 +411,21 @@ memmove (dest, src, size)
      const lt_ptr src;
      size_t size;
 {
-  size_t i;
+  const char *	s = src;
+  char *	d = dest;
+  size_t	i;
 
-  if (dest < src)
+  if (d < s)
     for (i = 0; i < size; ++i)
       {
-	dest[i] = src[i];
+	d[i] = s[i];
       }
-  else if (dest > src)
-    for (i = size -1; i >= 0; --i)
+  else if (d > s && size > 0)
+    for (i = size -1; ; --i)
       {
-	dest[i] = src[i];
+	d[i] = s[i];
+	if (i == 0)
+	  break;
       }
 
   return dest;
@@ -371,6 +433,79 @@ memmove (dest, src, size)
 
 #endif /* !HAVE_MEMMOVE */
 
+#ifdef LT_USE_WINDOWS_DIRENT_EMULATION
+
+static void closedir LT_PARAMS((DIR *entry));
+
+static void
+closedir(entry)
+  DIR *entry;
+{
+  assert(entry != (DIR *) NULL);
+  FindClose(entry->hSearch);
+  lt_dlfree((lt_ptr)entry);
+}
+
+
+static DIR * opendir LT_PARAMS((const char *path));
+
+static DIR*
+opendir (path)
+  const char *path;
+{
+  char file_specification[LT_FILENAME_MAX];
+  DIR *entry;
+
+  assert(path != (char *) NULL);
+  /* allow space for: path + '\\' '\\' '*' '.' '*' + '\0' */
+  (void) strncpy (file_specification, path, LT_FILENAME_MAX-6);
+  file_specification[LT_FILENAME_MAX-6] = LT_EOS_CHAR;
+  (void) strcat(file_specification,"\\");
+  entry = LT_DLMALLOC (DIR,sizeof(DIR));
+  if (entry != (DIR *) 0)
+    {
+      entry->firsttime = TRUE;
+      entry->hSearch = FindFirstFile(file_specification,&entry->Win32FindData);
+    }
+  if (entry->hSearch == INVALID_HANDLE_VALUE)
+    {
+      (void) strcat(file_specification,"\\*.*");
+      entry->hSearch = FindFirstFile(file_specification,&entry->Win32FindData);
+      if (entry->hSearch == INVALID_HANDLE_VALUE)
+        {
+          LT_DLFREE (entry);
+          return (DIR *) 0;
+        }
+    }
+  return(entry);
+}
+
+
+static struct dirent *readdir LT_PARAMS((DIR *entry));
+
+static struct dirent *readdir(entry)
+  DIR *entry;
+{
+  int
+    status;
+
+  if (entry == (DIR *) 0)
+    return((struct dirent *) 0);
+  if (!entry->firsttime)
+    {
+      status = FindNextFile(entry->hSearch,&entry->Win32FindData);
+      if (status == 0)
+        return((struct dirent *) 0);
+    }
+  entry->firsttime = FALSE;
+  (void) strncpy(entry->file_info.d_name,entry->Win32FindData.cFileName,
+    LT_FILENAME_MAX-1);
+  entry->file_info.d_name[LT_FILENAME_MAX - 1] = LT_EOS_CHAR;
+  entry->file_info.d_namlen = strlen(entry->file_info.d_name);
+  return(&entry->file_info);
+}
+
+#endif /* LT_USE_WINDOWS_DIRENT_EMULATION */
 
 /* According to Alexandre Oliva <oliva@lsd.ic.unicamp.br>,
     ``realloc is not entirely portable''
@@ -379,8 +514,15 @@ memmove (dest, src, size)
    Instead implement our own version (with known boundary conditions)
    using lt_dlmalloc and lt_dlfree. */
 
-#undef realloc
-#define realloc rpl_realloc
+/* #undef realloc
+   #define realloc rpl_realloc
+*/
+#if 0
+  /* You can't (re)define realloc unless you also (re)define malloc.
+     Right now, this code uses the size of the *destination* to decide
+     how much to copy.  That's not right, but you can't know the size
+     of the source unless you know enough about, or wrote malloc.  So
+     this code is disabled... */
 
 static lt_ptr
 realloc (ptr, size)
@@ -390,14 +532,14 @@ realloc (ptr, size)
   if (size == 0)
     {
       /* For zero or less bytes, free the original memory */
-      if (ptr != NULL)
+      if (ptr != 0)
 	{
 	  lt_dlfree (ptr);
 	}
 
       return (lt_ptr) 0;
     }
-  else if (ptr == NULL)
+  else if (ptr == 0)
     {
       /* Allow reallocation of a NULL pointer.  */
       return lt_dlmalloc (size);
@@ -418,6 +560,7 @@ realloc (ptr, size)
       return mem;
     }
 }
+#endif
 
 
 #if ! HAVE_ARGZ_APPEND
@@ -476,13 +619,13 @@ argz_create_sep (str, delim, pargz, pargz_len)
      size_t *pargz_len;
 {
   size_t argz_len;
-  char *argz = NULL;
+  char *argz = 0;
 
   assert (str);
   assert (pargz);
   assert (pargz_len);
 
-  /* Make a copy of STR, but replacing each occurence of
+  /* Make a copy of STR, but replacing each occurrence of
      DELIM with '\0'.  */
   argz_len = 1+ LT_STRLEN (str);
   if (argz_len)
@@ -550,7 +693,7 @@ argz_insert (pargz, pargz_len, before, entry)
   /* This probably indicates a programmer error, but to preserve
      semantics, scan back to the start of an entry if BEFORE points
      into the middle of it.  */
-  while ((before >= *pargz) && (before[-1] != LT_EOS_CHAR))
+  while ((before > *pargz) && (before[-1] != LT_EOS_CHAR))
     --before;
 
   {
@@ -751,17 +894,17 @@ static	const char	sys_search_path[]	= LTDL_SYSSEARCHPATH;
 		(*lt_dlmutex_seterror_func) (errormsg);		\
 	else 	lt_dllast_error = (errormsg);	} LT_STMT_END
 #define LT_DLMUTEX_GETERROR(errormsg)		LT_STMT_START {	\
-	if (lt_dlmutex_seterror_func)				\
+	if (lt_dlmutex_geterror_func)				\
 		(errormsg) = (*lt_dlmutex_geterror_func) ();	\
 	else	(errormsg) = lt_dllast_error;	} LT_STMT_END
 
 /* The mutex functions stored here are global, and are necessarily the
    same for all threads that wish to share access to libltdl.  */
-static	lt_dlmutex_lock	    *lt_dlmutex_lock_func     = NULL;
-static	lt_dlmutex_unlock   *lt_dlmutex_unlock_func   = NULL;
-static	lt_dlmutex_seterror *lt_dlmutex_seterror_func = NULL;
-static	lt_dlmutex_geterror *lt_dlmutex_geterror_func = NULL;
-static	const char	    *lt_dllast_error	      = NULL;
+static	lt_dlmutex_lock	    *lt_dlmutex_lock_func     = 0;
+static	lt_dlmutex_unlock   *lt_dlmutex_unlock_func   = 0;
+static	lt_dlmutex_seterror *lt_dlmutex_seterror_func = 0;
+static	lt_dlmutex_geterror *lt_dlmutex_geterror_func = 0;
+static	const char	    *lt_dllast_error	      = 0;
 
 
 /* Either set or reset the mutex functions.  Either all the arguments must
@@ -810,7 +953,7 @@ lt_dlmutex_register (lock, unlock, seterror, geterror)
 /* --- ERROR HANDLING --- */
 
 
-static	const char    **user_error_strings	= NULL;
+static	const char    **user_error_strings	= 0;
 static	int		errorcount		= LT_ERROR_MAX;
 
 int
@@ -819,7 +962,7 @@ lt_dladderror (diagnostic)
 {
   int		errindex = 0;
   int		result	 = -1;
-  const char  **temp     = NULL;
+  const char  **temp     = (const char **) 0;
 
   assert (diagnostic);
 
@@ -884,7 +1027,7 @@ lt_erealloc (addr, size)
      lt_ptr addr;
      size_t size;
 {
-  lt_ptr mem = realloc (addr, size);
+  lt_ptr mem = lt_dlrealloc (addr, size);
   if (size && !mem)
     LT_DLMUTEX_SETERROR (LT_DLSTRERROR (NO_MEMORY));
   return mem;
@@ -906,11 +1049,7 @@ lt_estrdup (str)
 /* --- DLOPEN() INTERFACE LOADER --- */
 
 
-/* The Cygwin dlopen implementation prints a spurious error message to
-   stderr if its call to LoadLibrary() fails for any reason.  We can
-   mitigate this by not using the Cygwin implementation, and falling
-   back to our own LoadLibrary() wrapper. */
-#if HAVE_LIBDL && !defined(__CYGWIN__)
+#if HAVE_LIBDL
 
 /* dynamic linking with dlopen/dlsym */
 
@@ -1131,7 +1270,7 @@ sys_shl_sym (loader_data, module, symbol)
      lt_module module;
      const char *symbol;
 {
-  lt_ptr address = NULL;
+  lt_ptr address = 0;
 
   /* sys_shl_open should never return a NULL module handle */
   if (module == (lt_module) 0)
@@ -1175,16 +1314,16 @@ sys_wll_open (loader_data, filename)
      const char *filename;
 {
   lt_dlhandle	cur;
-  lt_module	module	   = NULL;
-  const char   *errormsg   = NULL;
-  char	       *searchname = NULL;
+  lt_module	module	   = 0;
+  const char   *errormsg   = 0;
+  char	       *searchname = 0;
   char	       *ext;
   char		self_name_buf[MAX_PATH];
 
   if (!filename)
     {
       /* Get the name of main module */
-      *self_name_buf = '\0';
+      *self_name_buf = 0;
       GetModuleFileName (NULL, self_name_buf, sizeof (self_name_buf));
       filename = ext = self_name_buf;
     }
@@ -1209,15 +1348,27 @@ sys_wll_open (loader_data, filename)
   if (!searchname)
     return 0;
 
-#if __CYGWIN__
   {
-    char wpath[MAX_PATH];
-    cygwin_conv_to_full_win32_path(searchname, wpath);
-    module = LoadLibrary(wpath);
-  }
+    /* Silence dialog from LoadLibrary on some failures.
+       No way to get the error mode, but to set it,
+       so set it twice to preserve any previous flags. */
+    UINT errormode = SetErrorMode(SEM_FAILCRITICALERRORS);
+    SetErrorMode(errormode | SEM_FAILCRITICALERRORS);
+
+#if defined(__CYGWIN__)
+    {
+      char wpath[MAX_PATH];
+      cygwin_conv_to_full_win32_path (searchname, wpath);
+      module = LoadLibrary (wpath);
+    }
 #else
-  module = LoadLibrary (searchname);
+    module = LoadLibrary (searchname);
 #endif
+
+    /* Restore the error mode. */
+    SetErrorMode(errormode);
+  }
+
   LT_DLFREE (searchname);
 
   /* libltdl expects this function to fail if it is unable
@@ -1234,7 +1385,7 @@ sys_wll_open (loader_data, filename)
     {
       if (!cur->module)
 	{
-	  cur = NULL;
+	  cur = 0;
 	  break;
 	}
 
@@ -1250,7 +1401,7 @@ sys_wll_open (loader_data, filename)
   if (cur || !module)
     {
       LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
-      module = NULL;
+      module = 0;
     }
 
   return module;
@@ -1356,13 +1507,13 @@ sys_bedl_sym (loader_data, module, symbol)
      lt_module module;
      const char *symbol;
 {
-  lt_ptr address = NULL;
+  lt_ptr address = 0;
   image_id image = (image_id) module;
 
   if (get_image_symbol (image, symbol, B_SYMBOL_TYPE_ANY, address) != B_OK)
     {
       LT_DLMUTEX_SETERROR (LT_DLSTRERROR (SYMBOL_NOT_FOUND));
-      address = NULL;
+      address = 0;
     }
 
   return address;
@@ -1399,7 +1550,7 @@ sys_dld_open (loader_data, filename)
     {
       LT_DLMUTEX_SETERROR (LT_DLSTRERROR (CANNOT_OPEN));
       LT_DLFREE (module);
-      module = NULL;
+      module = 0;
     }
 
   return module;
@@ -1447,7 +1598,350 @@ static struct lt_user_dlloader sys_dld = {
 
 #endif /* HAVE_DLD */
 
+/* --- DYLD() MACOSX/DARWIN INTERFACE LOADER --- */
+#if HAVE_DYLD
+
+
+#if HAVE_MACH_O_DYLD_H
+#if !defined(__APPLE_CC__) && !defined(__MWERKS__) && !defined(__private_extern__)
+/* Is this correct? Does it still function properly? */
+#define __private_extern__ extern
+#endif
+# include <mach-o/dyld.h>
+#endif
+#include <mach-o/getsect.h>
+
+/* We have to put some stuff here that isn't in older dyld.h files */
+#ifndef ENUM_DYLD_BOOL
+# define ENUM_DYLD_BOOL
+# undef FALSE
+# undef TRUE
+ enum DYLD_BOOL {
+    FALSE,
+    TRUE
+ };
+#endif
+#ifndef LC_REQ_DYLD
+# define LC_REQ_DYLD 0x80000000
+#endif
+#ifndef LC_LOAD_WEAK_DYLIB
+# define LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)
+#endif
+static const struct mach_header * (*ltdl_NSAddImage)(const char *image_name, unsigned long options) = 0;
+static NSSymbol (*ltdl_NSLookupSymbolInImage)(const struct mach_header *image,const char *symbolName, unsigned long options) = 0;
+static enum DYLD_BOOL (*ltdl_NSIsSymbolNameDefinedInImage)(const struct mach_header *image, const char *symbolName) = 0;
+static enum DYLD_BOOL (*ltdl_NSMakePrivateModulePublic)(NSModule module) = 0;
+
+#ifndef NSADDIMAGE_OPTION_NONE
+#define NSADDIMAGE_OPTION_NONE                          0x0
+#endif
+#ifndef NSADDIMAGE_OPTION_RETURN_ON_ERROR
+#define NSADDIMAGE_OPTION_RETURN_ON_ERROR               0x1
+#endif
+#ifndef NSADDIMAGE_OPTION_WITH_SEARCHING
+#define NSADDIMAGE_OPTION_WITH_SEARCHING                0x2
+#endif
+#ifndef NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED
+#define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED         0x4
+#endif
+#ifndef NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME
+#define NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME 0x8
+#endif
+#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND
+#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND            0x0
+#endif
+#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
+#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW        0x1
+#endif
+#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY
+#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY      0x2
+#endif
+#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
+#define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR 0x4
+#endif
+
+
+static const char *
+lt_int_dyld_error(othererror)
+	char* othererror;
+{
+/* return the dyld error string, or the passed in error string if none */
+	NSLinkEditErrors ler;
+	int lerno;
+	const char *errstr;
+	const char *file;
+	NSLinkEditError(&ler,&lerno,&file,&errstr);
+	if (!errstr || !strlen(errstr)) errstr = othererror;
+	return errstr;
+}
+
+static const struct mach_header *
+lt_int_dyld_get_mach_header_from_nsmodule(module)
+	NSModule module;
+{
+/* There should probably be an apple dyld api for this */
+	int i=_dyld_image_count();
+	int j;
+	const char *modname=NSNameOfModule(module);
+	const struct mach_header *mh=NULL;
+	if (!modname) return NULL;
+	for (j = 0; j < i; j++)
+	{
+		if (!strcmp(_dyld_get_image_name(j),modname))
+		{
+			mh=_dyld_get_image_header(j);
+			break;
+		}
+	}
+	return mh;
+}
+
+static const char* lt_int_dyld_lib_install_name(mh)
+	const struct mach_header *mh;
+{
+/* NSAddImage is also used to get the loaded image, but it only works if the lib
+   is installed, for uninstalled libs we need to check the install_names against
+   each other. Note that this is still broken if DYLD_IMAGE_SUFFIX is set and a
+   different lib was loaded as a result
+*/
+	int j;
+	struct load_command *lc;
+	unsigned long offset = sizeof(struct mach_header);
+	const char* retStr=NULL;
+	for (j = 0; j < mh->ncmds; j++)
+	{
+		lc = (struct load_command*)(((unsigned long)mh) + offset);
+		if (LC_ID_DYLIB == lc->cmd)
+		{
+			retStr=(char*)(((struct dylib_command*)lc)->dylib.name.offset +
+									(unsigned long)lc);
+		}
+		offset += lc->cmdsize;
+	}
+	return retStr;
+}
+
+static const struct mach_header *
+lt_int_dyld_match_loaded_lib_by_install_name(const char *name)
+{
+	int i=_dyld_image_count();
+	int j;
+	const struct mach_header *mh=NULL;
+	const char *id=NULL;
+	for (j = 0; j < i; j++)
+	{
+		id=lt_int_dyld_lib_install_name(_dyld_get_image_header(j));
+		if ((id) && (!strcmp(id,name)))
+		{
+			mh=_dyld_get_image_header(j);
+			break;
+		}
+	}
+	return mh;
+}
+
+static NSSymbol
+lt_int_dyld_NSlookupSymbolInLinkedLibs(symbol,mh)
+	const char *symbol;
+	const struct mach_header *mh;
+{
+	/* Safe to assume our mh is good */
+	int j;
+	struct load_command *lc;
+	unsigned long offset = sizeof(struct mach_header);
+	NSSymbol retSym = 0;
+	const struct mach_header *mh1;
+	if ((ltdl_NSLookupSymbolInImage) && NSIsSymbolNameDefined(symbol) )
+	{
+		for (j = 0; j < mh->ncmds; j++)
+		{
+			lc = (struct load_command*)(((unsigned long)mh) + offset);
+			if ((LC_LOAD_DYLIB == lc->cmd) || (LC_LOAD_WEAK_DYLIB == lc->cmd))
+			{
+				mh1=lt_int_dyld_match_loaded_lib_by_install_name((char*)(((struct dylib_command*)lc)->dylib.name.offset +
+										(unsigned long)lc));
+				if (!mh1)
+				{
+					/* Maybe NSAddImage can find it */
+					mh1=ltdl_NSAddImage((char*)(((struct dylib_command*)lc)->dylib.name.offset +
+										(unsigned long)lc),
+										NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED +
+										NSADDIMAGE_OPTION_WITH_SEARCHING +
+										NSADDIMAGE_OPTION_RETURN_ON_ERROR );
+				}
+				if (mh1)
+				{
+					retSym = ltdl_NSLookupSymbolInImage(mh1,
+											symbol,
+											NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
+											| NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
+											);
+					if (retSym) break;
+				}
+			}
+			offset += lc->cmdsize;
+		}
+	}
+	return retSym;
+}
+
+static int
+sys_dyld_init()
+{
+	int retCode = 0;
+	int err = 0;
+	if (!_dyld_present()) {
+		retCode=1;
+	}
+	else {
+      err = _dyld_func_lookup("__dyld_NSAddImage",(unsigned long*)&ltdl_NSAddImage);
+      err = _dyld_func_lookup("__dyld_NSLookupSymbolInImage",(unsigned long*)&ltdl_NSLookupSymbolInImage);
+      err = _dyld_func_lookup("__dyld_NSIsSymbolNameDefinedInImage",(unsigned long*)&ltdl_NSIsSymbolNameDefinedInImage);
+      err = _dyld_func_lookup("__dyld_NSMakePrivateModulePublic",(unsigned long*)&ltdl_NSMakePrivateModulePublic);
+    }
+ return retCode;
+}
+
+static lt_module
+sys_dyld_open (loader_data, filename)
+     lt_user_data loader_data;
+     const char *filename;
+{
+	lt_module   module   = 0;
+	NSObjectFileImage ofi = 0;
+	NSObjectFileImageReturnCode ofirc;
+
+  	if (!filename)
+  		return (lt_module)-1;
+	ofirc = NSCreateObjectFileImageFromFile(filename, &ofi);
+	switch (ofirc)
+	{
+		case NSObjectFileImageSuccess:
+			module = NSLinkModule(ofi, filename,
+						NSLINKMODULE_OPTION_RETURN_ON_ERROR
+						 | NSLINKMODULE_OPTION_PRIVATE
+						 | NSLINKMODULE_OPTION_BINDNOW);
+			NSDestroyObjectFileImage(ofi);
+			if (module)
+				ltdl_NSMakePrivateModulePublic(module);
+			break;
+		case NSObjectFileImageInappropriateFile:
+		    if (ltdl_NSIsSymbolNameDefinedInImage && ltdl_NSLookupSymbolInImage)
+		    {
+				module = (lt_module)ltdl_NSAddImage(filename, NSADDIMAGE_OPTION_RETURN_ON_ERROR);
+				break;
+			}
+		default:
+			LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_OPEN)));
+			return 0;
+	}
+	if (!module) LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_OPEN)));
+  return module;
+}
+
+static int
+sys_dyld_close (loader_data, module)
+     lt_user_data loader_data;
+     lt_module module;
+{
+	int retCode = 0;
+	int flags = 0;
+	if (module == (lt_module)-1) return 0;
+#ifdef __BIG_ENDIAN__
+  	if (((struct mach_header *)module)->magic == MH_MAGIC)
+#else
+    if (((struct mach_header *)module)->magic == MH_CIGAM)
+#endif
+	{
+	  LT_DLMUTEX_SETERROR("Can not close a dylib");
+	  retCode = 1;
+	}
+	else
+	{
+#if 1
+/* Currently, if a module contains c++ static destructors and it is unloaded, we
+   get a segfault in atexit(), due to compiler and dynamic loader differences of
+   opinion, this works around that.
+*/
+		if ((const struct section *)NULL !=
+		   getsectbynamefromheader(lt_int_dyld_get_mach_header_from_nsmodule(module),
+		   "__DATA","__mod_term_func"))
+		{
+			flags += NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED;
+		}
+#endif
+#ifdef __ppc__
+			flags += NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES;
+#endif
+		if (!NSUnLinkModule(module,flags))
+		{
+			retCode=1;
+			LT_DLMUTEX_SETERROR (lt_int_dyld_error(LT_DLSTRERROR(CANNOT_CLOSE)));
+		}
+	}
+
+ return retCode;
+}
 
+static lt_ptr
+sys_dyld_sym (loader_data, module, symbol)
+     lt_user_data loader_data;
+     lt_module module;
+     const char *symbol;
+{
+	lt_ptr address = 0;
+  	NSSymbol *nssym = 0;
+  	void *unused;
+  	const struct mach_header *mh=NULL;
+  	char saveError[256] = "Symbol not found";
+  	if (module == (lt_module)-1)
+  	{
+  		_dyld_lookup_and_bind(symbol,(unsigned long*)&address,&unused);
+  		return address;
+  	}
+#ifdef __BIG_ENDIAN__
+  	if (((struct mach_header *)module)->magic == MH_MAGIC)
+#else
+    if (((struct mach_header *)module)->magic == MH_CIGAM)
+#endif
+  	{
+  	    if (ltdl_NSIsSymbolNameDefinedInImage && ltdl_NSLookupSymbolInImage)
+  	    {
+  	    	mh=module;
+			if (ltdl_NSIsSymbolNameDefinedInImage((struct mach_header*)module,symbol))
+			{
+				nssym = ltdl_NSLookupSymbolInImage((struct mach_header*)module,
+											symbol,
+											NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW
+											| NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR
+											);
+			}
+	    }
+
+  	}
+  else {
+	nssym = NSLookupSymbolInModule(module, symbol);
+	}
+	if (!nssym)
+	{
+		strncpy(saveError, lt_int_dyld_error(LT_DLSTRERROR(SYMBOL_NOT_FOUND)), 255);
+		saveError[255] = 0;
+		if (!mh) mh=lt_int_dyld_get_mach_header_from_nsmodule(module);
+		nssym = lt_int_dyld_NSlookupSymbolInLinkedLibs(symbol,mh);
+	}
+	if (!nssym)
+	{
+		LT_DLMUTEX_SETERROR (saveError);
+		return NULL;
+	}
+	return NSAddressOfSymbol(nssym);
+}
+
+static struct lt_user_dlloader sys_dyld =
+  { "_", sys_dyld_open, sys_dyld_close, sys_dyld_sym, 0, 0 };
+
+
+#endif /* HAVE_DYLD */
 
 
 /* --- DLPREOPEN() INTERFACE LOADER --- */
@@ -1461,8 +1955,8 @@ typedef struct lt_dlsymlists_t
   const lt_dlsymlist	       *syms;
 } lt_dlsymlists_t;
 
-static	const lt_dlsymlist     *default_preloaded_symbols	= NULL;
-static	lt_dlsymlists_t	       *preloaded_symbols		= NULL;
+static	const lt_dlsymlist     *default_preloaded_symbols	= 0;
+static	lt_dlsymlists_t	       *preloaded_symbols		= 0;
 
 static int
 presym_init (loader_data)
@@ -1472,7 +1966,7 @@ presym_init (loader_data)
 
   LT_DLMUTEX_LOCK ();
 
-  preloaded_symbols = NULL;
+  preloaded_symbols = 0;
   if (default_preloaded_symbols)
     {
       errors = lt_dlpreload (default_preloaded_symbols);
@@ -1498,7 +1992,7 @@ presym_free_symlists ()
       lists = lists->next;
       LT_DLFREE (tmp);
     }
-  preloaded_symbols = NULL;
+  preloaded_symbols = 0;
 
   LT_DLMUTEX_UNLOCK ();
 
@@ -1607,7 +2101,7 @@ presym_close (loader_data, module)
      lt_module module;
 {
   /* Just to silence gcc -Wall */
-  module = NULL;
+  module = 0;
   return 0;
 }
 
@@ -1689,7 +2183,8 @@ static	int	trim		      LT_PARAMS((char **dest,
 static	int	try_dlopen	      LT_PARAMS((lt_dlhandle *handle,
 						 const char *filename));
 static	int	tryall_dlopen	      LT_PARAMS((lt_dlhandle *handle,
-						 const char *filename));
+						 const char *filename,
+						 const char * useloader));
 static	int	unload_deplibs	      LT_PARAMS((lt_dlhandle handle));
 static	int	lt_argz_insert	      LT_PARAMS((char **pargz,
 						 size_t *pargz_len,
@@ -1710,9 +2205,9 @@ static	int	list_files_by_dir     LT_PARAMS((const char *dirnam,
 						 size_t *pargz_len));
 static	int	file_not_found	      LT_PARAMS((void));
 
-static	char	       *user_search_path= NULL;
-static	lt_dlloader    *loaders		= NULL;
-static	lt_dlhandle	handles 	= NULL;
+static	char	       *user_search_path= 0;
+static	lt_dlloader    *loaders		= 0;
+static	lt_dlhandle	handles 	= 0;
 static	int		initialized 	= 0;
 
 /* Initialize libltdl. */
@@ -1726,10 +2221,10 @@ lt_dlinit ()
   /* Initialize only at first call. */
   if (++initialized == 1)
     {
-      handles = NULL;
-      user_search_path = NULL; /* empty search path */
+      handles = 0;
+      user_search_path = 0; /* empty search path */
 
-#if HAVE_LIBDL && !defined(__CYGWIN__)
+#if HAVE_LIBDL
       errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dl, "dlopen");
 #endif
 #if HAVE_SHL_LOAD
@@ -1743,6 +2238,10 @@ lt_dlinit ()
 #endif
 #if HAVE_DLD
       errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dld, "dld");
+#endif
+#if HAVE_DYLD
+       errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dyld, "dyld");
+       errors += sys_dyld_init();
 #endif
       errors += lt_dlloader_add (lt_dlloader_next (0), &presym, "dlpreload");
 
@@ -1862,7 +2361,7 @@ lt_dlexit ()
 
 	  LT_DLMEM_REASSIGN (loader, next);
 	}
-      loaders = NULL;
+      loaders = 0;
     }
 
  done:
@@ -1871,9 +2370,10 @@ lt_dlexit ()
 }
 
 static int
-tryall_dlopen (handle, filename)
+tryall_dlopen (handle, filename, useloader)
      lt_dlhandle *handle;
      const char *filename;
+     const char *useloader;
 {
   lt_dlhandle	 cur;
   lt_dlloader   *loader;
@@ -1914,6 +2414,18 @@ tryall_dlopen (handle, filename)
   cur = *handle;
   if (filename)
     {
+      /* Comment out the check of file permissions using access.
+	 This call seems to always return -1 with error EACCES.
+      */
+      /* We need to catch missing file errors early so that
+	 file_not_found() can detect what happened.
+      if (access (filename, R_OK) != 0)
+	{
+	  LT_DLMUTEX_SETERROR (LT_DLSTRERROR (FILE_NOT_FOUND));
+	  ++errors;
+	  goto done;
+	} */
+
       cur->info.filename = lt_estrdup (filename);
       if (!cur->info.filename)
 	{
@@ -1923,16 +2435,21 @@ tryall_dlopen (handle, filename)
     }
   else
     {
-      cur->info.filename = NULL;
+      cur->info.filename = 0;
     }
 
   while (loader)
     {
+      if (useloader && strcmp(loader->loader_name, useloader))
+	{
+	  loader = loader->next;
+	  continue;
+	}
       lt_user_data data = loader->dlloader_data;
 
       cur->module = loader->module_open (data, filename);
 
-      if (cur->module != NULL)
+      if (cur->module != 0)
 	{
 	  break;
 	}
@@ -1963,7 +2480,7 @@ tryall_dlopen_module (handle, prefix, dirname, dlname)
      const char *dlname;
 {
   int      error	= 0;
-  char     *filename	= NULL;
+  char     *filename	= 0;
   size_t   filename_len	= 0;
   size_t   dirname_len	= LT_STRLEN (dirname);
 
@@ -1973,11 +2490,12 @@ tryall_dlopen_module (handle, prefix, dirname, dlname)
 #ifdef LT_DIRSEP_CHAR
   /* Only canonicalized names (i.e. with DIRSEP chars already converted)
      should make it into this function:  */
-  assert (strchr (dirname, LT_DIRSEP_CHAR) == NULL);
+  assert (strchr (dirname, LT_DIRSEP_CHAR) == 0);
 #endif
 
-  if (dirname[dirname_len -1] == '/')
-    --dirname_len;
+  if (dirname_len > 0)
+    if (dirname[dirname_len -1] == '/')
+      --dirname_len;
   filename_len = dirname_len + 1 + LT_STRLEN (dlname);
 
   /* Allocate memory, and combine DIRNAME and MODULENAME into it.
@@ -1996,7 +2514,7 @@ tryall_dlopen_module (handle, prefix, dirname, dlname)
       error += tryall_dlopen_module (handle,
 				     (const char *) 0, prefix, filename);
     }
-  else if (tryall_dlopen (handle, filename) != 0)
+  else if (tryall_dlopen (handle, filename, NULL) != 0)
     {
       ++error;
     }
@@ -2017,7 +2535,7 @@ find_module (handle, dir, libdir, dlname, old_name, installed)
   /* Try to open the old library first; if it was dlpreopened,
      we want the preopened version of it, even if a dlopenable
      module is available.  */
-  if (old_name && tryall_dlopen (handle, old_name) == 0)
+  if (old_name && tryall_dlopen (handle, old_name, "dlpreload") == 0)
     {
       return 0;
     }
@@ -2042,8 +2560,8 @@ find_module (handle, dir, libdir, dlname, old_name, installed)
 
       /* maybe it was moved to another directory */
       {
-	  if (tryall_dlopen_module (handle,
-				    (const char *) 0, dir, dlname) == 0)
+	  if (dir && (tryall_dlopen_module (handle,
+				    (const char *) 0, dir, dlname) == 0))
 	    return 0;
       }
     }
@@ -2057,7 +2575,7 @@ canonicalize_path (path, pcanonical)
      const char *path;
      char **pcanonical;
 {
-  char *canonical = NULL;
+  char *canonical = 0;
 
   assert (path && *path);
   assert (pcanonical);
@@ -2161,9 +2679,9 @@ foreach_dirinpath (search_path, base_name, func, data1, data2)
   int	 filenamesize	= 0;
   size_t lenbase	= LT_STRLEN (base_name);
   size_t argz_len	= 0;
-  char *argz		= NULL;
-  char *filename	= NULL;
-  char *canonical	= NULL;
+  char *argz		= 0;
+  char *filename	= 0;
+  char *canonical	= 0;
 
   LT_DLMUTEX_LOCK ();
 
@@ -2180,7 +2698,7 @@ foreach_dirinpath (search_path, base_name, func, data1, data2)
     goto cleanup;
 
   {
-    char *dir_name = NULL;
+    char *dir_name = 0;
     while ((dir_name = argz_next (argz, argz_len, dir_name)))
       {
 	size_t lendir = LT_STRLEN (dir_name);
@@ -2247,7 +2765,7 @@ find_file_callback (filename, data1, data2)
 
       LT_DLFREE (*pdir);
       *pdir   = lt_estrdup (filename);
-      is_done = (*pdir == NULL) ? -1 : 1;
+      is_done = (*pdir == 0) ? -1 : 1;
     }
 
   return is_done;
@@ -2259,7 +2777,7 @@ find_file (search_path, base_name, pdir)
      const char *base_name;
      char **pdir;
 {
-  FILE *file = NULL;
+  FILE *file = 0;
 
   foreach_dirinpath (search_path, base_name, find_file_callback, pdir, &file);
 
@@ -2281,8 +2799,8 @@ find_handle_callback (filename, data, ignored)
 
   /* Try to dlopen the file, but do not continue searching in any
      case.  */
-  if (tryall_dlopen (handle, filename) != 0)
-    *handle = NULL;
+  if (tryall_dlopen (handle, filename,NULL) != 0)
+    *handle = 0;
 
   return 1;
 }
@@ -2311,10 +2829,10 @@ load_deplibs (handle, deplibs)
      char *deplibs;
 {
 #if LTDL_DLOPEN_DEPLIBS
-  char	*p, *save_search_path = NULL;
+  char	*p, *save_search_path = 0;
   int   depcount = 0;
   int	i;
-  char	**names = NULL;
+  char	**names = 0;
 #endif
   int	errors = 0;
 
@@ -2350,7 +2868,7 @@ load_deplibs (handle, deplibs)
 	  if (strncmp(p, "-L", 2) == 0 || strncmp(p, "-R", 2) == 0)
 	    {
 	      char save = *end;
-	      *end = '\0'; /* set a temporary string terminator */
+	      *end = 0; /* set a temporary string terminator */
 	      if (lt_dladdsearchdir(p+2))
 		{
 		  goto cleanup;
@@ -2370,12 +2888,6 @@ load_deplibs (handle, deplibs)
 	}
     }
 
-  /* restore the old search path */
-  LT_DLFREE (user_search_path);
-  user_search_path = save_search_path;
-
-  LT_DLMUTEX_UNLOCK ();
-
   if (!depcount)
     {
       errors = 0;
@@ -2407,7 +2919,7 @@ load_deplibs (handle, deplibs)
 	    {
 	      char *name;
 	      char save = *end;
-	      *end = '\0'; /* set a temporary string terminator */
+	      *end = 0; /* set a temporary string terminator */
 	      if (strncmp(p, "-l", 2) == 0)
 		{
 		  size_t name_len = 3+ /* "lib" */ LT_STRLEN (p + 2);
@@ -2462,6 +2974,13 @@ load_deplibs (handle, deplibs)
 
  cleanup:
   LT_DLFREE (names);
+  /* restore the old search path */
+  if (user_search_path) {
+    LT_DLFREE (user_search_path);
+    user_search_path = save_search_path;
+  }
+  LT_DLMUTEX_UNLOCK ();
+
 #endif
 
   return errors;
@@ -2501,6 +3020,9 @@ trim (dest, str)
 
   LT_DLFREE (*dest);
 
+  if (!end)
+    return 1;
+
   if (len > 3 && str[0] == '\'')
     {
       tmp = LT_EMALLOC (char, end - str);
@@ -2513,7 +3035,7 @@ trim (dest, str)
     }
   else
     {
-      *dest = NULL;
+      *dest = 0;
     }
 
   return 0;
@@ -2539,17 +3061,17 @@ try_dlopen (phandle, filename)
      lt_dlhandle *phandle;
      const char *filename;
 {
-  const char *	ext		= NULL;
-  const char *	saved_error	= NULL;
-  char *	canonical	= NULL;
-  char *	base_name	= NULL;
-  char *	dir		= NULL;
-  char *	name		= NULL;
+  const char *	ext		= 0;
+  const char *	saved_error	= 0;
+  char *	canonical	= 0;
+  char *	base_name	= 0;
+  char *	dir		= 0;
+  char *	name		= 0;
   int		errors		= 0;
   lt_dlhandle	newhandle;
 
   assert (phandle);
-  assert (*phandle == NULL);
+  assert (*phandle == 0);
 
   LT_DLMUTEX_GETERROR (saved_error);
 
@@ -2557,7 +3079,7 @@ try_dlopen (phandle, filename)
   if (!filename)
     {
       *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
-      if (*phandle == NULL)
+      if (*phandle == 0)
 	return 1;
 
       memset (*phandle, 0, sizeof(struct lt_dlhandle_struct));
@@ -2566,7 +3088,7 @@ try_dlopen (phandle, filename)
       /* lt_dlclose()ing yourself is very bad!  Disallow it.  */
       LT_DLSET_FLAG (*phandle, LT_DLRESIDENT_FLAG);
 
-      if (tryall_dlopen (&newhandle, 0) != 0)
+      if (tryall_dlopen (&newhandle, 0, NULL) != 0)
 	{
 	  LT_DLFREE (*phandle);
 	  return 1;
@@ -2605,7 +3127,7 @@ try_dlopen (phandle, filename)
       ++base_name;
     }
   else
-    LT_DLMEM_REASSIGN (base_name, canonical);
+    base_name = canonical;
 
   assert (base_name && *base_name);
 
@@ -2614,12 +3136,12 @@ try_dlopen (phandle, filename)
   if (ext && strcmp (ext, archive_ext) == 0)
     {
       /* this seems to be a libtool module */
-      FILE *	file	 = NULL;
-      char *	dlname	 = NULL;
-      char *	old_name = NULL;
-      char *	libdir	 = NULL;
-      char *	deplibs	 = NULL;
-      char *    line	 = NULL;
+      FILE *	file	 = 0;
+      char *	dlname	 = 0;
+      char *	old_name = 0;
+      char *	libdir	 = 0;
+      char *	deplibs	 = 0;
+      char *    line	 = 0;
       size_t	line_len;
 
       /* if we can't find the installed flag, it is probably an
@@ -2688,7 +3210,7 @@ try_dlopen (phandle, filename)
 	    }
 #endif
 	}
-      if (!file)
+      else
 	{
 	  file = fopen (filename, LT_READTEXT_MODE);
 	}
@@ -2721,7 +3243,7 @@ try_dlopen (phandle, filename)
 
 	  /* Handle the case where we occasionally need to read a line
 	     that is longer than the initial buffer size.  */
-	  while (line[LT_STRLEN(line) -1] != '\n')
+	  while ((line[LT_STRLEN(line) -1] != '\n') && (!feof (file)))
 	    {
 	      line = LT_DLREALLOC (char, line, line_len *2);
 	      if (!fgets (&line[line_len -1], (int) line_len +1, file))
@@ -2782,7 +3304,7 @@ try_dlopen (phandle, filename)
 	      errors += trim (&dlname, &line[sizeof (STR_LIBRARY_NAMES) - 1]);
 	      if (!errors
 		  && dlname
-		  && (last_libname = strrchr (dlname, ' ')) != NULL)
+		  && (last_libname = strrchr (dlname, ' ')) != 0)
 		{
 		  last_libname = lt_estrdup (last_libname + 1);
 		  if (!last_libname)
@@ -2803,7 +3325,7 @@ try_dlopen (phandle, filename)
 
       /* allocate the handle */
       *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
-      if (*phandle == NULL)
+      if (*phandle == 0)
 	++errors;
 
       if (errors)
@@ -2847,7 +3369,7 @@ try_dlopen (phandle, filename)
     {
       /* not a libtool module */
       *phandle = (lt_dlhandle) LT_EMALLOC (struct lt_dlhandle_struct, 1);
-      if (*phandle == NULL)
+      if (*phandle == 0)
 	{
 	  ++errors;
 	  goto cleanup;
@@ -2872,7 +3394,7 @@ try_dlopen (phandle, filename)
 #endif
 		   )))
 	{
-          if (tryall_dlopen (&newhandle, filename) != 0)
+          if (tryall_dlopen (&newhandle, filename, NULL) != 0)
             {
               newhandle = NULL;
             }
@@ -2914,7 +3436,7 @@ lt_dlhandle
 lt_dlopen (filename)
      const char *filename;
 {
-  lt_dlhandle handle = NULL;
+  lt_dlhandle handle = 0;
 
   /* Just incase we missed a code path in try_dlopen() that reports
      an error, but forgets to reset handle... */
@@ -2929,7 +3451,7 @@ lt_dlopen (filename)
 static int
 file_not_found ()
 {
-  const char *error = NULL;
+  const char *error = 0;
 
   LT_DLMUTEX_GETERROR (error);
   if (error == LT_DLSTRERROR (FILE_NOT_FOUND))
@@ -2946,9 +3468,9 @@ lt_dlhandle
 lt_dlopenext (filename)
      const char *filename;
 {
-  lt_dlhandle	handle		= NULL;
-  char *	tmp		= NULL;
-  char *	ext		= NULL;
+  lt_dlhandle	handle		= 0;
+  char *	tmp		= 0;
+  char *	ext		= 0;
   size_t	len;
   int		errors		= 0;
 
@@ -2987,7 +3509,7 @@ lt_dlopenext (filename)
      failed, it is better to return an error message here than to
      report FILE_NOT_FOUND when the alternatives (foo.so etc) are not
      in the module search path.  */
-  if (handle || ((errors > 0) && file_not_found ()))
+  if (handle || ((errors > 0) && !file_not_found ()))
     {
       LT_DLFREE (tmp);
       return handle;
@@ -3014,7 +3536,7 @@ lt_dlopenext (filename)
 
   /* As before, if the file was found but loading failed, return now
      with the current error message.  */
-  if (handle || ((errors > 0) && file_not_found ()))
+  if (handle || ((errors > 0) && !file_not_found ()))
     {
       LT_DLFREE (tmp);
       return handle;
@@ -3038,7 +3560,14 @@ lt_argz_insert (pargz, pargz_len, before, entry)
 {
   error_t error;
 
-  if ((error = argz_insert (pargz, pargz_len, before, entry)))
+  /* Prior to Sep 8, 2005, newlib had a bug where argz_insert(pargz,
+     pargz_len, NULL, entry) failed with EINVAL.  */
+  if (before)
+    error = argz_insert (pargz, pargz_len, before, entry);
+  else
+    error = argz_append (pargz, pargz_len, entry, 1 + LT_STRLEN (entry));
+
+  if (error)
     {
       switch (error)
 	{
@@ -3061,7 +3590,7 @@ lt_argz_insertinorder (pargz, pargz_len, entry)
      size_t *pargz_len;
      const char *entry;
 {
-  char *before = NULL;
+  char *before = 0;
 
   assert (pargz);
   assert (pargz_len);
@@ -3086,9 +3615,9 @@ lt_argz_insertdir (pargz, pargz_len, dirnam, dp)
      const char *dirnam;
      struct dirent *dp;
 {
-  char   *buf	    = NULL;
+  char   *buf	    = 0;
   size_t buf_len    = 0;
-  char   *end	    = NULL;
+  char   *end	    = 0;
   size_t end_offset = 0;
   size_t dir_len    = 0;
   int    errors	    = 0;
@@ -3151,7 +3680,7 @@ list_files_by_dir (dirnam, pargz, pargz_len)
      char **pargz;
      size_t *pargz_len;
 {
-  DIR	*dirp	  = NULL;
+  DIR	*dirp	  = 0;
   int    errors	  = 0;
 
   assert (dirnam && *dirnam);
@@ -3162,7 +3691,7 @@ list_files_by_dir (dirnam, pargz, pargz_len)
   dirp = opendir (dirnam);
   if (dirp)
     {
-      struct dirent *dp	= NULL;
+      struct dirent *dp	= 0;
 
       while ((dp = readdir (dirp)))
 	if (dp->d_name[0] != '.')
@@ -3193,7 +3722,7 @@ foreachfile_callback (dirname, data1, data2)
 	= (int (*) LT_PARAMS((const char *filename, lt_ptr data))) data1;
 
   int	  is_done  = 0;
-  char   *argz     = NULL;
+  char   *argz     = 0;
   size_t  argz_len = 0;
 
   if (list_files_by_dir (dirname, &argz, &argz_len) != 0)
@@ -3202,7 +3731,7 @@ foreachfile_callback (dirname, data1, data2)
     goto cleanup;
 
   {
-    char *filename = NULL;
+    char *filename = 0;
     while ((filename = argz_next (argz, argz_len, filename)))
       if ((is_done = (*func) (filename, data2)))
 	break;
@@ -3436,7 +3965,7 @@ lt_dlerror ()
   LT_DLMUTEX_GETERROR (error);
   LT_DLMUTEX_SETERROR (0);
 
-  return error ? error : LT_DLSTRERROR (UNKNOWN);
+  return error ? error : NULL;
 }
 
 static int
@@ -3446,8 +3975,8 @@ lt_dlpath_insertdir (ppath, before, dir)
      const char *dir;
 {
   int    errors		= 0;
-  char  *canonical	= NULL;
-  char  *argz		= NULL;
+  char  *canonical	= 0;
+  char  *argz		= 0;
   size_t argz_len	= 0;
 
   assert (ppath);
@@ -3462,13 +3991,13 @@ lt_dlpath_insertdir (ppath, before, dir)
   assert (canonical && *canonical);
 
   /* If *PPATH is empty, set it to DIR.  */
-  if (*ppath == NULL)
+  if (*ppath == 0)
     {
       assert (!before);		/* BEFORE cannot be set without PPATH.  */
       assert (dir);		/* Without DIR, don't call this function!  */
 
       *ppath = lt_estrdup (dir);
-      if (*ppath == NULL)
+      if (*ppath == 0)
 	++errors;
 
       return errors;
@@ -3702,7 +4231,7 @@ lt_dlcaller_set_data (key, handle, data)
      lt_ptr data;
 {
   int n_elements = 0;
-  lt_ptr stale = NULL;
+  lt_ptr stale = (lt_ptr) 0;
   int i;
 
   /* This needs to be locked so that the caller data can be updated
@@ -3731,7 +4260,7 @@ lt_dlcaller_set_data (key, handle, data)
 
       if (!temp)
 	{
-	  stale = NULL;
+	  stale = 0;
 	  goto done;
 	}
 
@@ -3791,12 +4320,12 @@ lt_dlloader_add (place, dlloader, loader_name)
      const char *loader_name;
 {
   int errors = 0;
-  lt_dlloader *node = NULL, *ptr = NULL;
+  lt_dlloader *node = 0, *ptr = 0;
 
-  if ((dlloader == NULL)	/* diagnose null parameters */
-      || (dlloader->module_open == NULL)
-      || (dlloader->module_close == NULL)
-      || (dlloader->find_sym == NULL))
+  if ((dlloader == 0)	/* diagnose null parameters */
+      || (dlloader->module_open == 0)
+      || (dlloader->module_close == 0)
+      || (dlloader->find_sym == 0))
     {
       LT_DLMUTEX_SETERROR (LT_DLSTRERROR (INVALID_LOADER));
       return 1;
@@ -3807,7 +4336,7 @@ lt_dlloader_add (place, dlloader, loader_name)
   if (!node)
     return 1;
 
-  node->next		= NULL;
+  node->next		= 0;
   node->loader_name	= loader_name;
   node->sym_prefix	= dlloader->sym_prefix;
   node->dlloader_exit	= dlloader->dlloader_exit;
@@ -3943,7 +4472,7 @@ const char *
 lt_dlloader_name (place)
      lt_dlloader *place;
 {
-  const char *name = NULL;
+  const char *name = 0;
 
   if (place)
     {
@@ -3963,7 +4492,7 @@ lt_user_data *
 lt_dlloader_data (place)
      lt_dlloader *place;
 {
-  lt_user_data *data = NULL;
+  lt_user_data *data = 0;
 
   if (place)
     {
@@ -3983,7 +4512,7 @@ lt_dlloader *
 lt_dlloader_find (loader_name)
      const char *loader_name;
 {
-  lt_dlloader *place = NULL;
+  lt_dlloader *place = 0;
 
   LT_DLMUTEX_LOCK ();
   for (place = loaders; place; place = place->next)
diff --git a/src/pdsh/ltdl.h b/src/pdsh/ltdl.h
index 2bbfa30..8aaf342 100644
--- a/src/pdsh/ltdl.h
+++ b/src/pdsh/ltdl.h
@@ -20,8 +20,8 @@ Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-02111-1307  USA
+Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301  USA
 */
 
 /* Only include this header file once. */
@@ -79,7 +79,7 @@ LT_BEGIN_C_DECLS
 
 /* LT_CONC creates a new concatenated symbol for the compiler
    in a portable way.  */
-#if defined(__STDC__) || defined(__cplusplus)
+#if defined(__STDC__) || defined(__cplusplus) || defined(_MSC_VER)
 #  define LT_CONC(s,t)	s##t
 #else
 #  define LT_CONC(s,t)	s/**/t
@@ -111,6 +111,7 @@ LT_BEGIN_C_DECLS
 #  endif
 #endif
 
+
 #ifdef __WINDOWS__
 #  ifndef __CYGWIN__
 /* LT_DIRSEP_CHAR is accepted *in addition* to '/' as a directory
@@ -140,6 +141,10 @@ LT_BEGIN_C_DECLS
 #endif
 
 
+#if defined(_MSC_VER) /* Visual Studio */
+#  define R_OK 4
+#endif
+
 
 
 /* --- DYNAMIC MODULE LOADING API --- */
@@ -148,31 +153,31 @@ LT_BEGIN_C_DECLS
 typedef	struct lt_dlhandle_struct *lt_dlhandle;	/* A loaded module.  */
 
 /* Initialisation and finalisation functions for libltdl. */
-extern	int	    lt_dlinit		LT_PARAMS((void));
-extern	int	    lt_dlexit		LT_PARAMS((void));
+LT_SCOPE	int	    lt_dlinit		LT_PARAMS((void));
+LT_SCOPE	int	    lt_dlexit		LT_PARAMS((void));
 
 /* Module search path manipulation.  */
-extern	int	    lt_dladdsearchdir	 LT_PARAMS((const char *search_dir));
-extern	int	    lt_dlinsertsearchdir LT_PARAMS((const char *before,
+LT_SCOPE	int	    lt_dladdsearchdir	 LT_PARAMS((const char *search_dir));
+LT_SCOPE	int	    lt_dlinsertsearchdir LT_PARAMS((const char *before,
 						    const char *search_dir));
-extern	int 	    lt_dlsetsearchpath	 LT_PARAMS((const char *search_path));
-extern	const char *lt_dlgetsearchpath	 LT_PARAMS((void));
-extern	int	    lt_dlforeachfile	 LT_PARAMS((
+LT_SCOPE	int 	    lt_dlsetsearchpath	 LT_PARAMS((const char *search_path));
+LT_SCOPE	const char *lt_dlgetsearchpath	 LT_PARAMS((void));
+LT_SCOPE	int	    lt_dlforeachfile	 LT_PARAMS((
 			const char *search_path,
 			int (*func) (const char *filename, lt_ptr data),
 			lt_ptr data));
 
 /* Portable libltdl versions of the system dlopen() API. */
-extern	lt_dlhandle lt_dlopen		LT_PARAMS((const char *filename));
-extern	lt_dlhandle lt_dlopenext	LT_PARAMS((const char *filename));
-extern	lt_ptr	    lt_dlsym		LT_PARAMS((lt_dlhandle handle,
+LT_SCOPE	lt_dlhandle lt_dlopen		LT_PARAMS((const char *filename));
+LT_SCOPE	lt_dlhandle lt_dlopenext	LT_PARAMS((const char *filename));
+LT_SCOPE	lt_ptr	    lt_dlsym		LT_PARAMS((lt_dlhandle handle,
 						     const char *name));
-extern	const char *lt_dlerror		LT_PARAMS((void));
-extern	int	    lt_dlclose		LT_PARAMS((lt_dlhandle handle));
+LT_SCOPE	const char *lt_dlerror		LT_PARAMS((void));
+LT_SCOPE	int	    lt_dlclose		LT_PARAMS((lt_dlhandle handle));
 
 /* Module residency management. */
-extern	int	    lt_dlmakeresident	LT_PARAMS((lt_dlhandle handle));
-extern	int	    lt_dlisresident	LT_PARAMS((lt_dlhandle handle));
+LT_SCOPE	int	    lt_dlmakeresident	LT_PARAMS((lt_dlhandle handle));
+LT_SCOPE	int	    lt_dlisresident	LT_PARAMS((lt_dlhandle handle));
 
 
 
@@ -185,7 +190,7 @@ typedef void	lt_dlmutex_unlock	LT_PARAMS((void));
 typedef void	lt_dlmutex_seterror	LT_PARAMS((const char *errmsg));
 typedef const char *lt_dlmutex_geterror	LT_PARAMS((void));
 
-extern	int	lt_dlmutex_register	LT_PARAMS((lt_dlmutex_lock *lock,
+LT_SCOPE	int	lt_dlmutex_register	LT_PARAMS((lt_dlmutex_lock *lock,
 					    lt_dlmutex_unlock *unlock,
 					    lt_dlmutex_seterror *seterror,
 					    lt_dlmutex_geterror *geterror));
@@ -218,8 +223,8 @@ typedef struct {
   lt_ptr      address;
 } lt_dlsymlist;
 
-extern	int	lt_dlpreload	LT_PARAMS((const lt_dlsymlist *preloaded));
-extern	int	lt_dlpreload_default
+LT_SCOPE	int	lt_dlpreload	LT_PARAMS((const lt_dlsymlist *preloaded));
+LT_SCOPE	int	lt_dlpreload_default
 				LT_PARAMS((const lt_dlsymlist *preloaded));
 
 #define LTDL_SET_PRELOADED_SYMBOLS() 		LT_STMT_START{	\
@@ -241,20 +246,20 @@ typedef	struct {
 				   number of times lt_dlclosed. */
 } lt_dlinfo;
 
-extern	const lt_dlinfo	*lt_dlgetinfo	    LT_PARAMS((lt_dlhandle handle));
-extern	lt_dlhandle	lt_dlhandle_next    LT_PARAMS((lt_dlhandle place));
-extern	int		lt_dlforeach	    LT_PARAMS((
+LT_SCOPE	const lt_dlinfo	*lt_dlgetinfo	    LT_PARAMS((lt_dlhandle handle));
+LT_SCOPE	lt_dlhandle	lt_dlhandle_next    LT_PARAMS((lt_dlhandle place));
+LT_SCOPE	int		lt_dlforeach	    LT_PARAMS((
 				int (*func) (lt_dlhandle handle, lt_ptr data),
 				lt_ptr data));
 
 /* Associating user data with loaded modules. */
 typedef unsigned lt_dlcaller_id;
 
-extern	lt_dlcaller_id	lt_dlcaller_register  LT_PARAMS((void));
-extern	lt_ptr		lt_dlcaller_set_data  LT_PARAMS((lt_dlcaller_id key,
+LT_SCOPE	lt_dlcaller_id	lt_dlcaller_register  LT_PARAMS((void));
+LT_SCOPE	lt_ptr		lt_dlcaller_set_data  LT_PARAMS((lt_dlcaller_id key,
 						lt_dlhandle handle,
 						lt_ptr data));
-extern	lt_ptr		lt_dlcaller_get_data  LT_PARAMS((lt_dlcaller_id key,
+LT_SCOPE	lt_ptr		lt_dlcaller_get_data  LT_PARAMS((lt_dlcaller_id key,
 						lt_dlhandle handle));
 
 
@@ -285,15 +290,15 @@ struct lt_user_dlloader {
   lt_user_data		dlloader_data;
 };
 
-extern	lt_dlloader    *lt_dlloader_next    LT_PARAMS((lt_dlloader *place));
-extern	lt_dlloader    *lt_dlloader_find    LT_PARAMS((
+LT_SCOPE	lt_dlloader    *lt_dlloader_next    LT_PARAMS((lt_dlloader *place));
+LT_SCOPE	lt_dlloader    *lt_dlloader_find    LT_PARAMS((
 						const char *loader_name));
-extern	const char     *lt_dlloader_name    LT_PARAMS((lt_dlloader *place));
-extern	lt_user_data   *lt_dlloader_data    LT_PARAMS((lt_dlloader *place));
-extern	int		lt_dlloader_add     LT_PARAMS((lt_dlloader *place,
+LT_SCOPE	const char     *lt_dlloader_name    LT_PARAMS((lt_dlloader *place));
+LT_SCOPE	lt_user_data   *lt_dlloader_data    LT_PARAMS((lt_dlloader *place));
+LT_SCOPE	int		lt_dlloader_add     LT_PARAMS((lt_dlloader *place,
 				const struct lt_user_dlloader *dlloader,
 				const char *loader_name));
-extern	int		lt_dlloader_remove  LT_PARAMS((
+LT_SCOPE	int		lt_dlloader_remove  LT_PARAMS((
 						const char *loader_name));
 
 
@@ -336,8 +341,8 @@ enum {
 };
 
 /* These functions are only useful from inside custom module loaders. */
-extern	int	lt_dladderror	LT_PARAMS((const char *diagnostic));
-extern	int	lt_dlseterror	LT_PARAMS((int errorcode));
+LT_SCOPE	int	lt_dladderror	LT_PARAMS((const char *diagnostic));
+LT_SCOPE	int	lt_dlseterror	LT_PARAMS((int errorcode));
 
 
 
