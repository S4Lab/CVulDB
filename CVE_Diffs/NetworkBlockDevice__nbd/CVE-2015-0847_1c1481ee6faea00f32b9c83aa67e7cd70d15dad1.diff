NetworkBlockDevice__nbd
commit 1c1481ee6faea00f32b9c83aa67e7cd70d15dad1
Author:     Wouter Verhelst <w@uter.be>
AuthorDate: Fri May 15 12:35:50 2015 +0200
Commit:     Wouter Verhelst <w@uter.be>
CommitDate: Fri May 15 13:04:39 2015 +0200

    Backport fix for CVE-2015-0847 to wheezy

diff --git a/debian/changelog b/debian/changelog
index 89206df..723fdae 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,9 @@
+nbd (1:3.2-4~deb7u5) oldstable-security; urgency=medium
+
+  * Backport fix for CVE-2015-0847 to fix handling of SIGTERM and SIGCHLD.
+
+ -- Wouter Verhelst <wouter@debian.org>  Fri, 15 May 2015 13:03:42 +0200
+
 nbd (1:3.2-4~deb7u4) stable-security; urgency=low
 
   * Cherry-pick df890c99337a255979e608d71f42401c0cddd5e0 from git HEAD
diff --git a/nbd-server.c b/nbd-server.c
index 8491cb8..c6d1d45 100644
--- a/nbd-server.c
+++ b/nbd-server.c
@@ -196,6 +196,9 @@ char* modernport=NBD_DEFAULT_PORT; /**< Port number on which to listen for
 
 bool logged_oversized=false;  /**< whether we logged oversized requests already */
 
+static volatile sig_atomic_t is_sigchld_caught;
+static volatile sig_atomic_t is_sigterm_caught;
+
 /**
  * Types of virtuatlization
  **/
@@ -1059,22 +1062,7 @@ GArray* parse_cfile(gchar* f, bool have_global, GError** e) {
  * is severely wrong)
  **/
 void sigchld_handler(int s) {
-        int status;
-	int* i;
-	pid_t pid;
-
-	while((pid=waitpid(-1, &status, WNOHANG)) > 0) {
-		if(WIFEXITED(status)) {
-			msg3(LOG_INFO, "Child exited with %d", WEXITSTATUS(status));
-		}
-		i=g_hash_table_lookup(children, &pid);
-		if(!i) {
-			msg3(LOG_INFO, "SIGCHLD received for an unknown child with PID %ld", (long)pid);
-		} else {
-			DEBUG("Removing %d from the list of children", pid);
-			g_hash_table_remove(children, &pid);
-		}
-	}
+	is_sigchld_caught = 1;
 }
 
 /**
@@ -1092,15 +1080,16 @@ void killchild(gpointer key, gpointer value, gpointer user_data) {
 }
 
 /**
- * Handle SIGTERM and dispatch it to our children
+ * Handle SIGTERM by setting atomically a flag which will be evaluated in the
+ * main loop of the root server process. This allows us to separate the signal
+ * catching from th actual task triggered by SIGTERM and hence processing in the
+ * interrupt context is kept as minimial as possible.
+ *
  * @param s the signal we're handling (must be SIGTERM, or something
  * is severely wrong).
  **/
-void sigterm_handler(int s) {
-	g_hash_table_foreach(children, killchild, NULL);
-	unlink(pidfname);
-
-	exit(EXIT_SUCCESS);
+static void sigterm_handler(const int s G_GNUC_UNUSED) {
+	is_sigterm_caught = 1;
 }
 
 /**
@@ -2227,6 +2216,7 @@ handle_connection(GArray *servers, int net, SERVER *serve, CLIENT *client)
 		/* child */
 		signal(SIGCHLD, SIG_DFL);
 		signal(SIGTERM, SIG_DFL);
+		sigemptyset(&oldset);
 		sigprocmask(SIG_SETMASK, &oldset, NULL);
 
 		g_hash_table_destroy(children);
@@ -2265,6 +2255,8 @@ int serveloop(GArray* servers) {
 	int sock;
 	fd_set mset;
 	fd_set rset;
+	sigset_t blocking_mask;
+	sigset_t original_mask;
 
 	/* 
 	 * Set up the master fd_set. The set of descriptors we need
@@ -2285,9 +2277,58 @@ int serveloop(GArray* servers) {
 		FD_SET(modernsock, &mset);
 		max=modernsock>max?modernsock:max;
 	}
+	
+	/* Construct a signal mask which is used to make signal testing and
+	 * receiving an atomic operation to ensure no signal is received between
+	 * tests and blocking pselect(). */
+	if (sigemptyset(&blocking_mask) == -1)
+		err("failed to initialize blocking_mask: %m");
+
+	if (sigaddset(&blocking_mask, SIGCHLD) == -1)
+		err("failed to add SIGCHLD to blocking_mask: %m");
+
+	if (sigaddset(&blocking_mask, SIGHUP) == -1)
+		err("failed to add SIGHUP to blocking_mask: %m");
+
+	if (sigaddset(&blocking_mask, SIGTERM) == -1)
+		err("failed to add SIGTERM to blocking_mask: %m");
+
+	if (sigprocmask(SIG_BLOCK, &blocking_mask, &original_mask) == -1)
+		err("failed to block signals: %m");
+
 	for(;;) {
+		if (is_sigterm_caught) {
+			is_sigterm_caught = 0;
+
+			g_hash_table_foreach(children, killchild, NULL);
+			unlink(pidfname);
+
+			exit(EXIT_SUCCESS);
+		}
+
+		if (is_sigchld_caught) {
+			int status;
+			int* i;
+			pid_t pid;
+
+			is_sigchld_caught = 0;
+
+			while ((pid=waitpid(-1, &status, WNOHANG)) > 0) {
+				if (WIFEXITED(status)) {
+					msg3(LOG_INFO, "Child exited with %d", WEXITSTATUS(status));
+				}
+				i = g_hash_table_lookup(children, &pid);
+				if (!i) {
+					msg3(LOG_INFO, "SIGCHLD received for an unknown child with PID %ld", (long)pid);
+				} else {
+					DEBUG("Removing %d from the list of children", pid);
+					g_hash_table_remove(children, &pid);
+				}
+			}
+		}
+
 		memcpy(&rset, &mset, sizeof(fd_set));
-		if(select(max+1, &rset, NULL, NULL, NULL)>0) {
+		if(pselect(max+1, &rset, NULL, NULL, NULL, &original_mask)>0) {
 			int net;
 
 			DEBUG("accept, ");
