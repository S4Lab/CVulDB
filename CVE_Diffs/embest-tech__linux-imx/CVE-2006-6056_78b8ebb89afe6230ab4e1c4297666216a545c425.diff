embest-tech__linux-imx
commit 78b8ebb89afe6230ab4e1c4297666216a545c425
Author:     Eric Sandeen <sandeen@redhat.com>
AuthorDate: Sat Dec 30 18:29:13 2006 -0500
Commit:     Greg Kroah-Hartman <gregkh@suse.de>
CommitDate: Fri Feb 23 15:49:51 2007 -0800

    hfs_fill_super returns success even if no root inode (CVE-2006-6056)
    
    http://kernelfun.blogspot.com/2006/11/mokb-14-11-2006-linux-26x-selinux.html
    
    mount that image...
    fs: filesystem was not cleanly unmounted, running fsck.hfs is recommended.  mounting read-only.
    hfs: get root inode failed.
    BUG: unable to handle kernel NULL pointer dereference at virtual address 00000018
     printing eip
    ...
    EIP is at superblock_doinit+0x21/0x767
    ...
     [] selinux_sb_kern_mount+0xc/0x4b
     [] vfs_kern_mount+0x99/0xf6
     [] do_kern_mount+0x2d/0x3e
     [] do_mount+0x5fa/0x66d
     [] sys_mount+0x77/0xae
     [] syscall_call+0x7/0xb
    DWARF2 unwinder stuck at syscall_call+0x7/0xb
    
    hfs_fill_super() returns success even if
      root_inode = hfs_iget(sb, &fd.search_key->cat, &rec);
    or
      sb->s_root = d_alloc_root(root_inode);
    
    fails.  This superblock finds its way to superblock_doinit() which does:
    
            struct dentry *root = sb->s_root;
            struct inode *inode = root->d_inode;
    
    and boom.  Need to make sure the error cases return an error, I think.
    
    [akpm@osdl.org: return -ENOMEM on oom]
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/fs/hfs/super.c b/fs/hfs/super.c
index 34937ee83ab1..9882a9050695 100644
--- a/fs/hfs/super.c
+++ b/fs/hfs/super.c
@@ -391,11 +391,13 @@ static int hfs_fill_super(struct super_block *sb, void *data, int silent)
 		hfs_find_exit(&fd);
 		goto bail_no_root;
 	}
+	res = -EINVAL;
 	root_inode = hfs_iget(sb, &fd.search_key->cat, &rec);
 	hfs_find_exit(&fd);
 	if (!root_inode)
 		goto bail_no_root;
 
+	res = -ENOMEM;
 	sb->s_root = d_alloc_root(root_inode);
 	if (!sb->s_root)
 		goto bail_iput;
