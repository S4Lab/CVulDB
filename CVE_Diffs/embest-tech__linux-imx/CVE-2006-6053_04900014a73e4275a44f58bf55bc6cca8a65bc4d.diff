embest-tech__linux-imx
commit 04900014a73e4275a44f58bf55bc6cca8a65bc4d
Author:     Eric Sandeen <sandeen@redhat.com>
AuthorDate: Mon Jan 8 07:01:06 2007 +0100
Commit:     Adrian Bunk <bunk@stusta.de>
CommitDate: Tue Jan 9 03:23:34 2007 +0100

    handle ext3 directory corruption better (CVE-2006-6053)
    
    I've been using Steve Grubb's purely evil "fsfuzzer" tool, at
    http://people.redhat.com/sgrubb/files/fsfuzzer-0.4.tar.gz
    
    Basically it makes a filesystem, splats some random bits over it, then
    tries to mount it and do some simple filesystem actions.
    
    At best, the filesystem catches the corruption gracefully.  At worst,
    things spin out of control.
    
    As you might guess, we found a couple places in ext3 where things spin out
    of control :)
    
    First, we had a corrupted directory that was never checked for
    consistency...  it was corrupt, and pointed to another bad "entry" of
    length 0.  The for() loop looped forever, since the length of
    ext3_next_entry(de) was 0, and we kept looking at the same pointer over and
    over and over and over...  I modeled this check and subsequent action on
    what is done for other directory types in ext3_readdir...
    
    (adding this check adds some computational expense; I am testing a followup
    patch to reduce the number of times we check and re-check these directory
    entries, in all cases.  Thanks for the idea, Andreas).
    
    Next we had a root directory inode which had a corrupted size, claimed to
    be > 200M on a 4M filesystem.  There was only really 1 block in the
    directory, but because the size was so large, readdir kept coming back for
    more, spewing thousands of printk's along the way.
    
    Per Andreas' suggestion, if we're in this read error condition and we're
    trying to read an offset which is greater than i_blocks worth of bytes,
    stop trying, and break out of the loop.
    
    With these two changes fsfuzz test survives quite well on ext3.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/fs/ext3/dir.c b/fs/ext3/dir.c
index 832867aef3dc..6611801322ce 100644
--- a/fs/ext3/dir.c
+++ b/fs/ext3/dir.c
@@ -134,6 +134,9 @@ static int ext3_readdir(struct file * filp,
 			ext3_error (sb, "ext3_readdir",
 				"directory #%lu contains a hole at offset %lu",
 				inode->i_ino, (unsigned long)filp->f_pos);
+			/* corrupt size?  Maybe no more blocks to read */
+			if (filp->f_pos > inode->i_blocks << 9)
+				break;
 			filp->f_pos += sb->s_blocksize - offset;
 			continue;
 		}
diff --git a/fs/ext3/namei.c b/fs/ext3/namei.c
index 7be89fe95d7b..3035dd4b6407 100644
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -551,6 +551,15 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 					   dir->i_sb->s_blocksize -
 					   EXT3_DIR_REC_LEN(0));
 	for (; de < top; de = ext3_next_entry(de)) {
+		if (!ext3_check_dir_entry("htree_dirblock_to_tree", dir, de, bh,
+					(block<<EXT3_BLOCK_SIZE_BITS(dir->i_sb))
+						+((char *)de - bh->b_data))) {
+			/* On error, skip the f_pos to the next block. */
+			dir_file->f_pos = (dir_file->f_pos |
+					(dir->i_sb->s_blocksize - 1)) + 1;
+			brelse (bh);
+			return count;
+		}
 		ext3fs_dirhash(de->name, de->name_len, hinfo);
 		if ((hinfo->hash < start_hash) ||
 		    ((hinfo->hash == start_hash) &&
