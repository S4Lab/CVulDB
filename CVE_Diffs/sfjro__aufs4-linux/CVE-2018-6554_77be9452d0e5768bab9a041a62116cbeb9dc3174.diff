sfjro__aufs4-linux
commit 77be9452d0e5768bab9a041a62116cbeb9dc3174
Author:     Tyler Hicks <tyhicks@canonical.com>
AuthorDate: Tue Sep 4 15:24:04 2018 +0000
Commit:     Greg Kroah-Hartman <gregkh@linuxfoundation.org>
CommitDate: Sat Sep 15 09:45:36 2018 +0200

    irda: Fix memory leak caused by repeated binds of irda socket
    
    The irda_bind() function allocates memory for self->ias_obj without
    checking to see if the socket is already bound. A userspace process
    could repeatedly bind the socket, have each new object added into the
    LM-IAS database, and lose the reference to the old object assigned to
    the socket to exhaust memory resources. This patch errors out of the
    bind operation when self->ias_obj is already assigned.
    
    CVE-2018-6554
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Reviewed-by: Seth Arnold <seth.arnold@canonical.com>
    Reviewed-by: Stefan Bader <stefan.bader@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/irda/net/af_irda.c b/drivers/staging/irda/net/af_irda.c
index 23fa7c8b09a5..a08cd3dd7a6e 100644
--- a/drivers/staging/irda/net/af_irda.c
+++ b/drivers/staging/irda/net/af_irda.c
@@ -775,6 +775,13 @@ static int irda_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 		return -EINVAL;
 
 	lock_sock(sk);
+
+	/* Ensure that the socket is not already bound */
+	if (self->ias_obj) {
+		err = -EINVAL;
+		goto out;
+	}
+
 #ifdef CONFIG_IRDA_ULTRA
 	/* Special care for Ultra sockets */
 	if ((sk->sk_type == SOCK_DGRAM) &&
