riscv__riscv-qemu
commit d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62
Author:     Michael S. Tsirkin <mst@redhat.com>
AuthorDate: Thu Apr 3 19:51:42 2014 +0300
Commit:     Juan Quintela <quintela@redhat.com>
CommitDate: Mon May 5 22:15:02 2014 +0200

    vmstate: fix buffer overflow in target-arm/machine.c
    
    CVE-2013-4531
    
    cpreg_vmstate_indexes is a VARRAY_INT32. A negative value for
    cpreg_vmstate_array_len will cause a buffer overflow.
    
    VMSTATE_INT32_LE was supposed to protect against this
    but doesn't because it doesn't validate that input is
    non-negative.
    
    Fix this macro to valide the value appropriately.
    
    The only other user of VMSTATE_INT32_LE doesn't
    ever use negative numbers so it doesn't care.
    
    Reported-by: Anthony Liguori <anthony@codemonkey.ws>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Juan Quintela <quintela@redhat.com>

diff --git a/vmstate.c b/vmstate.c
index f019228188..dbb76665d9 100644
--- a/vmstate.c
+++ b/vmstate.c
@@ -337,8 +337,9 @@ const VMStateInfo vmstate_info_int32_equal = {
     .put  = put_int32,
 };
 
-/* 32 bit int. Check that the received value is less than or equal to
-   the one in the field */
+/* 32 bit int. Check that the received value is non-negative
+ * and less than or equal to the one in the field.
+ */
 
 static int get_int32_le(QEMUFile *f, void *pv, size_t size)
 {
@@ -346,7 +347,7 @@ static int get_int32_le(QEMUFile *f, void *pv, size_t size)
     int32_t loaded;
     qemu_get_sbe32s(f, &loaded);
 
-    if (loaded <= *cur) {
+    if (loaded >= 0 && loaded <= *cur) {
         *cur = loaded;
         return 0;
     }
