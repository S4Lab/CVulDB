ValveSoftware__steamos_kernel
commit 4d1805f9990db66894c32bc12ec8d61778d53533
Author:     Andrew Honig <ahonig@google.com>
AuthorDate: Wed Nov 18 14:50:23 2015 -0800
Commit:     Willy Tarreau <w@1wt.eu>
CommitDate: Fri Jan 29 22:12:59 2016 +0100

    KVM: x86: Reload pit counters for all channels when restoring state
    
    commit 0185604c2d82c560dab2f2933a18f797e74ab5a8 upstream.
    
    Currently if userspace restores the pit counters with a count of 0
    on channels 1 or 2 and the guest attempts to read the count on those
    channels, then KVM will perform a mod of 0 and crash.  This will ensure
    that 0 values are converted to 65536 as per the spec.
    
    This is CVE-2015-7513.
    
    Signed-off-by: Andy Honig <ahonig@google.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    [bwh: Backported to 3.2: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    (cherry picked from commit 08b8d1a6ccdefd3d517d04c472b7f42f51b3059b)
    Signed-off-by: Willy Tarreau <w@1wt.eu>

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index cdee77eed199..3d575770bf72 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -2131,10 +2131,11 @@ static int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 {
 	int r = 0;
-
+	int i;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));
-	kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);
+	for (i = 0; i < 3; i++)
+		kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return r;
 }
@@ -2155,6 +2156,7 @@ static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int r = 0, start = 0;
+	int i;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
@@ -2164,7 +2166,8 @@ static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
-	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
+	for (i = 0; i < 3; i++)
+		kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return r;
 }
