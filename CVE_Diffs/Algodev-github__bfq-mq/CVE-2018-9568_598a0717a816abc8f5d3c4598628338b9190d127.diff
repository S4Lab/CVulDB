Algodev-github__bfq-mq
commit 598a0717a816abc8f5d3c4598628338b9190d127
Author:     Kees Cook <keescook@chromium.org>
AuthorDate: Thu Jul 11 20:53:23 2019 -0700
Commit:     Linus Torvalds <torvalds@linux-foundation.org>
CommitDate: Fri Jul 12 11:05:41 2019 -0700

    mm/slab: validate cache membership under freelist hardening
    
    Patch series "mm/slab: Improved sanity checking".
    
    This adds defenses against slab cache confusion (as seen in real-world
    exploits[1]) and gracefully handles type confusions when trying to look
    up slab caches from an arbitrary page.  (Also is patch 3: new LKDTM
    tests for these defenses as well as for the existing double-free
    detection.
    
    This patch (of 3):
    
    When building under CONFIG_SLAB_FREELIST_HARDENING, it makes sense to
    perform sanity-checking on the assumed slab cache during
    kmem_cache_free() to make sure the kernel doesn't mix freelists across
    slab caches and corrupt memory (as seen in the exploitation of flaws
    like CVE-2018-9568[1]).  Note that the prior code might WARN() but still
    corrupt memory (i.e.  return the assumed cache instead of the owned
    cache).
    
    There is no noticeable performance impact (changes are within noise).
    Measuring parallel kernel builds, I saw the following with
    CONFIG_SLAB_FREELIST_HARDENED, before and after this patch:
    
    before:
    
            Run times: 288.85 286.53 287.09 287.07 287.21
            Min: 286.53 Max: 288.85 Mean: 287.35 Std Dev: 0.79
    
    after:
    
            Run times: 289.58 287.40 286.97 287.20 287.01
            Min: 286.97 Max: 289.58 Mean: 287.63 Std Dev: 0.99
    
    Delta: 0.1% which is well below the standard deviation
    
    [1] https://github.com/ThomasKing2014/slides/raw/master/Building%20universal%20Android%20rooting%20with%20a%20type%20confusion%20vulnerability.pdf
    
    Link: http://lkml.kernel.org/r/20190530045017.15252-2-keescook@chromium.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Alexander Popov <alex.popov@linux.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/slab.h b/mm/slab.h
index 43ac818b8592..4dafae2c8620 100644
--- a/mm/slab.h
+++ b/mm/slab.h
@@ -310,7 +310,7 @@ static inline bool is_root_cache(struct kmem_cache *s)
 static inline bool slab_equal_or_root(struct kmem_cache *s,
 				      struct kmem_cache *p)
 {
-	return true;
+	return s == p;
 }
 
 static inline const char *cache_name(struct kmem_cache *s)
@@ -363,18 +363,16 @@ static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)
 	 * will also be a constant.
 	 */
 	if (!memcg_kmem_enabled() &&
+	    !IS_ENABLED(CONFIG_SLAB_FREELIST_HARDENED) &&
 	    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))
 		return s;
 
 	page = virt_to_head_page(x);
 	cachep = page->slab_cache;
-	if (slab_equal_or_root(cachep, s))
-		return cachep;
-
-	pr_err("%s: Wrong slab cache. %s but object is from %s\n",
-	       __func__, s->name, cachep->name);
-	WARN_ON_ONCE(1);
-	return s;
+	WARN_ONCE(!slab_equal_or_root(cachep, s),
+		  "%s: Wrong slab cache. %s but object is from %s\n",
+		  __func__, s->name, cachep->name);
+	return cachep;
 }
 
 static inline size_t slab_ksize(const struct kmem_cache *s)
