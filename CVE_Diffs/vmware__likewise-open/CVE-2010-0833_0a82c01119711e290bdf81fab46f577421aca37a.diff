vmware__likewise-open
commit 0a82c01119711e290bdf81fab46f577421aca37a
Author:     Gerald W. Carter <gcarter@likewiseopen.org>
AuthorDate: Wed Jul 21 22:19:54 2010 +0000
Commit:     Gerald W. Carter <gcarter@likewiseopen.org>
CommitDate: Wed Jul 21 15:22:03 2010 -0700

    lsass:local-provider: Fix for CVE-2010-0833
    
    * Set the Administrator account as disabled when first provisioned.
    * Explicitly mark lsassd local provider accounts accounts as disabled
      if the account exists in its initial provisioned state
    * Force pam password changes, when run under the context of root services,
      to require the existing password for authentication
    * Enforce the "user cannot change password" field on local provider
      account in the provider interface as well as the RPC server interface
    
    Original patch: rafal@likewise.com
    CR: gcarter@likewise.com, ssalley@likewise.com
    Additional review: kstemen@likewise.com
    
    (lsass: r47769)

diff --git a/lsass/interop/auth/pam/pam-passwd.c b/lsass/interop/auth/pam/pam-passwd.c
index 2c3e57edf..07bc476ab 100644
--- a/lsass/interop/auth/pam/pam-passwd.c
+++ b/lsass/interop/auth/pam/pam-passwd.c
@@ -321,7 +321,6 @@ LsaPamUpdatePassword(
     PSTR   pszPassword = NULL;
     PSTR   pszLoginId = NULL;
     HANDLE hLsaConnection = (HANDLE)NULL;
-    BOOLEAN bCheckOldPassword = FALSE;
 
     LSA_LOG_PAM_DEBUG("LsaPamUpdatePassword::begin");
 
@@ -347,20 +346,11 @@ LsaPamUpdatePassword(
     dwError = LsaOpenServer(&hLsaConnection);
     BAIL_ON_LSA_ERROR(dwError);
 
-    dwError = LsaPamMustCheckCurrentPassword(
-                         hLsaConnection,
-                         pszLoginId,
-                         &bCheckOldPassword);
-    BAIL_ON_LSA_ERROR(dwError);
-
-    if (bCheckOldPassword)
-    {
-	dwError = LsaPamGetOldPassword(
+    dwError = LsaPamGetOldPassword(
                    pamh,
                    pPamContext,
                    &pszOldPassword);
-	BAIL_ON_LSA_ERROR(dwError);
-    }
+    BAIL_ON_LSA_ERROR(dwError);
 
     dwError = LsaPamGetNewPassword(
                    pamh,
@@ -368,23 +358,12 @@ LsaPamUpdatePassword(
                    &pszPassword);
     BAIL_ON_LSA_ERROR(dwError);
 
-    if (bCheckOldPassword)
-    {
-        dwError = LsaChangePassword(
-                       hLsaConnection,
-                       pszLoginId,
-                       pszPassword,
-                       pszOldPassword);
-        BAIL_ON_LSA_ERROR(dwError);
-    }
-    else
-    {
-        dwError = LsaSetPassword(
-                       hLsaConnection,
-                       pszLoginId,
-                       pszPassword);
-        BAIL_ON_LSA_ERROR(dwError);
-    }
+    dwError = LsaChangePassword(
+                   hLsaConnection,
+                   pszLoginId,
+                   pszPassword,
+                   pszOldPassword);
+    BAIL_ON_LSA_ERROR(dwError);
 
 cleanup:
 
diff --git a/lsass/server/auth-providers/local-provider/lpdefs.h.in b/lsass/server/auth-providers/local-provider/lpdefs.h.in
index 79bbe0bc3..c3b1f14e7 100644
--- a/lsass/server/auth-providers/local-provider/lpdefs.h.in
+++ b/lsass/server/auth-providers/local-provider/lpdefs.h.in
@@ -127,6 +127,8 @@
     {'O','b','j','e','c','t','C','l','a','s','s',0}
 #define LOCAL_DIR_ATTR_OBJECT_SID \
     {'O','b','j','e','c','t','S','I','D',0}
+#define LOCAL_DIR_ATTR_SECURITY_DESCRIPTOR \
+    {'S','e','c','u','r','i','t','y','D','e','s','c','r','i','p','t','o','r',0}
 #define LOCAL_DIR_ATTR_DISTINGUISHED_NAME  \
     {'D','i','s','t','i','n','g','u','i','s','h','e','d','N','a','m','e',0}
 #define LOCAL_DIR_ATTR_DOMAIN \
diff --git a/lsass/server/auth-providers/local-provider/lpuser.c b/lsass/server/auth-providers/local-provider/lpuser.c
index b077d2ee2..b7348c0fd 100644
--- a/lsass/server/auth-providers/local-provider/lpuser.c
+++ b/lsass/server/auth-providers/local-provider/lpuser.c
@@ -1221,7 +1221,75 @@ LocalDirChangePassword(
     )
 {
     DWORD dwError = 0;
+    NTSTATUS ntStatus = STATUS_SUCCESS;
     PLOCAL_PROVIDER_CONTEXT pContext = (PLOCAL_PROVIDER_CONTEXT)hProvider;
+    PLW_MAP_SECURITY_CONTEXT pSecCtx = NULL;
+    PACCESS_TOKEN pUserToken = NULL;
+    PWSTR pwszBase = NULL;
+    DWORD dwScope = 0;
+    PWSTR pwszFilter = NULL;
+    WCHAR wszAttrSecurityDescriptor[] = LOCAL_DIR_ATTR_SECURITY_DESCRIPTOR;
+
+    PWSTR wszAttributes[] = {
+        wszAttrSecurityDescriptor,
+        NULL
+    };
+
+    PDIRECTORY_ENTRY pUserEntry = NULL;
+    DWORD dwNumEntries = 0;
+    PSECURITY_DESCRIPTOR_ABSOLUTE pSecDesc = NULL;
+    GENERIC_MAPPING GenericMapping = {0};
+    DWORD dwAccessGranted = 0;
+
+    /*
+     * Check if user has right to change the password first
+     */
+    ntStatus = LwMapSecurityCreateContext(&pSecCtx);
+    BAIL_ON_NT_STATUS(ntStatus);
+
+    ntStatus = LwMapSecurityCreateAccessTokenFromUidGid(
+                    pSecCtx,
+                    &pUserToken,
+                    pContext->uid,
+                    pContext->gid);
+    BAIL_ON_NT_STATUS(ntStatus);
+
+    dwError = DirectorySearch(
+                    pContext->hDirectory,
+                    pwszBase,
+                    dwScope,
+                    pwszFilter,
+                    wszAttributes,
+                    FALSE,
+                    &pUserEntry,
+                    &dwNumEntries);
+    BAIL_ON_LSA_ERROR(dwError);
+
+    if (dwNumEntries == 0)
+    {
+        dwError = LW_ERROR_NO_SUCH_USER;
+    }
+    else if (dwNumEntries != 1)
+    {
+        dwError = LW_ERROR_DATA_ERROR;
+    }
+    BAIL_ON_LSA_ERROR(dwError);
+
+    dwError = DirectoryGetEntrySecurityDescriptor(
+                    pUserEntry,
+                    &pSecDesc);
+    BAIL_ON_LSA_ERROR(dwError);
+
+    if (!RtlAccessCheck(pSecDesc,
+                        pUserToken,
+                        USER_ACCESS_CHANGE_PASSWORD,
+                        0,
+                        &GenericMapping,
+                        &dwAccessGranted,
+                        &ntStatus))
+    {
+        BAIL_ON_NT_STATUS(ntStatus);
+    }
 
     dwError = DirectoryChangePassword(
                     pContext->hDirectory,
@@ -1230,11 +1298,32 @@ LocalDirChangePassword(
                     pwszNewPassword);
     BAIL_ON_LSA_ERROR(dwError);
 
-error:
+cleanup:
+    if (pUserEntry)
+    {
+        DirectoryFreeEntries(pUserEntry, dwNumEntries);
+    }
+
+    LW_SAFE_FREE_MEMORY(pwszFilter);
+
+    DirectoryFreeEntrySecurityDescriptor(&pSecDesc);
+
+    RtlReleaseAccessToken(&pUserToken);
+    LwMapSecurityFreeContext(&pSecCtx);
+
+    if (dwError == ERROR_SUCCESS &&
+        ntStatus != STATUS_SUCCESS)
+    {
+        dwError = LwNtStatusToWin32Error(ntStatus);
+    }
 
     return dwError;
+
+error:
+    goto cleanup;
 }
 
+
 DWORD
 LocalDirSetPassword(
     HANDLE hProvider,
diff --git a/lsass/server/store/samdb/samdbinit.c b/lsass/server/store/samdb/samdbinit.c
index 273da3a7c..e644d472d 100644
--- a/lsass/server/store/samdb/samdbinit.c
+++ b/lsass/server/store/samdb/samdbinit.c
@@ -131,6 +131,12 @@ SamDbFixAcls(
     HANDLE hDirectory
     );
 
+static
+DWORD
+SamDbFixLocalAccounts(
+    HANDLE hDirectory
+    );
+
 static
 VOID
 SamDbFreeAbsoluteSecurityDescriptor(
@@ -259,6 +265,9 @@ SamDbInit(
         dwError = SamDbFixAcls(hDirectory1);
         BAIL_ON_SAMDB_ERROR(dwError);
 
+        dwError = SamDbFixLocalAccounts(hDirectory1);
+        BAIL_ON_SAMDB_ERROR(dwError);
+
         goto cleanup;
     }
 
@@ -1220,7 +1229,7 @@ SamDbAddLocalAccounts(
                                 "computer/domain",
             .pszShell         = SAM_DB_DEFAULT_ADMINISTRATOR_SHELL,
             .pszHomedir       = SAM_DB_DEFAULT_ADMINISTRATOR_HOMEDIR,
-            .flags            = SAMDB_ACB_NORMAL,
+            .flags            = SAMDB_ACB_NORMAL | SAMDB_ACB_DISABLED,
             .objectClass      = SAMDB_OBJECT_CLASS_USER
         },
         {
@@ -2093,6 +2102,145 @@ error:
     goto cleanup;
 }
 
+
+static
+DWORD
+SamDbFixLocalAccounts(
+    HANDLE hDirectory
+    )
+{
+
+    DWORD dwError = 0;
+    const wchar_t wszUserObjectFilterFmt[] = L"%ws = %u";
+    const DWORD dwInt32StrSize = 10;
+    WCHAR wszAttrObjectClass[] = SAM_DB_DIR_ATTR_OBJECT_CLASS;
+    WCHAR wszAttrObjectDN[] = SAM_DB_DIR_ATTR_DISTINGUISHED_NAME;
+    WCHAR wszAttrAccountFlags[] = SAM_DB_DIR_ATTR_ACCOUNT_FLAGS;
+    WCHAR wszAttrNtHash[] = SAM_DB_DIR_ATTR_NT_HASH;
+    DWORD dwUserObjectFilterLen = 0;
+    PWSTR pwszUserObjectFilter = NULL;
+    ULONG ulScope = 0;
+    ULONG ulAttributesOnly = 0;
+    PWSTR pwszBase = NULL;
+    PWSTR wszAttributes[] = {
+        &wszAttrObjectDN[0],
+        &wszAttrAccountFlags[0],
+        &wszAttrNtHash[0],
+        NULL
+    };
+
+    PDIRECTORY_ENTRY pUserEntries = NULL;
+    DWORD dwNumUserEntries = 0;
+    PDIRECTORY_ENTRY pUserEntry = NULL;
+    DWORD iEntry = 0;
+    PWSTR pwszUserObjectDN = NULL;
+    DWORD dwAccountFlags = 0;
+    POCTET_STRING pNtHash = NULL;
+    DWORD iMod = 0;
+
+    enum AttrValueIndex {
+        ATTR_VAL_IDX_ACCOUNT_FLAGS = 0,
+        ATTR_VAL_IDX_SENTINEL
+    };
+
+    ATTRIBUTE_VALUE AttrValues[] = {
+        {   /* ATTR_VAL_IDX_ACCOUNT_FLAGS */
+            .Type = DIRECTORY_ATTR_TYPE_LARGE_INTEGER,
+            .data.ulValue = 0
+        }
+    };
+
+    DIRECTORY_MOD ModAccountFlags = {
+        DIR_MOD_FLAGS_REPLACE,
+        wszAttrAccountFlags,
+        1,
+        &AttrValues[ATTR_VAL_IDX_ACCOUNT_FLAGS]
+    };
+
+    DIRECTORY_MOD Mods[ATTR_VAL_IDX_SENTINEL + 1];
+    memset(&Mods, 0, sizeof(Mods));
+
+    dwUserObjectFilterLen = (sizeof(wszAttrObjectClass)/sizeof(wszAttrObjectClass[0]) +
+                             dwInt32StrSize +
+                             sizeof(wszUserObjectFilterFmt));
+    dwError = LwAllocateMemory(dwUserObjectFilterLen * sizeof(WCHAR),
+                               OUT_PPVOID(&pwszUserObjectFilter));
+    BAIL_ON_SAMDB_ERROR(dwError);
+
+    if (sw16printfw(pwszUserObjectFilter, dwUserObjectFilterLen,
+                    wszUserObjectFilterFmt,
+                    &wszAttrObjectClass[0], SAMDB_OBJECT_CLASS_USER) < 0)
+    {
+        dwError = LwErrnoToWin32Error(errno);
+        BAIL_ON_SAMDB_ERROR(dwError);
+    }
+
+    dwError = SamDbSearchObject(hDirectory,
+                                pwszBase,
+                                ulScope,
+                                pwszUserObjectFilter,
+                                wszAttributes,
+                                ulAttributesOnly,
+                                &pUserEntries,
+                                &dwNumUserEntries);
+    BAIL_ON_SAMDB_ERROR(dwError);
+
+    for (iEntry = 0; iEntry < dwNumUserEntries; iEntry++)
+    {
+        pUserEntry = &(pUserEntries[iEntry]);
+
+        dwError = DirectoryGetEntryAttrValueByName(
+                                    pUserEntry,
+                                    wszAttrObjectDN,
+                                    DIRECTORY_ATTR_TYPE_UNICODE_STRING,
+                                    &pwszUserObjectDN);
+        BAIL_ON_SAMDB_ERROR(dwError);
+
+        dwError = DirectoryGetEntryAttrValueByName(
+                                    pUserEntry,
+                                    wszAttrAccountFlags,
+                                    DIRECTORY_ATTR_TYPE_INTEGER,
+                                    &dwAccountFlags);
+        BAIL_ON_SAMDB_ERROR(dwError);
+
+        dwError = DirectoryGetEntryAttrValueByName(
+                                    pUserEntry,
+                                    wszAttrNtHash,
+                                    DIRECTORY_ATTR_TYPE_OCTET_STREAM,
+                                    &pNtHash);
+        BAIL_ON_SAMDB_ERROR(dwError);
+
+        if ((pNtHash == NULL || pNtHash->ulNumBytes == 0) &&
+            !(dwAccountFlags & SAMDB_ACB_DISABLED))
+        {
+            dwAccountFlags |= SAMDB_ACB_DISABLED;
+
+            AttrValues[ATTR_VAL_IDX_ACCOUNT_FLAGS].data.ulValue = dwAccountFlags;
+
+            Mods[iMod++] = ModAccountFlags;
+
+            dwError = SamDbModifyObject(hDirectory,
+                                        pwszUserObjectDN,
+                                        Mods);
+            BAIL_ON_SAMDB_ERROR(dwError);
+        }
+    }
+
+cleanup:
+    if (pUserEntries)
+    {
+        DirectoryFreeEntries(pUserEntries, dwNumUserEntries);
+    }
+
+    LW_SAFE_FREE_MEMORY(pwszUserObjectFilter);
+
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+
 static
 VOID
 SamDbFreeAbsoluteSecurityDescriptor(
