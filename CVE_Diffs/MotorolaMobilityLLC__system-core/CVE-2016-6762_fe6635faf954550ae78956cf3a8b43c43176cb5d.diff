MotorolaMobilityLLC__system-core
commit fe6635faf954550ae78956cf3a8b43c43176cb5d
Author:     Tianjie Xu <xunchang@google.com>
AuthorDate: Wed Sep 21 14:58:11 2016 -0700
Commit:     Hareesh Mittapalli <hareeshm@motorola.com>
CommitDate: Thu Nov 24 03:19:19 2016 -0600

    Fix out of bound access in libziparchive
    
    ANDROID-31251826 : Elevation of privilege vulnerability in libziparchive
    CVE-2016-6762
    Mot-CRs-fixed: (CR)
    
    The boundary check of an invalid EOCD record may succeed due to the
    overflow of uint32_t. Fix the check.
    
    Test: Open the crash.apk and libziparchive reports the offset error as expected.
    
    Bug: 31251826
    Change-Id: I1d8092a19b73886a671bc9d291cfc27d65e3d236
    (cherry picked from commit ae8180c06dee228cd1378c56afa6020ae98d8a24)
    (cherry picked from commit 1ee4892e66ba314131b7ecf17e98bb1762c4b84c)
    Reviewed-on: https://gerrit.mot.com/918144
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Jason Hrycay <jason.hrycay@motorola.com>
    Submit-Approved: Raja Phani K <a16821@motorola.com>

diff --git a/libziparchive/zip_archive.cc b/libziparchive/zip_archive.cc
index 1f2750047..986ee7208 100644
--- a/libziparchive/zip_archive.cc
+++ b/libziparchive/zip_archive.cc
@@ -269,9 +269,14 @@ static int32_t MapCentralDirectory0(int fd, const char* debug_file_name,
    * Grab the CD offset and size, and the number of entries in the
    * archive and verify that they look reasonable.
    */
-  if (eocd->cd_start_offset + eocd->cd_size > eocd_offset) {
+  if (static_cast<off64_t>(eocd->cd_start_offset) + eocd->cd_size > eocd_offset) {
     ALOGW("Zip: bad offsets (dir %" PRIu32 ", size %" PRIu32 ", eocd %" PRId64 ")",
         eocd->cd_start_offset, eocd->cd_size, static_cast<int64_t>(eocd_offset));
+#if defined(__ANDROID__)
+    if (eocd->cd_start_offset + eocd->cd_size <= eocd_offset) {
+      android_errorWriteLog(0x534e4554, "31251826");
+    }
+#endif
     return kInvalidOffset;
   }
   if (eocd->num_records == 0) {
