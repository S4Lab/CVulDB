MotorolaMobilityLLC__system-core
commit 5df380ce945daf72e34fbddec7af7dd54d8fb909
Author:     yangqh5 <yangqh5@lenovo.com>
AuthorDate: Mon Aug 15 14:28:08 2016 +0800
Commit:     zhangly19 <zhangly19@lenovo.com>
CommitDate: Mon Aug 22 10:26:17 2016 +0800

    [MTK Patch](CR)For_mt6755_66_m_alps-mp-m0.mp7-V2.3_P108
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02854742
    Severity:
    
    Description:
      [Patch Request] [PMS] mt, Project: mt6755_66_M, SW Version: alps-mp-m0.mp7-V2.3N/A
    
    Associated Files:
      device/mt/mt6755_66_m/ProjectConfig.mk
      device/mt/mt6755_66c_m/ProjectConfig.mk
      device/mt/mt6755_66t_m/ProjectConfig.mk
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840687
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3861]Remote code execution vulnerability in LibUtils
      [[問題標題]]
      [Google Security P***h][CVE-2016-3861]Remote code execution vulnerability in LibUtils
      [[問題現象]]
      [Google Security P***h][CVE-2016-3861]Remote code execution vulnerability in LibUtils
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3861]Remote code execution vulnerability in LibUtils
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3861]Remote code execution vulnerability in LibUtils
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
      frameworks/base/libs/hwui/mediatek/MTKDisplayListRecorder.cpp
      frameworks/base/tools/aapt/Android.mk
      frameworks/base/tools/aapt2/Util.cpp
      frameworks/base/tools/split-select/Android.mk
      system/core/include/utils/Unicode.h
      system/core/libutils/String8.cpp
      system/core/libutils/Unicode.cpp
      system/core/libutils/tests/String8_test.cpp
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840705
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3822]Update: Remote code execution vulnerability in libjhead
      [[問題標題]]
      [Google Security P***h][CVE-2016-3822]Update: Remote code execution vulnerability in libjhead
      [[問題現象]]
      [Google Security P***h][CVE-2016-3822]Update: Remote code execution vulnerability in libjhead
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3822]Update: Remote code execution vulnerability in libjhead
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3822]Update: Remote code execution vulnerability in libjhead
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      external/jhead/gpsinfo.c
      external/jhead/makernote.c
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840706
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3870][CVE-2016-3871][CVE-2016-3872]Elevation of privilege vulnerability in Mediaserver
      [[問題標題]]
      [Google Security P***h][CVE-2016-3870][CVE-2016-3871][CVE-2016-3872]Elevation of privilege vulnerability in Mediaserver
      [[問題現象]]
      [Google Security P***h][CVE-2016-3870][CVE-2016-3871][CVE-2016-3872]Elevation of privilege vulnerability in Mediaserver
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3870][CVE-2016-3871][CVE-2016-3872]Elevation of privilege vulnerability in Mediaserver
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3870][CVE-2016-3871][CVE-2016-3872]Elevation of privilege vulnerability in Mediaserver
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      frameworks/av/media/libstagefright/codecs/mp3dec/SoftMP3.cpp
      frameworks/av/media/libstagefright/codecs/mp3dec/SoftMP3.h
      frameworks/av/media/libstagefright/codecs/on2/dec/SoftVPX.cpp
      frameworks/av/media/libstagefright/codecs/on2/dec/SoftVPX.h
      frameworks/av/media/libstagefright/omx/SimpleSoftOMXComponent.cpp
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840708
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3875]Elevation of privilege vulnerability in device boot
      [[問題標題]]
      [Google Security P***h][CVE-2016-3875]Elevation of privilege vulnerability in device boot
      [[問題現象]]
      [Google Security P***h][CVE-2016-3875]Elevation of privilege vulnerability in device boot
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3875]Elevation of privilege vulnerability in device boot
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3875]Elevation of privilege vulnerability in device boot
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840702
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3863]Remote code execution vulnerability in MediaMuxer
      [[問題標題]]
      [Google Security P***h][CVE-2016-3863]Remote code execution vulnerability in MediaMuxer
      [[問題現象]]
      [Google Security P***h][CVE-2016-3863]Remote code execution vulnerability in MediaMuxer
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3863]Remote code execution vulnerability in MediaMuxer
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3863]Remote code execution vulnerability in MediaMuxer
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      frameworks/av/media/libstagefright/Utils.cpp
    
    Change-Id: Ib3c91373b0896d1326fc951b2343b9c01b263501

diff --git a/include/utils/Unicode.h b/include/utils/Unicode.h
index b76a5e268..4e17cc3d9 100644
--- a/include/utils/Unicode.h
+++ b/include/utils/Unicode.h
@@ -87,7 +87,7 @@ ssize_t utf32_to_utf8_length(const char32_t *src, size_t src_len);
  * "dst" becomes \xE3\x81\x82\xE3\x81\x84
  * (note that "dst" is NOT null-terminated, like strncpy)
  */
-void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst);
+void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst, size_t dst_len);
 
 /**
  * Returns the unicode value at "index".
@@ -109,7 +109,7 @@ ssize_t utf16_to_utf8_length(const char16_t *src, size_t src_len);
  * enough to fit the UTF-16 as measured by utf16_to_utf8_length with an added
  * NULL terminator.
  */
-void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst);
+void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst, size_t dst_len);
 
 /**
  * Returns the length of "src" when "src" is valid UTF-8 string.
diff --git a/libutils/String8.cpp b/libutils/String8.cpp
index ad65fdb88..75dfa2994 100644
--- a/libutils/String8.cpp
+++ b/libutils/String8.cpp
@@ -102,20 +102,21 @@ static char* allocFromUTF16(const char16_t* in, size_t len)
 {
     if (len == 0) return getEmptyString();
 
-    const ssize_t bytes = utf16_to_utf8_length(in, len);
-    if (bytes < 0) {
+     // Allow for closing '\0'
+    const ssize_t resultStrLen = utf16_to_utf8_length(in, len) + 1;
+    if (resultStrLen < 1) {
         return getEmptyString();
     }
 
-    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);
+    SharedBuffer* buf = SharedBuffer::alloc(resultStrLen);
     ALOG_ASSERT(buf, "Unable to allocate shared buffer");
     if (!buf) {
         return getEmptyString();
     }
 
-    char* str = (char*)buf->data();
-    utf16_to_utf8(in, len, str);
-    return str;
+    char* resultStr = (char*)buf->data();
+    utf16_to_utf8(in, len, resultStr, resultStrLen);
+    return resultStr;
 }
 
 static char* allocFromUTF32(const char32_t* in, size_t len)
@@ -124,21 +125,21 @@ static char* allocFromUTF32(const char32_t* in, size_t len)
         return getEmptyString();
     }
 
-    const ssize_t bytes = utf32_to_utf8_length(in, len);
-    if (bytes < 0) {
+    const ssize_t resultStrLen = utf32_to_utf8_length(in, len) + 1;
+    if (resultStrLen < 1) {
         return getEmptyString();
     }
 
-    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);
+    SharedBuffer* buf = SharedBuffer::alloc(resultStrLen);
     ALOG_ASSERT(buf, "Unable to allocate shared buffer");
     if (!buf) {
         return getEmptyString();
     }
 
-    char* str = (char*) buf->data();
-    utf32_to_utf8(in, len, str);
+    char* resultStr = (char*) buf->data();
+    utf32_to_utf8(in, len, resultStr, resultStrLen);
 
-    return str;
+    return resultStr;
 }
 
 // ---------------------------------------------------------------------------
diff --git a/libutils/Unicode.cpp b/libutils/Unicode.cpp
index fb876c91f..2b5293e74 100644
--- a/libutils/Unicode.cpp
+++ b/libutils/Unicode.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <log/log.h>
 #include <utils/Unicode.h>
 
 #include <stddef.h>
@@ -182,7 +183,7 @@ ssize_t utf32_to_utf8_length(const char32_t *src, size_t src_len)
     return ret;
 }
 
-void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst)
+void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst, size_t dst_len)
 {
     if (src == NULL || src_len == 0 || dst == NULL) {
         return;
@@ -193,9 +194,12 @@ void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst)
     char *cur = dst;
     while (cur_utf32 < end_utf32) {
         size_t len = utf32_codepoint_utf8_length(*cur_utf32);
+        LOG_ALWAYS_FATAL_IF(dst_len < len, "%zu < %zu", dst_len, len);
         utf32_codepoint_to_utf8((uint8_t *)cur, *cur_utf32++, len);
         cur += len;
+        dst_len -= len;
     }
+    LOG_ALWAYS_FATAL_IF(dst_len < 1, "dst_len < 1: %zu < 1", dst_len);
     *cur = '\0';
 }
 
@@ -324,7 +328,7 @@ int strzcmp16_h_n(const char16_t *s1H, size_t n1, const char16_t *s2N, size_t n2
            : 0);
 }
 
-void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst)
+void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst, size_t dst_len)
 {
     if (src == NULL || src_len == 0 || dst == NULL) {
         return;
@@ -345,9 +349,12 @@ void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst)
             utf32 = (char32_t) *cur_utf16++;
         }
         const size_t len = utf32_codepoint_utf8_length(utf32);
+        LOG_ALWAYS_FATAL_IF(dst_len < len, "%zu < %zu", dst_len, len);
         utf32_codepoint_to_utf8((uint8_t*)cur, utf32, len);
         cur += len;
+        dst_len -= len;
     }
+    LOG_ALWAYS_FATAL_IF(dst_len < 1, "%zu < 1", dst_len);
     *cur = '\0';
 }
 
@@ -408,10 +415,10 @@ ssize_t utf16_to_utf8_length(const char16_t *src, size_t src_len)
     const char16_t* const end = src + src_len;
     while (src < end) {
         if ((*src & 0xFC00) == 0xD800 && (src + 1) < end
-                && (*++src & 0xFC00) == 0xDC00) {
+                && (*(src + 1) & 0xFC00) == 0xDC00) {
             // surrogate pairs are always 4 bytes.
             ret += 4;
-            src++;
+            src += 2;
         } else {
             ret += utf32_codepoint_utf8_length((char32_t) *src++);
         }
diff --git a/libutils/tests/String8_test.cpp b/libutils/tests/String8_test.cpp
index c42c68dce..7cd67d314 100644
--- a/libutils/tests/String8_test.cpp
+++ b/libutils/tests/String8_test.cpp
@@ -17,6 +17,7 @@
 #define LOG_TAG "String8_test"
 #include <utils/Log.h>
 #include <utils/String8.h>
+#include <utils/String16.h>
 
 #include <gtest/gtest.h>
 
@@ -72,4 +73,22 @@ TEST_F(String8Test, OperatorPlusEquals) {
     EXPECT_STREQ(src3, " Verify me.");
 }
 
+// http://b/29250543
+TEST_F(String8Test, CorrectInvalidSurrogate) {
+    // d841d8 is an invalid start for a surrogate pair. Make sure this is handled by ignoring the
+    // first character in the pair and handling the rest correctly.
+    String16 string16(u"\xd841\xd841\xdc41\x0000");
+    String8 string8(string16);
+
+    EXPECT_EQ(4U, string8.length());
+}
+
+TEST_F(String8Test, CheckUtf32Conversion) {
+    // Since bound checks were added, check the conversion can be done without fatal errors.
+    // The utf8 lengths of these are chars are 1 + 2 + 3 + 4 = 10.
+    const char32_t string32[] = U"\x0000007f\x000007ff\x0000911\x0010fffe";
+    String8 string8(string32);
+    EXPECT_EQ(10U, string8.length());
+}
+
 }
