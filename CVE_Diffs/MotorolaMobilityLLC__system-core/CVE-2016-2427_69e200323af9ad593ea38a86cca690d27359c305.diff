MotorolaMobilityLLC__system-core
commit 69e200323af9ad593ea38a86cca690d27359c305
Author:     yangqh5 <yangqh5@lenovo.com>
AuthorDate: Mon Aug 15 13:58:07 2016 +0800
Commit:     zhangly19 <zhangly19@lenovo.com>
CommitDate: Mon Aug 22 10:14:21 2016 +0800

    [MTK Patch](CR)For_mt6755_66_m_alps-mp-m0.mp7-V2.3_P106
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02854761
    Severity:
    
    Description:
      [Patch Request] [PMS] mt, Project: mt6755_66_M, SW Version: alps-mp-m0.mp7-V2.3N/A
    
    Associated Files:
      device/mt/mt6755_66_m/ProjectConfig.mk
      device/mt/mt6755_66c_m/ProjectConfig.mk
      device/mt/mt6755_66t_m/ProjectConfig.mk
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840769
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-2427]Elevation of privilege vulnerability in Debuggerd
      [[問題標題]]
      [Google Security P***h][CVE-2016-2427]Elevation of privilege vulnerability in Debuggerd
      [[問題現象]]
      [Google Security P***h][CVE-2016-2427]Elevation of privilege vulnerability in Debuggerd
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-2427]Elevation of privilege vulnerability in Debuggerd
      [[Problem Description]]
      [Google Security P***h][CVE-2016-2427]Elevation of privilege vulnerability in Debuggerd
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      external/bouncycastle/bcprov/src/main/java/org/bouncycastle/asn1/cms/GCMParameters.java
      libcore/luni/src/test/java/libcore/javax/crypto/CipherTest.java
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840761
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3896]Information disclosure vulnerability in AOSP Mail
      [[問題標題]]
      [Google Security P***h][CVE-2016-3896]I***o***ation disclosure vulnerability in AOSP Mail
      [[問題現象]]
      [Google Security P***h][CVE-2016-3896]I***o***ation disclosure vulnerability in AOSP Mail
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3896]I***o***ation disclosure vulnerability in AOSP Mail
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3896]I***o***ation disclosure vulnerability in AOSP Mail
      [[Impa***]]
      Email
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      EmailN/A
    
    Associated Files:
      packages/apps/Email/AndroidManifest.xml
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840764
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3897]Information disclosure vulnerability in Wi-Fi
      [[問題標題]]
      [Google Security P***h][CVE-2016-3897]I***o***ation disclosure vulnerability in Wi-Fi
      [[問題現象]]
      [Google Security P***h][CVE-2016-3897]I***o***ation disclosure vulnerability in Wi-Fi
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3897]I***o***ation disclosure vulnerability in Wi-Fi
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3897]I***o***ation disclosure vulnerability in Wi-Fi
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      frameworks/base/wifi/java/android/net/wifi/WifiEnterpriseConfig.java
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02812108
    Severity:
      Critical
    Description:
      [Google Security Patch]{ANDROID-29513589}Change Security Patch Level in Settings  [[問題標題]]
      [Google Security P***h][AN***D-29513589]Change Security P***h Level in Settings
      [[問題現象]]
      [Google Security P***h][AN***D-29513589]Change Security P***h Level in Settings
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][AN***D-29513589]Change Security P***h Level in Settings
      [[Problem Description]]
      [Google Security P***h][AN***D-29513589]Change Security P***h Level in Settings
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      build/core/version_defaults.mk
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840767
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3898]Denial of service vulnerability in Telephony
      [[問題標題]]
      [Google Security P***h][CVE-2016-3898]Denial of service vulnerability ***elephony
      [[問題現象]]
      [Google Security P***h][CVE-2016-3898]Denial of service vulnerability ***elephony
      [[問題影響]]
      TTY broadcast pe***ission control
      [[問題復現步驟]]
      change TTY mode ***elephony setting
      [[建議驗證模塊]]
      Set TTY mode ***elephony setting
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3898]Denial of service vulnerability ***elephony
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3898]Denial of service vulnerability ***elephony
      [[Impa***]]
      TTY broadcast pe***ission control
      [[Reproduced Steps]]
      change TTY mode ***elephony setting
      [[Modules to be verified after taking p***h]]
      Set TTY mode ***elephony settingN/A
    
    Associated Files:
      packages/services/Telephony/AndroidManifest.xml
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840755
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3833]Update: Elevation of privilege vulnerability in Shell
      [[問題標題]]
      [Google Security P***h][CVE-2016-3833]Update: Elevation of privilege vulnerability in Shell
      [[問題現象]]
      ***S fail with side effe*** of ALPS02799725(ID: CVE-2016-3833)
      [[問題影響]]
      ***S fail with side effe*** of ALPS02799725(ID: CVE-2016-3833)
      [[問題復現步驟]]
      run ***s
      [[建議驗證模塊]]
      ***S
    
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3833]Update: Elevation of privilege vulnerability in Shell
      [[Problem Description]]
      ***S fail with side effe*** of ALPS02799725(ID: CVE-2016-3833)
      [[Impa***]]
      ***S fail with side effe*** of ALPS02799725(ID: CVE-2016-3833)
      [[Reproduced Steps]]
      run ***s
      [[Modules to be verified after taking p***h]]
      ***SN/A
    
    Associated Files:
      frameworks/base/services/core/java/com/android/server/pm/UserManagerService.java
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840748
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3890]Elevation of privilege vulnerability in Java Debug Wire Protocol
      [[問題標題]]
      [Google Security P***h][CVE-2016-3890]Elevation of privilege vulnerability in Java Debug Wire Protocol
      [[問題現象]]
      Maybe NE when use adb and plug out USB cable
      [Google Security P***h][CVE-2016-3890]Elevation of privilege vulnerability in Java Debug Wire Protocol
      [[問題影響]]
      Debug tool may be affe***ed
      [[問題復現步驟]]
      Use adb and plug out USB cable
      [[建議驗證模塊]]
      Use adb and plug out USB
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3890]Elevation of privilege vulnerability in Java Debug Wire Protocol
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3890]Elevation of privilege vulnerability in Java Debug Wire Protocol
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      system/core/adb/Android.mk
      system/core/adb/mutex_list.h
      system/core/adb/sockets.cpp
      system/core/adb/sysdeps/mutex.h
    
    Patch Type:
      Customer Request
    CR ID:
      ALPS02840760
    Severity:
      Critical
    Description:
      [Google Security Patch][CVE-2016-3895]Information disclosure vulnerability in Mediaserver
      [[問題標題]]
      [Google Security P***h][CVE-2016-3895]I***o***ation disclosure vulnerability in Mediaserver
      [[問題現象]]
      [Google Security P***h][CVE-2016-3895]I***o***ation disclosure vulnerability in Mediaserver
      [[問題影響]]
      N/A
      [[問題復現步驟]]
      N/A
      [[建議驗證模塊]]
      N/A
      [[Title for Customer]]
      [Google Security P***h][CVE-2016-3895]I***o***ation disclosure vulnerability in Mediaserver
      [[Problem Description]]
      [Google Security P***h][CVE-2016-3895]I***o***ation disclosure vulnerability in Mediaserver
      [[Impa***]]
      N/A
      [[Reproduced Steps]]
      N/A
      [[Modules to be verified after taking p***h]]
      N/AN/A
    
    Associated Files:
      frameworks/native/libs/ui/Region.cpp
    
    Change-Id: I1b5623d358cb426cb4cdfe716cf921600200d387

diff --git a/adb/Android.mk b/adb/Android.mk
index f359ca8b3..2625ae89c 100755
--- a/adb/Android.mk
+++ b/adb/Android.mk
@@ -200,7 +200,10 @@ endif
 # will violate ODR
 LOCAL_SHARED_LIBRARIES :=
 
+# Don't build the host adb on Windows (this branch should only be used for security updates.)
+ifneq ($(HOST_OS),windows)
 include $(BUILD_HOST_EXECUTABLE)
+endif
 
 $(call dist-for-goals,dist_files sdk,$(LOCAL_BUILT_MODULE))
 
diff --git a/adb/mutex_list.h b/adb/mutex_list.h
index ff7275129..15e383cd4 100644
--- a/adb/mutex_list.h
+++ b/adb/mutex_list.h
@@ -6,7 +6,6 @@
 #ifndef ADB_MUTEX
 #error ADB_MUTEX not defined when including this file
 #endif
-ADB_MUTEX(socket_list_lock)
 ADB_MUTEX(transport_lock)
 #if ADB_HOST
 ADB_MUTEX(local_transports_lock)
diff --git a/adb/sockets.cpp b/adb/sockets.cpp
index 32ca17d2c..3919147a3 100755
--- a/adb/sockets.cpp
+++ b/adb/sockets.cpp
@@ -25,18 +25,25 @@
 #include <string.h>
 #include <unistd.h>
 
+#include <algorithm>
+#include <mutex>
+#include <string>
+#include <vector>
+
 #if !ADB_HOST
 #include "cutils/properties.h"
 #endif
 
 #include "adb.h"
 #include "adb_io.h"
+#include "sysdeps/mutex.h"
 #include "transport.h"
 
-ADB_MUTEX_DEFINE( socket_list_lock );
-
-static void local_socket_close_locked(asocket *s);
+#if !defined(__BIONIC__)
+using std::recursive_mutex;
+#endif
 
+static recursive_mutex& local_socket_list_lock = *new recursive_mutex();
 static unsigned local_socket_next_id = 1;
 
 static asocket local_socket_list = {
@@ -61,7 +68,7 @@ asocket *find_local_socket(unsigned local_id, unsigned peer_id)
     asocket *s;
     asocket *result = NULL;
 
-    adb_mutex_lock(&socket_list_lock);
+    std::lock_guard<recursive_mutex> lock(local_socket_list_lock);
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->id != local_id)
             continue;
@@ -70,7 +77,6 @@ asocket *find_local_socket(unsigned local_id, unsigned peer_id)
         }
         break;
     }
-    adb_mutex_unlock(&socket_list_lock);
 
     return result;
 }
@@ -84,20 +90,17 @@ insert_local_socket(asocket*  s, asocket*  list)
     s->next->prev = s;
 }
 
-
-void install_local_socket(asocket *s)
-{
-    adb_mutex_lock(&socket_list_lock);
+void install_local_socket(asocket* s) {
+    std::lock_guard<recursive_mutex> lock(local_socket_list_lock);
 
     s->id = local_socket_next_id++;
 
     // Socket ids should never be 0.
-    if (local_socket_next_id == 0)
-      local_socket_next_id = 1;
+    if (local_socket_next_id == 0) {
+        fatal("local socket id overflow");
+    }
 
     insert_local_socket(s, &local_socket_list);
-
-    adb_mutex_unlock(&socket_list_lock);
 }
 
 void remove_socket(asocket *s)
@@ -116,19 +119,17 @@ void remove_socket(asocket *s)
 void close_all_sockets(atransport *t)
 {
     asocket *s;
-
-        /* this is a little gross, but since s->close() *will* modify
-        ** the list out from under you, your options are limited.
-        */
-    adb_mutex_lock(&socket_list_lock);
+    /* this is a little gross, but since s->close() *will* modify
+    ** the list out from under you, your options are limited.
+    */
+    std::lock_guard<recursive_mutex> lock(local_socket_list_lock);
 restart:
-    for(s = local_socket_list.next; s != &local_socket_list; s = s->next){
-        if(s->transport == t || (s->peer && s->peer->transport == t)) {
-            local_socket_close_locked(s);
+    for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
+        if (s->transport == t || (s->peer && s->peer->transport == t)) {
+            s->close(s);
             goto restart;
         }
     }
-    adb_mutex_unlock(&socket_list_lock);
 }
 
 static int local_socket_enqueue(asocket *s, apacket *p)
@@ -191,13 +192,6 @@ static void local_socket_ready(asocket *s)
     fdevent_add(&s->fde, FDE_READ);
 }
 
-static void local_socket_close(asocket *s)
-{
-    adb_mutex_lock(&socket_list_lock);
-    local_socket_close_locked(s);
-    adb_mutex_unlock(&socket_list_lock);
-}
-
 // be sure to hold the socket list lock when calling this
 static void local_socket_destroy(asocket  *s)
 {
@@ -226,27 +220,21 @@ static void local_socket_destroy(asocket  *s)
     }
 }
 
-
-static void local_socket_close_locked(asocket *s)
-{
-    D("entered local_socket_close_locked. LS(%d) fd=%d\n", s->id, s->fd);
-    if(s->peer) {
-        D("LS(%d): closing peer. peer->id=%d peer->fd=%d\n",
-          s->id, s->peer->id, s->peer->fd);
+static void local_socket_close(asocket* s) {
+    D("entered local_socket_close. LS(%d) fd=%d", s->id, s->fd);
+    std::lock_guard<recursive_mutex> lock(local_socket_list_lock);
+    if (s->peer) {
+        D("LS(%d): closing peer. peer->id=%d peer->fd=%d", s->id, s->peer->id, s->peer->fd);
         /* Note: it's important to call shutdown before disconnecting from
          * the peer, this ensures that remote sockets can still get the id
          * of the local socket they're connected to, to send a CLOSE()
          * protocol event. */
-        if (s->peer->shutdown)
-          s->peer->shutdown(s->peer);
-        s->peer->peer = 0;
-        // tweak to avoid deadlock
-        if (s->peer->close == local_socket_close) {
-            local_socket_close_locked(s->peer);
-        } else {
-            s->peer->close(s->peer);
+        if (s->peer->shutdown) {
+            s->peer->shutdown(s->peer);
         }
-        s->peer = 0;
+        s->peer->peer = nullptr;
+        s->peer->close(s->peer);
+        s->peer = nullptr;
     }
 
         /* If we are already closing, or if there are no
diff --git a/adb/sysdeps/mutex.h b/adb/sysdeps/mutex.h
new file mode 100644
index 000000000..ef5d9b164
--- /dev/null
+++ b/adb/sysdeps/mutex.h
@@ -0,0 +1,143 @@
+#pragma once
+
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#if defined(_WIN32)
+
+#include <windows.h>
+
+#include <android-base/macros.h>
+
+#include "adb.h"
+
+// The prebuilt version of mingw we use doesn't support mutex or recursive_mutex.
+// Therefore, implement our own using the Windows primitives.
+// Put them directly into the std namespace, so that when they're actually available, the build
+// breaks until they're removed.
+
+#include <mutex>
+namespace std {
+
+// CRITICAL_SECTION is recursive, so just wrap it in a Mutex-compatible class.
+class recursive_mutex {
+  public:
+    recursive_mutex() {
+        InitializeCriticalSection(&mutex_);
+    }
+
+    ~recursive_mutex() {
+        DeleteCriticalSection(&mutex_);
+    }
+
+    void lock() {
+        EnterCriticalSection(&mutex_);
+    }
+
+    bool try_lock() {
+        return TryEnterCriticalSection(&mutex_);
+    }
+
+    void unlock() {
+        LeaveCriticalSection(&mutex_);
+    }
+
+  private:
+    CRITICAL_SECTION mutex_;
+
+    DISALLOW_COPY_AND_ASSIGN(recursive_mutex);
+};
+
+class mutex {
+  public:
+    mutex() {
+    }
+
+    ~mutex() {
+    }
+
+    void lock() {
+        mutex_.lock();
+        if (++lock_count_ != 1) {
+            fatal("non-recursive mutex locked reentrantly");
+        }
+    }
+
+    void unlock() {
+        if (--lock_count_ != 0) {
+            fatal("non-recursive mutex unlock resulted in unexpected lock count: %d", lock_count_);
+        }
+        mutex_.unlock();
+    }
+
+    bool try_lock() {
+        if (!mutex_.try_lock()) {
+            return false;
+        }
+
+        if (lock_count_ != 0) {
+            mutex_.unlock();
+            return false;
+        }
+
+        ++lock_count_;
+        return true;
+    }
+
+  private:
+    recursive_mutex mutex_;
+    size_t lock_count_ = 0;
+};
+
+}
+
+#elif defined(__BIONIC__)
+
+// On M, the recovery image uses parts of adb that depends on recursive_mutex, and uses libstdc++,
+// which lacks it.
+
+#include <pthread.h>
+#include <mutex>
+
+#include <base/macros.h>
+
+class recursive_mutex {
+  public:
+    recursive_mutex() {
+    }
+
+    ~recursive_mutex() {
+    }
+
+    void lock() {
+        pthread_mutex_lock(&mutex_);
+    }
+
+    bool try_lock() {
+        return pthread_mutex_trylock(&mutex_);
+    }
+
+    void unlock() {
+        pthread_mutex_unlock(&mutex_);
+    }
+
+  private:
+    pthread_mutex_t mutex_ = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+
+    DISALLOW_COPY_AND_ASSIGN(recursive_mutex);
+};
+
+#endif
