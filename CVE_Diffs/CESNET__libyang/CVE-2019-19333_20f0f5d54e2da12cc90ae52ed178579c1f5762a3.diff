CESNET__libyang
commit 20f0f5d54e2da12cc90ae52ed178579c1f5762a3
Author:     David Lamparter <equinox@diac24.net>
AuthorDate: Sun Dec 22 11:00:36 2019 +0100
Commit:     David Lamparter <equinox@diac24.net>
CommitDate: Sun Dec 22 14:46:40 2019 +0100

    debian: fix #946217
    
    backport fixes for CVE-2019-19333 & CVE-2019-19334 from libyang
    upstream.

diff --git a/debian/changelog b/debian/changelog
index f3dbdc85..f5af4795 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,9 @@
+libyang (0.16.105-2) UNRELEASED; urgency=medium
+
+  * fix CVE-2019-19333 & CVE-2019-19334 (Closes: #946217)
+
+ -- David Lamparter <equinox-debian@diac24.net>  Sun, 22 Dec 2019 11:02:55 +0100
+
 libyang (0.16.105-1) unstable; urgency=medium
 
   * upstream 0.16.105 (0.16-r3) release
diff --git a/debian/patches/0001-parser-BUGFIX-long-identity-name-buffer-overflow.patch b/debian/patches/0001-parser-BUGFIX-long-identity-name-buffer-overflow.patch
new file mode 100644
index 00000000..821fcd24
--- /dev/null
+++ b/debian/patches/0001-parser-BUGFIX-long-identity-name-buffer-overflow.patch
@@ -0,0 +1,253 @@
+Applied-Upstream: f6d684ade99dd37b21babaa8a856f64faa1e2e0d
+Author: Michal Vasko <mvasko@cesnet.cz>
+Last-Update: 2019-12-22
+Description: parser BUGFIX long identity name buffer overflow
+ STRING_OVERFLOW (CWE-120)
+
+diff --git a/src/parser.c b/src/parser.c
+index 3303041d15e7..281a97aac6d6 100644
+--- a/src/parser.c
++++ b/src/parser.c
+@@ -979,7 +979,7 @@ lyp_precompile_pattern(struct ly_ctx *ctx, const char *pattern, pcre** pcre_cmp,
+  * @param[in] data2 If \p type is #LY_TYPE_BITS: (int *) type bit field length,
+  *                                #LY_TYPE_DEC64: (uint8_t *) number of fraction digits (position of the floating point),
+  *                                otherwise ignored.
+- * @return 1 if a conversion took place, 0 if the value was kept the same.
++ * @return 1 if a conversion took place, 0 if the value was kept the same, -1 on error.
+  */
+ static int
+ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)
+@@ -994,6 +994,8 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+     uint64_t unum;
+     uint8_t c;
+ 
++#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, "Value \"%s\" is too long.", str)
++
+     switch (type) {
+     case LY_TYPE_BITS:
+         bits = (struct lys_type_bit **)data1;
+@@ -1006,8 +1008,10 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+                 continue;
+             }
+             if (buf[0]) {
++                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);
+                 sprintf(buf + strlen(buf), " %s", bits[i]->name);
+             } else {
++                LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);
+                 strcpy(buf, bits[i]->name);
+             }
+         }
+@@ -1025,7 +1029,7 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+ 
+     case LY_TYPE_INST:
+         exp = lyxp_parse_expr(ctx, *value);
+-        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), 0);
++        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);
+ 
+         module_name = NULL;
+         count = 0;
+@@ -1035,9 +1039,9 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+             /* copy WS */
+             if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {
+                 if (count + (cur_expr - end) > buf_len) {
+-                    LOGINT(ctx);
+                     lyxp_expr_free(exp);
+-                    return 0;
++                    LOGBUF(end);
++                    return -1;
+                 }
+                 strncpy(&buf[count], end, cur_expr - end);
+                 count += cur_expr - end;
+@@ -1051,9 +1055,9 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+                 if (!module_name || strncmp(cur_expr, module_name, j)) {
+                     /* print module name with colon, it does not equal to the parent one */
+                     if (count + j > buf_len) {
+-                        LOGINT(ctx);
+                         lyxp_expr_free(exp);
+-                        return 0;
++                        LOGBUF(cur_expr);
++                        return -1;
+                     }
+                     strncpy(&buf[count], cur_expr, j);
+                     count += j;
+@@ -1062,17 +1066,17 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+ 
+                 /* copy the rest */
+                 if (count + (exp->tok_len[i] - j) > buf_len) {
+-                    LOGINT(ctx);
+                     lyxp_expr_free(exp);
+-                    return 0;
++                    LOGBUF(end);
++                    return -1;
+                 }
+                 strncpy(&buf[count], end, exp->tok_len[i] - j);
+                 count += exp->tok_len[i] - j;
+             } else {
+                 if (count + exp->tok_len[i] > buf_len) {
+-                    LOGINT(ctx);
+                     lyxp_expr_free(exp);
+-                    return 0;
++                    LOGBUF(&exp->expr[exp->expr_pos[i]]);
++                    return -1;
+                 }
+                 strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);
+                 count += exp->tok_len[i];
+@@ -1081,7 +1085,7 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+         if (count > buf_len) {
+             LOGINT(ctx);
+             lyxp_expr_free(exp);
+-            return 0;
++            return -1;
+         }
+         buf[count] = '\0';
+ 
+@@ -1146,6 +1150,8 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+     }
+ 
+     return 0;
++
++#undef LOGBUF
+ }
+ 
+ static const char *
+@@ -1411,7 +1417,10 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             c = c + len;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_BITS, value_, bits, &type->info.bits.count);
++        if (make_canonical(ctx, LY_TYPE_BITS, value_, bits, &type->info.bits.count) == -1) {
++            free(bits);
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1469,7 +1478,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_DEC64, value_, &num, &type->info.dec64.dig);
++        if (make_canonical(ctx, LY_TYPE_DEC64, value_, &num, &type->info.dec64.dig) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1597,7 +1608,10 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             type->parent->flags |= LYS_DFLTJSON;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_IDENT, &value, (void*)lys_main_module(local_mod)->name, NULL);
++        if (make_canonical(ctx, LY_TYPE_IDENT, &value, (void*)lys_main_module(local_mod)->name, NULL) == -1) {
++            lydict_remove(ctx, value);
++            goto error;
++        }
+ 
+         /* replace the old value with the new one (even if they may be the same) */
+         lydict_remove(ctx, *value_);
+@@ -1650,8 +1664,12 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             /* turn logging back on */
+             ly_ilo_restore(NULL, prev_ilo, NULL, 0);
+         } else {
+-            if (make_canonical(ctx, LY_TYPE_INST, &value, NULL, NULL)) {
+-                /* if a change occured, value was removed from the dicionary so fix the pointers */
++            if ((c = make_canonical(ctx, LY_TYPE_INST, &value, NULL, NULL))) {
++                if (c == -1) {
++                    goto error;
++                }
++
++                /* if a change occurred, value was removed from the dictionary so fix the pointers */
+                 *value_ = value;
+             }
+         }
+@@ -1752,7 +1770,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_INT8, value_, &num, NULL);
++        if (make_canonical(ctx, LY_TYPE_INT8, value_, &num, NULL) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1767,7 +1787,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_INT16, value_, &num, NULL);
++        if (make_canonical(ctx, LY_TYPE_INT16, value_, &num, NULL) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1782,7 +1804,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_INT32, value_, &num, NULL);
++        if (make_canonical(ctx, LY_TYPE_INT32, value_, &num, NULL) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1798,7 +1822,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_INT64, value_, &num, NULL);
++        if (make_canonical(ctx, LY_TYPE_INT64, value_, &num, NULL) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1813,7 +1839,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_UINT8, value_, &unum, NULL);
++        if (make_canonical(ctx, LY_TYPE_UINT8, value_, &unum, NULL) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1828,7 +1856,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_UINT16, value_, &unum, NULL);
++        if (make_canonical(ctx, LY_TYPE_UINT16, value_, &unum, NULL) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1843,7 +1873,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_UINT32, value_, &unum, NULL);
++        if (make_canonical(ctx, LY_TYPE_UINT32, value_, &unum, NULL) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+@@ -1858,7 +1890,9 @@ lyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *x
+             goto error;
+         }
+ 
+-        make_canonical(ctx, LY_TYPE_UINT64, value_, &unum, NULL);
++        if (make_canonical(ctx, LY_TYPE_UINT64, value_, &unum, NULL) == -1) {
++            goto error;
++        }
+ 
+         if (store) {
+             /* store the result */
+-- 
+2.24.1
+
diff --git a/debian/patches/0002-parser-BUGFIX-long-identityref-default-value-buffer-.patch b/debian/patches/0002-parser-BUGFIX-long-identityref-default-value-buffer-.patch
new file mode 100644
index 00000000..c33c02d7
--- /dev/null
+++ b/debian/patches/0002-parser-BUGFIX-long-identityref-default-value-buffer-.patch
@@ -0,0 +1,24 @@
+Applied-Upstream: 6980afae2ff9fcd6d67508b0a3f694d75fd059d6
+Author: Michal Vasko <mvasko@cesnet.cz>
+Last-Updated: 2019-12-22
+Description: parser BUGFIX long identityref default value buffer overflow
+ STRING_OVERFLOW (CWE-120)
+
+diff --git a/src/parser.c b/src/parser.c
+index 281a97aac6d6..6979b9c17df3 100644
+--- a/src/parser.c
++++ b/src/parser.c
+@@ -1021,8 +1021,10 @@ make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, vo
+         module_name = (const char *)data1;
+         /* identity must always have a prefix */
+         if (!strchr(*value, ':')) {
++            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);
+             sprintf(buf, "%s:%s", module_name, *value);
+         } else {
++            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);
+             strcpy(buf, *value);
+         }
+         break;
+-- 
+2.24.1
+
diff --git a/debian/patches/series b/debian/patches/series
index b9989c90..e8581025 100644
--- a/debian/patches/series
+++ b/debian/patches/series
@@ -1,2 +1,4 @@
 pybuild
 swigpy37
+0001-parser-BUGFIX-long-identity-name-buffer-overflow.patch
+0002-parser-BUGFIX-long-identityref-default-value-buffer-.patch
