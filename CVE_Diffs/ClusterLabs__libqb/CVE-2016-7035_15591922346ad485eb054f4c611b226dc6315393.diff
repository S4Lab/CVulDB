ClusterLabs__libqb
commit 15591922346ad485eb054f4c611b226dc6315393
Author:     Jan Pokorný <jpokorny@redhat.com>
AuthorDate: Fri Nov 4 19:05:35 2016 +0100
Commit:     Jan Pokorný <jpokorny@redhat.com>
CommitDate: Fri Nov 4 19:05:35 2016 +0100

    Med: rb: use new qb_rb_close_helper able to resort to file truncating
    
    This changeset builds on previous 2-3 commits and represents the main
    libqb's answer to the original question behind pacemaker's security
    defect known as CVE-2016-7035.
    
    Beside the helper partly unifying handling of qb_rb_force_close and
    qb_rb_close, it provides the former with ability to use file truncating
    as a fallback for when unlinking fails, e.g., because client (note that
    mentioned is currently only relevant for the client side as normally
    server is responsible for the lifecycle of the materialized files,
    unless it crashes and only client is left to do its best) is not the
    owner while they are placed at a directory with restricted deletion,
    which enforces this very ownership condition.
    
    In practice, this means that, at worst, just the zero-size files are
    left behind, so not that much space exhaustion (usually "ramdisk"
    like tmpfs is what backs default storage directory /dev/shm, so it
    boils down to physical memory exhaustion, even if it can be just
    for page cache and related overhead) can happen even on repeated
    crashes as the memory mappings are cleared as much as possible.
    
    Also openat/unlinkat functions (sported in qb_sys_unlink_or_truncate_at
    as of the previous commit) are, when applicable, used so as to limit
    possible race conditions between/during individual path traversals
    (both files being got rid of presumably share the same directory).
    
    Few words on which actions are attempted in which order for the
    equivalent of qb_rb_force_close now:
    There are subtle interactions between what's externally visible
    (files) and what's not (memory mappings associated with such files),
    and perhaps between memory pages management from the perspective of
    the former (usually "ramdisk"/tmpfs) and the latter (mmap + munmap).
    If the associated file is no longer publicly exposed by the means of
    unlink (even if the object survives internally as refcounting is in
    the game, with mmap holding a reference), memory mapping is not
    affected.  On the other hand, if it's just limited by truncation
    to zero size, memory mapping is aware and generates SIGBUS in response
    to accessing respective addresses.  Similarly, accessing munmap'd
    (no refcounting here) memory generates SIGSEGV.  For delicacy,
    the inputs for all of unlink, truncate, and munmap are stored
    at the mmap'd location we are about to drop, but that's just a matter
    of making copies ahead of time.
    At Ken's suggestion, the scheme is: (unlink or truncate) then munmap,
    which has a benefit that externally visible (and program's life span
    otherwise surviving!) part is eliminated first, with memory mappings
    (disposed at program termination automatically at latest) to follow.
    (There was originally a paranoid expectation on my side that truncate
    on tmpfs actually does silent munmap, so that our munmap could in fact
    tear down the mapping added in the interim by the libraries, signal
    handler or due to requirements of another thread, also because of
    munmap on the range without any current mappings will not fail, and
    thus there's likely no portable way to non-intrusively check the
    status, but also due to documented SIGBUS vs. SIGSEGV differences
    the whole assumption appears bogus on the second thought.)
    
    Relevant unit tests that exercise client-side unlinking:
    - check_ipc: test_ipc_server_fail_shm, test_ipc_exit_shm
    - new test in a subsequent commit

diff --git a/lib/ringbuffer.c b/lib/ringbuffer.c
index db842ce..60b0ea1 100644
--- a/lib/ringbuffer.c
+++ b/lib/ringbuffer.c
@@ -290,22 +290,7 @@ qb_rb_close(struct qb_ringbuffer_s * rb)
 	qb_enter();
 
 	(void)qb_atomic_int_dec_and_test(&rb->shared_hdr->ref_count);
-	if (rb->flags & QB_RB_FLAG_CREATE) {
-		if (rb->notifier.destroy_fn) {
-			(void)rb->notifier.destroy_fn(rb->notifier.instance);
-		}
-		unlink(rb->shared_hdr->data_path);
-		unlink(rb->shared_hdr->hdr_path);
-		qb_util_log(LOG_DEBUG,
-			    "Free'ing ringbuffer: %s",
-			    rb->shared_hdr->hdr_path);
-	} else {
-		qb_util_log(LOG_DEBUG,
-			    "Closing ringbuffer: %s", rb->shared_hdr->hdr_path);
-	}
-	munmap(rb->shared_data, (rb->shared_hdr->word_size * sizeof(uint32_t)) << 1);
-	munmap(rb->shared_hdr, sizeof(struct qb_ringbuffer_shared_s));
-	free(rb);
+	(void)qb_rb_close_helper(rb, rb->flags & QB_RB_FLAG_CREATE, QB_FALSE);
 }
 
 void
@@ -316,24 +301,8 @@ qb_rb_force_close(struct qb_ringbuffer_s * rb)
 	}
 	qb_enter();
 
-	if (rb->notifier.destroy_fn) {
-		(void)rb->notifier.destroy_fn(rb->notifier.instance);
-	}
-
-        errno = 0;
-	unlink(rb->shared_hdr->data_path);
-	qb_util_perror(LOG_DEBUG,
-		    "Force free'ing ringbuffer: %s",
-		    rb->shared_hdr->data_path);
-
-        errno = 0;
-	unlink(rb->shared_hdr->hdr_path);
-	qb_util_perror(LOG_DEBUG,
-		    "Force free'ing ringbuffer: %s",
-		    rb->shared_hdr->hdr_path);
-	munmap(rb->shared_data, (rb->shared_hdr->word_size * sizeof(uint32_t)) << 1);
-	munmap(rb->shared_hdr, sizeof(struct qb_ringbuffer_shared_s));
-	free(rb);
+	qb_atomic_int_set(&rb->shared_hdr->ref_count, -1);
+	(void)qb_rb_close_helper(rb, QB_TRUE, QB_TRUE);
 }
 
 char *
diff --git a/lib/ringbuffer_helper.c b/lib/ringbuffer_helper.c
index 455fd99..dbde275 100644
--- a/lib/ringbuffer_helper.c
+++ b/lib/ringbuffer_helper.c
@@ -306,3 +306,93 @@ qb_rb_sem_create(struct qb_ringbuffer_s * rb, uint32_t flags)
 	}
 	return rc;
 }
+
+
+/* For qb_rb_close_helper, we need to open directory in read-only
+   mode and with as lightweight + strict flags as available at
+   given platform (O_PATH for the former, O_DIRECTORY for the
+   latter); end result is available as RB_DIR_RO_FLAGS.
+ */
+#if defined(HAVE_OPENAT) && defined(HAVE_UNLINKAT)
+#  ifndef O_DIRECTORY
+#    define RB_DIR_RO_FLAGS1 O_RDONLY
+#  else
+#    define RB_DIR_RO_FLAGS1 O_RDONLY|O_DIRECTORY
+#  endif
+#  ifndef O_PATH
+#    define RB_DIR_RO_FLAGS RB_DIR_RO_FLAGS1
+#  else
+#    define RB_DIR_RO_FLAGS RB_DIR_RO_FLAGS1|O_PATH
+#  endif
+
+int32_t
+qb_rb_close_helper(struct qb_ringbuffer_s * rb, int32_t unlink_it,
+		   int32_t truncate_fallback)
+{
+	int32_t res = 0, res2 = 0;
+	uint32_t word_size = rb->shared_hdr->word_size;
+	char *hdr_path = rb->shared_hdr->hdr_path;
+
+	if (unlink_it) {
+		qb_util_log(LOG_DEBUG, "Free'ing ringbuffer: %s", hdr_path);
+		if (rb->notifier.destroy_fn) {
+			(void)rb->notifier.destroy_fn(rb->notifier.instance);
+		}
+	} else {
+		qb_util_log(LOG_DEBUG, "Closing ringbuffer: %s", hdr_path);
+		hdr_path = NULL;
+	}
+
+	if (unlink_it) {
+		char *data_path = rb->shared_hdr->data_path;
+		char *sep = strrchr(data_path, '/');
+		/* we could modify data_path in-situ, but that would segfault if
+		   we hadn't write permissions to the underlying mmap'd file */
+		char dir_path[PATH_MAX];
+		int dirfd;
+
+		if (sep != NULL) {
+			strncpy(dir_path, data_path, sep - data_path);
+			dir_path[sep - data_path] = '\0';
+			if ((dirfd = open(dir_path, RB_DIR_RO_FLAGS)) != -1) {
+				res = qb_sys_unlink_or_truncate_at(dirfd, sep + 1,
+								   truncate_fallback);
+
+				/* the dirname part is assumed to be the same */
+				assert(!strncmp(dir_path, hdr_path, sep - data_path));
+
+				sep = hdr_path + (sep - data_path);
+				/* now, don't touch neither data_path nor hdr_path */
+				res2 = qb_sys_unlink_or_truncate_at(dirfd, sep + 1,
+								    truncate_fallback);
+				close(dirfd);
+			} else {
+				res = -errno;
+				qb_util_perror(LOG_DEBUG,
+					       "Cannot open dir: %s", hdr_path);
+			}
+		} else {
+			res = -EINVAL;
+			qb_util_perror(LOG_DEBUG,
+				       "Not dir-separable path: %s", hdr_path);
+		}
+#else
+		res = qb_sys_unlink_or_truncate(data_path, truncate_fallback);
+		res2 = qb_sys_unlink_or_truncate(hdr_path, truncate_fallback);
+#endif  /* defined(HAVE_OPENAT) && defined(HAVE_UNLINKAT) */
+
+		res = res ? res : res2;
+		hdr_path = NULL;
+	}  /* if (unlink_it) */
+
+	if (munmap(rb->shared_data, (word_size * sizeof(uint32_t)) << 1) == -1) {
+		res = res ? res : -errno;
+		qb_util_perror(LOG_DEBUG, "Cannot munmap shared_data");
+	}
+	if (munmap(rb->shared_hdr, sizeof(struct qb_ringbuffer_shared_s)) == -1) {
+		res = res ? res : -errno;
+		qb_util_perror(LOG_DEBUG, "Cannot munmap shared_hdr");
+	}
+	free(rb);
+	return res;
+}
diff --git a/lib/ringbuffer_int.h b/lib/ringbuffer_int.h
index 1e8dbf5..9e5a844 100644
--- a/lib/ringbuffer_int.h
+++ b/lib/ringbuffer_int.h
@@ -82,6 +82,16 @@ struct qb_ringbuffer_s {
 
 void qb_rb_force_close(qb_ringbuffer_t * rb);
 
+/**
+ * Helper to munmap, and conditionally unlink the file or possibly truncate it.
+ * @param rb ringbuffer instance.
+ * @param unlink_it whether the underlying files should be unlinked.
+ * @param truncate_fallback whether to truncate the files when unlink fails.
+ * @return 0 (success) or -errno
+ */
+int32_t qb_rb_close_helper(struct qb_ringbuffer_s * rb, int32_t unlink_it,
+			   int32_t truncate_fallback);
+
 qb_ringbuffer_t *qb_rb_open_2(const char *name, size_t size, uint32_t flags,
 			      size_t shared_user_data_size,
 			      struct qb_rb_notifier *notifier);
