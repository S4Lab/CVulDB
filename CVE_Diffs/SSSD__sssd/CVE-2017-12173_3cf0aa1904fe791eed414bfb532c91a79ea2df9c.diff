SSSD__sssd
commit 3cf0aa1904fe791eed414bfb532c91a79ea2df9c
Author:     Sumit Bose <sbose@redhat.com>
AuthorDate: Thu Oct 5 11:07:38 2017 +0200
Commit:     Lukas Slebodnik <lslebodn@redhat.com>
CommitDate: Thu Feb 22 14:26:54 2018 +0100

    sysdb: sanitize search filter input
    
    This patch sanitizes the input for sysdb searches by UPN/email, SID and
    UUID.
    
    This security issue was assigned CVE-2017-12173
    
    Resolves:
    https://pagure.io/SSSD/sssd/issue/3549
    
    Reviewed-by: Lukáš Slebodník <lslebodn@redhat.com>
    Reviewed-by: Jakub Hrozek <jhrozek@redhat.com>
    (cherry picked from commit 1f2662c8f97c9c0fa250055d4b6750abfc6d0835)
    (cherry picked from commit e45e50e4523e36f310d7ff0b052500c024c434bf)

diff --git a/src/db/sysdb_ops.c b/src/db/sysdb_ops.c
index 3df02b163..7680cfe7e 100644
--- a/src/db/sysdb_ops.c
+++ b/src/db/sysdb_ops.c
@@ -494,6 +494,7 @@ int sysdb_search_user_by_upn_res(TALLOC_CTX *mem_ctx,
     int ret;
     const char *def_attrs[] = { SYSDB_NAME, SYSDB_UPN, SYSDB_CANONICAL_UPN,
                                 NULL };
+    char *sanitized;
 
     tmp_ctx = talloc_new(NULL);
     if (tmp_ctx == NULL) {
@@ -501,6 +502,12 @@ int sysdb_search_user_by_upn_res(TALLOC_CTX *mem_ctx,
         goto done;
     }
 
+    ret = sss_filter_sanitize(tmp_ctx, upn, &sanitized);
+    if (ret != EOK) {
+        DEBUG(SSSDBG_OP_FAILURE, "sss_filter_sanitize failed.\n");
+        goto done;
+    }
+
     base_dn = sysdb_base_dn(domain->sysdb, tmp_ctx);
     if (base_dn == NULL) {
         ret = ENOMEM;
@@ -509,7 +516,7 @@ int sysdb_search_user_by_upn_res(TALLOC_CTX *mem_ctx,
 
     ret = ldb_search(domain->sysdb->ldb, tmp_ctx, &res,
                      base_dn, LDB_SCOPE_SUBTREE, attrs ? attrs : def_attrs,
-                     SYSDB_PWUPN_FILTER, upn, upn);
+                     SYSDB_PWUPN_FILTER, sanitized, sanitized);
     if (ret != EOK) {
         ret = sysdb_error_to_errno(ret);
         goto done;
@@ -3730,16 +3737,30 @@ static errno_t sysdb_search_object_by_str_attr(TALLOC_CTX *mem_ctx,
                                                const char **attrs,
                                                struct ldb_result **_res)
 {
-    char *filter;
+    char *filter = NULL;
     errno_t ret;
+    char *sanitized = NULL;
+
+    if (str == NULL) {
+        return EINVAL;
+    }
+
+    ret = sss_filter_sanitize(NULL, str, &sanitized);
+    if (ret != EOK) {
+        DEBUG(SSSDBG_OP_FAILURE, "sss_filter_sanitize failed.\n");
+        goto done;
+    }
 
-    filter = talloc_asprintf(NULL, filter_tmpl, str);
+    filter = talloc_asprintf(NULL, filter_tmpl, sanitized);
     if (filter == NULL) {
-        return ENOMEM;
+        ret = ENOMEM;
+        goto done;
     }
 
     ret = sysdb_search_object_attr(mem_ctx, domain, filter, attrs, _res);
 
+done:
+    talloc_free(sanitized);
     talloc_free(filter);
     return ret;
 }
@@ -3828,7 +3849,8 @@ errno_t sysdb_search_object_by_cert(TALLOC_CTX *mem_ctx,
                                     struct ldb_result **res)
 {
     int ret;
-    char *user_filter;
+    char *user_filter = NULL;
+    char *filter = NULL;
 
     ret = sss_cert_derb64_to_ldap_filter(mem_ctx, cert, SYSDB_USER_CERT,
                                          &user_filter);
@@ -3837,10 +3859,15 @@ errno_t sysdb_search_object_by_cert(TALLOC_CTX *mem_ctx,
         return ret;
     }
 
-    ret = sysdb_search_object_by_str_attr(mem_ctx, domain,
-                                          SYSDB_USER_CERT_FILTER,
-                                          user_filter, attrs, res);
+    filter = talloc_asprintf(NULL, SYSDB_USER_CERT_FILTER, user_filter);
     talloc_free(user_filter);
+    if (filter == NULL) {
+        return ENOMEM;
+    }
+
+    ret = sysdb_search_object_attr(mem_ctx, domain, filter, attrs, res);
+
+    talloc_free(filter);
 
     return ret;
 }
diff --git a/src/tests/sysdb-tests.c b/src/tests/sysdb-tests.c
index 23c0ed518..8eab46747 100644
--- a/src/tests/sysdb-tests.c
+++ b/src/tests/sysdb-tests.c
@@ -6266,6 +6266,13 @@ START_TEST(test_upn_basic)
     fail_unless(strcmp(str, UPN_PRINC) == 0,
                 "Expected [%s], got [%s].", UPN_PRINC, str);
 
+    /* check if input is sanitized */
+    ret = sysdb_search_user_by_upn(test_ctx, test_ctx->domain,
+                                   "abc@def.ghi)(name="UPN_USER_NAME")(abc=xyz",
+                                   NULL, &msg);
+    fail_unless(ret == ENOENT,
+                "sysdb_search_user_by_upn failed with un-sanitized input.");
+
     talloc_free(test_ctx);
 }
 END_TEST
