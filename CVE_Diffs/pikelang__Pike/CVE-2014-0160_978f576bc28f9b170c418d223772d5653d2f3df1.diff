pikelang__Pike
commit 978f576bc28f9b170c418d223772d5653d2f3df1
Author:     Henrik Grubbström (Grubba) <grubba@grubba.org>
AuthorDate: Mon Apr 14 20:57:12 2014 +0200
Commit:     Henrik Grubbström (Grubba) <grubba@grubba.org>
CommitDate: Mon Apr 14 20:57:12 2014 +0200

    SSL: Probe peer for the Heartbleed vulnerability.
    
    The first packet sent after a successful handshake is now a
    packet to probe for the Heartbleed (CVE-2014-0160) vulnerability,
    and the connection is aborted with an insufficient_security
    failure if the peer is suffering.
    
    Also adds a debug flag (SSL3_SIMULATE_HEARTBLEED) to simulate
    this state.

diff --git a/lib/modules/SSL.pmod/connection.pike b/lib/modules/SSL.pmod/connection.pike
index 67df935a23..d401283653 100644
--- a/lib/modules/SSL.pmod/connection.pike
+++ b/lib/modules/SSL.pmod/connection.pike
@@ -288,17 +288,6 @@ int handle_change_cipher(int c)
   }
 }
 
-private Crypto.AES heartbeat_encode;
-private Crypto.AES heartbeat_decode;
-
-Packet heartbeat_packet(string s)
-{
-  Packet packet = Packet();
-  packet->content_type = PACKET_heartbeat;
-  packet->fragment = s;
-  return packet;
-}
-
 void send_heartbeat()
 {
   if (!handshake_finished ||
@@ -307,20 +296,6 @@ void send_heartbeat()
     return;
   }
 
-  if (!heartbeat_encode) {
-    // NB: We encrypt the payload with a random AES key
-    //     to reduce the amount of known plaintext in
-    //     the heartbeat masseages. This is needed now
-    //     that many cipher suites (such as GCM and CCM)
-    //     use xor with a cipher stream, to reduce risk
-    //     of revealing larger segments of the stream.
-    heartbeat_encode = Crypto.AES();
-    heartbeat_decode = Crypto.AES();
-    string heartbeat_key = random_string(16);
-    heartbeat_encode->set_encrypt_key(heartbeat_key);
-    heartbeat_decode->set_decrypt_key(heartbeat_key);
-  }
-
   ADT.struct hb_msg = ADT.struct();
   hb_msg->put_uint(HEARTBEAT_MESSAGE_request, 1);
   hb_msg->put_uint(16, 2);
@@ -341,13 +316,27 @@ void handle_heartbeat(string s)
   SSL3_DEBUG_MSG("SSL.connection: Heartbeat %s (%d bytes)",
 		 fmt_constant(hb_type, "HEARTBEAT_MESSAGE"), hb_len);
 
+  string(8bit) payload;
+  int pad_len = 16;
+
   // RFC 6520 4:
   // If the payload_length of a received HeartbeatMessage is too
   // large, the received HeartbeatMessage MUST be discarded silently.
-  if ((hb_len < 0) || ((hb_len + 16) > sizeof(hb_msg))) return;
-
-  string payload = hb_msg->get_fix_string(hb_len);
-  int pad_len = sizeof(hb_msg);
+  if ((hb_len < 0) || ((hb_len + 16) > sizeof(hb_msg))) {
+#ifdef SSL3_SIMULATE_HEARTBLEED
+    payload = hb_msg->get_rest();
+    if (sizeof(payload) < hb_len) {
+      payload = payload + random_string(hb_len - sizeof(payload));
+    } else {
+      payload = payload[..hb_len-1];
+    }
+#else
+    return;
+#endif
+  } else {
+    payload = hb_msg->get_fix_string(hb_len);
+    pad_len = sizeof(hb_msg);
+  }
 
   switch(hb_type) {
   case HEARTBEAT_MESSAGE_request:
@@ -372,7 +361,15 @@ void handle_heartbeat(string s)
       hb_msg = ADT.struct(heartbeat_decode->crypt(payload));
       int a = hb_msg->get_uint(8);
       int b = hb_msg->get_uint(8);
-      if (a != b) break;
+      if (a != b) {
+	if (!b) {
+	  // Heartbleed probe response.
+	  send_packet(Alert(ALERT_fatal, ALERT_insufficient_security,
+			    "Peer suffers from a bleeding heart.\n",
+			    backtrace()));
+	}
+	break;
+      }
       int delta = gethrtime() - a;
       SSL3_DEBUG_MSG("SSL.connection: Heartbeat roundtrip: %dus\n", delta);
     }
diff --git a/lib/modules/SSL.pmod/handshake.pike b/lib/modules/SSL.pmod/handshake.pike
index 35a7f719e6..4c743c377d 100644
--- a/lib/modules/SSL.pmod/handshake.pike
+++ b/lib/modules/SSL.pmod/handshake.pike
@@ -578,6 +578,53 @@ Packet certificate_packet(array(string(0..255)) certificates)
   return handshake_packet(HANDSHAKE_certificate, struct->pop_data());
 }
 
+Packet heartbeat_packet(string s)
+{
+  Packet packet = Packet();
+  packet->content_type = PACKET_heartbeat;
+  packet->fragment = s;
+  return packet;
+}
+
+protected Crypto.AES heartbeat_encode;
+protected Crypto.AES heartbeat_decode;
+
+Packet heartbleed_packet()
+{
+  if (!heartbeat_encode) {
+    // NB: We encrypt the payload with a random AES key
+    //     to reduce the amount of known plaintext in
+    //     the heartbeat masseages. This is needed now
+    //     that many cipher suites (such as GCM and CCM)
+    //     use xor with a cipher stream, to reduce risk
+    //     of revealing larger segments of the stream.
+    heartbeat_encode = Crypto.AES();
+    heartbeat_decode = Crypto.AES();
+    string(8bit) heartbeat_key = random_string(16);
+    heartbeat_encode->set_encrypt_key(heartbeat_key);
+    heartbeat_decode->set_decrypt_key(heartbeat_key);
+  }
+
+  // This packet probes for the Heartbleed vulnerability (CVE-2014-0160)
+  // by crafting a heartbeat packet with insufficient (0) padding.
+  //
+  // If we get a response, the peer doesn't validate the message sizes
+  // properly, and probably suffers from the Heartbleed vulnerability.
+  //
+  // Note that we don't use negative padding (as per the actual attack),
+  // to avoid actually stealing information from the peer.
+  //
+  // Note that we detect the packet on return by it having all zeros
+  // in the second field.
+  ADT.struct hb_msg = ADT.struct();
+  hb_msg->put_uint(HEARTBEAT_MESSAGE_request, 1);
+  hb_msg->put_uint(16, 2);
+  int now = gethrtime();
+  hb_msg->put_fix_string(heartbeat_encode->crypt(sprintf("%8c%8c", now, 0)));
+  // No padding.
+  return heartbeat_packet(hb_msg->pop_data());
+}
+
 string(0..255) server_derive_master_secret(string(0..255) data)
 {
   string(0..255)|int res =
@@ -1133,6 +1180,11 @@ int(-1..1) handle_handshake(int type, string(0..255) data, string(0..255) raw)
 	  else if(version >= PROTOCOL_TLS_1_0)
 	    send_packet(finished_packet("server finished"));
 
+	  if (session->heartbeat_mode == HEARTBEAT_MODE_peer_allowed_to_send) {
+	    // Probe for the Heartbleed vulnerability (CVE-2014-0160).
+	    send_packet(heartbleed_packet());
+	  }
+
 	  expect_change_cipher = 1;
 	 
 	  handshake_state = STATE_server_wait_for_finish;
@@ -1220,6 +1272,12 @@ int(-1..1) handle_handshake(int type, string(0..255) data, string(0..255) raw)
 	   send_packet(finished_packet("SRVR"));
 	 else if(version >= PROTOCOL_TLS_1_0)
 	   send_packet(finished_packet("server finished"));
+
+	 if (session->heartbeat_mode == HEARTBEAT_MODE_peer_allowed_to_send) {
+	   // Probe for the Heartbleed vulnerability (CVE-2014-0160).
+	   send_packet(heartbleed_packet());
+	 }
+
 	 expect_change_cipher = 1;
 	 context->record_session(session); /* Cache this session */
        }
@@ -1740,6 +1798,11 @@ int(-1..1) handle_handshake(int type, string(0..255) data, string(0..255) raw)
       else if(version >= PROTOCOL_TLS_1_0)
 	send_packet(finished_packet("client finished"));
 
+      if (session->heartbeat_mode == HEARTBEAT_MODE_peer_allowed_to_send) {
+	// Probe for the Heartbleed vulnerability (CVE-2014-0160).
+	send_packet(heartbleed_packet());
+      }
+
       handshake_state = STATE_client_wait_for_finish;
       expect_change_cipher = 1;
       break;
