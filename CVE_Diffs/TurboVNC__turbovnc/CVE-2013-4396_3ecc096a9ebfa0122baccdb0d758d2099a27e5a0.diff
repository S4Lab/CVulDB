TurboVNC__turbovnc
commit 3ecc096a9ebfa0122baccdb0d758d2099a27e5a0
Author:     DRC <dcommander@users.sourceforge.net>
AuthorDate: Fri Dec 12 14:03:40 2014 +0000
Commit:     DRC <dcommander@users.sourceforge.net>
CommitDate: Fri Dec 12 14:03:40 2014 +0000

    From 7bddc2ba16a2a15773c2ea8947059afa27727764 Mon Sep 17 00:00:00 2001
    From: Alan Coopersmith <alan.coopersmith at oracle.com>
    Date: Mon, 16 Sep 2013 21:47:16 -0700
    Subject: [PATCH] Avoid use-after-free in dix/dixfonts.c: doImageText()
     [CVE-2013-4396]
    
    Save a pointer to the passed in closure structure before copying it
    and overwriting the *c pointer to point to our copy instead of the
    original.  If we hit an error, once we free(c), reset c to point to
    the original structure before jumping to the cleanup code that
    references *c.
    
    Since one of the errors being checked for is whether the server was
    able to malloc(c->nChars * itemSize), the client can potentially pass
    a number of characters chosen to cause the malloc to fail and the
    error path to be taken, resulting in the read from freed memory.
    
    Since the memory is accessed almost immediately afterwards, and the
    X server is mostly single threaded, the odds of the free memory having
    invalid contents are low with most malloc implementations when not using
    memory debugging features, but some allocators will definitely overwrite
    the memory there, leading to a likely crash.
    
    Reported-by: Pedro Ribeiro <pedrib at gmail.com>
    Signed-off-by: Alan Coopersmith <alan.coopersmith at oracle.com>
    Reviewed-by: Julien Cristau <jcristau at debian.org>
    
    
    git-svn-id: svn+ssh://svn.code.sf.net/p/turbovnc/code/trunk@2923 799e4f7b-5fd2-41f6-823c-2ecc41bc7f0b

diff --git a/unix/Xvnc/programs/Xserver/dix/dixfonts.c b/unix/Xvnc/programs/Xserver/dix/dixfonts.c
index 19fd31e3..7a04ebf3 100644
--- a/unix/Xvnc/programs/Xserver/dix/dixfonts.c
+++ b/unix/Xvnc/programs/Xserver/dix/dixfonts.c
@@ -1414,6 +1414,7 @@ doImageText(ClientPtr client, ITclosurePtr c)
             GC *pGC;
             unsigned char *data;
             ITclosurePtr new_closure;
+            ITclosurePtr old_closure;
 
             /* We're putting the client to sleep.  We need to
                save some state.  Similar problem to that handled
@@ -1425,12 +1426,14 @@ doImageText(ClientPtr client, ITclosurePtr c)
                 err = BadAlloc;
                 goto bail;
             }
+            old_closure = c;
             *new_closure = *c;
             c = new_closure;
 
             data = malloc(c->nChars * itemSize);
             if (!data) {
                 free(c);
+                c = old_closure;
                 err = BadAlloc;
                 goto bail;
             }
@@ -1441,6 +1444,7 @@ doImageText(ClientPtr client, ITclosurePtr c)
             if (!pGC) {
                 free(c->data);
                 free(c);
+                c = old_closure;
                 err = BadAlloc;
                 goto bail;
             }
@@ -1453,6 +1457,7 @@ doImageText(ClientPtr client, ITclosurePtr c)
                 FreeScratchGC(pGC);
                 free(c->data);
                 free(c);
+                c = old_closure;
                 err = BadAlloc;
                 goto bail;
             }
