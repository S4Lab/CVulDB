TurboVNC__turbovnc
commit 3f5da68f1e14461eb3f1ea4f969c153682e44474
Author:     DRC <dcommander@users.sourceforge.net>
AuthorDate: Fri Dec 12 14:37:59 2014 +0000
Commit:     DRC <dcommander@users.sourceforge.net>
CommitDate: Fri Dec 12 14:37:59 2014 +0000

    From 05c8020a49416dd8b7510cbba45ce4f3fc81a7dc Mon Sep 17 00:00:00 2001
    From: Alan Coopersmith <alan.coopersmith@oracle.com>
    Date: Fri, 25 Apr 2014 23:01:48 -0700
    Subject: [PATCH] CVE-2014-0209: integer overflow of realloc() size in
     lexAlias()
    
    lexAlias() reads from a file in a loop. It does this by starting with a
    64 byte buffer.  If that size limit is hit, it does a realloc of the
    buffer size << 1, basically doubling the needed length every time the
    length limit is hit.
    
    Eventually, this will shift out to 0 (for a length of ~4gig), and that
    length will be passed on to realloc().  A length of 0 (with a valid
    pointer) causes realloc to free the buffer on most POSIX platforms,
    but the caller will still have a pointer to it, leading to use after
    free issues.
    
    Reported-by: Ilja Van Sprundel <ivansprundel@ioactive.com>
    Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
    Reviewed-by: Adam Jackson <ajax@redhat.com>
    Reviewed-by: Matthieu Herrb <matthieu@herrb.eu>
    
    
    git-svn-id: svn+ssh://svn.code.sf.net/p/turbovnc/code/trunk@2926 799e4f7b-5fd2-41f6-823c-2ecc41bc7f0b

diff --git a/unix/Xvnc/lib/libXfont/fontfile/dirfile.c b/unix/Xvnc/lib/libXfont/fontfile/dirfile.c
index 0d34db90..639310c3 100644
--- a/unix/Xvnc/lib/libXfont/fontfile/dirfile.c
+++ b/unix/Xvnc/lib/libXfont/fontfile/dirfile.c
@@ -42,6 +42,7 @@ in this Software without prior written authorization from The Open Group.
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <errno.h>
+#include <limits.h>
 
 static Bool AddFileNameAliases ( FontDirectoryPtr dir );
 static int ReadFontAlias ( char *directory, Bool isFile,
@@ -374,6 +375,9 @@ lexAlias(FILE *file, char **lexToken)
 	    int         nsize;
 	    char       *nbuf;
 
+	    if (tokenSize >= (INT_MAX >> 2))
+		/* Stop before we overflow */
+		return EALLOC;
 	    nsize = tokenSize ? (tokenSize << 1) : 64;
 	    nbuf = realloc(tokenBuf, nsize);
 	    if (!nbuf)
