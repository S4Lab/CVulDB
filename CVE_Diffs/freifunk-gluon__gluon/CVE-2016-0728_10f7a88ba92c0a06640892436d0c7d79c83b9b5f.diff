freifunk-gluon__gluon
commit 10f7a88ba92c0a06640892436d0c7d79c83b9b5f
Author:     Matthias Schiffer <mschiffer@universe-factory.net>
AuthorDate: Sat Feb 6 07:39:51 2016 +0100
Commit:     Matthias Schiffer <mschiffer@universe-factory.net>
CommitDate: Sat Feb 6 07:39:51 2016 +0100

    Backport fix for CVE-2016-0728 (local root exploit)
    
    We're too close to the release of Gluon 2016.1 to do a full update of our
    OpenWrt tree, therefore just make a backport of this.

diff --git a/patches/openwrt/0048-kernel-fix-keyring-reference-leak-CVE-2016-0728.patch b/patches/openwrt/0048-kernel-fix-keyring-reference-leak-CVE-2016-0728.patch
new file mode 100644
index 00000000..406be868
--- /dev/null
+++ b/patches/openwrt/0048-kernel-fix-keyring-reference-leak-CVE-2016-0728.patch
@@ -0,0 +1,87 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sat, 6 Feb 2016 07:35:33 +0100
+Subject: kernel: fix keyring reference leak (CVE-2016-0728)
+
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+
+diff --git a/target/linux/generic/patches-3.18/010-KEYS-Fix-keyring-ref-leak-in-join_session_keyring.patch b/target/linux/generic/patches-3.18/010-KEYS-Fix-keyring-ref-leak-in-join_session_keyring.patch
+new file mode 100644
+index 0000000..9c6a969
+--- /dev/null
++++ b/target/linux/generic/patches-3.18/010-KEYS-Fix-keyring-ref-leak-in-join_session_keyring.patch
+@@ -0,0 +1,75 @@
++From 7ca88764d45c209791e8813131c1457c2e9e51e7 Mon Sep 17 00:00:00 2001
++From: Yevgeny Pats <yevgeny@perception-point.io>
++Date: Mon, 11 Jan 2016 12:05:28 +0000
++Subject: KEYS: Fix keyring ref leak in join_session_keyring()
++
++If a thread is asked to join as a session keyring the keyring that's already
++set as its session, we leak a keyring reference.
++
++This can be tested with the following program:
++
++	#include <stddef.h>
++	#include <stdio.h>
++	#include <sys/types.h>
++	#include <keyutils.h>
++
++	int main(int argc, const char *argv[])
++	{
++		int i = 0;
++		key_serial_t serial;
++
++		serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING,
++				"leaked-keyring");
++		if (serial < 0) {
++			perror("keyctl");
++			return -1;
++		}
++
++		if (keyctl(KEYCTL_SETPERM, serial,
++			   KEY_POS_ALL | KEY_USR_ALL) < 0) {
++			perror("keyctl");
++			return -1;
++		}
++
++		for (i = 0; i < 100; i++) {
++			serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING,
++					"leaked-keyring");
++			if (serial < 0) {
++				perror("keyctl");
++				return -1;
++			}
++		}
++
++		return 0;
++	}
++
++If, after the program has run, there something like the following line in
++/proc/keys:
++
++3f3d898f I--Q---   100 perm 3f3f0000     0     0 keyring   leaked-keyring: empty
++
++with a usage count of 100 * the number of times the program has been run,
++then the kernel is malfunctioning.  If leaked-keyring has zero usages or
++has been garbage collected, then the problem is fixed.
++
++Reported-by: Yevgeny Pats <yevgeny@perception-point.io>
++Signed-off-by: David Howells <dhowells@redhat.com>
++---
++ security/keys/process_keys.c | 1 +
++ 1 file changed, 1 insertion(+)
++
++diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
++index a3f85d2..e6d50172 100644
++--- a/security/keys/process_keys.c
+++++ b/security/keys/process_keys.c
++@@ -794,6 +794,7 @@ long join_session_keyring(const char *name)
++ 		ret = PTR_ERR(keyring);
++ 		goto error2;
++ 	} else if (keyring == new->session_keyring) {
+++		key_put(keyring);
++ 		ret = 0;
++ 		goto error2;
++ 	}
++-- 
++2.7.0.rc3
++
