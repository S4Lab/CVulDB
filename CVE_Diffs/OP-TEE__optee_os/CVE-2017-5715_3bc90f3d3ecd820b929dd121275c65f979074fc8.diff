OP-TEE__optee_os
commit 3bc90f3d3ecd820b929dd121275c65f979074fc8
Author:     Jens Wiklander <jens.wiklander@linaro.org>
AuthorDate: Wed Dec 13 12:30:46 2017 +0100
Commit:     Jérôme Forissier <jerome.forissier@linaro.org>
CommitDate: Mon Jan 8 13:02:28 2018 +0100

    core: arm32: sm: invalidate branch predictor
    
    If build with secure monitor and CFG_CORE_WORKAROUND_SPECTRE_BP=y
    invalidate branch predictor on non-secure entry.
    
    Fixes CVE-2017-5715
    
    Reviewed-by: Jerome Forissier <jerome.forissier@linaro.org>
    Reviewed-by: Joakim Bech <joakim.bech@linaro.org>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/core/arch/arm/arm.mk b/core/arch/arm/arm.mk
index 8b7efe09..fc9a0e91 100644
--- a/core/arch/arm/arm.mk
+++ b/core/arch/arm/arm.mk
@@ -31,6 +31,12 @@ platform-hard-float-enabled := y
 endif
 endif
 
+# Adds protection against CVE-2017-5715 also know as Spectre
+# (https://spectreattack.com)
+# See also https://developer.arm.com/-/media/Files/pdf/Cache_Speculation_Side-channels.pdf
+# Variant 2
+CFG_CORE_WORKAROUND_SPECTRE_BP ?= y
+
 CFG_CORE_RWDATA_NOEXEC ?= y
 CFG_CORE_RODATA_NOEXEC ?= n
 ifeq ($(CFG_CORE_RODATA_NOEXEC),y)
diff --git a/core/arch/arm/sm/sm_a32.S b/core/arch/arm/sm/sm_a32.S
index dc88650f..a49a80fa 100644
--- a/core/arch/arm/sm/sm_a32.S
+++ b/core/arch/arm/sm/sm_a32.S
@@ -35,6 +35,7 @@
 #include <sm/optee_smc.h>
 #include <sm/teesmc_opteed.h>
 #include <sm/teesmc_opteed_macros.h>
+#include <util.h>
 
 	.section .text.sm_asm
 
@@ -249,6 +250,47 @@ END_FUNC sm_fiq_entry
 LOCAL_FUNC sm_vect_table , :
 UNWIND(	.fnstart)
 UNWIND(	.cantunwind)
+#ifdef CFG_CORE_WORKAROUND_SPECTRE_BP
+	/*
+	 * This depends on SP being 8 byte aligned, that is, the lowest
+	 * three bits in SP are zero.
+	 *
+	 * The idea is to form a specific bit pattern in the lowest three
+	 * bits of SP depending on which entry in the vector we enter via.
+	 * This is done by adding 1 to SP in each entry but the last.
+	 */
+	add	sp, sp, #1	/* 7:111 Reset			*/
+	add	sp, sp, #1	/* 6:110 Undefined instruction	*/
+	add	sp, sp, #1	/* 5:101 Secure monitor call	*/
+	add	sp, sp, #1	/* 4:100 Prefetch abort		*/
+	add	sp, sp, #1	/* 3:011 Data abort		*/
+	add	sp, sp, #1	/* 2:010 Reserved		*/
+	add	sp, sp, #1	/* 1:001 IRQ			*/
+	nop			/* 0:000 FIQ			*/
+
+	/* Invalidate the branch predictor for the current processor. */
+	write_bpiall
+	isb
+
+	/*
+	 * Only two exception does normally occur, smc and fiq. With all
+	 * other exceptions it's good enough to just spinn, the lowest bits
+	 * still tells which exception we're stuck with when attaching a
+	 * debugger.
+	 */
+
+	/* Test for FIQ, all the lowest bits of SP are supposed to be 0 */
+	tst	sp, #(BIT(0) | BIT(1) | BIT(2))
+	beq	sm_fiq_entry
+
+	/* Test for SMC, xor the lowest bits of SP to be 0 */
+	eor	sp, sp, #(BIT(0) | BIT(2))
+	tst	sp, #(BIT(0) | BIT(1) | BIT(2))
+	beq	sm_smc_entry
+
+	/* unhandled exception */
+	b	.
+#else /*!CFG_CORE_WORKAROUND_SPECTRE_BP*/
 	b	.		/* Reset			*/
 	b	.		/* Undefined instruction	*/
 	b	sm_smc_entry	/* Secure monitor call		*/
@@ -257,6 +299,7 @@ UNWIND(	.cantunwind)
 	b	.		/* Reserved			*/
 	b	.		/* IRQ				*/
 	b	sm_fiq_entry	/* FIQ				*/
+#endif /*!CFG_CORE_WORKAROUND_SPECTRE_BP*/
 UNWIND(	.fnend)
 END_FUNC sm_vect_table
 
