multipath-tcp__mptcp
commit ffdfda924245cbd3fef745f918178940a07037e0
Author:     Dave Hansen <dave@linux.vnet.ibm.com>
AuthorDate: Fri May 18 11:46:30 2012 -0700
Commit:     Luis Henriques <luis.henriques@canonical.com>
CommitDate: Mon Jul 2 10:45:49 2012 +0100

    hugetlb: fix resv_map leak in error path
    
    BugLink: http://bugs.launchpad.net/bugs/1013723
    
    commit c50ac050811d6485616a193eb0f37bfbd191cc89 upstream.
    
    When called for anonymous (non-shared) mappings, hugetlb_reserve_pages()
    does a resv_map_alloc().  It depends on code in hugetlbfs's
    vm_ops->close() to release that allocation.
    
    However, in the mmap() failure path, we do a plain unmap_region() without
    the remove_vma() which actually calls vm_ops->close().
    
    This is a decent fix.  This leak could get reintroduced if new code (say,
    after hugetlb_reserve_pages() in hugetlbfs_file_mmap()) decides to return
    an error.  But, I think it would have to unroll the reservation anyway.
    
    Christoph's test case:
    
            http://marc.info/?l=linux-mm&m=133728900729735
    
    Signed-off-by: Dave Hansen <dave@linux.vnet.ibm.com>
    [Christoph Lameter: I have rediffed the patch against 2.6.32 and 3.2.0.]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    [Herton Krzesinski: due to CVE-2012-2133 fix applied, we don't need the
     rediffed version, switched to the original diff applied on Linus tree ]
    Signed-off-by: Herton Ronaldo Krzesinski <herton.krzesinski@canonical.com>

diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index a5582e8c3ac6..ebcc5e496db2 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -2146,6 +2146,15 @@ static void hugetlb_vm_op_open(struct vm_area_struct *vma)
 		kref_get(&reservations->refs);
 }
 
+static void resv_map_put(struct vm_area_struct *vma)
+{
+	struct resv_map *reservations = vma_resv_map(vma);
+
+	if (!reservations)
+		return;
+	kref_put(&reservations->refs, resv_map_release);
+}
+
 static void hugetlb_vm_op_close(struct vm_area_struct *vma)
 {
 	struct hstate *h = hstate_vma(vma);
@@ -2162,7 +2171,7 @@ static void hugetlb_vm_op_close(struct vm_area_struct *vma)
 		reserve = (end - start) -
 			region_count(&reservations->regions, start, end);
 
-		kref_put(&reservations->refs, resv_map_release);
+		resv_map_put(vma);
 
 		if (reserve) {
 			hugetlb_acct_memory(h, -reserve);
@@ -2964,12 +2973,16 @@ int hugetlb_reserve_pages(struct inode *inode,
 		set_vma_resv_flags(vma, HPAGE_RESV_OWNER);
 	}
 
-	if (chg < 0)
-		return chg;
+	if (chg < 0) {
+		ret = chg;
+		goto out_err;
+	}
 
 	/* There must be enough pages in the subpool for the mapping */
-	if (hugepage_subpool_get_pages(spool, chg))
-		return -ENOSPC;
+	if (hugepage_subpool_get_pages(spool, chg)) {
+		ret = -ENOSPC;
+		goto out_err;
+	}
 
 	/*
 	 * Check enough hugepages are available for the reservation.
@@ -2978,7 +2991,7 @@ int hugetlb_reserve_pages(struct inode *inode,
 	ret = hugetlb_acct_memory(h, chg);
 	if (ret < 0) {
 		hugepage_subpool_put_pages(spool, chg);
-		return ret;
+		goto out_err;
 	}
 
 	/*
@@ -2995,6 +3008,9 @@ int hugetlb_reserve_pages(struct inode *inode,
 	if (!vma || vma->vm_flags & VM_MAYSHARE)
 		region_add(&inode->i_mapping->private_list, from, to);
 	return 0;
+out_err:
+	resv_map_put(vma);
+	return ret;
 }
 
 void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)
