liblouis__liblouis
commit af5791ea792acc0a9707738001aa1df3daff7a66
Author:     Mike Gorse <mgorse@suse.com>
AuthorDate: Wed Aug 30 15:13:09 2017 -0500
Commit:     Mike Gorse <mgorse@linux-e5s4.suse>
CommitDate: Wed Aug 30 16:37:26 2017 -0500

    Fix possible use after free when calling compileBrailleIndicator
    
    CompileBrailleIndicator calls addRule, which may realloc the table header,
    so it is unsafe to pass an out parameter under the assumption that the
    value of table will not change.
    
    Fixes CVE-2017-13741.

diff --git a/liblouis/compileTranslationTable.c b/liblouis/compileTranslationTable.c
index 5ec8812b..c83cc9c9 100644
--- a/liblouis/compileTranslationTable.c
+++ b/liblouis/compileTranslationTable.c
@@ -3812,6 +3812,7 @@ compileRule (FileInfo * nested,
   int k, i;
   int noback, nofor;
   noback = nofor = 0;
+  TranslationTableOffset tmp_offset;
 doOpcode:
   if (!getToken (nested, &token, NULL, &lastToken))
     return 1;			/*blank line */
@@ -3844,8 +3845,10 @@ doOpcode:
       break;
     case CTO_Undefined:
       ok =
+	tmp_offset = table->undefined;
 	compileBrailleIndicator (nested, "undefined character opcode",
-				 CTO_Undefined, &table->undefined, &lastToken, newRuleOffset, newRule, noback, nofor);
+				 CTO_Undefined, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+	table->undefined = tmp_offset;
       break;
 
     case CTO_Match:
@@ -3967,9 +3970,11 @@ doOpcode:
       }
 
     case CTO_BegCapsPhrase:
+	tmp_offset = table->emphRules[capsRule][begPhraseOffset];
       ok =
 	compileBrailleIndicator (nested, "first word capital sign",
-				 CTO_BegCapsPhraseRule, &table->emphRules[capsRule][begPhraseOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				 CTO_BegCapsPhraseRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+	table->emphRules[capsRule][begPhraseOffset] = tmp_offset;
       break;
     case CTO_EndCapsPhrase:
 		switch (compileBeforeAfter(nested, &lastToken)) {
@@ -3979,10 +3984,12 @@ doOpcode:
 					ok = 0;
 					break;
 				}
+	tmp_offset = table->emphRules[capsRule][endPhraseBeforeOffset];
 				ok =
 					compileBrailleIndicator (nested, "capital sign before last word",
-						CTO_EndCapsPhraseBeforeRule, &table->emphRules[capsRule][endPhraseBeforeOffset],
+						CTO_EndCapsPhraseBeforeRule, &tmp_offset,
 						&lastToken, newRuleOffset, newRule, noback, nofor);
+	table->emphRules[capsRule][endPhraseBeforeOffset] = tmp_offset;
 				break;
 			case 2: // after
 				if (table->emphRules[capsRule][endPhraseBeforeOffset]) {
@@ -3990,10 +3997,12 @@ doOpcode:
 					ok = 0;
 					break;
 				}
+	tmp_offset = table->emphRules[capsRule][endPhraseAfterOffset];
 				ok =
 					compileBrailleIndicator (nested, "capital sign after last word",
-						CTO_EndCapsPhraseAfterRule, &table->emphRules[capsRule][endPhraseAfterOffset],
+						CTO_EndCapsPhraseAfterRule, &tmp_offset,
 						&lastToken, newRuleOffset, newRule, noback, nofor);
+	table->emphRules[capsRule][endPhraseAfterOffset] = tmp_offset;
 				break;
 			default: // error
 				compileError (nested, "Invalid lastword indicator location.");
@@ -4002,28 +4011,38 @@ doOpcode:
 		}
       break;
 	  case CTO_BegCaps:
+	tmp_offset = table->emphRules[capsRule][begOffset];
       ok =
 	compileBrailleIndicator (nested, "first letter capital sign",
-				 CTO_BegCapsRule, &table->emphRules[capsRule][begOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				 CTO_BegCapsRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+	table->emphRules[capsRule][begOffset] = tmp_offset;
 		break;
 	  case CTO_EndCaps:
+	tmp_offset = table->emphRules[capsRule][endOffset];
       ok =
 	compileBrailleIndicator (nested, "last letter capital sign",
-				 CTO_EndCapsRule, &table->emphRules[capsRule][endOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				 CTO_EndCapsRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+	table->emphRules[capsRule][endOffset] = tmp_offset;
       break;
 	  case CTO_CapsLetter:
+	tmp_offset = table->emphRules[capsRule][letterOffset];
       ok =
 	compileBrailleIndicator (nested, "single letter capital sign",
-				 CTO_CapsLetterRule, &table->emphRules[capsRule][letterOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				 CTO_CapsLetterRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+	table->emphRules[capsRule][letterOffset] = tmp_offset;
       break;
     case CTO_BegCapsWord:
+	tmp_offset = table->emphRules[capsRule][begWordOffset];
       ok =
 	compileBrailleIndicator (nested, "capital word", CTO_BegCapsWordRule,
-				 &table->emphRules[capsRule][begWordOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				 &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+	table->emphRules[capsRule][begWordOffset] = tmp_offset;
       break;
 	case CTO_EndCapsWord:
+	tmp_offset = table->emphRules[capsRule][endWordOffset];
 		ok = compileBrailleIndicator(nested, "capital word stop",
-				 CTO_EndCapsWordRule, &table->emphRules[capsRule][endWordOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				 CTO_EndCapsWordRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+	table->emphRules[capsRule][endWordOffset] = tmp_offset;
       break;
     case CTO_LenCapsPhrase:
       ok = table->emphRules[capsRule][lenPhraseOffset] = compileNumber (nested, &lastToken);
@@ -4148,19 +4167,25 @@ doOpcode:
 	      }
 		i++; // in table->emphRules the first index is used for caps
 		if (opcode == CTO_EmphLetter) {
+			tmp_offset = table->emphRules[i][letterOffset];
 			ok = compileBrailleIndicator (nested, "single letter",
 				CTO_Emph1LetterRule + letterOffset + (8 * i),
-				&table->emphRules[i][letterOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				&tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+			table->emphRules[i][letterOffset] = tmp_offset;
 		}
 		else if (opcode == CTO_BegEmphWord) {
+			tmp_offset = table->emphRules[i][begWordOffset];
 			ok = compileBrailleIndicator (nested, "word",
 				CTO_Emph1LetterRule + begWordOffset + (8 * i),
-				&table->emphRules[i][begWordOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				&tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+			table->emphRules[i][begWordOffset] = tmp_offset;
 		}
 		else if (opcode == CTO_EndEmphWord) {
+			tmp_offset = table->emphRules[i][endWordOffset];
 			ok = compileBrailleIndicator(nested, "word stop",
 				CTO_Emph1LetterRule + endWordOffset + (8 * i),
-				&table->emphRules[i][endWordOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				&tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+			table->emphRules[i][endWordOffset] = tmp_offset;
 		}
 		else if (opcode == CTO_BegEmph) {
 		  /* fail if both begemph and any of begemphphrase or begemphword are defined */
@@ -4169,9 +4194,11 @@ doOpcode:
 		    ok = 0;
 		    break;
 		  }
+			tmp_offset = table->emphRules[i][begOffset];
 			ok = compileBrailleIndicator (nested, "first letter",
 				CTO_Emph1LetterRule + begOffset + (8 * i),
-				&table->emphRules[i][begOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				&tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+			table->emphRules[i][begOffset] = tmp_offset;
 		}
 		else if (opcode == CTO_EndEmph) {
 		  if (table->emphRules[i][endWordOffset] || table->emphRules[i][endPhraseBeforeOffset] || table->emphRules[i][endPhraseAfterOffset]) {
@@ -4179,14 +4206,18 @@ doOpcode:
 		    ok = 0;
 		    break;
 		  }
+			tmp_offset = table->emphRules[i][endOffset];
 			ok = compileBrailleIndicator (nested, "last letter",
 				CTO_Emph1LetterRule + endOffset + (8 * i),
-				&table->emphRules[i][endOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				&tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+			table->emphRules[i][endOffset] = tmp_offset;
 		}
 		else if (opcode == CTO_BegEmphPhrase) {
+			tmp_offset = table->emphRules[i][begPhraseOffset];
 			ok = compileBrailleIndicator (nested, "first word",
 				CTO_Emph1LetterRule + begPhraseOffset + (8 * i),
-				&table->emphRules[i][begPhraseOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+				&tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+			table->emphRules[i][begPhraseOffset] = tmp_offset;
 		}
 		else if (opcode == CTO_EndEmphPhrase)
 			switch (compileBeforeAfter(nested, &lastToken)) {
@@ -4196,9 +4227,11 @@ doOpcode:
 						ok = 0;
 						break;
 					}
+					tmp_offset = table->emphRules[i][endPhraseBeforeOffset];
 					ok = compileBrailleIndicator (nested, "last word before",
 						CTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),
-						&table->emphRules[i][endPhraseBeforeOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+						&tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+					table->emphRules[i][endPhraseBeforeOffset] = tmp_offset;
 					break;
 				case 2: // after
 					if (table->emphRules[i][endPhraseBeforeOffset]) {
@@ -4206,9 +4239,11 @@ doOpcode:
 						ok = 0;
 						break;
 					}
+					tmp_offset = table->emphRules[i][endPhraseAfterOffset];
 					ok = compileBrailleIndicator (nested, "last word after",
 						CTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),
-						&table->emphRules[i][endPhraseAfterOffset], &lastToken, newRuleOffset, newRule, noback, nofor);
+						&tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+					table->emphRules[i][endPhraseAfterOffset] = tmp_offset;
 					break;
 				default: // error
 					compileError (nested, "Invalid lastword indicator location.");
@@ -4222,9 +4257,11 @@ doOpcode:
 	break;
 
     case CTO_LetterSign:
+      tmp_offset = table->letterSign;
       ok =
 	compileBrailleIndicator (nested, "letter sign", CTO_LetterRule,
-				 &table->letterSign, &lastToken, newRuleOffset, newRule, noback, nofor);
+				 &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+       table->letterSign = tmp_offset;
       break;
     case CTO_NoLetsignBefore:
       if (getRuleCharsText (nested, &ruleChars, &lastToken))
@@ -4268,9 +4305,11 @@ doOpcode:
 	}
       break;
     case CTO_NumberSign:
+      tmp_offset = table->numberSign;
       ok =
 	compileBrailleIndicator (nested, "number sign", CTO_NumberRule,
-				 &table->numberSign, &lastToken, newRuleOffset, newRule, noback, nofor);
+				 &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+      table->numberSign = tmp_offset;
       break;
 
 	case CTO_Attribute:
@@ -4366,8 +4405,10 @@ doOpcode:
 		
 	case CTO_NoContractSign:
 	
+      tmp_offset = table->noContractSign;
 		ok = compileBrailleIndicator
-			(nested, "no contractions sign", CTO_NoContractRule, &table->noContractSign, &lastToken, newRuleOffset, newRule, noback, nofor);
+			(nested, "no contractions sign", CTO_NoContractRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+      table->noContractSign = tmp_offset;
 		break;
 	  
 	case CTO_SeqDelimiter:
@@ -4482,14 +4523,18 @@ doOpcode:
 		break;
 	
     case CTO_BegComp:
+      tmp_offset = table->begComp;
       ok =
 	compileBrailleIndicator (nested, "begin computer braille",
-				 CTO_BegCompRule, &table->begComp, &lastToken, newRuleOffset, newRule, noback, nofor);
+				 CTO_BegCompRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+      table->begComp = tmp_offset;
       break;
     case CTO_EndComp:
+      tmp_offset = table->endComp;
       ok =
 	compileBrailleIndicator (nested, "end computer braslle",
-				 CTO_EndCompRule, &table->endComp, &lastToken, newRuleOffset, newRule, noback, nofor);
+				 CTO_EndCompRule, &tmp_offset, &lastToken, newRuleOffset, newRule, noback, nofor);
+      table->endComp = tmp_offset;
       break;
     case CTO_Syllable:
       table->syllables = 1;
