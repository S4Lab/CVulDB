UPBGE__blender
commit e04d7c49dca9dc7bbf1cbe446b612aaa5ba12581
Author:     Brecht Van Lommel <brechtvanlommel@gmail.com>
AuthorDate: Sun Jan 14 22:14:20 2018 +0100
Commit:     Brecht Van Lommel <brechtvanlommel@gmail.com>
CommitDate: Thu Jan 18 00:54:07 2018 +0100

    Fix buffer overflow vulnerabilities in mesh code.
    
    Solves these security issues from T52924:
    CVE-2017-12081
    CVE-2017-12082
    CVE-2017-12086
    CVE-2017-12099
    CVE-2017-12100
    CVE-2017-12101
    CVE-2017-12105
    
    While the specific overflow issue may be fixed, loading the repro .blend
    files may still crash because they are incomplete and corrupt. The way
    they crash may be impossible to exploit, but this is difficult to prove.
    
    Differential Revision: https://developer.blender.org/D3002

diff --git a/source/blender/blenkernel/intern/DerivedMesh.c b/source/blender/blenkernel/intern/DerivedMesh.c
index 7ccd00b3f6..48edf55d76 100644
--- a/source/blender/blenkernel/intern/DerivedMesh.c
+++ b/source/blender/blenkernel/intern/DerivedMesh.c
@@ -184,7 +184,7 @@ static MPoly *dm_getPolyArray(DerivedMesh *dm)
 
 static MVert *dm_dupVertArray(DerivedMesh *dm)
 {
-	MVert *tmp = MEM_mallocN(sizeof(*tmp) * dm->getNumVerts(dm),
+	MVert *tmp = MEM_malloc_arrayN(dm->getNumVerts(dm), sizeof(*tmp),
 	                         "dm_dupVertArray tmp");
 
 	if (tmp) dm->copyVertArray(dm, tmp);
@@ -194,7 +194,7 @@ static MVert *dm_dupVertArray(DerivedMesh *dm)
 
 static MEdge *dm_dupEdgeArray(DerivedMesh *dm)
 {
-	MEdge *tmp = MEM_mallocN(sizeof(*tmp) * dm->getNumEdges(dm),
+	MEdge *tmp = MEM_malloc_arrayN(dm->getNumEdges(dm), sizeof(*tmp),
 	                         "dm_dupEdgeArray tmp");
 
 	if (tmp) dm->copyEdgeArray(dm, tmp);
@@ -204,7 +204,7 @@ static MEdge *dm_dupEdgeArray(DerivedMesh *dm)
 
 static MFace *dm_dupFaceArray(DerivedMesh *dm)
 {
-	MFace *tmp = MEM_mallocN(sizeof(*tmp) * dm->getNumTessFaces(dm),
+	MFace *tmp = MEM_malloc_arrayN(dm->getNumTessFaces(dm), sizeof(*tmp),
 	                         "dm_dupFaceArray tmp");
 
 	if (tmp) dm->copyTessFaceArray(dm, tmp);
@@ -214,7 +214,7 @@ static MFace *dm_dupFaceArray(DerivedMesh *dm)
 
 static MLoop *dm_dupLoopArray(DerivedMesh *dm)
 {
-	MLoop *tmp = MEM_mallocN(sizeof(*tmp) * dm->getNumLoops(dm),
+	MLoop *tmp = MEM_malloc_arrayN(dm->getNumLoops(dm), sizeof(*tmp),
 	                         "dm_dupLoopArray tmp");
 
 	if (tmp) dm->copyLoopArray(dm, tmp);
@@ -224,7 +224,7 @@ static MLoop *dm_dupLoopArray(DerivedMesh *dm)
 
 static MPoly *dm_dupPolyArray(DerivedMesh *dm)
 {
-	MPoly *tmp = MEM_mallocN(sizeof(*tmp) * dm->getNumPolys(dm),
+	MPoly *tmp = MEM_malloc_arrayN(dm->getNumPolys(dm), sizeof(*tmp),
 	                         "dm_dupPolyArray tmp");
 
 	if (tmp) dm->copyPolyArray(dm, tmp);
@@ -525,7 +525,7 @@ void DM_ensure_looptri_data(DerivedMesh *dm)
 
 	if (totpoly) {
 		if (dm->looptris.array_wip == NULL) {
-			dm->looptris.array_wip = MEM_mallocN(sizeof(*dm->looptris.array_wip) * looptris_num, __func__);
+			dm->looptris.array_wip = MEM_malloc_arrayN(looptris_num, sizeof(*dm->looptris.array_wip), __func__);
 			dm->looptris.num_alloc = looptris_num;
 		}
 
@@ -574,7 +574,7 @@ void DM_update_tessface_data(DerivedMesh *dm)
 	    CustomData_has_layer(fdata, CD_TESSLOOPNORMAL) ||
 	    CustomData_has_layer(fdata, CD_TANGENT))
 	{
-		loopindex = MEM_mallocN(sizeof(*loopindex) * totface, __func__);
+		loopindex = MEM_malloc_arrayN(totface, sizeof(*loopindex), __func__);
 
 		for (mf_idx = 0, mf = mface; mf_idx < totface; mf_idx++, mf++) {
 			const int mf_len = mf->v4 ? 4 : 3;
@@ -635,7 +635,7 @@ void DM_generate_tangent_tessface_data(DerivedMesh *dm, bool generate)
 				CustomData_bmesh_update_active_layers(fdata, pdata, ldata);
 
 				if (!loopindex) {
-					loopindex = MEM_mallocN(sizeof(*loopindex) * totface, __func__);
+					loopindex = MEM_malloc_arrayN(totface, sizeof(*loopindex), __func__);
 					for (mf_idx = 0, mf = mface; mf_idx < totface; mf_idx++, mf++) {
 						const int mf_len = mf->v4 ? 4 : 3;
 						unsigned int *ml_idx = loopindex[mf_idx];
@@ -680,7 +680,7 @@ void DM_update_materials(DerivedMesh *dm, Object *ob)
 		if (dm->mat)
 			MEM_freeN(dm->mat);
 
-		dm->mat = MEM_mallocN(totmat * sizeof(*dm->mat), "DerivedMesh.mat");
+		dm->mat = MEM_malloc_arrayN(totmat, sizeof(*dm->mat), "DerivedMesh.mat");
 	}
 
 	/* we leave last material as empty - rationale here is being able to index
@@ -870,7 +870,7 @@ void DM_to_meshkey(DerivedMesh *dm, Mesh *me, KeyBlock *kb)
 	}
 	
 	if (kb->data) MEM_freeN(kb->data);
-	kb->data = MEM_mallocN(me->key->elemsize * me->totvert, "kb->data");
+	kb->data = MEM_malloc_arrayN(me->key->elemsize, me->totvert, "kb->data");
 	kb->totelem = totvert;
 	
 	fp = kb->data;
@@ -1206,7 +1206,7 @@ static float (*get_editbmesh_orco_verts(BMEditMesh *em))[3]
 	/* these may not really be the orco's, but it's only for preview.
 	 * could be solver better once, but isn't simple */
 	
-	orco = MEM_mallocN(sizeof(float) * 3 * em->bm->totvert, "BMEditMesh Orco");
+	orco = MEM_malloc_arrayN(em->bm->totvert, sizeof(float) * 3, "BMEditMesh Orco");
 
 	BM_ITER_MESH_INDEX (eve, &iter, em->bm, BM_VERTS_OF_MESH, i) {
 		copy_v3_v3(orco[i], eve->co);
@@ -1280,7 +1280,7 @@ static void add_orco_dm(
 	totvert = dm->getNumVerts(dm);
 
 	if (orcodm) {
-		orco = MEM_callocN(sizeof(float[3]) * totvert, "dm orco");
+		orco = MEM_calloc_arrayN(totvert, sizeof(float[3]), "dm orco");
 		free = 1;
 
 		if (orcodm->getNumVerts(orcodm) == totvert)
@@ -1562,7 +1562,7 @@ void DM_update_weight_mcol(
 		wtcol_v = em->derivedVertColor;
 	}
 	else {
-		wtcol_v = MEM_mallocN(sizeof(*wtcol_v) * numVerts, __func__);
+		wtcol_v = MEM_malloc_arrayN(numVerts, sizeof(*wtcol_v), __func__);
 	}
 
 	/* Weights are given by caller. */
@@ -1571,7 +1571,7 @@ void DM_update_weight_mcol(
 		/* If indices is not NULL, it means we do not have weights for all vertices,
 		 * so we must create them (and set them to zero)... */
 		if (indices) {
-			w = MEM_callocN(sizeof(float) * numVerts, "Temp weight array DM_update_weight_mcol");
+			w = MEM_calloc_arrayN(numVerts, sizeof(float), "Temp weight array DM_update_weight_mcol");
 			i = num;
 			while (i--)
 				w[indices[i]] = weights[i];
@@ -1603,7 +1603,7 @@ void DM_update_weight_mcol(
 		/* now add to loops, so the data can be passed through the modifier stack
 		 * If no CD_PREVIEW_MLOOPCOL existed yet, we have to add a new one! */
 		if (!wtcol_l) {
-			wtcol_l = MEM_mallocN(sizeof(*wtcol_l) * dm_totloop, __func__);
+			wtcol_l = MEM_malloc_arrayN(dm_totloop, sizeof(*wtcol_l), __func__);
 			CustomData_add_layer(&dm->loopData, CD_PREVIEW_MLOOPCOL, CD_ASSIGN, wtcol_l, dm_totloop);
 		}
 
@@ -1658,7 +1658,7 @@ static void shapekey_layers_to_keyblocks(DerivedMesh *dm, Mesh *me, int actshape
 		cos = CustomData_get_layer_n(&dm->vertData, CD_SHAPEKEY, i);
 		kb->totelem = dm->numVertData;
 
-		kb->data = kbcos = MEM_mallocN(sizeof(float) * 3 * kb->totelem, "kbcos DerivedMesh.c");
+		kb->data = kbcos = MEM_malloc_arrayN(kb->totelem, sizeof(float), "kbcos DerivedMesh.c");
 		if (kb->uid == actshape_uid) {
 			MVert *mvert = dm->getVertArray(dm);
 			
@@ -1679,7 +1679,7 @@ static void shapekey_layers_to_keyblocks(DerivedMesh *dm, Mesh *me, int actshape
 				MEM_freeN(kb->data);
 			
 			kb->totelem = dm->numVertData;
-			kb->data = MEM_callocN(sizeof(float) * 3 * kb->totelem, "kb->data derivedmesh.c");
+			kb->data = MEM_calloc_arrayN(kb->totelem, 3 * sizeof(float), "kb->data derivedmesh.c");
 			fprintf(stderr, "%s: lost a shapekey layer: '%s'! (bmesh internal error)\n", __func__, kb->name);
 		}
 	}
@@ -1690,7 +1690,6 @@ static void add_shapekey_layers(DerivedMesh *dm, Mesh *me, Object *UNUSED(ob))
 	KeyBlock *kb;
 	Key *key = me->key;
 	int i;
-	const size_t shape_alloc_len = sizeof(float) * 3 * me->totvert;
 
 	if (!me->key)
 		return;
@@ -1711,11 +1710,11 @@ static void add_shapekey_layers(DerivedMesh *dm, Mesh *me, Object *UNUSED(ob))
 			fprintf(stderr,
 			        "%s: vertex size mismatch (Mesh '%s':%d != KeyBlock '%s':%d)\n",
 			        __func__, me->id.name + 2, me->totvert, kb->name, kb->totelem);
-			array = MEM_callocN(shape_alloc_len, __func__);
+			array = MEM_calloc_arrayN((size_t)me->totvert, 3 * sizeof(float), __func__);
 		}
 		else {
-			array = MEM_mallocN(shape_alloc_len, __func__);
-			memcpy(array, kb->data, shape_alloc_len);
+			array = MEM_malloc_arrayN((size_t)me->totvert, 3 * sizeof(float), __func__);
+			memcpy(array, kb->data, (size_t)me->totvert * 3 * sizeof(float));
 		}
 
 		CustomData_add_layer_named(&dm->vertData, CD_SHAPEKEY, CD_ASSIGN, array, dm->numVertData, kb->name);
@@ -1988,7 +1987,7 @@ static void mesh_calc_modifiers(
 					 */
 					numVerts = dm->getNumVerts(dm);
 					deformedVerts =
-					    MEM_mallocN(sizeof(*deformedVerts) * numVerts, "dfmv");
+					    MEM_malloc_arrayN(numVerts, sizeof(*deformedVerts), "dfmv");
 					dm->getVertCos(dm, deformedVerts);
 				}
 				else {
@@ -2281,7 +2280,7 @@ float (*editbmesh_get_vertex_cos(BMEditMesh *em, int *r_numVerts))[3]
 
 	*r_numVerts = em->bm->totvert;
 
-	cos = MEM_mallocN(sizeof(float) * 3 * em->bm->totvert, "vertexcos");
+	cos = MEM_malloc_arrayN(em->bm->totvert, 3 * sizeof(float), "vertexcos");
 
 	BM_ITER_MESH_INDEX (eve, &iter, em->bm, BM_VERTS_OF_MESH, i) {
 		copy_v3_v3(cos[i], eve->co);
@@ -2387,7 +2386,7 @@ static void editbmesh_calc_modifiers(
 					 */
 					numVerts = dm->getNumVerts(dm);
 					deformedVerts =
-					    MEM_mallocN(sizeof(*deformedVerts) * numVerts, "dfmv");
+					    MEM_malloc_arrayN(numVerts, sizeof(*deformedVerts), "dfmv");
 					dm->getVertCos(dm, deformedVerts);
 				}
 				else {
@@ -3000,11 +2999,11 @@ DMCoNo *mesh_get_mapped_verts_nors(Scene *scene, Object *ob)
 	dm = mesh_get_derived_final(scene, ob, CD_MASK_BAREMESH | CD_MASK_ORIGINDEX);
 	
 	if (dm->foreachMappedVert) {
-		vertexcosnos = MEM_callocN(sizeof(DMCoNo) * me->totvert, "vertexcosnos map");
+		vertexcosnos = MEM_calloc_arrayN(me->totvert, sizeof(DMCoNo), "vertexcosnos map");
 		dm->foreachMappedVert(dm, make_vertexcosnos__mapFunc, vertexcosnos);
 	}
 	else {
-		DMCoNo *v_co_no = vertexcosnos = MEM_mallocN(sizeof(DMCoNo) * me->totvert, "vertexcosnos map");
+		DMCoNo *v_co_no = vertexcosnos = MEM_malloc_arrayN(me->totvert, sizeof(DMCoNo), "vertexcosnos map");
 		int a;
 		for (a = 0; a < me->totvert; a++, v_co_no++) {
 			dm->getVertCo(dm, a, v_co_no->co);
@@ -3443,7 +3442,7 @@ void DM_calc_loop_tangents(
 			/* over alloc, since we dont know how many ngon or quads we have */
 
 			/* map fake face index to looptri */
-			face_as_quad_map = MEM_mallocN(sizeof(int) * totface, __func__);
+			face_as_quad_map = MEM_malloc_arrayN(totface, sizeof(int), __func__);
 			int k, j;
 			for (k = 0, j = 0; j < totface; k++, j++) {
 				face_as_quad_map[k] = j;
@@ -4337,7 +4336,7 @@ MVert *DM_get_vert_array(DerivedMesh *dm, bool *allocated)
 	*allocated = false;
 
 	if (mvert == NULL) {
-		mvert = MEM_mallocN(sizeof(MVert) * dm->getNumVerts(dm), "dmvh vert data array");
+		mvert = MEM_malloc_arrayN(dm->getNumVerts(dm), sizeof(MVert), "dmvh vert data array");
 		dm->copyVertArray(dm, mvert);
 		*allocated = true;
 	}
@@ -4352,7 +4351,7 @@ MEdge *DM_get_edge_array(DerivedMesh *dm, bool *allocated)
 	*allocated = false;
 
 	if (medge == NULL) {
-		medge = MEM_mallocN(sizeof(MEdge) * dm->getNumEdges(dm), "dm medge data array");
+		medge = MEM_malloc_arrayN(dm->getNumEdges(dm), sizeof(MEdge), "dm medge data array");
 		dm->copyEdgeArray(dm, medge);
 		*allocated = true;
 	}
@@ -4367,7 +4366,7 @@ MLoop *DM_get_loop_array(DerivedMesh *dm, bool *r_allocated)
 	*r_allocated = false;
 
 	if (mloop == NULL) {
-		mloop = MEM_mallocN(sizeof(MLoop) * dm->getNumLoops(dm), "dm loop data array");
+		mloop = MEM_malloc_arrayN(dm->getNumLoops(dm), sizeof(MLoop), "dm loop data array");
 		dm->copyLoopArray(dm, mloop);
 		*r_allocated = true;
 	}
@@ -4382,7 +4381,7 @@ MPoly *DM_get_poly_array(DerivedMesh *dm, bool *r_allocated)
 	*r_allocated = false;
 
 	if (mpoly == NULL) {
-		mpoly = MEM_mallocN(sizeof(MPoly) * dm->getNumPolys(dm), "dm poly data array");
+		mpoly = MEM_malloc_arrayN(dm->getNumPolys(dm), sizeof(MPoly), "dm poly data array");
 		dm->copyPolyArray(dm, mpoly);
 		*r_allocated = true;
 	}
@@ -4400,7 +4399,7 @@ MFace *DM_get_tessface_array(DerivedMesh *dm, bool *r_allocated)
 		int numTessFaces = dm->getNumTessFaces(dm);
 
 		if (numTessFaces > 0) {
-			mface = MEM_mallocN(sizeof(MFace) * numTessFaces, "bvh mface data array");
+			mface = MEM_malloc_arrayN(numTessFaces, sizeof(MFace), "bvh mface data array");
 			dm->copyTessFaceArray(dm, mface);
 			*r_allocated = true;
 		}
diff --git a/source/blender/blenkernel/intern/cdderivedmesh.c b/source/blender/blenkernel/intern/cdderivedmesh.c
index bbc66b9ecf..d3b106835e 100644
--- a/source/blender/blenkernel/intern/cdderivedmesh.c
+++ b/source/blender/blenkernel/intern/cdderivedmesh.c
@@ -303,7 +303,7 @@ static PBVH *cdDM_getPBVH(Object *ob, DerivedMesh *dm)
 		cddm->pbvh = BKE_pbvh_new();
 		cddm->pbvh_draw = can_pbvh_draw(ob, dm);
 
-		looptri = MEM_mallocN(sizeof(*looptri) * looptris_num, __func__);
+		looptri = MEM_malloc_arrayN(looptris_num, sizeof(*looptri), __func__);
 
 		BKE_mesh_recalc_looptri(
 		        me->mloop, me->mpoly,
@@ -328,7 +328,7 @@ static PBVH *cdDM_getPBVH(Object *ob, DerivedMesh *dm)
 			int totvert;
 
 			totvert = deformdm->getNumVerts(deformdm);
-			vertCos = MEM_mallocN(totvert * sizeof(float[3]), "cdDM_getPBVH vertCos");
+			vertCos = MEM_malloc_arrayN(totvert, sizeof(float[3]), "cdDM_getPBVH vertCos");
 			deformdm->getVertCos(deformdm, vertCos);
 			BKE_pbvh_apply_vertCos(cddm->pbvh, vertCos);
 			MEM_freeN(vertCos);
@@ -1013,9 +1013,9 @@ static void cdDM_drawMappedFacesGLSL(
 
 		tot_active_mat = dm->drawObject->totmaterial;
 
-		matconv = MEM_callocN(sizeof(*matconv) * tot_active_mat,
+		matconv = MEM_calloc_arrayN(tot_active_mat, sizeof(*matconv),
 		                      "cdDM_drawMappedFacesGLSL.matconv");
-		mat_orig_to_new = MEM_mallocN(sizeof(*mat_orig_to_new) * dm->totmat,
+		mat_orig_to_new = MEM_malloc_arrayN(dm->totmat, sizeof(*mat_orig_to_new),
 		                              "cdDM_drawMappedFacesGLSL.mat_orig_to_new");
 
 		/* part one, check what attributes are needed per material */
@@ -1304,7 +1304,7 @@ static void cdDM_buffer_copy_triangles(
 	const MLoopTri *lt = dm->getLoopTriArray(dm);
 	const int totpoly = dm->getNumPolys(dm);
 
-	FaceCount *fc = MEM_mallocN(sizeof(*fc) * gpu_totmat, "gpumaterial.facecount");
+	FaceCount *fc = MEM_malloc_arrayN(gpu_totmat, sizeof(*fc), "gpumaterial.facecount");
 
 	for (i = 0; i < gpu_totmat; i++) {
 		fc[i].i_visible = 0;
@@ -1485,7 +1485,7 @@ static void cdDM_buffer_copy_uv_texpaint(
 
 	/* should have been checked for before, reassert */
 	BLI_assert(DM_get_loop_data_layer(dm, CD_MLOOPUV));
-	uv_base = MEM_mallocN(totmaterial * sizeof(*uv_base), "texslots");
+	uv_base = MEM_malloc_arrayN(totmaterial, sizeof(*uv_base), "texslots");
 
 	for (i = 0; i < totmaterial; i++) {
 		uv_base[i] = DM_paint_uvlayer_active_get(dm, i);
@@ -1699,10 +1699,10 @@ static void cdDM_drawobject_init_vert_points(
 	int tot_loops = 0;
 
 	/* allocate the array and space for links */
-	gdo->vert_points = MEM_mallocN(sizeof(GPUVertPointLink) * gdo->totvert,
+	gdo->vert_points = MEM_malloc_arrayN(gdo->totvert, sizeof(GPUVertPointLink),
 	                               "GPUDrawObject.vert_points");
 #ifdef USE_GPU_POINT_LINK
-	gdo->vert_points_mem = MEM_callocN(sizeof(GPUVertPointLink) * gdo->totvert,
+	gdo->vert_points_mem = MEM_calloc_arrayN(gdo->totvert, sizeof(GPUVertPointLink),
 	                                   "GPUDrawObject.vert_points_mem");
 	gdo->vert_points_usage = 0;
 #endif
@@ -1757,7 +1757,7 @@ static GPUDrawObject *cdDM_GPUobject_new(DerivedMesh *dm)
 
 	/* get the number of points used by each material, treating
 	 * each quad as two triangles */
-	mat_info = MEM_callocN(sizeof(*mat_info) * dm_totmat, "GPU_drawobject_new.mat_orig_to_new");
+	mat_info = MEM_calloc_arrayN(dm_totmat, sizeof(*mat_info), "GPU_drawobject_new.mat_orig_to_new");
 
 	for (i = 0; i < totpolys; i++) {
 		const short mat_nr = ME_MAT_NR_TEST(mpoly[i].mat_nr, dm_totmat);
@@ -2604,7 +2604,7 @@ void CDDM_calc_normals_mapping_ex(DerivedMesh *dm, const bool only_face_normals)
 	}
 #endif
 
-	face_nors = MEM_mallocN(sizeof(*face_nors) * dm->numPolyData, "face_nors");
+	face_nors = MEM_malloc_arrayN(dm->numPolyData, sizeof(*face_nors), "face_nors");
 
 	/* calculate face normals */
 	BKE_mesh_calc_normals_poly(
@@ -2985,31 +2985,31 @@ DerivedMesh *CDDM_merge_verts(DerivedMesh *dm, const int *vtargetmap, const int
 
 	const int totvert_final = totvert - tot_vtargetmap;
 
-	MVert *mv, *mvert = MEM_mallocN(sizeof(*mvert) * totvert_final, __func__);
-	int *oldv         = MEM_mallocN(sizeof(*oldv)  * totvert_final, __func__);
-	int *newv         = MEM_mallocN(sizeof(*newv)  * totvert, __func__);
+	MVert *mv, *mvert = MEM_malloc_arrayN(totvert_final, sizeof(*mvert), __func__);
+	int *oldv         = MEM_malloc_arrayN(totvert_final, sizeof(*oldv), __func__);
+	int *newv         = MEM_malloc_arrayN(totvert, sizeof(*newv), __func__);
 	STACK_DECLARE(mvert);
 	STACK_DECLARE(oldv);
 
 	/* Note: create (totedge + totloop) elements because partially invalid polys due to merge may require
 	 * generating new edges, and while in 99% cases we'll still end with less final edges than totedge,
 	 * cases can be forged that would end requiring more... */
-	MEdge *med, *medge = MEM_mallocN(sizeof(*medge) * (totedge + totloop), __func__);
-	int *olde          = MEM_mallocN(sizeof(*olde)  * (totedge + totloop), __func__);
-	int *newe          = MEM_mallocN(sizeof(*newe)  * (totedge + totloop), __func__);
+	MEdge *med, *medge = MEM_malloc_arrayN((totedge + totloop), sizeof(*medge), __func__);
+	int *olde          = MEM_malloc_arrayN((totedge + totloop), sizeof(*olde), __func__);
+	int *newe          = MEM_malloc_arrayN((totedge + totloop), sizeof(*newe), __func__);
 	STACK_DECLARE(medge);
 	STACK_DECLARE(olde);
 
-	MLoop *ml, *mloop = MEM_mallocN(sizeof(*mloop) * totloop, __func__);
-	int *oldl         = MEM_mallocN(sizeof(*oldl)  * totloop, __func__);
+	MLoop *ml, *mloop = MEM_malloc_arrayN(totloop, sizeof(*mloop), __func__);
+	int *oldl         = MEM_malloc_arrayN(totloop, sizeof(*oldl), __func__);
 #ifdef USE_LOOPS
-	int newl          = MEM_mallocN(sizeof(*newl)  * totloop, __func__);
+	int newl          = MEM_malloc_arrayN(totloop, sizeof(*newl), __func__);
 #endif
 	STACK_DECLARE(mloop);
 	STACK_DECLARE(oldl);
 
-	MPoly *mp, *mpoly = MEM_mallocN(sizeof(*medge) * totpoly, __func__);
-	int *oldp         = MEM_mallocN(sizeof(*oldp)  * totpoly, __func__);
+	MPoly *mp, *mpoly = MEM_malloc_arrayN(totpoly, sizeof(*medge), __func__);
+	int *oldp         = MEM_malloc_arrayN(totpoly, sizeof(*oldp), __func__);
 	STACK_DECLARE(mpoly);
 	STACK_DECLARE(oldp);
 
@@ -3087,7 +3087,7 @@ DerivedMesh *CDDM_merge_verts(DerivedMesh *dm, const int *vtargetmap, const int
 		/* if the targets already make up a poly, in which case the new poly is dropped */
 		/* This poly equality check is rather complex.   We use a BLI_ghash to speed it up with a first level check */
 		PolyKey *mpgh;
-		poly_keys = MEM_mallocN(sizeof(PolyKey) * totpoly, __func__);
+		poly_keys = MEM_malloc_arrayN(totpoly, sizeof(PolyKey), __func__);
 		poly_gset = BLI_gset_new_ex(poly_gset_hash_fn, poly_gset_compare_fn, __func__, totpoly);
 		/* Duplicates allowed because our compare function is not pure equality */
 		BLI_gset_flag_set(poly_gset, GHASH_FLAG_ALLOW_DUPES);
diff --git a/source/blender/blenkernel/intern/curve.c b/source/blender/blenkernel/intern/curve.c
index f3894fb034..91fe44e4d5 100644
--- a/source/blender/blenkernel/intern/curve.c
+++ b/source/blender/blenkernel/intern/curve.c
@@ -166,12 +166,12 @@ void BKE_curve_init(Curve *cu)
 	if (cu->type == OB_FONT) {
 		cu->vfont = cu->vfontb = cu->vfonti = cu->vfontbi = BKE_vfont_builtin_get();
 		cu->vfont->id.us += 4;
-		cu->str = MEM_mallocN(12, "str");
+		cu->str = MEM_malloc_arrayN(12, sizeof(unsigned char), "str");
 		BLI_strncpy(cu->str, "Text", 12);
 		cu->len = cu->len_wchar = cu->pos = 4;
-		cu->strinfo = MEM_callocN(12 * sizeof(CharInfo), "strinfo new");
+		cu->strinfo = MEM_calloc_arrayN(12, sizeof(CharInfo), "strinfo new");
 		cu->totbox = cu->actbox = 1;
-		cu->tb = MEM_callocN(MAXTEXTBOX * sizeof(TextBox), "textbox");
+		cu->tb = MEM_calloc_arrayN(MAXTEXTBOX, sizeof(TextBox), "textbox");
 		cu->tb[0].w = cu->tb[0].h = 0.0;
 	}
 }
@@ -477,13 +477,13 @@ Nurb *BKE_nurb_duplicate(const Nurb *nu)
 
 	if (nu->bezt) {
 		newnu->bezt =
-		    (BezTriple *)MEM_mallocN((nu->pntsu) * sizeof(BezTriple), "duplicateNurb2");
+		    (BezTriple *)MEM_malloc_arrayN(nu->pntsu, sizeof(BezTriple), "duplicateNurb2");
 		memcpy(newnu->bezt, nu->bezt, nu->pntsu * sizeof(BezTriple));
 	}
 	else {
 		len = nu->pntsu * nu->pntsv;
 		newnu->bp =
-		    (BPoint *)MEM_mallocN((len) * sizeof(BPoint), "duplicateNurb3");
+		    (BPoint *)MEM_malloc_arrayN(len, sizeof(BPoint), "duplicateNurb3");
 		memcpy(newnu->bp, nu->bp, len * sizeof(BPoint));
 
 		newnu->knotsu = newnu->knotsv = NULL;
@@ -491,14 +491,14 @@ Nurb *BKE_nurb_duplicate(const Nurb *nu)
 		if (nu->knotsu) {
 			len = KNOTSU(nu);
 			if (len) {
-				newnu->knotsu = MEM_mallocN(len * sizeof(float), "duplicateNurb4");
+				newnu->knotsu = MEM_malloc_arrayN(len, sizeof(float), "duplicateNurb4");
 				memcpy(newnu->knotsu, nu->knotsu, sizeof(float) * len);
 			}
 		}
 		if (nu->pntsv > 1 && nu->knotsv) {
 			len = KNOTSV(nu);
 			if (len) {
-				newnu->knotsv = MEM_mallocN(len * sizeof(float), "duplicateNurb5");
+				newnu->knotsv = MEM_malloc_arrayN(len, sizeof(float), "duplicateNurb5");
 				memcpy(newnu->knotsv, nu->knotsv, sizeof(float) * len);
 			}
 		}
@@ -521,10 +521,10 @@ Nurb *BKE_nurb_copy(Nurb *src, int pntsu, int pntsv)
 	newnu->knotsv = NULL;
 
 	if (src->bezt) {
-		newnu->bezt = (BezTriple *)MEM_mallocN(pntsu * pntsv * sizeof(BezTriple), "copyNurb2");
+		newnu->bezt = (BezTriple *)MEM_malloc_arrayN(pntsu * pntsv, sizeof(BezTriple), "copyNurb2");
 	}
 	else {
-		newnu->bp = (BPoint *)MEM_mallocN(pntsu * pntsv * sizeof(BPoint), "copyNurb3");
+		newnu->bp = (BPoint *)MEM_malloc_arrayN(pntsu * pntsv, sizeof(BPoint), "copyNurb3");
 	}
 
 	return newnu;
@@ -971,7 +971,7 @@ static void makeknots(Nurb *nu, short uv)
 			if (nu->knotsu)
 				MEM_freeN(nu->knotsu);
 			if (BKE_nurb_check_valid_u(nu)) {
-				nu->knotsu = MEM_callocN(4 + sizeof(float) * KNOTSU(nu), "makeknots");
+				nu->knotsu = MEM_calloc_arrayN(KNOTSU(nu) + 1, sizeof(float), "makeknots");
 				if (nu->flagu & CU_NURB_CYCLIC) {
 					calcknots(nu->knotsu, nu->pntsu, nu->orderu, 0);  /* cyclic should be uniform */
 					makecyclicknots(nu->knotsu, nu->pntsu, nu->orderu);
@@ -987,7 +987,7 @@ static void makeknots(Nurb *nu, short uv)
 			if (nu->knotsv)
 				MEM_freeN(nu->knotsv);
 			if (BKE_nurb_check_valid_v(nu)) {
-				nu->knotsv = MEM_callocN(4 + sizeof(float) * KNOTSV(nu), "makeknots");
+				nu->knotsv = MEM_calloc_arrayN(KNOTSV(nu) + 1, sizeof(float), "makeknots");
 				if (nu->flagv & CU_NURB_CYCLIC) {
 					calcknots(nu->knotsv, nu->pntsv, nu->orderv, 0);  /* cyclic should be uniform */
 					makecyclicknots(nu->knotsv, nu->pntsv, nu->orderv);
@@ -1104,7 +1104,7 @@ void BKE_nurb_makeFaces(Nurb *nu, float *coord_array, int rowstride, int resolu,
 	if (len == 0)
 		return;
 
-	sum = (float *)MEM_callocN(sizeof(float) * len, "makeNurbfaces1");
+	sum = (float *)MEM_calloc_arrayN(len, sizeof(float), "makeNurbfaces1");
 
 	bp = nu->bp;
 	i = nu->pntsu * nu->pntsv;
@@ -1125,7 +1125,7 @@ void BKE_nurb_makeFaces(Nurb *nu, float *coord_array, int rowstride, int resolu,
 		uend = fp[nu->pntsu];
 	ustep = (uend - ustart) / ((nu->flagu & CU_NURB_CYCLIC) ? totu : totu - 1);
 
-	basisu = (float *)MEM_mallocN(sizeof(float) * KNOTSU(nu), "makeNurbfaces3");
+	basisu = (float *)MEM_malloc_arrayN(KNOTSU(nu), sizeof(float), "makeNurbfaces3");
 
 	fp = nu->knotsv;
 	vstart = fp[nu->orderv - 1];
@@ -1137,9 +1137,9 @@ void BKE_nurb_makeFaces(Nurb *nu, float *coord_array, int rowstride, int resolu,
 	vstep = (vend - vstart) / ((nu->flagv & CU_NURB_CYCLIC) ? totv : totv - 1);
 
 	len = KNOTSV(nu);
-	basisv = (float *)MEM_mallocN(sizeof(float) * len * totv, "makeNurbfaces3");
-	jstart = (int *)MEM_mallocN(sizeof(float) * totv, "makeNurbfaces4");
-	jend = (int *)MEM_mallocN(sizeof(float) * totv, "makeNurbfaces5");
+	basisv = (float *)MEM_malloc_arrayN(len * totv, sizeof(float), "makeNurbfaces3");
+	jstart = (int *)MEM_malloc_arrayN(totv, sizeof(float), "makeNurbfaces4");
+	jend = (int *)MEM_malloc_arrayN(totv, sizeof(float), "makeNurbfaces5");
 
 	/* precalculation of basisv and jstart, jend */
 	if (nu->flagv & CU_NURB_CYCLIC)
@@ -1277,7 +1277,7 @@ void BKE_nurb_makeCurve(Nurb *nu, float *coord_array, float *tilt_array, float *
 	len = nu->pntsu;
 	if (len == 0)
 		return;
-	sum = (float *)MEM_callocN(sizeof(float) * len, "makeNurbcurve1");
+	sum = (float *)MEM_calloc_arrayN(len, sizeof(float), "makeNurbcurve1");
 
 	resolu = (resolu * SEGMENTSU(nu));
 
@@ -1294,7 +1294,7 @@ void BKE_nurb_makeCurve(Nurb *nu, float *coord_array, float *tilt_array, float *
 		uend = fp[nu->pntsu];
 	ustep = (uend - ustart) / (resolu - ((nu->flagu & CU_NURB_CYCLIC) ? 0 : 1));
 
-	basisu = (float *)MEM_mallocN(sizeof(float) * KNOTSU(nu), "makeNurbcurve3");
+	basisu = (float *)MEM_malloc_arrayN(KNOTSU(nu), sizeof(float), "makeNurbcurve3");
 
 	if (nu->flagu & CU_NURB_CYCLIC)
 		cycl = nu->orderu - 1;
@@ -1545,7 +1545,7 @@ float *BKE_curve_surf_make_orco(Object *ob)
 		nu = nu->next;
 	}
 	/* makeNurbfaces wants zeros */
-	fp = coord_array = MEM_callocN(3 * sizeof(float) * tot, "make_orco");
+	fp = coord_array = MEM_calloc_arrayN(tot, 3 * sizeof(float), "make_orco");
 
 	nu = cu->nurb.first;
 	while (nu) {
@@ -1656,7 +1656,7 @@ float *BKE_curve_make_orco(Scene *scene, Object *ob, int *r_numVerts)
 	if (r_numVerts)
 		*r_numVerts = numVerts;
 
-	fp = coord_array = MEM_mallocN(3 * sizeof(float) * numVerts, "cu_orco");
+	fp = coord_array = MEM_malloc_arrayN(numVerts, 3 * sizeof(float), "cu_orco");
 	for (dl = disp.first; dl; dl = dl->next) {
 		if (dl->type == DL_INDEX3) {
 			for (u = 0; u < dl->nr; u++, fp += 3) {
@@ -1759,7 +1759,7 @@ void BKE_curve_bevel_make(Scene *scene, Object *ob, ListBase *disp,
 				if (ELEM(dl->type, DL_POLY, DL_SEGM)) {
 					dlnew = MEM_mallocN(sizeof(DispList), "makebevelcurve1");
 					*dlnew = *dl;
-					dlnew->verts = MEM_mallocN(3 * sizeof(float) * dl->parts * dl->nr, "makebevelcurve1");
+					dlnew->verts = MEM_malloc_arrayN(dl->parts * dl->nr, 3 * sizeof(float), "makebevelcurve1");
 					memcpy(dlnew->verts, dl->verts, 3 * sizeof(float) * dl->parts * dl->nr);
 
 					if (dlnew->type == DL_SEGM)
@@ -1786,7 +1786,7 @@ void BKE_curve_bevel_make(Scene *scene, Object *ob, ListBase *disp,
 	}
 	else if (cu->ext2 == 0.0f) {
 		dl = MEM_callocN(sizeof(DispList), "makebevelcurve2");
-		dl->verts = MEM_mallocN(2 * sizeof(float[3]), "makebevelcurve2");
+		dl->verts = MEM_malloc_arrayN(2, sizeof(float[3]), "makebevelcurve2");
 		BLI_addtail(disp, dl);
 		dl->type = DL_SEGM;
 		dl->parts = 1;
@@ -1803,7 +1803,7 @@ void BKE_curve_bevel_make(Scene *scene, Object *ob, ListBase *disp,
 		nr = 4 + 2 * cu->bevresol;
 
 		dl = MEM_callocN(sizeof(DispList), "makebevelcurve p1");
-		dl->verts = MEM_mallocN(nr * sizeof(float[3]), "makebevelcurve p1");
+		dl->verts = MEM_malloc_arrayN(nr, sizeof(float[3]), "makebevelcurve p1");
 		BLI_addtail(disp, dl);
 		dl->type = DL_POLY;
 		dl->parts = 1;
@@ -1835,7 +1835,7 @@ void BKE_curve_bevel_make(Scene *scene, Object *ob, ListBase *disp,
 				nr = 3 + 2 * cu->bevresol;
 			}
 			dl = MEM_callocN(sizeof(DispList), "makebevelcurve p1");
-			dl->verts = MEM_mallocN(nr * sizeof(float[3]), "makebevelcurve p1");
+			dl->verts = MEM_malloc_arrayN(nr, sizeof(float[3]), "makebevelcurve p1");
 			BLI_addtail(disp, dl);
 			dl->type = DL_SEGM;
 			dl->parts = 1;
@@ -1861,7 +1861,7 @@ void BKE_curve_bevel_make(Scene *scene, Object *ob, ListBase *disp,
 			nr = 2;
 
 			dl = MEM_callocN(sizeof(DispList), "makebevelcurve p2");
-			dl->verts = MEM_mallocN(nr * sizeof(float[3]), "makebevelcurve p2");
+			dl->verts = MEM_malloc_arrayN(nr, sizeof(float[3]), "makebevelcurve p2");
 			BLI_addtail(disp, dl);
 			dl->type = DL_SEGM;
 			dl->parts = 1;
@@ -1893,7 +1893,7 @@ void BKE_curve_bevel_make(Scene *scene, Object *ob, ListBase *disp,
 				nr = 3 + 2 * cu->bevresol;
 			}
 			dl = MEM_callocN(sizeof(DispList), "makebevelcurve p3");
-			dl->verts = MEM_mallocN(nr * sizeof(float[3]), "makebevelcurve p3");
+			dl->verts = MEM_malloc_arrayN(nr, sizeof(float[3]), "makebevelcurve p3");
 			BLI_addtail(disp, dl);
 			dl->type = DL_SEGM;
 			dl->flag = DL_FRONT_CURVE;
@@ -2706,8 +2706,8 @@ void BKE_curve_bevelList_make(Object *ob, ListBase *nurbs, bool for_render)
 				len = nu->pntsu;
 				bl = MEM_callocN(sizeof(BevList) + len * sizeof(BevPoint), "makeBevelList2");
 				if (need_seglen && (nu->flagu & CU_NURB_CYCLIC) == 0) {
-					bl->seglen = MEM_mallocN(segcount * sizeof(float), "makeBevelList2_seglen");
-					bl->segbevcount = MEM_mallocN(segcount * sizeof(int), "makeBevelList2_segbevcount");
+					bl->seglen = MEM_malloc_arrayN(segcount, sizeof(float), "makeBevelList2_seglen");
+					bl->segbevcount = MEM_malloc_arrayN(segcount, sizeof(int), "makeBevelList2_segbevcount");
 				}
 				BLI_addtail(bev, bl);
 
@@ -2752,8 +2752,8 @@ void BKE_curve_bevelList_make(Object *ob, ListBase *nurbs, bool for_render)
 
 				bl = MEM_callocN(sizeof(BevList) + len * sizeof(BevPoint), "makeBevelBPoints");
 				if (need_seglen && (nu->flagu & CU_NURB_CYCLIC) == 0) {
-					bl->seglen = MEM_mallocN(segcount * sizeof(float), "makeBevelBPoints_seglen");
-					bl->segbevcount = MEM_mallocN(segcount * sizeof(int), "makeBevelBPoints_segbevcount");
+					bl->seglen = MEM_malloc_arrayN(segcount, sizeof(float), "makeBevelBPoints_seglen");
+					bl->segbevcount = MEM_malloc_arrayN(segcount, sizeof(int), "makeBevelBPoints_segbevcount");
 				}
 				BLI_addtail(bev, bl);
 
@@ -2888,8 +2888,8 @@ void BKE_curve_bevelList_make(Object *ob, ListBase *nurbs, bool for_render)
 
 					bl = MEM_callocN(sizeof(BevList) + len * sizeof(BevPoint), "makeBevelList3");
 					if (need_seglen && (nu->flagu & CU_NURB_CYCLIC) == 0) {
-						bl->seglen = MEM_mallocN(segcount * sizeof(float), "makeBevelList3_seglen");
-						bl->segbevcount = MEM_mallocN(segcount * sizeof(int), "makeBevelList3_segbevcount");
+						bl->seglen = MEM_malloc_arrayN(segcount, sizeof(float), "makeBevelList3_seglen");
+						bl->segbevcount = MEM_malloc_arrayN(segcount, sizeof(int), "makeBevelList3_segbevcount");
 					}
 					BLI_addtail(bev, bl);
 					bl->nr = len;
@@ -3022,7 +3022,7 @@ void BKE_curve_bevelList_make(Object *ob, ListBase *nurbs, bool for_render)
 
 	/* find extreme left points, also test (turning) direction */
 	if (poly > 0) {
-		sd = sortdata = MEM_mallocN(sizeof(struct BevelSort) * poly, "makeBevelList5");
+		sd = sortdata = MEM_malloc_arrayN(poly, sizeof(struct BevelSort), "makeBevelList5");
 		bl = bev->first;
 		while (bl) {
 			if (bl->poly > 0) {
@@ -4424,7 +4424,7 @@ void BKE_nurb_direction_switch(Nurb *nu)
 				/* and make in increasing order again */
 				a = KNOTSU(nu);
 				fp1 = nu->knotsu;
-				fp2 = tempf = MEM_mallocN(sizeof(float) * a, "switchdirect");
+				fp2 = tempf = MEM_malloc_arrayN(a, sizeof(float), "switchdirect");
 				a--;
 				fp2[a] = fp1[a];
 				while (a--) {
@@ -4468,7 +4468,7 @@ void BKE_nurb_direction_switch(Nurb *nu)
 float (*BKE_curve_nurbs_vertexCos_get(ListBase *lb, int *r_numVerts))[3]
 {
 	int i, numVerts = *r_numVerts = BKE_nurbList_verts_count(lb);
-	float *co, (*cos)[3] = MEM_mallocN(sizeof(*cos) * numVerts, "cu_vcos");
+	float *co, (*cos)[3] = MEM_malloc_arrayN(numVerts, sizeof(*cos), "cu_vcos");
 	Nurb *nu;
 
 	co = cos[0];
@@ -4525,7 +4525,7 @@ void BK_curve_nurbs_vertexCos_apply(ListBase *lb, float (*vertexCos)[3])
 float (*BKE_curve_nurbs_keyVertexCos_get(ListBase *lb, float *key))[3]
 {
 	int i, numVerts = BKE_nurbList_verts_count(lb);
-	float *co, (*cos)[3] = MEM_mallocN(sizeof(*cos) * numVerts, "cu_vcos");
+	float *co, (*cos)[3] = MEM_malloc_arrayN(numVerts, sizeof(*cos), "cu_vcos");
 	Nurb *nu;
 
 	co = cos[0];
@@ -4672,7 +4672,7 @@ bool BKE_nurb_type_convert(Nurb *nu, const short type, const bool use_handles)
 	if (nu->type == CU_POLY) {
 		if (type == CU_BEZIER) {  /* to Bezier with vecthandles  */
 			nr = nu->pntsu;
-			bezt = (BezTriple *)MEM_callocN(nr * sizeof(BezTriple), "setsplinetype2");
+			bezt = (BezTriple *)MEM_calloc_arrayN(nr, sizeof(BezTriple), "setsplinetype2");
 			nu->bezt = bezt;
 			a = nr;
 			bp = nu->bp;
@@ -4708,7 +4708,7 @@ bool BKE_nurb_type_convert(Nurb *nu, const short type, const bool use_handles)
 	else if (nu->type == CU_BEZIER) {   /* Bezier */
 		if (type == CU_POLY || type == CU_NURBS) {
 			nr = use_handles ? (3 * nu->pntsu) : nu->pntsu;
-			nu->bp = MEM_callocN(nr * sizeof(BPoint), "setsplinetype");
+			nu->bp = MEM_calloc_arrayN(nr, sizeof(BPoint), "setsplinetype");
 			a = nu->pntsu;
 			bezt = nu->bezt;
 			bp = nu->bp;
@@ -4771,7 +4771,7 @@ bool BKE_nurb_type_convert(Nurb *nu, const short type, const bool use_handles)
 				return false;  /* conversion impossible */
 			}
 			else {
-				bezt = MEM_callocN(nr * sizeof(BezTriple), "setsplinetype2");
+				bezt = MEM_calloc_arrayN(nr, sizeof(BezTriple), "setsplinetype2");
 				nu->bezt = bezt;
 				a = nr;
 				bp = nu->bp;
diff --git a/source/blender/blenkernel/intern/customdata.c b/source/blender/blenkernel/intern/customdata.c
index 68acb60f21..cf86963cf6 100644
--- a/source/blender/blenkernel/intern/customdata.c
+++ b/source/blender/blenkernel/intern/customdata.c
@@ -157,7 +157,7 @@ static void layerCopy_mdeformvert(const void *source, void *dest,
 		MDeformVert *dvert = POINTER_OFFSET(dest, i * size);
 
 		if (dvert->totweight) {
-			MDeformWeight *dw = MEM_mallocN(dvert->totweight * sizeof(*dw),
+			MDeformWeight *dw = MEM_malloc_arrayN(dvert->totweight, sizeof(*dw),
 			                                "layerCopy_mdeformvert dw");
 
 			memcpy(dw, dvert->dw, dvert->totweight * sizeof(*dw));
@@ -281,7 +281,7 @@ static void layerInterp_mdeformvert(
 		}
 
 		if (totweight) {
-			dvert->dw = MEM_mallocN(sizeof(*dvert->dw) * totweight, __func__);
+			dvert->dw = MEM_malloc_arrayN(totweight, sizeof(*dvert->dw), __func__);
 		}
 	}
 
@@ -536,11 +536,11 @@ static void layerSwap_mdisps(void *data, const int *ci)
 
 			MEM_freeN(s->disps);
 			s->totdisp = (s->totdisp / corners) * nverts;
-			s->disps = MEM_callocN(s->totdisp * sizeof(float) * 3, "mdisp swap");
+			s->disps = MEM_calloc_arrayN(s->totdisp, sizeof(float) * 3, "mdisp swap");
 			return;
 		}
 
-		d = MEM_callocN(sizeof(float) * 3 * s->totdisp, "mdisps swap");
+		d = MEM_calloc_arrayN(s->totdisp, 3 * sizeof(float), "mdisps swap");
 
 		for (S = 0; S < corners; S++)
 			memcpy(d + cornersize * S, s->disps + cornersize * ci[S], cornersize * 3 * sizeof(float));
@@ -596,7 +596,7 @@ static int layerRead_mdisps(CDataFile *cdf, void *data, int count)
 
 	for (i = 0; i < count; ++i) {
 		if (!d[i].disps)
-			d[i].disps = MEM_callocN(sizeof(float) * 3 * d[i].totdisp, "mdisps read");
+			d[i].disps = MEM_calloc_arrayN(d[i].totdisp, 3 * sizeof(float), "mdisps read");
 
 		if (!cdf_read_data(cdf, d[i].totdisp * 3 * sizeof(float), d[i].disps)) {
 			printf("failed to read multires displacement %d/%d %d\n", i, count, d[i].totdisp);
@@ -1806,7 +1806,7 @@ void CustomData_set_layer_flag(struct CustomData *data, int type, int flag)
 
 static int customData_resize(CustomData *data, int amount)
 {
-	CustomDataLayer *tmp = MEM_callocN(sizeof(*tmp) * (data->maxlayer + amount),
+	CustomDataLayer *tmp = MEM_calloc_arrayN((data->maxlayer + amount), sizeof(*tmp),
 	                                   "CustomData->layers");
 	if (!tmp) return 0;
 
@@ -1824,7 +1824,6 @@ static CustomDataLayer *customData_add_layer__internal(CustomData *data, int typ
                                                        int totelem, const char *name)
 {
 	const LayerTypeInfo *typeInfo = layerType_getInfo(type);
-	const size_t size = (size_t)totelem * typeInfo->size;
 	int flag = 0, index = data->totlayer;
 	void *newlayerdata = NULL;
 
@@ -1841,12 +1840,12 @@ static CustomDataLayer *customData_add_layer__internal(CustomData *data, int typ
 	if ((alloctype == CD_ASSIGN) || (alloctype == CD_REFERENCE)) {
 		newlayerdata = layerdata;
 	}
-	else if (size > 0) {
+	else if (totelem > 0 && typeInfo->size > 0) {
 		if (alloctype == CD_DUPLICATE && layerdata) {
-			newlayerdata = MEM_mallocN(size, layerType_getName(type));
+			newlayerdata = MEM_malloc_arrayN((size_t)totelem, typeInfo->size, layerType_getName(type));
 		}
 		else {
-			newlayerdata = MEM_callocN(size, layerType_getName(type));
+			newlayerdata = MEM_calloc_arrayN((size_t)totelem, typeInfo->size, layerType_getName(type));
 		}
 
 		if (!newlayerdata)
@@ -1857,7 +1856,7 @@ static CustomDataLayer *customData_add_layer__internal(CustomData *data, int typ
 		if (typeInfo->copy)
 			typeInfo->copy(layerdata, newlayerdata, totelem);
 		else
-			memcpy(newlayerdata, layerdata, size);
+			memcpy(newlayerdata, layerdata, (size_t)totelem * typeInfo->size);
 	}
 	else if (alloctype == CD_DEFAULT) {
 		if (typeInfo->set_default)
@@ -2048,7 +2047,7 @@ static void *customData_duplicate_referenced_layer_index(CustomData *data, const
 		const LayerTypeInfo *typeInfo = layerType_getInfo(layer->type);
 
 		if (typeInfo->copy) {
-			void *dst_data = MEM_mallocN((size_t)totelem * typeInfo->size, "CD duplicate ref layer");
+			void *dst_data = MEM_malloc_arrayN((size_t)totelem, typeInfo->size, "CD duplicate ref layer");
 			typeInfo->copy(layer->data, dst_data, totelem);
 			layer->data = dst_data;
 		}
@@ -2277,7 +2276,7 @@ void CustomData_interp(const CustomData *source, CustomData *dest,
 	 * elements
 	 */
 	if (count > SOURCE_BUF_SIZE)
-		sources = MEM_mallocN(sizeof(*sources) * count, __func__);
+		sources = MEM_malloc_arrayN(count, sizeof(*sources), __func__);
 
 	/* interpolates a layer at a time */
 	dest_i = 0;
@@ -3144,7 +3143,7 @@ void CustomData_bmesh_interp(
 	 * elements
 	 */
 	if (count > SOURCE_BUF_SIZE)
-		sources = MEM_mallocN(sizeof(*sources) * count, __func__);
+		sources = MEM_malloc_arrayN(count, sizeof(*sources), __func__);
 
 	/* interpolates a layer at a time */
 	for (i = 0; i < data->totlayer; ++i) {
@@ -3334,7 +3333,7 @@ void CustomData_file_write_prepare(
 		else {
 			if (UNLIKELY((size_t)j >= write_layers_size)) {
 				if (write_layers == write_layers_buff) {
-					write_layers = MEM_mallocN(sizeof(*write_layers) * (write_layers_size + chunk_size), __func__);
+					write_layers = MEM_malloc_arrayN((write_layers_size + chunk_size), sizeof(*write_layers), __func__);
 					if (write_layers_buff) {
 						memcpy(write_layers, write_layers_buff, sizeof(*write_layers) * write_layers_size);
 					}
@@ -4002,7 +4001,7 @@ void CustomData_data_transfer(const MeshPairRemap *me_remap, const CustomDataTra
 	}
 
 	if (data_src) {
-		tmp_data_src = MEM_mallocN(sizeof(*tmp_data_src) * tmp_buff_size, __func__);
+		tmp_data_src = MEM_malloc_arrayN(tmp_buff_size, sizeof(*tmp_data_src), __func__);
 	}
 
 	if (data_type & CD_FAKE) {
diff --git a/source/blender/blenkernel/intern/customdata_file.c b/source/blender/blenkernel/intern/customdata_file.c
index 41579aaa56..d17c9ef5cc 100644
--- a/source/blender/blenkernel/intern/customdata_file.c
+++ b/source/blender/blenkernel/intern/customdata_file.c
@@ -210,9 +210,13 @@ static int cdf_read_header(CDataFile *cdf)
 	if (fseek(f, offset, SEEK_SET) != 0)
 		return 0;
 
-	cdf->layer = MEM_callocN(sizeof(CDataFileLayer) * header->totlayer, "CDataFileLayer");
+	cdf->layer = MEM_calloc_arrayN(header->totlayer, sizeof(CDataFileLayer), "CDataFileLayer");
 	cdf->totlayer = header->totlayer;
 
+	if (!cdf->layer) {
+		return 0;
+	}
+
 	for (a = 0; a < header->totlayer; a++) {
 		layer = &cdf->layer[a];
 
@@ -429,7 +433,7 @@ CDataFileLayer *cdf_layer_add(CDataFile *cdf, int type, const char *name, size_t
 	CDataFileLayer *newlayer, *layer;
 
 	/* expand array */
-	newlayer = MEM_callocN(sizeof(CDataFileLayer) * (cdf->totlayer + 1), "CDataFileLayer");
+	newlayer = MEM_calloc_arrayN((cdf->totlayer + 1), sizeof(CDataFileLayer), "CDataFileLayer");
 	memcpy(newlayer, cdf->layer, sizeof(CDataFileLayer) * cdf->totlayer);
 	cdf->layer = newlayer;
 
diff --git a/source/blender/blenkernel/intern/font.c b/source/blender/blenkernel/intern/font.c
index ef479d7791..7c4185616a 100644
--- a/source/blender/blenkernel/intern/font.c
+++ b/source/blender/blenkernel/intern/font.c
@@ -382,7 +382,7 @@ static void build_underline(Curve *cu, ListBase *nubase, const rctf *rect,
 	nu2->orderv = 1;
 	nu2->flagu = CU_NURB_CYCLIC;
 
-	bp = (BPoint *)MEM_callocN(4 * sizeof(BPoint), "underline_bp");
+	bp = (BPoint *)MEM_calloc_arrayN(4, sizeof(BPoint), "underline_bp");
 
 	copy_v4_fl4(bp[0].vec, rect->xmin, (rect->ymax + yofs), 0.0f, 1.0f);
 	copy_v4_fl4(bp[1].vec, rect->xmax, (rect->ymax + yofs), 0.0f, 1.0f);
@@ -481,7 +481,7 @@ static void buildchar(Main *bmain, Curve *cu, ListBase *nubase, unsigned int cha
 			/* nu2->trim.last = 0; */
 			i = nu2->pntsu;
 
-			bezt2 = (BezTriple *)MEM_mallocN(i * sizeof(BezTriple), "duplichar_bezt2");
+			bezt2 = (BezTriple *)MEM_malloc_arrayN(i, sizeof(BezTriple), "duplichar_bezt2");
 			if (bezt2 == NULL) {
 				MEM_freeN(nu2);
 				break;
@@ -692,12 +692,12 @@ bool BKE_vfont_to_curve_ex(Main *bmain, Object *ob, Curve *cu, int mode, ListBas
 		slen = cu->len_wchar;
 
 		/* Create unicode string */
-		mem_tmp = MEM_mallocN(((slen + 1) * sizeof(wchar_t)), "convertedmem");
+		mem_tmp = MEM_malloc_arrayN((slen + 1), sizeof(wchar_t), "convertedmem");
 
 		BLI_strncpy_wchar_from_utf8(mem_tmp, cu->str, slen + 1);
 
 		if (cu->strinfo == NULL) {  /* old file */
-			cu->strinfo = MEM_callocN((slen + 4) * sizeof(CharInfo), "strinfo compat");
+			cu->strinfo = MEM_calloc_arrayN((slen + 4), sizeof(CharInfo), "strinfo compat");
 		}
 		custrinfo = cu->strinfo;
 
@@ -705,7 +705,7 @@ bool BKE_vfont_to_curve_ex(Main *bmain, Object *ob, Curve *cu, int mode, ListBas
 	}
 
 	if (cu->tb == NULL)
-		cu->tb = MEM_callocN(MAXTEXTBOX * sizeof(TextBox), "TextBox compat");
+		cu->tb = MEM_calloc_arrayN(MAXTEXTBOX, sizeof(TextBox), "TextBox compat");
 
 	if (ef != NULL && ob != NULL) {
 		if (ef->selboxes)
@@ -713,7 +713,7 @@ bool BKE_vfont_to_curve_ex(Main *bmain, Object *ob, Curve *cu, int mode, ListBas
 
 		if (BKE_vfont_select_get(ob, &selstart, &selend)) {
 			ef->selboxes_len = (selend - selstart) + 1;
-			ef->selboxes = MEM_callocN(ef->selboxes_len * sizeof(EditFontSelBox), "font selboxes");
+			ef->selboxes = MEM_calloc_arrayN(ef->selboxes_len, sizeof(EditFontSelBox), "font selboxes");
 		}
 		else {
 			ef->selboxes_len = 0;
@@ -724,10 +724,10 @@ bool BKE_vfont_to_curve_ex(Main *bmain, Object *ob, Curve *cu, int mode, ListBas
 	}
 
 	/* calc offset and rotation of each char */
-	ct = chartransdata = MEM_callocN((slen + 1) * sizeof(struct CharTrans), "buildtext");
+	ct = chartransdata = MEM_calloc_arrayN((slen + 1), sizeof(struct CharTrans), "buildtext");
 
 	/* We assume the worst case: 1 character per line (is freed at end anyway) */
-	lineinfo = MEM_mallocN(sizeof(*lineinfo) * (slen * 2 + 1), "lineinfo");
+	lineinfo = MEM_malloc_arrayN((slen * 2 + 1), sizeof(*lineinfo), "lineinfo");
 	
 	linedist = cu->linedist;
 	
@@ -1373,12 +1373,12 @@ void BKE_vfont_clipboard_set(const wchar_t *text_buf, const CharInfo *info_buf,
 	/* clean previous buffers*/
 	BKE_vfont_clipboard_free();
 
-	text = MEM_mallocN((len + 1) * sizeof(wchar_t), __func__);
+	text = MEM_malloc_arrayN((len + 1), sizeof(wchar_t), __func__);
 	if (text == NULL) {
 		return;
 	}
 
-	info = MEM_mallocN(len * sizeof(CharInfo), __func__);
+	info = MEM_malloc_arrayN(len, sizeof(CharInfo), __func__);
 	if (info == NULL) {
 		MEM_freeN(text);
 		return;
diff --git a/source/blender/blenkernel/intern/mesh.c b/source/blender/blenkernel/intern/mesh.c
index a3fa754c72..bf937267b8 100644
--- a/source/blender/blenkernel/intern/mesh.c
+++ b/source/blender/blenkernel/intern/mesh.c
@@ -782,7 +782,7 @@ float (*BKE_mesh_orco_verts_get(Object *ob))[3]
 	float (*vcos)[3] = NULL;
 
 	/* Get appropriate vertex coordinates */
-	vcos = MEM_callocN(sizeof(*vcos) * me->totvert, "orco mesh");
+	vcos = MEM_calloc_arrayN(me->totvert, sizeof(*vcos), "orco mesh");
 	mvert = tme->mvert;
 	totvert = min_ii(tme->totvert, me->totvert);
 
@@ -1021,7 +1021,7 @@ static void make_edges_mdata_extend(MEdge **r_alledge, int *r_totedge,
 		unsigned int e_index = totedge;
 
 		*r_alledge = medge = (*r_alledge ? MEM_reallocN(*r_alledge, sizeof(MEdge) * (totedge + totedge_new)) :
-		                                   MEM_callocN(sizeof(MEdge) * totedge_new, __func__));
+		                                   MEM_calloc_arrayN(totedge_new, sizeof(MEdge), __func__));
 		medge += totedge;
 
 		totedge += totedge_new;
@@ -1141,13 +1141,13 @@ int BKE_mesh_nurbs_displist_to_mdata(
 		return -1;
 	}
 
-	*r_allvert = mvert = MEM_callocN(sizeof(MVert) * totvert, "nurbs_init mvert");
-	*r_alledge = medge = MEM_callocN(sizeof(MEdge) * totedge, "nurbs_init medge");
-	*r_allloop = mloop = MEM_callocN(sizeof(MLoop) * totvlak * 4, "nurbs_init mloop"); // totloop
-	*r_allpoly = mpoly = MEM_callocN(sizeof(MPoly) * totvlak, "nurbs_init mloop");
+	*r_allvert = mvert = MEM_calloc_arrayN(totvert, sizeof(MVert), "nurbs_init mvert");
+	*r_alledge = medge = MEM_calloc_arrayN(totedge, sizeof(MEdge), "nurbs_init medge");
+	*r_allloop = mloop = MEM_calloc_arrayN(totvlak, 4 * sizeof(MLoop), "nurbs_init mloop"); // totloop
+	*r_allpoly = mpoly = MEM_calloc_arrayN(totvlak, sizeof(MPoly), "nurbs_init mloop");
 
 	if (r_alluv)
-		*r_alluv = mloopuv = MEM_callocN(sizeof(MLoopUV) * totvlak * 4, "nurbs_init mloopuv");
+		*r_alluv = mloopuv = MEM_calloc_arrayN(totvlak, 4 * sizeof(MLoopUV), "nurbs_init mloopuv");
 	
 	/* verts and faces */
 	vertcount = 0;
@@ -1487,7 +1487,7 @@ void BKE_mesh_to_curve_nurblist(DerivedMesh *dm, ListBase *nurblist, const int e
 	ListBase edges = {NULL, NULL};
 
 	/* get boundary edges */
-	edge_users = MEM_callocN(sizeof(int) * dm_totedge, __func__);
+	edge_users = MEM_calloc_arrayN(dm_totedge, sizeof(int), __func__);
 	for (i = 0, mp = mpoly; i < dm_totpoly; i++, mp++) {
 		MLoop *ml = &mloop[mp->loopstart];
 		int j;
@@ -1583,7 +1583,7 @@ void BKE_mesh_to_curve_nurblist(DerivedMesh *dm, ListBase *nurblist, const int e
 				nu->flagu = CU_NURB_ENDPOINT | (closed ? CU_NURB_CYCLIC : 0);  /* endpoint */
 				nu->resolu = 12;
 
-				nu->bp = (BPoint *)MEM_callocN(sizeof(BPoint) * totpoly, "bpoints");
+				nu->bp = (BPoint *)MEM_calloc_arrayN(totpoly, sizeof(BPoint), "bpoints");
 
 				/* add points */
 				vl = polyline.first;
@@ -1739,7 +1739,7 @@ void BKE_mesh_smooth_flag_set(Object *meshOb, int enableSmooth)
 float (*BKE_mesh_vertexCos_get(const Mesh *me, int *r_numVerts))[3]
 {
 	int i, numVerts = me->totvert;
-	float (*cos)[3] = MEM_mallocN(sizeof(*cos) * numVerts, "vertexcos1");
+	float (*cos)[3] = MEM_malloc_arrayN(numVerts, sizeof(*cos), "vertexcos1");
 
 	if (r_numVerts) *r_numVerts = numVerts;
 	for (i = 0; i < numVerts; i++)
@@ -1875,7 +1875,7 @@ void BKE_mesh_ensure_navmesh(Mesh *me)
 		int i;
 		int numFaces = me->totpoly;
 		int *recastData;
-		recastData = (int *)MEM_mallocN(numFaces * sizeof(int), __func__);
+		recastData = (int *)MEM_malloc_arrayN(numFaces, sizeof(int), __func__);
 		for (i = 0; i < numFaces; i++) {
 			recastData[i] = i + 1;
 		}
@@ -1963,7 +1963,7 @@ void BKE_mesh_mselect_validate(Mesh *me)
 		return;
 
 	mselect_src = me->mselect;
-	mselect_dst = MEM_mallocN(sizeof(MSelect) * (me->totselect), "Mesh selection history");
+	mselect_dst = MEM_malloc_arrayN((me->totselect), sizeof(MSelect), "Mesh selection history");
 
 	for (i_src = 0, i_dst = 0; i_src < me->totselect; i_src++) {
 		int index = mselect_src[i_src].index;
@@ -2106,7 +2106,7 @@ void BKE_mesh_calc_normals_split_ex(Mesh *mesh, MLoopNorSpaceArray *r_lnors_spac
 		free_polynors = false;
 	}
 	else {
-		polynors = MEM_mallocN(sizeof(float[3]) * mesh->totpoly, __func__);
+		polynors = MEM_malloc_arrayN(mesh->totpoly, sizeof(float[3]), __func__);
 		BKE_mesh_calc_normals_poly(
 		            mesh->mvert, NULL, mesh->totvert,
 		            mesh->mloop, mesh->mpoly, mesh->totloop, mesh->totpoly, polynors, false);
diff --git a/source/blender/blenkernel/intern/mesh_evaluate.c b/source/blender/blenkernel/intern/mesh_evaluate.c
index 76c629912a..f95fad38c7 100644
--- a/source/blender/blenkernel/intern/mesh_evaluate.c
+++ b/source/blender/blenkernel/intern/mesh_evaluate.c
@@ -127,8 +127,8 @@ void BKE_mesh_calc_normals_mapping_ex(
 		return;
 	}
 
-	if (!pnors) pnors = MEM_callocN(sizeof(float[3]) * (size_t)numPolys, __func__);
-	/* if (!fnors) fnors = MEM_callocN(sizeof(float[3]) * numFaces, "face nors mesh.c"); */ /* NO NEED TO ALLOC YET */
+	if (!pnors) pnors = MEM_calloc_arrayN((size_t)numPolys, sizeof(float[3]), __func__);
+	/* if (!fnors) fnors = MEM_calloc_arrayN(numFaces, sizeof(float[3]), "face nors mesh.c"); */ /* NO NEED TO ALLOC YET */
 
 
 	if (only_face_normals == false) {
@@ -306,12 +306,12 @@ void BKE_mesh_calc_normals_poly(
 	}
 
 	float (*vnors)[3] = r_vertnors;
-	float (*lnors_weighted)[3] = MEM_mallocN(sizeof(*lnors_weighted) * (size_t)numLoops, __func__);
+	float (*lnors_weighted)[3] = MEM_malloc_arrayN((size_t)numLoops, sizeof(*lnors_weighted), __func__);
 	bool free_vnors = false;
 
 	/* first go through and calculate normals for all the polys */
 	if (vnors == NULL) {
-		vnors = MEM_callocN(sizeof(*vnors) * (size_t)numVerts, __func__);
+		vnors = MEM_calloc_arrayN((size_t)numVerts, sizeof(*vnors), __func__);
 		free_vnors = true;
 	}
 	else {
@@ -356,10 +356,14 @@ void BKE_mesh_calc_normals_tessface(
         const MFace *mfaces, int numFaces,
         float (*r_faceNors)[3])
 {
-	float (*tnorms)[3] = MEM_callocN(sizeof(*tnorms) * (size_t)numVerts, "tnorms");
-	float (*fnors)[3] = (r_faceNors) ? r_faceNors : MEM_callocN(sizeof(*fnors) * (size_t)numFaces, "meshnormals");
+	float (*tnorms)[3] = MEM_calloc_arrayN((size_t)numVerts, sizeof(*tnorms), "tnorms");
+	float (*fnors)[3] = (r_faceNors) ? r_faceNors : MEM_calloc_arrayN((size_t)numFaces, sizeof(*fnors), "meshnormals");
 	int i;
 
+	if (!tnorms || !fnors) {
+		goto cleanup;
+	}
+
 	for (i = 0; i < numFaces; i++) {
 		const MFace *mf = &mfaces[i];
 		float *f_no = fnors[i];
@@ -388,6 +392,7 @@ void BKE_mesh_calc_normals_tessface(
 		normal_float_to_short_v3(mv->no, no);
 	}
 	
+cleanup:
 	MEM_freeN(tnorms);
 
 	if (fnors != r_faceNors)
@@ -400,10 +405,14 @@ void BKE_mesh_calc_normals_looptri(
         const MLoopTri *looptri, int looptri_num,
         float (*r_tri_nors)[3])
 {
-	float (*tnorms)[3] = MEM_callocN(sizeof(*tnorms) * (size_t)numVerts, "tnorms");
-	float (*fnors)[3] = (r_tri_nors) ? r_tri_nors : MEM_callocN(sizeof(*fnors) * (size_t)looptri_num, "meshnormals");
+	float (*tnorms)[3] = MEM_calloc_arrayN((size_t)numVerts, sizeof(*tnorms), "tnorms");
+	float (*fnors)[3] = (r_tri_nors) ? r_tri_nors : MEM_calloc_arrayN((size_t)looptri_num, sizeof(*fnors), "meshnormals");
 	int i;
 
+	if (!tnorms || !fnors) {
+		goto cleanup;
+	}
+
 	for (i = 0; i < looptri_num; i++) {
 		const MLoopTri *lt = &looptri[i];
 		float *f_no = fnors[i];
@@ -434,6 +443,7 @@ void BKE_mesh_calc_normals_looptri(
 		normal_float_to_short_v3(mv->no, no);
 	}
 
+cleanup:
 	MEM_freeN(tnorms);
 
 	if (fnors != r_tri_nors)
@@ -1174,7 +1184,7 @@ static void loop_split_generator(TaskPool *pool, LoopSplitTaskDataCommon *common
 
 				if (pool) {
 					if (data_idx == 0) {
-						data_buff = MEM_callocN(sizeof(*data_buff) * LOOP_SPLIT_TASK_BLOCK_SIZE, __func__);
+						data_buff = MEM_calloc_arrayN(LOOP_SPLIT_TASK_BLOCK_SIZE, sizeof(*data_buff), __func__);
 					}
 					data = &data_buff[data_idx];
 				}
@@ -1304,10 +1314,10 @@ void BKE_mesh_normals_loop_split(
 	 * store the negated value of loop index instead of INDEX_INVALID to retrieve the real value later in code).
 	 * Note also that lose edges always have both values set to 0!
 	 */
-	int (*edge_to_loops)[2] = MEM_callocN(sizeof(*edge_to_loops) * (size_t)numEdges, __func__);
+	int (*edge_to_loops)[2] = MEM_calloc_arrayN((size_t)numEdges, sizeof(*edge_to_loops), __func__);
 
 	/* Simple mapping from a loop to its polygon index. */
-	int *loop_to_poly = r_loop_to_poly ? r_loop_to_poly : MEM_mallocN(sizeof(*loop_to_poly) * (size_t)numLoops, __func__);
+	int *loop_to_poly = r_loop_to_poly ? r_loop_to_poly : MEM_malloc_arrayN((size_t)numLoops, sizeof(*loop_to_poly), __func__);
 
 	MPoly *mp;
 	int mp_index;
@@ -1461,8 +1471,8 @@ static void mesh_normals_loop_custom_set(
 	 */
 	MLoopNorSpaceArray lnors_spacearr = {NULL};
 	BLI_bitmap *done_loops = BLI_BITMAP_NEW((size_t)numLoops, __func__);
-	float (*lnors)[3] = MEM_callocN(sizeof(*lnors) * (size_t)numLoops, __func__);
-	int *loop_to_poly = MEM_mallocN(sizeof(int) * (size_t)numLoops, __func__);
+	float (*lnors)[3] = MEM_calloc_arrayN((size_t)numLoops, sizeof(*lnors), __func__);
+	int *loop_to_poly = MEM_malloc_arrayN((size_t)numLoops, sizeof(int), __func__);
 	/* In this case we always consider split nors as ON, and do not want to use angle to define smooth fans! */
 	const bool use_split_normals = true;
 	const float split_angle = (float)M_PI;
@@ -1677,7 +1687,7 @@ void BKE_mesh_normals_loop_to_vertex(
 	const MLoop *ml;
 	int i;
 
-	int *vert_loops_nbr = MEM_callocN(sizeof(*vert_loops_nbr) * (size_t)numVerts, __func__);
+	int *vert_loops_nbr = MEM_calloc_arrayN((size_t)numVerts, sizeof(*vert_loops_nbr), __func__);
 
 	copy_vn_fl((float *)r_vert_clnors, 3 * numVerts, 0.0f);
 
@@ -2669,9 +2679,9 @@ int BKE_mesh_recalc_tessellation(
 	/* allocate the length of totfaces, avoid many small reallocs,
 	 * if all faces are tri's it will be correct, quads == 2x allocs */
 	/* take care. we are _not_ calloc'ing so be sure to initialize each field */
-	mface_to_poly_map = MEM_mallocN(sizeof(*mface_to_poly_map) * (size_t)looptri_num, __func__);
-	mface             = MEM_mallocN(sizeof(*mface) *             (size_t)looptri_num, __func__);
-	lindices          = MEM_mallocN(sizeof(*lindices) *          (size_t)looptri_num, __func__);
+	mface_to_poly_map = MEM_malloc_arrayN((size_t)looptri_num, sizeof(*mface_to_poly_map), __func__);
+	mface             = MEM_malloc_arrayN((size_t)looptri_num, sizeof(*mface), __func__);
+	lindices          = MEM_malloc_arrayN((size_t)looptri_num, sizeof(*lindices), __func__);
 
 	mface_index = 0;
 	mp = mpoly;
@@ -3051,7 +3061,7 @@ int BKE_mesh_mpoly_to_mface(struct CustomData *fdata, struct CustomData *ldata,
 	const bool hasLNor = CustomData_has_layer(ldata, CD_NORMAL);
 
 	/* over-alloc, ngons will be skipped */
-	mface = MEM_mallocN(sizeof(*mface) * (size_t)totpoly, __func__);
+	mface = MEM_malloc_arrayN((size_t)totpoly, sizeof(*mface), __func__);
 
 	mpoly = CustomData_get_layer(pdata, CD_MPOLY);
 	mloop = CustomData_get_layer(ldata, CD_MLOOP);
@@ -3219,7 +3229,6 @@ static void bm_corners_to_loops_ex(ID *id, CustomData *fdata, CustomData *ldata,
 		else {
 			const int side = (int)sqrtf((float)(fd->totdisp / corners));
 			const int side_sq = side * side;
-			const size_t disps_size = sizeof(float[3]) * (size_t)side_sq;
 
 			for (i = 0; i < tot; i++, disps += side_sq, ld++) {
 				ld->totdisp = side_sq;
@@ -3228,12 +3237,12 @@ static void bm_corners_to_loops_ex(ID *id, CustomData *fdata, CustomData *ldata,
 				if (ld->disps)
 					MEM_freeN(ld->disps);
 
-				ld->disps = MEM_mallocN(disps_size, "converted loop mdisps");
+				ld->disps = MEM_malloc_arrayN((size_t)side_sq, sizeof(float[3]), "converted loop mdisps");
 				if (fd->disps) {
-					memcpy(ld->disps, disps, disps_size);
+					memcpy(ld->disps, disps, (size_t)side_sq * sizeof(float[3]));
 				}
 				else {
-					memset(ld->disps, 0, disps_size);
+					memset(ld->disps, 0, (size_t)side_sq * sizeof(float[3]));
 				}
 			}
 		}
@@ -3295,7 +3304,7 @@ void BKE_mesh_convert_mfaces_to_mpolys_ex(ID *id, CustomData *fdata, CustomData
 	CustomData_free(pdata, totpoly_i);
 
 	totpoly = totface_i;
-	mpoly = MEM_callocN(sizeof(MPoly) * (size_t)totpoly, "mpoly converted");
+	mpoly = MEM_calloc_arrayN((size_t)totpoly, sizeof(MPoly), "mpoly converted");
 	CustomData_add_layer(pdata, CD_MPOLY, CD_ASSIGN, mpoly, totpoly);
 
 	numTex = CustomData_number_of_layers(fdata, CD_MTFACE);
@@ -3307,7 +3316,7 @@ void BKE_mesh_convert_mfaces_to_mpolys_ex(ID *id, CustomData *fdata, CustomData
 		totloop += mf->v4 ? 4 : 3;
 	}
 
-	mloop = MEM_callocN(sizeof(MLoop) * (size_t)totloop, "mloop converted");
+	mloop = MEM_calloc_arrayN((size_t)totloop, sizeof(MLoop), "mloop converted");
 
 	CustomData_add_layer(ldata, CD_MLOOP, CD_ASSIGN, mloop, totloop);
 
@@ -3706,7 +3715,7 @@ void BKE_mesh_calc_relative_deform(
 	const MPoly *mp;
 	int i;
 
-	int *vert_accum = MEM_callocN(sizeof(*vert_accum) * (size_t)totvert, __func__);
+	int *vert_accum = MEM_calloc_arrayN((size_t)totvert, sizeof(*vert_accum), __func__);
 
 	memset(vert_cos_new, '\0', sizeof(*vert_cos_new) * (size_t)totvert);
 
diff --git a/source/blender/blenkernel/intern/multires.c b/source/blender/blenkernel/intern/multires.c
index 3fc052414e..9c8fc9bfd0 100644
--- a/source/blender/blenkernel/intern/multires.c
+++ b/source/blender/blenkernel/intern/multires.c
@@ -440,7 +440,7 @@ int multiresModifier_reshapeFromDeformMod(Scene *scene, MultiresModifierData *mm
 	/* Create DerivedMesh for deformation modifier */
 	dm = get_multires_dm(scene, mmd, ob);
 	numVerts = dm->getNumVerts(dm);
-	deformedVerts = MEM_mallocN(sizeof(float[3]) * numVerts, "multiresReshape_deformVerts");
+	deformedVerts = MEM_malloc_arrayN(numVerts, sizeof(float[3]), "multiresReshape_deformVerts");
 
 	dm->getVertCos(dm, deformedVerts);
 	mti->deformVerts(md, ob, dm, deformedVerts, numVerts, 0);
@@ -533,7 +533,7 @@ static void multires_reallocate_mdisps(int totloop, MDisps *mdisps, int lvl)
 	/* reallocate displacements to be filled in */
 	for (i = 0; i < totloop; ++i) {
 		int totdisp = multires_grid_tot[lvl];
-		float (*disps)[3] = MEM_callocN(sizeof(float) * 3 * totdisp, "multires disps");
+		float (*disps)[3] = MEM_calloc_arrayN(totdisp, 3 * sizeof(float), "multires disps");
 
 		if (mdisps[i].disps)
 			MEM_freeN(mdisps[i].disps);
@@ -597,7 +597,7 @@ static void multires_grid_paint_mask_downsample(GridPaintMask *gpm, int level)
 {
 	if (level < gpm->level) {
 		int gridsize = BKE_ccg_gridsize(level);
-		float *data = MEM_callocN(sizeof(float) * SQUARE(gridsize),
+		float *data = MEM_calloc_arrayN(SQUARE(gridsize), sizeof(float),
 		                          "multires_grid_paint_mask_downsample");
 		int x, y;
 
@@ -642,7 +642,7 @@ static void multires_del_higher(MultiresModifierData *mmd, Object *ob, int lvl)
 					float (*disps)[3], (*ndisps)[3], (*hdisps)[3];
 					int totdisp = multires_grid_tot[lvl];
 
-					disps = MEM_callocN(sizeof(float) * 3 * totdisp, "multires disps");
+					disps = MEM_calloc_arrayN(totdisp, 3 * sizeof(float), "multires disps");
 
 					ndisps = disps;
 					hdisps = mdisp->disps;
@@ -785,7 +785,7 @@ void multiresModifier_base_apply(MultiresModifierData *mmd, Object *ob)
 
 	cddm = CDDM_from_mesh(me);
 	pmap = cddm->getPolyMap(ob, cddm);
-	origco = MEM_callocN(sizeof(float) * 3 * me->totvert, "multires apply base origco");
+	origco = MEM_calloc_arrayN(me->totvert, 3 * sizeof(float), "multires apply base origco");
 	for (i = 0; i < me->totvert; ++i)
 		copy_v3_v3(origco[i], me->mvert[i].co);
 
@@ -825,8 +825,8 @@ void multiresModifier_base_apply(MultiresModifierData *mmd, Object *ob)
 			 * BKE_mesh_calc_poly_normal_coords() */
 			fake_poly.totloop = p->totloop;
 			fake_poly.loopstart = 0;
-			fake_loops = MEM_mallocN(sizeof(MLoop) * p->totloop, "fake_loops");
-			fake_co = MEM_mallocN(sizeof(float) * 3 * p->totloop, "fake_co");
+			fake_loops = MEM_malloc_arrayN(p->totloop, sizeof(MLoop), "fake_loops");
+			fake_co = MEM_malloc_arrayN(p->totloop, 3 * sizeof(float), "fake_co");
 			
 			for (k = 0; k < p->totloop; ++k) {
 				int vndx = me->mloop[p->loopstart + k].v;
@@ -923,11 +923,11 @@ static void multires_subdivide(MultiresModifierData *mmd, Object *ob, int totlvl
 		lowGridData = lowdm->getGridData(lowdm);
 		lowdm->getGridKey(lowdm, &lowGridKey);
 
-		subGridData = MEM_callocN(sizeof(float *) * numGrids, "subGridData*");
+		subGridData = MEM_calloc_arrayN(numGrids, sizeof(float *), "subGridData*");
 
 		for (i = 0; i < numGrids; ++i) {
 			/* backup subsurf grids */
-			subGridData[i] = MEM_callocN(highGridKey.elem_size * highGridSize * highGridSize, "subGridData");
+			subGridData[i] = MEM_calloc_arrayN(highGridKey.elem_size, highGridSize * highGridSize, "subGridData");
 			memcpy(subGridData[i], highGridData[i], highGridKey.elem_size * highGridSize * highGridSize);
 
 			/* overwrite with current displaced grids */
@@ -1054,7 +1054,7 @@ static void multires_disp_run_cb(
 			if (gpm->data) {
 				MEM_freeN(gpm->data);
 			}
-			gpm->data = MEM_callocN(sizeof(float) * key->grid_area, "gpm.data");
+			gpm->data = MEM_calloc_arrayN(key->grid_area, sizeof(float), "gpm.data");
 		}
 
 		for (y = 0; y < gridSize; y++) {
@@ -1247,12 +1247,12 @@ void multires_modifier_update_mdisps(struct DerivedMesh *dm)
 
 			BLI_assert(highGridKey.elem_size == lowGridKey.elem_size);
 
-			subGridData = MEM_callocN(sizeof(CCGElem *) * numGrids, "subGridData*");
-			diffGrid = MEM_callocN(lowGridKey.elem_size * lowGridSize * lowGridSize, "diff");
+			subGridData = MEM_calloc_arrayN(numGrids, sizeof(CCGElem *), "subGridData*");
+			diffGrid = MEM_calloc_arrayN(lowGridKey.elem_size, lowGridSize * lowGridSize, "diff");
 
 			for (i = 0; i < numGrids; ++i) {
 				/* backup subsurf grids */
-				subGridData[i] = MEM_callocN(highGridKey.elem_size * highGridSize * highGridSize, "subGridData");
+				subGridData[i] = MEM_calloc_arrayN(highGridKey.elem_size, highGridSize * highGridSize, "subGridData");
 				memcpy(subGridData[i], highGridData[i], highGridKey.elem_size * highGridSize * highGridSize);
 
 				/* write difference of subsurf and displaced low level into high subsurf */
@@ -1363,10 +1363,10 @@ void multires_set_space(DerivedMesh *dm, Object *ob, int from, int to)
 	gridData = subsurf->getGridData(subsurf);
 	subsurf->getGridKey(subsurf, &key);
 
-	subGridData = MEM_callocN(sizeof(CCGElem *) * numGrids, "subGridData*");
+	subGridData = MEM_calloc_arrayN(numGrids, sizeof(CCGElem *), "subGridData*");
 
 	for (i = 0; i < numGrids; i++) {
-		subGridData[i] = MEM_callocN(key.elem_size * gridSize * gridSize, "subGridData");
+		subGridData[i] = MEM_calloc_arrayN(key.elem_size, gridSize * gridSize, "subGridData");
 		memcpy(subGridData[i], gridData[i], key.elem_size * gridSize * gridSize);
 	}
 	
@@ -1395,7 +1395,7 @@ void multires_set_space(DerivedMesh *dm, Object *ob, int from, int to)
 			if (!mdisp->disps) {
 				mdisp->totdisp = gridSize * gridSize;
 				mdisp->level = totlvl;
-				mdisp->disps = MEM_callocN(sizeof(float) * 3 * mdisp->totdisp, "disp in multires_set_space");
+				mdisp->disps = MEM_calloc_arrayN(mdisp->totdisp, 3 * sizeof(float), "disp in multires_set_space");
 			}
 
 			dispgrid = mdisp->disps;
@@ -1510,10 +1510,10 @@ DerivedMesh *multires_make_derived_from_derived(DerivedMesh *dm,
 	gridData = result->getGridData(result);
 	result->getGridKey(result, &key);
 
-	subGridData = MEM_mallocN(sizeof(CCGElem *) * numGrids, "subGridData*");
+	subGridData = MEM_malloc_arrayN(numGrids, sizeof(CCGElem *), "subGridData*");
 
 	for (i = 0; i < numGrids; i++) {
-		subGridData[i] = MEM_mallocN(key.elem_size * gridSize * gridSize, "subGridData");
+		subGridData[i] = MEM_malloc_arrayN(key.elem_size, gridSize * gridSize, "subGridData");
 		memcpy(subGridData[i], gridData[i], key.elem_size * gridSize * gridSize);
 	}
 
@@ -1603,7 +1603,7 @@ static void old_mdisps_convert(MFace *mface, MDisps *mdisp)
 	int x, y, S;
 	float (*disps)[3], (*out)[3], u = 0.0f, v = 0.0f; /* Quite gcc barking. */
 
-	disps = MEM_callocN(sizeof(float) * 3 * newtotdisp, "multires disps");
+	disps = MEM_calloc_arrayN(newtotdisp, 3 * sizeof(float), "multires disps");
 
 	out = disps;
 	for (S = 0; S < nvert; S++) {
@@ -1650,7 +1650,7 @@ void multires_load_old_250(Mesh *me)
 			int totdisp = mdisps[i].totdisp / nvert;
 			
 			for (j = 0; j < nvert; j++, k++) {
-				mdisps2[k].disps = MEM_callocN(sizeof(float) * 3 * totdisp, "multires disp in conversion");
+				mdisps2[k].disps = MEM_calloc_arrayN(totdisp, 3 * sizeof(float), "multires disp in conversion");
 				mdisps2[k].totdisp = totdisp;
 				mdisps2[k].level = mdisps[i].level;
 				memcpy(mdisps2[k].disps, mdisps[i].disps + totdisp * j, totdisp);
@@ -1710,8 +1710,8 @@ static void create_old_vert_face_map(ListBase **map, IndexNode **mem, const Mult
 	int i, j;
 	IndexNode *node = NULL;
 	
-	(*map) = MEM_callocN(sizeof(ListBase) * totvert, "vert face map");
-	(*mem) = MEM_callocN(sizeof(IndexNode) * totface * 4, "vert face map mem");
+	(*map) = MEM_calloc_arrayN(totvert, sizeof(ListBase), "vert face map");
+	(*mem) = MEM_calloc_arrayN(totface, 4 * sizeof(IndexNode), "vert face map mem");
 	node = *mem;
 	
 	/* Find the users */
@@ -1729,8 +1729,8 @@ static void create_old_vert_edge_map(ListBase **map, IndexNode **mem, const Mult
 	int i, j;
 	IndexNode *node = NULL;
 	
-	(*map) = MEM_callocN(sizeof(ListBase) * totvert, "vert edge map");
-	(*mem) = MEM_callocN(sizeof(IndexNode) * totedge * 2, "vert edge map mem");
+	(*map) = MEM_calloc_arrayN(totvert, sizeof(ListBase), "vert edge map");
+	(*mem) = MEM_calloc_arrayN(totedge, 2 * sizeof(IndexNode), "vert edge map mem");
 	node = *mem;
 	
 	/* Find the users */
@@ -1912,7 +1912,11 @@ static void multires_load_old_dm(DerivedMesh *dm, Mesh *me, int totlvl)
 	vsrc = mr->verts;
 	vdst = dm->getVertArray(dm);
 	totvert = (unsigned int)dm->getNumVerts(dm);
-	vvmap = MEM_callocN(sizeof(int) * totvert, "multires vvmap");
+	vvmap = MEM_calloc_arrayN(totvert, sizeof(int), "multires vvmap");
+
+	if (!vvmap) {
+		return;
+	}
 
 	lvl1 = mr->levels.first;
 	/* Load base verts */
@@ -1997,10 +2001,10 @@ static void multires_load_old_dm(DerivedMesh *dm, Mesh *me, int totlvl)
 		}
 
 		/* calculate vert to edge/face maps for each level (except the last) */
-		fmap = MEM_callocN(sizeof(ListBase *) * (mr->level_count - 1), "multires fmap");
-		emap = MEM_callocN(sizeof(ListBase *) * (mr->level_count - 1), "multires emap");
-		fmem = MEM_callocN(sizeof(IndexNode *) * (mr->level_count - 1), "multires fmem");
-		emem = MEM_callocN(sizeof(IndexNode *) * (mr->level_count - 1), "multires emem");
+		fmap = MEM_calloc_arrayN((mr->level_count - 1), sizeof(ListBase *), "multires fmap");
+		emap = MEM_calloc_arrayN((mr->level_count - 1), sizeof(ListBase *), "multires emap");
+		fmem = MEM_calloc_arrayN((mr->level_count - 1), sizeof(IndexNode *), "multires fmem");
+		emem = MEM_calloc_arrayN((mr->level_count - 1), sizeof(IndexNode *), "multires emem");
 		lvl = lvl1;
 		for (i = 0; i < (unsigned int)mr->level_count - 1; ++i) {
 			create_old_vert_face_map(fmap + i, fmem + i, lvl->faces, lvl->totvert, lvl->totface);
@@ -2302,7 +2306,7 @@ static void multires_apply_smat(Scene *scene, Object *ob, float smat[3][3])
 	cddm = mesh_get_derived_deform(scene, ob, CD_MASK_BAREMESH);
 
 	totvert = cddm->getNumVerts(cddm);
-	vertCos = MEM_mallocN(sizeof(*vertCos) * totvert, "multiresScale vertCos");
+	vertCos = MEM_malloc_arrayN(totvert, sizeof(*vertCos), "multiresScale vertCos");
 	cddm->getVertCos(cddm, vertCos);
 	for (i = 0; i < totvert; i++)
 		mul_m3_v3(smat, vertCos[i]);
@@ -2410,7 +2414,7 @@ void multires_topology_changed(Mesh *me)
 		if (!mdisp->totdisp || !mdisp->disps) {
 			if (grid) {
 				mdisp->totdisp = grid;
-				mdisp->disps = MEM_callocN(3 * mdisp->totdisp * sizeof(float), "mdisp topology");
+				mdisp->disps = MEM_calloc_arrayN(3 * sizeof(float),  mdisp->totdisp, "mdisp topology");
 			}
 
 			continue;
diff --git a/source/blender/blenloader/intern/readfile.c b/source/blender/blenloader/intern/readfile.c
index 51b77938de..8edaf071f3 100644
--- a/source/blender/blenloader/intern/readfile.c
+++ b/source/blender/blenloader/intern/readfile.c
@@ -289,7 +289,7 @@ static OldNewMap *oldnewmap_new(void)
 	OldNewMap *onm= MEM_callocN(sizeof(*onm), "OldNewMap");
 	
 	onm->entriessize = 1024;
-	onm->entries = MEM_mallocN(sizeof(*onm->entries)*onm->entriessize, "OldNewMap.entries");
+	onm->entries = MEM_malloc_arrayN(onm->entriessize, sizeof(*onm->entries), "OldNewMap.entries");
 	
 	return onm;
 }
@@ -536,7 +536,7 @@ void blo_split_main(ListBase *mainlist, Main *main)
 	
 	/* (Library.temp_index -> Main), lookup table */
 	const unsigned int lib_main_array_len = BLI_listbase_count(&main->library);
-	Main             **lib_main_array     = MEM_mallocN(lib_main_array_len * sizeof(*lib_main_array), __func__);
+	Main             **lib_main_array     = MEM_malloc_arrayN(lib_main_array_len, sizeof(*lib_main_array), __func__);
 
 	int i = 0;
 	for (Library *lib = main->library.first; lib; lib = lib->id.next, i++) {
@@ -1994,7 +1994,7 @@ static void test_pointer_array(FileData *fd, void **mat)
 		len = MEM_allocN_len(*mat)/fd->filesdna->pointerlen;
 			
 		if (fd->filesdna->pointerlen==8 && fd->memsdna->pointerlen==4) {
-			ipoin=imat= MEM_mallocN(len * 4, "newmatar");
+			ipoin=imat= MEM_malloc_arrayN(len, 4, "newmatar");
 			lpoin= *mat;
 			
 			while (len-- > 0) {
@@ -2009,7 +2009,7 @@ static void test_pointer_array(FileData *fd, void **mat)
 		}
 		
 		if (fd->filesdna->pointerlen==4 && fd->memsdna->pointerlen==8) {
-			lpoin = lmat = MEM_mallocN(len * 8, "newmatar");
+			lpoin = lmat = MEM_malloc_arrayN(len, 8, "newmatar");
 			ipoin = *mat;
 			
 			while (len-- > 0) {
@@ -3871,7 +3871,7 @@ static void direct_link_curve(FileData *fd, Curve *cu)
 	else {
 		cu->nurb.first=cu->nurb.last= NULL;
 		
-		tb = MEM_callocN(MAXTEXTBOX*sizeof(TextBox), "TextBoxread");
+		tb = MEM_calloc_arrayN(MAXTEXTBOX, sizeof(TextBox), "TextBoxread");
 		if (cu->tb) {
 			memcpy(tb, cu->tb, cu->totbox*sizeof(TextBox));
 			MEM_freeN(cu->tb);
@@ -5266,9 +5266,9 @@ static void direct_link_modifiers(FileData *fd, ListBase *lb)
 			collmd->xnew = newdataadr(fd, collmd->xnew);
 			collmd->mfaces = newdataadr(fd, collmd->mfaces);
 			
-			collmd->current_x = MEM_callocN(sizeof(MVert)*collmd->numverts, "current_x");
-			collmd->current_xnew = MEM_callocN(sizeof(MVert)*collmd->numverts, "current_xnew");
-			collmd->current_v = MEM_callocN(sizeof(MVert)*collmd->numverts, "current_v");
+			collmd->current_x = MEM_calloc_arrayN(collmd->numverts, sizeof(MVert), "current_x");
+			collmd->current_xnew = MEM_calloc_arrayN(collmd->numverts, sizeof(MVert), "current_xnew");
+			collmd->current_v = MEM_calloc_arrayN(collmd->numverts, sizeof(MVert), "current_v");
 #endif
 			
 			collmd->x = NULL;
@@ -8763,7 +8763,7 @@ static void sort_bhead_old_map(FileData *fd)
 	fd->tot_bheadmap = tot;
 	if (tot == 0) return;
 	
-	bhs = fd->bheadmap = MEM_mallocN(tot * sizeof(struct BHeadSort), "BHeadSort");
+	bhs = fd->bheadmap = MEM_malloc_arrayN(tot, sizeof(struct BHeadSort), "BHeadSort");
 	
 	for (bhead = blo_firstbhead(fd); bhead; bhead = blo_nextbhead(fd, bhead), bhs++) {
 		bhs->bhead = bhead;
diff --git a/source/blender/blenloader/intern/versioning_250.c b/source/blender/blenloader/intern/versioning_250.c
index 1956a17d57..97fdee748d 100644
--- a/source/blender/blenloader/intern/versioning_250.c
+++ b/source/blender/blenloader/intern/versioning_250.c
@@ -951,7 +951,7 @@ void blo_do_versions_250(FileData *fd, Library *lib, Main *main)
 			if (ob->totcol && ob->matbits == NULL) {
 				int a;
 
-				ob->matbits = MEM_callocN(sizeof(char)*ob->totcol, "ob->matbits");
+				ob->matbits = MEM_calloc_arrayN(ob->totcol, sizeof(char), "ob->matbits");
 				for (a = 0; a < ob->totcol; a++)
 					ob->matbits[a] = (ob->colbits & (1<<a)) != 0;
 			}
diff --git a/source/blender/blenloader/intern/versioning_legacy.c b/source/blender/blenloader/intern/versioning_legacy.c
index acb9ad581c..90dd968131 100644
--- a/source/blender/blenloader/intern/versioning_legacy.c
+++ b/source/blender/blenloader/intern/versioning_legacy.c
@@ -113,7 +113,7 @@ static void vcol_to_fcol(Mesh *me)
 	if (me->totface == 0 || me->mcol == NULL)
 		return;
 
-	mcoln = mcolmain = MEM_mallocN(4*sizeof(int)*me->totface, "mcoln");
+	mcoln = mcolmain = MEM_malloc_arrayN(me->totface, 4 * sizeof(int), "mcoln");
 	mcol = (unsigned int *)me->mcol;
 	mface = me->mface;
 	for (a = me->totface; a > 0; a--, mface++) {
diff --git a/source/blender/editors/space_view3d/drawobject.c b/source/blender/editors/space_view3d/drawobject.c
index d2f7f5e8a1..92faf743ad 100644
--- a/source/blender/editors/space_view3d/drawobject.c
+++ b/source/blender/editors/space_view3d/drawobject.c
@@ -5762,7 +5762,7 @@ static void draw_ptcache_edit(Scene *scene, View3D *v3d, PTCacheEdit *edit)
 	totkeys = (*edit->pathcache)->segments + 1;
 
 	glEnable(GL_BLEND);
-	pathcol = MEM_callocN(totkeys * 4 * sizeof(float), "particle path color data");
+	pathcol = MEM_calloc_arrayN(totkeys, 4 * sizeof(float), "particle path color data");
 
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_COLOR_ARRAY);
@@ -5815,8 +5815,8 @@ static void draw_ptcache_edit(Scene *scene, View3D *v3d, PTCacheEdit *edit)
 
 			if (totkeys_visible) {
 				if (edit->points && !(edit->points->keys->flag & PEK_USE_WCO))
-					pd = pdata = MEM_callocN(totkeys_visible * 3 * sizeof(float), "particle edit point data");
-				cd = cdata = MEM_callocN(totkeys_visible * (timed ? 4 : 3) * sizeof(float), "particle edit color data");
+					pd = pdata = MEM_calloc_arrayN(totkeys_visible, 3 * sizeof(float), "particle edit point data");
+				cd = cdata = MEM_calloc_arrayN(totkeys_visible, (timed ? 4 : 3) * sizeof(float), "particle edit color data");
 			}
 
 			for (i = 0, point = edit->points; i < totpoint; i++, point++) {
diff --git a/source/blender/modifiers/intern/MOD_array.c b/source/blender/modifiers/intern/MOD_array.c
index a3f3af0c74..8eda165395 100644
--- a/source/blender/modifiers/intern/MOD_array.c
+++ b/source/blender/modifiers/intern/MOD_array.c
@@ -217,8 +217,8 @@ static void dm_mvert_map_doubles(
 	source_end = source_start + source_num_verts;
 
 	/* build array of MVerts to be tested for merging */
-	sorted_verts_target = MEM_mallocN(sizeof(SortVertsElem) * target_num_verts, __func__);
-	sorted_verts_source = MEM_mallocN(sizeof(SortVertsElem) * source_num_verts, __func__);
+	sorted_verts_target = MEM_malloc_arrayN(target_num_verts, sizeof(SortVertsElem), __func__);
+	sorted_verts_source = MEM_malloc_arrayN(source_num_verts, sizeof(SortVertsElem), __func__);
 
 	/* Copy target vertices index and cos into SortVertsElem array */
 	svert_from_mvert(sorted_verts_target, mverts + target_start, target_start, target_end);
@@ -538,7 +538,7 @@ static DerivedMesh *arrayModifier_doArray(
 
 	if (use_merge) {
 		/* Will need full_doubles_map for handling merge */
-		full_doubles_map = MEM_mallocN(sizeof(int) * result_nverts, "mod array doubles map");
+		full_doubles_map = MEM_malloc_arrayN(result_nverts, sizeof(int), "mod array doubles map");
 		copy_vn_i(full_doubles_map, result_nverts, -1);
 	}
 
diff --git a/source/blender/modifiers/intern/MOD_boolean.c b/source/blender/modifiers/intern/MOD_boolean.c
index 1140460161..45c829e05f 100644
--- a/source/blender/modifiers/intern/MOD_boolean.c
+++ b/source/blender/modifiers/intern/MOD_boolean.c
@@ -257,7 +257,7 @@ static DerivedMesh *applyModifier_bmesh(
 				int tottri;
 				BMLoop *(*looptris)[3];
 
-				looptris = MEM_mallocN(sizeof(*looptris) * looptris_tot, __func__);
+				looptris = MEM_malloc_arrayN(looptris_tot, sizeof(*looptris), __func__);
 
 				BM_mesh_calc_tessellation_beauty(bm, looptris, &tottri);
 
diff --git a/source/blender/modifiers/intern/MOD_build.c b/source/blender/modifiers/intern/MOD_build.c
index 56a274b9ac..62da8b8ffe 100644
--- a/source/blender/modifiers/intern/MOD_build.c
+++ b/source/blender/modifiers/intern/MOD_build.c
@@ -104,9 +104,9 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *UNUSED(ob),
 	MVert *mvert_src = dm->getVertArray(dm);
 
 
-	vertMap = MEM_mallocN(sizeof(*vertMap) * numVert_src, "build modifier vertMap");
-	edgeMap = MEM_mallocN(sizeof(*edgeMap) * numEdge_src, "build modifier edgeMap");
-	faceMap = MEM_mallocN(sizeof(*faceMap) * numPoly_src, "build modifier faceMap");
+	vertMap = MEM_malloc_arrayN(numVert_src, sizeof(*vertMap), "build modifier vertMap");
+	edgeMap = MEM_malloc_arrayN(numEdge_src, sizeof(*edgeMap), "build modifier edgeMap");
+	faceMap = MEM_malloc_arrayN(numPoly_src, sizeof(*faceMap), "build modifier faceMap");
 
 	range_vn_i(vertMap, numVert_src, 0);
 	range_vn_i(edgeMap, numEdge_src, 0);
diff --git a/source/blender/modifiers/intern/MOD_collision.c b/source/blender/modifiers/intern/MOD_collision.c
index 74e49dda07..0a15799f61 100644
--- a/source/blender/modifiers/intern/MOD_collision.c
+++ b/source/blender/modifiers/intern/MOD_collision.c
@@ -158,7 +158,7 @@ static void deformVerts(ModifierData *md, Object *ob,
 				{
 					const MLoop *mloop = dm->getLoopArray(dm);
 					const MLoopTri *looptri = dm->getLoopTriArray(dm);
-					MVertTri *tri = MEM_mallocN(sizeof(*tri) * collmd->tri_num, __func__);
+					MVertTri *tri = MEM_malloc_arrayN(collmd->tri_num, sizeof(*tri), __func__);
 					DM_verttri_from_looptri(tri, mloop, looptri, collmd->tri_num);
 					collmd->tri = tri;
 				}
diff --git a/source/blender/modifiers/intern/MOD_correctivesmooth.c b/source/blender/modifiers/intern/MOD_correctivesmooth.c
index 1c3a5d3d7b..08f4588df8 100644
--- a/source/blender/modifiers/intern/MOD_correctivesmooth.c
+++ b/source/blender/modifiers/intern/MOD_correctivesmooth.c
@@ -156,7 +156,7 @@ static void dm_get_boundaries(DerivedMesh *dm, float *smooth_weights)
 	mpoly_num = (unsigned int)dm->getNumPolys(dm);
 	medge_num = (unsigned int)dm->getNumEdges(dm);
 
-	boundaries = MEM_callocN(medge_num * sizeof(*boundaries), __func__);
+	boundaries = MEM_calloc_arrayN(medge_num, sizeof(*boundaries), __func__);
 
 	/* count the number of adjacent faces */
 	for (i = 0; i < mpoly_num; i++) {
@@ -199,9 +199,9 @@ static void smooth_iter__simple(
 
 	struct SmoothingData_Simple {
 		float delta[3];
-	} *smooth_data = MEM_callocN((size_t)numVerts * sizeof(*smooth_data), __func__);
+	} *smooth_data = MEM_calloc_arrayN(numVerts, sizeof(*smooth_data), __func__);
 
-	vertex_edge_count_div = MEM_callocN((size_t)numVerts * sizeof(float), __func__);
+	vertex_edge_count_div = MEM_calloc_arrayN(numVerts, sizeof(float), __func__);
 
 	/* calculate as floats to avoid int->float conversion in #smooth_iter */
 	for (i = 0; i < numEdges; i++) {
@@ -277,11 +277,11 @@ static void smooth_iter__length_weight(
 	struct SmoothingData_Weighted {
 		float delta[3];
 		float edge_length_sum;
-	} *smooth_data = MEM_callocN((size_t)numVerts * sizeof(*smooth_data), __func__);
+	} *smooth_data = MEM_calloc_arrayN(numVerts, sizeof(*smooth_data), __func__);
 
 
 	/* calculate as floats to avoid int->float conversion in #smooth_iter */
-	vertex_edge_count = MEM_callocN((size_t)numVerts * sizeof(float), __func__);
+	vertex_edge_count = MEM_calloc_arrayN(numVerts, sizeof(float), __func__);
 	for (i = 0; i < numEdges; i++) {
 		vertex_edge_count[edges[i].v1] += 1.0f;
 		vertex_edge_count[edges[i].v2] += 1.0f;
@@ -382,7 +382,7 @@ static void smooth_verts(
 
 	if (dvert || (csmd->flag & MOD_CORRECTIVESMOOTH_PIN_BOUNDARY)) {
 
-		smooth_weights = MEM_mallocN(numVerts * sizeof(float), __func__);
+		smooth_weights = MEM_malloc_arrayN(numVerts, sizeof(float), __func__);
 
 		if (dvert) {
 			dm_get_weights(
@@ -530,7 +530,7 @@ static void calc_deltas(
 	float (*tangent_spaces)[3][3];
 	unsigned int i;
 
-	tangent_spaces = MEM_callocN((size_t)(numVerts) * sizeof(float[3][3]), __func__);
+	tangent_spaces = MEM_calloc_arrayN(numVerts, sizeof(float[3][3]), __func__);
 
 	if (csmd->delta_cache_num != numVerts) {
 		MEM_SAFE_FREE(csmd->delta_cache);
@@ -539,7 +539,7 @@ static void calc_deltas(
 	/* allocate deltas if they have not yet been allocated, otheriwse we will just write over them */
 	if (!csmd->delta_cache) {
 		csmd->delta_cache_num = numVerts;
-		csmd->delta_cache = MEM_mallocN((size_t)numVerts * sizeof(float[3]), __func__);
+		csmd->delta_cache = MEM_malloc_arrayN(numVerts, sizeof(float[3]), __func__);
 	}
 
 	smooth_verts(csmd, dm, dvert, defgrp_index, smooth_vertex_coords, numVerts);
@@ -680,7 +680,7 @@ static void correctivesmooth_modifier_do(
 		float (*tangent_spaces)[3][3];
 
 		/* calloc, since values are accumulated */
-		tangent_spaces = MEM_callocN((size_t)numVerts * sizeof(float[3][3]), __func__);
+		tangent_spaces = MEM_calloc_arrayN(numVerts, sizeof(float[3][3]), __func__);
 
 		calc_tangent_spaces(dm, vertexCos, tangent_spaces);
 
diff --git a/source/blender/modifiers/intern/MOD_decimate.c b/source/blender/modifiers/intern/MOD_decimate.c
index 617ae5a89f..8b5b054244 100644
--- a/source/blender/modifiers/intern/MOD_decimate.c
+++ b/source/blender/modifiers/intern/MOD_decimate.c
@@ -142,7 +142,7 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob,
 				const unsigned int vert_tot = dm->getNumVerts(dm);
 				unsigned int i;
 
-				vweights = MEM_mallocN(vert_tot * sizeof(float), __func__);
+				vweights = MEM_malloc_arrayN(vert_tot, sizeof(float), __func__);
 
 				if (dmd->flag & MOD_DECIM_FLAG_INVERT_VGROUP) {
 					for (i = 0; i < vert_tot; i++) {
diff --git a/source/blender/modifiers/intern/MOD_displace.c b/source/blender/modifiers/intern/MOD_displace.c
index 1b5c48f107..7651675934 100644
--- a/source/blender/modifiers/intern/MOD_displace.c
+++ b/source/blender/modifiers/intern/MOD_displace.c
@@ -334,7 +334,7 @@ static void displaceModifier_do(
 	modifier_get_vgroup(ob, dm, dmd->defgrp_name, &dvert, &defgrp_index);
 
 	if (dmd->texture) {
-		tex_co = MEM_callocN(sizeof(*tex_co) * numVerts,
+		tex_co = MEM_calloc_arrayN((size_t)numVerts, sizeof(*tex_co),
 		                     "displaceModifier_do tex_co");
 		get_texture_coords((MappingInfoModifierData *)dmd, ob, dm, vertexCos, tex_co, numVerts);
 
@@ -355,7 +355,7 @@ static void displaceModifier_do(
 			}
 
 			clnors = CustomData_get_layer(ldata, CD_NORMAL);
-			vert_clnors = MEM_mallocN(sizeof(*vert_clnors) * (size_t)numVerts, __func__);
+			vert_clnors = MEM_malloc_arrayN(numVerts, sizeof(*vert_clnors), __func__);
 			BKE_mesh_normals_loop_to_vertex(numVerts, dm->getLoopArray(dm), dm->getNumLoops(dm),
 			                                (const float (*)[3])clnors, vert_clnors);
 		}
diff --git a/source/blender/modifiers/intern/MOD_explode.c b/source/blender/modifiers/intern/MOD_explode.c
index 72bc046b44..c22901f194 100644
--- a/source/blender/modifiers/intern/MOD_explode.c
+++ b/source/blender/modifiers/intern/MOD_explode.c
@@ -119,9 +119,9 @@ static void createFacepa(ExplodeModifierData *emd,
 	if (emd->facepa)
 		MEM_freeN(emd->facepa);
 
-	facepa = emd->facepa = MEM_callocN(sizeof(int) * totface, "explode_facepa");
+	facepa = emd->facepa = MEM_calloc_arrayN(totface, sizeof(int), "explode_facepa");
 
-	vertpa = MEM_callocN(sizeof(int) * totvert, "explode_vertpa");
+	vertpa = MEM_calloc_arrayN(totvert, sizeof(int), "explode_vertpa");
 
 	/* initialize all faces & verts to no particle */
 	for (i = 0; i < totface; i++)
@@ -557,8 +557,8 @@ static DerivedMesh *cutEdges(ExplodeModifierData *emd, DerivedMesh *dm)
 	int totvert = dm->getNumVerts(dm);
 	int totface = dm->getNumTessFaces(dm);
 
-	int *facesplit = MEM_callocN(sizeof(int) * totface, "explode_facesplit");
-	int *vertpa = MEM_callocN(sizeof(int) * totvert, "explode_vertpa2");
+	int *facesplit = MEM_calloc_arrayN(totface, sizeof(int), "explode_facesplit");
+	int *vertpa = MEM_calloc_arrayN(totvert, sizeof(int), "explode_vertpa2");
 	int *facepa = emd->facepa;
 	int *fs, totesplit = 0, totfsplit = 0, curdupface = 0;
 	int i, v1, v2, v3, v4, esplit,
@@ -656,7 +656,7 @@ static DerivedMesh *cutEdges(ExplodeModifierData *emd, DerivedMesh *dm)
 	 * later interpreted as tri's, for this to work right I think we probably
 	 * have to stop using tessface - campbell */
 
-	facepa = MEM_callocN(sizeof(int) * (totface + (totfsplit * 2)), "explode_facepa");
+	facepa = MEM_calloc_arrayN((totface + (totfsplit * 2)), sizeof(int), "explode_facepa");
 	//memcpy(facepa, emd->facepa, totface*sizeof(int));
 	emd->facepa = facepa;
 
diff --git a/source/blender/modifiers/intern/MOD_fluidsim_util.c b/source/blender/modifiers/intern/MOD_fluidsim_util.c
index 3684e947fe..c9f475ad22 100644
--- a/source/blender/modifiers/intern/MOD_fluidsim_util.c
+++ b/source/blender/modifiers/intern/MOD_fluidsim_util.c
@@ -239,7 +239,7 @@ static DerivedMesh *fluidsim_read_obj(const char *filename, const MPoly *mp_exam
 		return NULL;
 	}
 
-	normals = MEM_callocN(sizeof(short) * numverts * 3, "fluid_tmp_normals");
+	normals = MEM_calloc_arrayN(numverts, 3 * sizeof(short), "fluid_tmp_normals");
 	if (!normals) {
 		if (dm)
 			dm->release(dm);
@@ -384,7 +384,7 @@ static void fluidsim_read_vel_cache(FluidsimModifierData *fluidmd, DerivedMesh *
 
 	if (fss->domainNovecgen > 0) return;
 
-	fss->meshVelocities = MEM_callocN(sizeof(FluidVertexVelocity) * dm->getNumVerts(dm), "Fluidsim_velocities");
+	fss->meshVelocities = MEM_calloc_arrayN(dm->getNumVerts(dm), sizeof(FluidVertexVelocity), "Fluidsim_velocities");
 	fss->totvert = totvert;
 
 	velarray = fss->meshVelocities;
diff --git a/source/blender/modifiers/intern/MOD_laplaciandeform.c b/source/blender/modifiers/intern/MOD_laplaciandeform.c
index c2896e83a0..91d41a6bad 100644
--- a/source/blender/modifiers/intern/MOD_laplaciandeform.c
+++ b/source/blender/modifiers/intern/MOD_laplaciandeform.c
@@ -108,12 +108,12 @@ static LaplacianSystem *initLaplacianSystem(
 	sys->total_anchors = totalAnchors;
 	sys->repeat = iterations;
 	BLI_strncpy(sys->anchor_grp_name, defgrpName, sizeof(sys->anchor_grp_name));
-	sys->co = MEM_mallocN(sizeof(float[3]) * totalVerts, "DeformCoordinates");
-	sys->no = MEM_callocN(sizeof(float[3]) * totalVerts, "DeformNormals");
-	sys->delta = MEM_callocN(sizeof(float[3]) * totalVerts, "DeformDeltas");
-	sys->tris = MEM_mallocN(sizeof(int[3]) * totalTris, "DeformFaces");
-	sys->index_anchors = MEM_mallocN(sizeof(int) * (totalAnchors), "DeformAnchors");
-	sys->unit_verts = MEM_callocN(sizeof(int) * totalVerts, "DeformUnitVerts");
+	sys->co = MEM_malloc_arrayN(totalVerts, sizeof(float[3]), "DeformCoordinates");
+	sys->no = MEM_calloc_arrayN(totalVerts, sizeof(float[3]), "DeformNormals");
+	sys->delta = MEM_calloc_arrayN(totalVerts, sizeof(float[3]), "DeformDeltas");
+	sys->tris = MEM_malloc_arrayN(totalTris, sizeof(int[3]), "DeformFaces");
+	sys->index_anchors = MEM_malloc_arrayN((totalAnchors), sizeof(int), "DeformAnchors");
+	sys->unit_verts = MEM_calloc_arrayN(totalVerts, sizeof(int), "DeformUnitVerts");
 	return sys;
 }
 
@@ -142,7 +142,7 @@ static void createFaceRingMap(
 {
 	int i, j, totalr = 0;
 	int *indices, *index_iter;
-	MeshElemMap *map = MEM_callocN(sizeof(MeshElemMap) * mvert_tot, "DeformRingMap");
+	MeshElemMap *map = MEM_calloc_arrayN(mvert_tot, sizeof(MeshElemMap), "DeformRingMap");
 	const MLoopTri *mlt;
 
 	for (i = 0, mlt = mlooptri; i < mtri_tot; i++, mlt++) {
@@ -153,7 +153,7 @@ static void createFaceRingMap(
 			totalr++;
 		}
 	}
-	indices = MEM_callocN(sizeof(int) * totalr, "DeformRingIndex");
+	indices = MEM_calloc_arrayN(totalr, sizeof(int), "DeformRingIndex");
 	index_iter = indices;
 	for (i = 0; i < mvert_tot; i++) {
 		map[i].indices = index_iter;
@@ -175,7 +175,7 @@ static void createVertRingMap(
         const int mvert_tot, const MEdge *medge, const int medge_tot,
         MeshElemMap **r_map, int **r_indices)
 {
-	MeshElemMap *map = MEM_callocN(sizeof(MeshElemMap) * mvert_tot, "DeformNeighborsMap");
+	MeshElemMap *map = MEM_calloc_arrayN(mvert_tot, sizeof(MeshElemMap), "DeformNeighborsMap");
 	int i, vid[2], totalr = 0;
 	int *indices, *index_iter;
 	const MEdge *me;
@@ -187,7 +187,7 @@ static void createVertRingMap(
 		map[vid[1]].count++;
 		totalr += 2;
 	}
-	indices = MEM_callocN(sizeof(int) * totalr, "DeformNeighborsIndex");
+	indices = MEM_calloc_arrayN(totalr, sizeof(int), "DeformNeighborsIndex");
 	index_iter = indices;
 	for (i = 0; i < mvert_tot; i++) {
 		map[i].indices = index_iter;
@@ -521,7 +521,7 @@ static void initSystem(LaplacianDeformModifierData *lmd, Object *ob, DerivedMesh
 	LaplacianSystem *sys;
 
 	if (isValidVertexGroup(lmd, ob, dm)) {
-		int *index_anchors = MEM_mallocN(sizeof(int) * numVerts, __func__);  /* over-alloc */
+		int *index_anchors = MEM_malloc_arrayN(numVerts, sizeof(int), __func__);  /* over-alloc */
 		const MLoopTri *mlooptri;
 		const MLoop *mloop;
 
@@ -547,7 +547,7 @@ static void initSystem(LaplacianDeformModifierData *lmd, Object *ob, DerivedMesh
 		memcpy(sys->index_anchors, index_anchors, sizeof(int) * total_anchors);
 		memcpy(sys->co, vertexCos, sizeof(float[3]) * numVerts);
 		MEM_freeN(index_anchors);
-		lmd->vertexco = MEM_mallocN(sizeof(float[3]) * numVerts, "ModDeformCoordinates");
+		lmd->vertexco = MEM_malloc_arrayN(numVerts, sizeof(float[3]), "ModDeformCoordinates");
 		memcpy(lmd->vertexco, vertexCos, sizeof(float[3]) * numVerts);
 		lmd->total_verts = numVerts;
 
@@ -631,7 +631,7 @@ static void LaplacianDeformModifier_do(
 		sys = lmd->cache_system;
 		if (sysdif) {
 			if (sysdif == LAPDEFORM_SYSTEM_ONLY_CHANGE_ANCHORS || sysdif == LAPDEFORM_SYSTEM_ONLY_CHANGE_GROUP) {
-				filevertexCos = MEM_mallocN(sizeof(float[3]) * numVerts, "TempModDeformCoordinates");
+				filevertexCos = MEM_malloc_arrayN(numVerts, sizeof(float[3]), "TempModDeformCoordinates");
 				memcpy(filevertexCos, lmd->vertexco, sizeof(float[3]) * numVerts);
 				MEM_SAFE_FREE(lmd->vertexco);
 				lmd->total_verts = 0;
@@ -667,7 +667,7 @@ static void LaplacianDeformModifier_do(
 			lmd->flag &= ~MOD_LAPLACIANDEFORM_BIND;
 		}
 		else if (lmd->total_verts > 0 && lmd->total_verts == numVerts) {
-			filevertexCos = MEM_mallocN(sizeof(float[3]) * numVerts, "TempDeformCoordinates");
+			filevertexCos = MEM_malloc_arrayN(numVerts, sizeof(float[3]), "TempDeformCoordinates");
 			memcpy(filevertexCos, lmd->vertexco, sizeof(float[3]) * numVerts);
 			MEM_SAFE_FREE(lmd->vertexco);
 			lmd->total_verts = 0;
diff --git a/source/blender/modifiers/intern/MOD_laplaciansmooth.c b/source/blender/modifiers/intern/MOD_laplaciansmooth.c
index f1216ff462..b3a542f68b 100644
--- a/source/blender/modifiers/intern/MOD_laplaciansmooth.c
+++ b/source/blender/modifiers/intern/MOD_laplaciansmooth.c
@@ -132,14 +132,14 @@ static LaplacianSystem *init_laplacian_system(int a_numEdges, int a_numPolys, in
 	sys->numLoops = a_numLoops;
 	sys->numVerts = a_numVerts;
 
-	sys->eweights =  MEM_callocN(sizeof(float) * sys->numEdges, __func__);
-	sys->fweights =  MEM_callocN(sizeof(float[3]) * sys->numLoops, __func__);
-	sys->numNeEd =  MEM_callocN(sizeof(short) * sys->numVerts, __func__);
-	sys->numNeFa =  MEM_callocN(sizeof(short) * sys->numVerts, __func__);
-	sys->ring_areas =  MEM_callocN(sizeof(float) * sys->numVerts, __func__);
-	sys->vlengths =  MEM_callocN(sizeof(float) * sys->numVerts, __func__);
-	sys->vweights =  MEM_callocN(sizeof(float) * sys->numVerts, __func__);
-	sys->zerola =  MEM_callocN(sizeof(short) * sys->numVerts, __func__);
+	sys->eweights =  MEM_calloc_arrayN(sys->numEdges, sizeof(float), __func__);
+	sys->fweights =  MEM_calloc_arrayN(sys->numLoops, sizeof(float[3]), __func__);
+	sys->numNeEd =  MEM_calloc_arrayN(sys->numVerts, sizeof(short), __func__);
+	sys->numNeFa =  MEM_calloc_arrayN(sys->numVerts, sizeof(short), __func__);
+	sys->ring_areas =  MEM_calloc_arrayN(sys->numVerts, sizeof(float), __func__);
+	sys->vlengths =  MEM_calloc_arrayN(sys->numVerts, sizeof(float), __func__);
+	sys->vweights =  MEM_calloc_arrayN(sys->numVerts, sizeof(float), __func__);
+	sys->zerola =  MEM_calloc_arrayN(sys->numVerts, sizeof(short), __func__);
 
 	return sys;
 }
diff --git a/source/blender/modifiers/intern/MOD_mask.c b/source/blender/modifiers/intern/MOD_mask.c
index 18caf4a39f..508897ec4f 100644
--- a/source/blender/modifiers/intern/MOD_mask.c
+++ b/source/blender/modifiers/intern/MOD_mask.c
@@ -181,7 +181,7 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob,
 		 * - each cell is a boolean saying whether bone corresponding to the ith group is selected
 		 * - groups that don't match a bone are treated as not existing (along with the corresponding ungrouped verts)
 		 */
-		bone_select_array = MEM_mallocN((size_t)defbase_tot * sizeof(char), "mask array");
+		bone_select_array = MEM_malloc_arrayN((size_t)defbase_tot, sizeof(char), "mask array");
 		
 		for (i = 0, def = ob->defbase.first; def; def = def->next, i++) {
 			pchan = BKE_pose_channel_find_name(oba->pose, def->name);
@@ -265,7 +265,7 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob,
 	mloop_src = dm->getLoopArray(dm);
 
 	/* overalloc, assume all polys are seen */
-	loop_mapping = MEM_mallocN(sizeof(int) * (size_t)maxPolys, "mask loopmap");
+	loop_mapping = MEM_malloc_arrayN((size_t)maxPolys, sizeof(int), "mask loopmap");
 
 	/* loop over edges and faces, and do the same thing to 
 	 * ensure that they only reference existing verts 
diff --git a/source/blender/modifiers/intern/MOD_meshcache.c b/source/blender/modifiers/intern/MOD_meshcache.c
index aa3e3ebcf7..e026d4da29 100644
--- a/source/blender/modifiers/intern/MOD_meshcache.c
+++ b/source/blender/modifiers/intern/MOD_meshcache.c
@@ -94,7 +94,7 @@ static void meshcache_do(
 {
 	const bool use_factor = mcmd->factor < 1.0f;
 	float (*vertexCos_Store)[3] = (use_factor || (mcmd->deform_mode == MOD_MESHCACHE_DEFORM_INTEGRATE)) ?
-	                              MEM_mallocN(sizeof(*vertexCos_Store) * numVerts, __func__) : NULL;
+	                              MEM_malloc_arrayN(numVerts, sizeof(*vertexCos_Store), __func__) : NULL;
 	float (*vertexCos)[3] = vertexCos_Store ? vertexCos_Store : vertexCos_Real;
 
 	Scene *scene = mcmd->modifier.scene;
@@ -197,8 +197,8 @@ static void meshcache_do(
 			/* the moons align! */
 			int i;
 
-			float (*vertexCos_Source)[3] = MEM_mallocN(sizeof(*vertexCos_Source) * numVerts, __func__);
-			float (*vertexCos_New)[3]    = MEM_mallocN(sizeof(*vertexCos_New) * numVerts, __func__);
+			float (*vertexCos_Source)[3] = MEM_malloc_arrayN(numVerts, sizeof(*vertexCos_Source), __func__);
+			float (*vertexCos_New)[3]    = MEM_malloc_arrayN(numVerts, sizeof(*vertexCos_New), __func__);
 			MVert *mv = me->mvert;
 
 			for (i = 0; i < numVerts; i++, mv++) {
diff --git a/source/blender/modifiers/intern/MOD_meshdeform.c b/source/blender/modifiers/intern/MOD_meshdeform.c
index 8f197ce3b9..99f0c892a3 100644
--- a/source/blender/modifiers/intern/MOD_meshdeform.c
+++ b/source/blender/modifiers/intern/MOD_meshdeform.c
@@ -380,7 +380,7 @@ static void meshdeformModifier_do(
 		return;
 	}
 
-	cagecos = MEM_mallocN(sizeof(*cagecos) * totcagevert, "meshdeformModifier vertCos");
+	cagecos = MEM_malloc_arrayN(totcagevert, sizeof(*cagecos), "meshdeformModifier vertCos");
 
 	/* setup deformation data */
 	cagedm->getVertCos(cagedm, cagecos);
@@ -389,7 +389,7 @@ static void meshdeformModifier_do(
 	/* We allocate 1 element extra to make it possible to
 	 * load the values to SSE registers, which are float4.
 	 */
-	dco = MEM_callocN(sizeof(*dco) * (totcagevert + 1), "MDefDco");
+	dco = MEM_calloc_arrayN((totcagevert + 1), sizeof(*dco), "MDefDco");
 	zero_v3(dco[totcagevert]);
 	for (a = 0; a < totcagevert; a++) {
 		/* get cage vertex in world space with binding transform */
@@ -486,8 +486,8 @@ void modifier_mdef_compact_influences(ModifierData *md)
 	}
 
 	/* allocate bind influences */
-	mmd->bindinfluences = MEM_callocN(sizeof(MDefInfluence) * mmd->totinfluence, "MDefBindInfluence");
-	mmd->bindoffsets = MEM_callocN(sizeof(int) * (totvert + 1), "MDefBindOffset");
+	mmd->bindinfluences = MEM_calloc_arrayN(mmd->totinfluence, sizeof(MDefInfluence), "MDefBindInfluence");
+	mmd->bindoffsets = MEM_calloc_arrayN((totvert + 1), sizeof(int), "MDefBindOffset");
 
 	/* write influences */
 	totinfluence = 0;
diff --git a/source/blender/modifiers/intern/MOD_mirror.c b/source/blender/modifiers/intern/MOD_mirror.c
index 157f37e973..6925e40a8c 100644
--- a/source/blender/modifiers/intern/MOD_mirror.c
+++ b/source/blender/modifiers/intern/MOD_mirror.c
@@ -183,7 +183,7 @@ static DerivedMesh *doMirrorOnAxis(MirrorModifierData *mmd,
 
 	if (do_vtargetmap) {
 		/* second half is filled with -1 */
-		vtargetmap = MEM_mallocN(sizeof(int) * maxVerts * 2, "MOD_mirror tarmap");
+		vtargetmap = MEM_malloc_arrayN(maxVerts, 2 * sizeof(int), "MOD_mirror tarmap");
 
 		vtmap_a = vtargetmap;
 		vtmap_b = vtargetmap + maxVerts;
diff --git a/source/blender/modifiers/intern/MOD_normal_edit.c b/source/blender/modifiers/intern/MOD_normal_edit.c
index 20eae751ca..af20d06a5a 100644
--- a/source/blender/modifiers/intern/MOD_normal_edit.c
+++ b/source/blender/modifiers/intern/MOD_normal_edit.c
@@ -119,7 +119,7 @@ static void mix_normals(
 	int i;
 
 	if (dvert) {
-		facs = MEM_mallocN(sizeof(*facs) * (size_t)num_loops, __func__);
+		facs = MEM_malloc_arrayN((size_t)num_loops, sizeof(*facs), __func__);
 		BKE_defvert_extract_vgroup_to_loopweights(
 		            dvert, defgrp_index, num_verts, mloop, num_loops, facs, use_invert_vgroup);
 	}
@@ -197,8 +197,8 @@ static void normalEditModifier_do_radial(
 {
 	int i;
 
-	float (*cos)[3] = MEM_mallocN(sizeof(*cos) * num_verts, __func__);
-	float (*nos)[3] = MEM_mallocN(sizeof(*nos) * num_loops, __func__);
+	float (*cos)[3] = MEM_malloc_arrayN((size_t)num_verts, sizeof(*cos), __func__);
+	float (*nos)[3] = MEM_malloc_arrayN((size_t)num_loops, sizeof(*nos), __func__);
 	float size[3];
 
 	BLI_bitmap *done_verts = BLI_BITMAP_NEW((size_t)num_verts, __func__);
@@ -296,8 +296,8 @@ static void normalEditModifier_do_directional(
 {
 	const bool use_parallel_normals = (enmd->flag & MOD_NORMALEDIT_USE_DIRECTION_PARALLEL) != 0;
 
-	float (*cos)[3] = MEM_mallocN(sizeof(*cos) * num_verts, __func__);
-	float (*nos)[3] = MEM_mallocN(sizeof(*nos) * num_loops, __func__);
+	float (*cos)[3] = MEM_malloc_arrayN((size_t)num_verts, sizeof(*cos), __func__);
+	float (*nos)[3] = MEM_malloc_arrayN((size_t)num_loops, sizeof(*nos), __func__);
 
 	float target_co[3];
 	int i;
@@ -436,7 +436,7 @@ static DerivedMesh *normalEditModifier_do(NormalEditModifierData *enmd, Object *
 
 	polynors = dm->getPolyDataArray(dm, CD_NORMAL);
 	if (!polynors) {
-		polynors = MEM_mallocN(sizeof(*polynors) * num_polys, __func__);
+		polynors = MEM_malloc_arrayN((size_t)num_polys, sizeof(*polynors), __func__);
 		BKE_mesh_calc_normals_poly(mvert, NULL, num_verts, mloop, mpoly, num_loops, num_polys, polynors, false);
 		free_polynors = true;
 	}
diff --git a/source/blender/modifiers/intern/MOD_particleinstance.c b/source/blender/modifiers/intern/MOD_particleinstance.c
index 0c91cb08da..22e83d9dae 100644
--- a/source/blender/modifiers/intern/MOD_particleinstance.c
+++ b/source/blender/modifiers/intern/MOD_particleinstance.c
@@ -238,7 +238,7 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob,
 
 	if (pimd->flag & eParticleInstanceFlag_UseSize) {
 		float *si;
-		si = size = MEM_callocN(totpart * sizeof(float), "particle size array");
+		si = size = MEM_calloc_arrayN(totpart, sizeof(float), "particle size array");
 
 		if (pimd->flag & eParticleInstanceFlag_Parents) {
 			for (p = 0, pa = psys->particles; p < psys->totpart; p++, pa++, si++)
diff --git a/source/blender/modifiers/intern/MOD_screw.c b/source/blender/modifiers/intern/MOD_screw.c
index 2c3d7f394b..7896ea0a94 100644
--- a/source/blender/modifiers/intern/MOD_screw.c
+++ b/source/blender/modifiers/intern/MOD_screw.c
@@ -140,7 +140,7 @@ static DerivedMesh *dm_remove_doubles_on_axis(
 
 	if (tot_doubles != 0) {
 		uint tot = totvert * step_tot;
-		int *full_doubles_map = MEM_mallocN(sizeof(int) * tot, __func__);
+		int *full_doubles_map = MEM_malloc_arrayN(tot, sizeof(int), __func__);
 		copy_vn_i(full_doubles_map, (int)tot, -1);
 
 		uint tot_doubles_left = tot_doubles;
@@ -449,10 +449,10 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob,
 
 		mpoly_orig = dm->getPolyArray(dm);
 		mloop_orig = dm->getLoopArray(dm);
-		edge_poly_map = MEM_mallocN(sizeof(*edge_poly_map) * totedge, __func__);
+		edge_poly_map = MEM_malloc_arrayN(totedge, sizeof(*edge_poly_map), __func__);
 		memset(edge_poly_map, 0xff, sizeof(*edge_poly_map) * totedge);
 
-		vert_loop_map = MEM_mallocN(sizeof(*vert_loop_map) * totvert, __func__);
+		vert_loop_map = MEM_malloc_arrayN(totvert, sizeof(*vert_loop_map), __func__);
 		memset(vert_loop_map, 0xff, sizeof(*vert_loop_map) * totvert);
 
 		for (i = 0, mp_orig = mpoly_orig; i < totpoly; i++, mp_orig++) {
@@ -498,7 +498,7 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob,
 		 * This makes the modifier faster with one less alloc.
 		 */
 
-		vert_connect = MEM_mallocN(sizeof(ScrewVertConnect) * totvert, "ScrewVertConnect");
+		vert_connect = MEM_malloc_arrayN(totvert, sizeof(ScrewVertConnect), "ScrewVertConnect");
 		//vert_connect = (ScrewVertConnect *) &medge_new[totvert];  /* skip the first slice of verts */
 		vc = vert_connect;
 
diff --git a/source/blender/modifiers/intern/MOD_skin.c b/source/blender/modifiers/intern/MOD_skin.c
index ad1e4badd3..6006b48628 100644
--- a/source/blender/modifiers/intern/MOD_skin.c
+++ b/source/blender/modifiers/intern/MOD_skin.c
@@ -419,7 +419,7 @@ static Frame **collect_hull_frames(int v, SkinNode *frames,
 	int nbr, i;
 
 	(*tothullframe) = emap[v].count;
-	hull_frames = MEM_callocN(sizeof(Frame *) * (*tothullframe),
+	hull_frames = MEM_calloc_arrayN((*tothullframe), sizeof(Frame *),
 	                          "hull_from_frames.hull_frames");
 	i = 0;
 	for (nbr = 0; nbr < emap[v].count; nbr++) {
@@ -600,7 +600,7 @@ static SkinNode *build_frames(const MVert *mvert, int totvert,
 	SkinNode *skin_nodes;
 	int v;
 
-	skin_nodes = MEM_callocN(sizeof(SkinNode) * totvert, "build_frames.skin_nodes");
+	skin_nodes = MEM_calloc_arrayN(totvert, sizeof(SkinNode), "build_frames.skin_nodes");
 
 	for (v = 0; v < totvert; v++) {
 		if (emap[v].count <= 1)
@@ -722,7 +722,7 @@ static EMat *build_edge_mats(const MVertSkin *vs,
 	stack = BLI_stack_new(sizeof(stack_elem), "build_edge_mats.stack");
 
 	visited_e = BLI_BITMAP_NEW(totedge, "build_edge_mats.visited_e");
-	emat = MEM_callocN(sizeof(EMat) * totedge, "build_edge_mats.emat");
+	emat = MEM_calloc_arrayN(totedge, sizeof(EMat), "build_edge_mats.emat");
 
 	/* Edge matrices are built from the root nodes, add all roots with
 	 * children to the stack */
@@ -836,14 +836,14 @@ static DerivedMesh *subdivide_base(DerivedMesh *orig)
 	totorigedge = orig->getNumEdges(orig);
 
 	/* Get degree of all vertices */
-	degree = MEM_callocN(sizeof(int) * totorigvert, "degree");
+	degree = MEM_calloc_arrayN(totorigvert, sizeof(int), "degree");
 	for (i = 0; i < totorigedge; i++) {
 		degree[origedge[i].v1]++;
 		degree[origedge[i].v2]++;
 	}
 
 	/* Per edge, store how many subdivisions are needed */
-	edge_subd = MEM_callocN(sizeof(int) * totorigedge, "edge_subd");
+	edge_subd = MEM_calloc_arrayN(totorigedge, sizeof(int), "edge_subd");
 	for (i = 0, totsubd = 0; i < totorigedge; i++) {
 		edge_subd[i] += calc_edge_subdivisions(origvert, orignode,
 		                                       &origedge[i], degree);
@@ -882,7 +882,7 @@ static DerivedMesh *subdivide_base(DerivedMesh *orig)
 		if (origdvert) {
 			const MDeformVert *dv1 = &origdvert[e->v1];
 			const MDeformVert *dv2 = &origdvert[e->v2];
-			vgroups = MEM_callocN(sizeof(*vgroups) * dv1->totweight, "vgroup");
+			vgroups = MEM_calloc_arrayN(dv1->totweight, sizeof(*vgroups), "vgroup");
 
 			/* Only want vertex groups used by both vertices */
 			for (j = 0; j < dv1->totweight; j++) {
diff --git a/source/blender/modifiers/intern/MOD_smooth.c b/source/blender/modifiers/intern/MOD_smooth.c
index d45c852851..92025512f0 100644
--- a/source/blender/modifiers/intern/MOD_smooth.c
+++ b/source/blender/modifiers/intern/MOD_smooth.c
@@ -102,10 +102,10 @@ static void smoothModifier_do(
 	unsigned char *uctmp;
 	float *ftmp, fac, facm;
 
-	ftmp = (float *)MEM_callocN(3 * sizeof(float) * numVerts,
+	ftmp = (float *)MEM_calloc_arrayN(numVerts, 3 * sizeof(float),
 	                            "smoothmodifier_f");
 	if (!ftmp) return;
-	uctmp = (unsigned char *)MEM_callocN(sizeof(unsigned char) * numVerts,
+	uctmp = (unsigned char *)MEM_calloc_arrayN(numVerts, sizeof(unsigned char),
 	                                     "smoothmodifier_uc");
 	if (!uctmp) {
 		if (ftmp) MEM_freeN(ftmp);
diff --git a/source/blender/modifiers/intern/MOD_solidify.c b/source/blender/modifiers/intern/MOD_solidify.c
index e96771e066..aa5b0caea2 100644
--- a/source/blender/modifiers/intern/MOD_solidify.c
+++ b/source/blender/modifiers/intern/MOD_solidify.c
@@ -101,7 +101,7 @@ static void dm_calc_normal(DerivedMesh *dm, float (*face_nors)[3], float (*r_ver
 	mp = mpoly;
 
 	{
-		EdgeFaceRef *edge_ref_array = MEM_callocN(sizeof(EdgeFaceRef) * (size_t)numEdges, "Edge Connectivity");
+		EdgeFaceRef *edge_ref_array = MEM_calloc_arrayN((size_t)numEdges, sizeof(EdgeFaceRef), "Edge Connectivity");
 		EdgeFaceRef *edge_ref;
 		float edge_normal[3];
 
@@ -235,7 +235,7 @@ static DerivedMesh *applyModifier(
 	unsigned int *new_edge_arr = NULL;
 	STACK_DECLARE(new_edge_arr);
 
-	unsigned int *old_vert_arr = MEM_callocN(sizeof(*old_vert_arr) * (size_t)numVerts, "old_vert_arr in solidify");
+	unsigned int *old_vert_arr = MEM_calloc_arrayN(numVerts, sizeof(*old_vert_arr), "old_vert_arr in solidify");
 
 	unsigned int *edge_users = NULL;
 	char *edge_order = NULL;
@@ -270,7 +270,7 @@ static DerivedMesh *applyModifier(
 
 	if (need_face_normals) {
 		/* calculate only face normals */
-		face_nors = MEM_mallocN(sizeof(*face_nors) * (size_t)numFaces, __func__);
+		face_nors = MEM_malloc_arrayN(numFaces, sizeof(*face_nors), __func__);
 		BKE_mesh_calc_normals_poly(
 		            orig_mvert, NULL, (int)numVerts,
 		            orig_mloop, orig_mpoly,
@@ -289,11 +289,11 @@ static DerivedMesh *applyModifier(
 #define INVALID_UNUSED ((unsigned int)-1)
 #define INVALID_PAIR ((unsigned int)-2)
 
-		new_vert_arr = MEM_mallocN(sizeof(*new_vert_arr) * (size_t)(numVerts * 2), __func__);
-		new_edge_arr = MEM_mallocN(sizeof(*new_edge_arr) * (size_t)((numEdges * 2) + numVerts), __func__);
+		new_vert_arr = MEM_malloc_arrayN(numVerts, 2 * sizeof(*new_vert_arr), __func__);
+		new_edge_arr = MEM_malloc_arrayN(((numEdges * 2) + numVerts), sizeof(*new_edge_arr), __func__);
 
-		edge_users = MEM_mallocN(sizeof(*edge_users) * (size_t)numEdges, "solid_mod edges");
-		edge_order = MEM_mallocN(sizeof(*edge_order) * (size_t)numEdges, "solid_mod eorder");
+		edge_users = MEM_malloc_arrayN(numEdges, sizeof(*edge_users), "solid_mod edges");
+		edge_order = MEM_malloc_arrayN(numEdges, sizeof(*edge_order), "solid_mod eorder");
 
 
 		/* save doing 2 loops here... */
@@ -366,7 +366,7 @@ static DerivedMesh *applyModifier(
 	}
 
 	if (smd->flag & MOD_SOLIDIFY_NORMAL_CALC) {
-		vert_nors = MEM_callocN(sizeof(float) * (size_t)numVerts * 3, "mod_solid_vno_hq");
+		vert_nors = MEM_calloc_arrayN(numVerts, 3 * sizeof(float), "mod_solid_vno_hq");
 		dm_calc_normal(dm, face_nors, vert_nors);
 	}
 
@@ -517,7 +517,7 @@ static DerivedMesh *applyModifier(
 		if (do_clamp) {
 			unsigned int i;
 
-			vert_lens = MEM_mallocN(sizeof(float) * numVerts, "vert_lens");
+			vert_lens = MEM_malloc_arrayN(numVerts, sizeof(float), "vert_lens");
 			copy_vn_fl(vert_lens, (int)numVerts, FLT_MAX);
 			for (i = 0; i < numEdges; i++) {
 				const float ed_len_sq = len_squared_v3v3(mvert[medge[i].v1].co, mvert[medge[i].v2].co);
@@ -596,13 +596,13 @@ static DerivedMesh *applyModifier(
 		const bool check_non_manifold = (smd->flag & MOD_SOLIDIFY_NORMAL_CALC) != 0;
 #endif
 		/* same as EM_solidify() in editmesh_lib.c */
-		float *vert_angles = MEM_callocN(sizeof(float) * numVerts * 2, "mod_solid_pair"); /* 2 in 1 */
+		float *vert_angles = MEM_calloc_arrayN(numVerts, 2 * sizeof(float), "mod_solid_pair"); /* 2 in 1 */
 		float *vert_accum = vert_angles + numVerts;
 		unsigned int vidx;
 		unsigned int i;
 
 		if (vert_nors == NULL) {
-			vert_nors = MEM_mallocN(sizeof(float) * numVerts * 3, "mod_solid_vno");
+			vert_nors = MEM_malloc_arrayN(numVerts, 3 * sizeof(float), "mod_solid_vno");
 			for (i = 0, mv = mvert; i < numVerts; i++, mv++) {
 				normal_short_to_float_v3(vert_nors[i], mv->no);
 			}
@@ -682,7 +682,7 @@ static DerivedMesh *applyModifier(
 		}
 
 		if (do_clamp) {
-			float *vert_lens_sq = MEM_mallocN(sizeof(float) * numVerts, "vert_lens");
+			float *vert_lens_sq = MEM_malloc_arrayN(numVerts, sizeof(float), "vert_lens");
 			const float offset    = fabsf(smd->offset) * smd->offset_clamp;
 			const float offset_sq = offset * offset;
 			copy_vn_fl(vert_lens_sq, (int)numVerts, FLT_MAX);
@@ -765,7 +765,7 @@ static DerivedMesh *applyModifier(
 #ifdef SOLIDIFY_SIDE_NORMALS
 		const bool do_side_normals = !(result->dirty & DM_DIRTY_NORMALS);
 		/* annoying to allocate these since we only need the edge verts, */
-		float (*edge_vert_nos)[3] = do_side_normals ? MEM_callocN(sizeof(float) * numVerts * 3, __func__) : NULL;
+		float (*edge_vert_nos)[3] = do_side_normals ? MEM_calloc_arrayN(numVerts, 3 * sizeof(float), __func__) : NULL;
 		float nor[3];
 #endif
 		const unsigned char crease_rim = smd->crease_rim * 255.0f;
diff --git a/source/blender/modifiers/intern/MOD_surface.c b/source/blender/modifiers/intern/MOD_surface.c
index e5b0f9c000..7bb4c0b2fd 100644
--- a/source/blender/modifiers/intern/MOD_surface.c
+++ b/source/blender/modifiers/intern/MOD_surface.c
@@ -130,8 +130,8 @@ static void deformVerts(ModifierData *md, Object *ob,
 				surmd->v = NULL;
 			}
 
-			surmd->x = MEM_callocN(numverts * sizeof(MVert), "MVert");
-			surmd->v = MEM_callocN(numverts * sizeof(MVert), "MVert");
+			surmd->x = MEM_calloc_arrayN(numverts, sizeof(MVert), "MVert");
+			surmd->v = MEM_calloc_arrayN(numverts, sizeof(MVert), "MVert");
 
 			surmd->numverts = numverts;
 
diff --git a/source/blender/modifiers/intern/MOD_surfacedeform.c b/source/blender/modifiers/intern/MOD_surfacedeform.c
index 17e6de4c34..14128b258b 100644
--- a/source/blender/modifiers/intern/MOD_surfacedeform.c
+++ b/source/blender/modifiers/intern/MOD_surfacedeform.c
@@ -405,7 +405,7 @@ BLI_INLINE SDefBindWeightData *computeBindWeights(SDefBindCalcData * const data,
 
 	bwdata->numpoly = data->vert_edges[nearest].num / 2;
 
-	bpoly = MEM_callocN(sizeof(*bpoly) * bwdata->numpoly, "SDefBindPoly");
+	bpoly = MEM_calloc_arrayN(bwdata->numpoly, sizeof(*bpoly), "SDefBindPoly");
 	if (bpoly == NULL) {
 		freeBindData(bwdata);
 		data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
@@ -448,14 +448,14 @@ BLI_INLINE SDefBindWeightData *computeBindWeights(SDefBindCalcData * const data,
 				bpoly->numverts = poly->totloop;
 				bpoly->loopstart = poly->loopstart;
 
-				bpoly->coords = MEM_mallocN(sizeof(*bpoly->coords) * poly->totloop, "SDefBindPolyCoords");
+				bpoly->coords = MEM_malloc_arrayN(poly->totloop, sizeof(*bpoly->coords), "SDefBindPolyCoords");
 				if (bpoly->coords == NULL) {
 					freeBindData(bwdata);
 					data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
 					return NULL;
 				}
 
-				bpoly->coords_v2 = MEM_mallocN(sizeof(*bpoly->coords_v2) * poly->totloop, "SDefBindPolyCoords_v2");
+				bpoly->coords_v2 = MEM_malloc_arrayN(poly->totloop, sizeof(*bpoly->coords_v2), "SDefBindPolyCoords_v2");
 				if (bpoly->coords_v2 == NULL) {
 					freeBindData(bwdata);
 					data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
@@ -782,7 +782,7 @@ static void bindVert(
 		return;
 	}
 
-	sdvert->binds = MEM_callocN(sizeof(*sdvert->binds) * bwdata->numbinds, "SDefVertBindData");
+	sdvert->binds = MEM_calloc_arrayN(bwdata->numbinds, sizeof(*sdvert->binds), "SDefVertBindData");
 	if (sdvert->binds == NULL) {
 		data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
 		sdvert->numbinds = 0;
@@ -804,13 +804,13 @@ static void bindVert(
 				sdbind->numverts = bpoly->numverts;
 
 				sdbind->mode = MOD_SDEF_MODE_NGON;
-				sdbind->vert_weights = MEM_mallocN(sizeof(*sdbind->vert_weights) * bpoly->numverts, "SDefNgonVertWeights");
+				sdbind->vert_weights = MEM_malloc_arrayN(bpoly->numverts, sizeof(*sdbind->vert_weights), "SDefNgonVertWeights");
 				if (sdbind->vert_weights == NULL) {
 					data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
 					return;
 				}
 
-				sdbind->vert_inds = MEM_mallocN(sizeof(*sdbind->vert_inds) * bpoly->numverts, "SDefNgonVertInds");
+				sdbind->vert_inds = MEM_malloc_arrayN(bpoly->numverts, sizeof(*sdbind->vert_inds), "SDefNgonVertInds");
 				if (sdbind->vert_inds == NULL) {
 					data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
 					return;
@@ -840,13 +840,13 @@ static void bindVert(
 					sdbind->numverts = bpoly->numverts;
 
 					sdbind->mode = MOD_SDEF_MODE_CENTROID;
-					sdbind->vert_weights = MEM_mallocN(sizeof(*sdbind->vert_weights) * 3, "SDefCentVertWeights");
+					sdbind->vert_weights = MEM_malloc_arrayN(3, sizeof(*sdbind->vert_weights), "SDefCentVertWeights");
 					if (sdbind->vert_weights == NULL) {
 						data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
 						return;
 					}
 
-					sdbind->vert_inds = MEM_mallocN(sizeof(*sdbind->vert_inds) * bpoly->numverts, "SDefCentVertInds");
+					sdbind->vert_inds = MEM_malloc_arrayN(bpoly->numverts, sizeof(*sdbind->vert_inds), "SDefCentVertInds");
 					if (sdbind->vert_inds == NULL) {
 						data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
 						return;
@@ -883,13 +883,13 @@ static void bindVert(
 					sdbind->numverts = bpoly->numverts;
 
 					sdbind->mode = MOD_SDEF_MODE_LOOPTRI;
-					sdbind->vert_weights = MEM_mallocN(sizeof(*sdbind->vert_weights) * 3, "SDefTriVertWeights");
+					sdbind->vert_weights = MEM_malloc_arrayN(3, sizeof(*sdbind->vert_weights), "SDefTriVertWeights");
 					if (sdbind->vert_weights == NULL) {
 						data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
 						return;
 					}
 
-					sdbind->vert_inds = MEM_mallocN(sizeof(*sdbind->vert_inds) * bpoly->numverts, "SDefTriVertInds");
+					sdbind->vert_inds = MEM_malloc_arrayN(bpoly->numverts, sizeof(*sdbind->vert_inds), "SDefTriVertInds");
 					if (sdbind->vert_inds == NULL) {
 						data->success = MOD_SDEF_BIND_RESULT_MEM_ERR;
 						return;
@@ -940,20 +940,20 @@ static bool surfacedeformBind(SurfaceDeformModifierData *smd, float (*vertexCos)
 	SDefAdjacency *adj_array;
 	SDefEdgePolys *edge_polys;
 
-	vert_edges = MEM_callocN(sizeof(*vert_edges) * tnumverts, "SDefVertEdgeMap");
+	vert_edges = MEM_calloc_arrayN(tnumverts, sizeof(*vert_edges), "SDefVertEdgeMap");
 	if (vert_edges == NULL) {
 		modifier_setError((ModifierData *)smd, "Out of memory");
 		return false;
 	}
 
-	adj_array = MEM_mallocN(sizeof(*adj_array) * tnumedges * 2, "SDefVertEdge");
+	adj_array = MEM_malloc_arrayN(tnumedges, 2 * sizeof(*adj_array), "SDefVertEdge");
 	if (adj_array == NULL) {
 		modifier_setError((ModifierData *)smd, "Out of memory");
 		MEM_freeN(vert_edges);
 		return false;
 	}
 
-	edge_polys = MEM_callocN(sizeof(*edge_polys) * tnumedges, "SDefEdgeFaceMap");
+	edge_polys = MEM_calloc_arrayN(tnumedges, sizeof(*edge_polys), "SDefEdgeFaceMap");
 	if (edge_polys == NULL) {
 		modifier_setError((ModifierData *)smd, "Out of memory");
 		MEM_freeN(vert_edges);
@@ -961,7 +961,7 @@ static bool surfacedeformBind(SurfaceDeformModifierData *smd, float (*vertexCos)
 		return false;
 	}
 
-	smd->verts = MEM_mallocN(sizeof(*smd->verts) * numverts, "SDefBindVerts");
+	smd->verts = MEM_malloc_arrayN(numverts, sizeof(*smd->verts), "SDefBindVerts");
 	if (smd->verts == NULL) {
 		modifier_setError((ModifierData *)smd, "Out of memory");
 		freeAdjacencyMap(vert_edges, adj_array, edge_polys);
@@ -998,7 +998,7 @@ static bool surfacedeformBind(SurfaceDeformModifierData *smd, float (*vertexCos)
 		                     .medge = medge,
 		                     .mloop = mloop,
 		                     .looptri = tdm->getLoopTriArray(tdm),
-		                     .targetCos = MEM_mallocN(sizeof(float[3]) * tnumverts, "SDefTargetBindVertArray"),
+		                     .targetCos = MEM_malloc_arrayN(tnumverts, sizeof(float[3]), "SDefTargetBindVertArray"),
 		                     .bind_verts = smd->verts,
 		                     .vertexCos = vertexCos,
 		                     .falloff = smd->falloff,
@@ -1071,7 +1071,7 @@ static void deformVert(
 
 	for (int j = 0; j < data->bind_verts[index].numbinds; j++, sdbind++) {
 		/* Mode-generic operations (allocate poly coordinates) */
-		float (*coords)[3] = MEM_mallocN(sizeof(*coords) * sdbind->numverts, "SDefDoPolyCoords");
+		float (*coords)[3] = MEM_malloc_arrayN(sdbind->numverts, sizeof(*coords), "SDefDoPolyCoords");
 
 		for (int k = 0; k < sdbind->numverts; k++) {
 			copy_v3_v3(coords[k], data->targetCos[sdbind->vert_inds[k]]);
@@ -1169,7 +1169,7 @@ static void surfacedeformModifier_do(ModifierData *md, float (*vertexCos)[3], un
 	/* Actual vertex location update starts here */
 	SDefDeformData data = {
 		.bind_verts = smd->verts,
-		.targetCos = MEM_mallocN(sizeof(float[3]) * tnumverts, "SDefTargetVertArray"),
+		.targetCos = MEM_malloc_arrayN(tnumverts, sizeof(float[3]), "SDefTargetVertArray"),
 		.vertexCos = vertexCos,
 	};
 
diff --git a/source/blender/modifiers/intern/MOD_util.c b/source/blender/modifiers/intern/MOD_util.c
index ded1f0b77e..5b19bcf481 100644
--- a/source/blender/modifiers/intern/MOD_util.c
+++ b/source/blender/modifiers/intern/MOD_util.c
@@ -87,7 +87,7 @@ void get_texture_coords(MappingInfoModifierData *dmd, Object *ob,
 			MPoly *mpoly = dm->getPolyArray(dm);
 			MPoly *mp;
 			MLoop *mloop = dm->getLoopArray(dm);
-			char *done = MEM_callocN(sizeof(*done) * numVerts,
+			char *done = MEM_calloc_arrayN(numVerts, sizeof(*done),
 			                         "get_texture_coords done");
 			int numPolys = dm->getNumPolys(dm);
 			char uvname[MAX_CUSTOMDATA_LAYER_NAME];
diff --git a/source/blender/modifiers/intern/MOD_uvproject.c b/source/blender/modifiers/intern/MOD_uvproject.c
index 01468c1143..89ce50d076 100644
--- a/source/blender/modifiers/intern/MOD_uvproject.c
+++ b/source/blender/modifiers/intern/MOD_uvproject.c
@@ -251,7 +251,7 @@ static DerivedMesh *uvprojectModifier_do(UVProjectModifierData *umd,
 
 	numVerts = dm->getNumVerts(dm);
 
-	coords = MEM_mallocN(sizeof(*coords) * numVerts,
+	coords = MEM_malloc_arrayN(numVerts, sizeof(*coords),
 	                     "uvprojectModifier_do coords");
 	dm->getVertCos(dm, coords);
 
diff --git a/source/blender/modifiers/intern/MOD_warp.c b/source/blender/modifiers/intern/MOD_warp.c
index b340356467..62813d7579 100644
--- a/source/blender/modifiers/intern/MOD_warp.c
+++ b/source/blender/modifiers/intern/MOD_warp.c
@@ -237,7 +237,7 @@ static void warpModifier_do(WarpModifierData *wmd, Object *ob,
 	weight = strength;
 
 	if (wmd->texture) {
-		tex_co = MEM_mallocN(sizeof(*tex_co) * numVerts, "warpModifier_do tex_co");
+		tex_co = MEM_malloc_arrayN(numVerts, sizeof(*tex_co), "warpModifier_do tex_co");
 		get_texture_coords((MappingInfoModifierData *)wmd, ob, dm, vertexCos, tex_co, numVerts);
 
 		modifier_init_texture(wmd->modifier.scene, wmd->texture);
diff --git a/source/blender/modifiers/intern/MOD_wave.c b/source/blender/modifiers/intern/MOD_wave.c
index b4990c5250..9e351d1e41 100644
--- a/source/blender/modifiers/intern/MOD_wave.c
+++ b/source/blender/modifiers/intern/MOD_wave.c
@@ -228,7 +228,7 @@ static void waveModifier_do(WaveModifierData *md,
 	}
 
 	if (wmd->texture) {
-		tex_co = MEM_mallocN(sizeof(*tex_co) * numVerts,
+		tex_co = MEM_malloc_arrayN(numVerts, sizeof(*tex_co),
 		                     "waveModifier_do tex_co");
 		get_texture_coords((MappingInfoModifierData *)wmd, ob, dm, vertexCos, tex_co, numVerts);
 
diff --git a/source/blender/modifiers/intern/MOD_weightvg_util.c b/source/blender/modifiers/intern/MOD_weightvg_util.c
index da7230ed5a..416f2964d6 100644
--- a/source/blender/modifiers/intern/MOD_weightvg_util.c
+++ b/source/blender/modifiers/intern/MOD_weightvg_util.c
@@ -143,9 +143,9 @@ void weightvg_do_mask(int num, const int *indices, float *org_w, const float *ne
 		t_map.map_object = tex_map_object;
 		BLI_strncpy(t_map.uvlayer_name, tex_uvlayer_name, sizeof(t_map.uvlayer_name));
 		t_map.texmapping = tex_mapping;
-		v_co = MEM_mallocN(sizeof(*v_co) * numVerts, "WeightVG Modifier, TEX mode, v_co");
+		v_co = MEM_malloc_arrayN(numVerts, sizeof(*v_co), "WeightVG Modifier, TEX mode, v_co");
 		dm->getVertCos(dm, v_co);
-		tex_co = MEM_callocN(sizeof(*tex_co) * numVerts, "WeightVG Modifier, TEX mode, tex_co");
+		tex_co = MEM_calloc_arrayN(numVerts, sizeof(*tex_co), "WeightVG Modifier, TEX mode, tex_co");
 		get_texture_coords(&t_map, ob, dm, v_co, tex_co, num);
 		MEM_freeN(v_co);
 
diff --git a/source/blender/modifiers/intern/MOD_weightvgedit.c b/source/blender/modifiers/intern/MOD_weightvgedit.c
index 13a97c1c13..a5f40a5e8c 100644
--- a/source/blender/modifiers/intern/MOD_weightvgedit.c
+++ b/source/blender/modifiers/intern/MOD_weightvgedit.c
@@ -231,9 +231,9 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob, DerivedMesh *der
 	}
 
 	/* Get org weights, assuming 0.0 for vertices not in given vgroup. */
-	org_w = MEM_mallocN(sizeof(float) * numVerts, "WeightVGEdit Modifier, org_w");
-	new_w = MEM_mallocN(sizeof(float) * numVerts, "WeightVGEdit Modifier, new_w");
-	dw = MEM_mallocN(sizeof(MDeformWeight *) * numVerts, "WeightVGEdit Modifier, dw");
+	org_w = MEM_malloc_arrayN(numVerts, sizeof(float), "WeightVGEdit Modifier, org_w");
+	new_w = MEM_malloc_arrayN(numVerts, sizeof(float), "WeightVGEdit Modifier, new_w");
+	dw = MEM_malloc_arrayN(numVerts, sizeof(MDeformWeight *), "WeightVGEdit Modifier, dw");
 	for (i = 0; i < numVerts; i++) {
 		dw[i] = defvert_find_index(&dvert[i], defgrp_index);
 		if (dw[i]) {
diff --git a/source/blender/modifiers/intern/MOD_weightvgmix.c b/source/blender/modifiers/intern/MOD_weightvgmix.c
index 392f42040b..b3a687474f 100644
--- a/source/blender/modifiers/intern/MOD_weightvgmix.c
+++ b/source/blender/modifiers/intern/MOD_weightvgmix.c
@@ -286,9 +286,9 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob, DerivedMesh *der
 			return dm;
 	}
 	/* Find out which vertices to work on. */
-	tidx = MEM_mallocN(sizeof(int) * numVerts, "WeightVGMix Modifier, tidx");
-	tdw1 = MEM_mallocN(sizeof(MDeformWeight *) * numVerts, "WeightVGMix Modifier, tdw1");
-	tdw2 = MEM_mallocN(sizeof(MDeformWeight *) * numVerts, "WeightVGMix Modifier, tdw2");
+	tidx = MEM_malloc_arrayN(numVerts, sizeof(int), "WeightVGMix Modifier, tidx");
+	tdw1 = MEM_malloc_arrayN(numVerts, sizeof(MDeformWeight *), "WeightVGMix Modifier, tdw1");
+	tdw2 = MEM_malloc_arrayN(numVerts, sizeof(MDeformWeight *), "WeightVGMix Modifier, tdw2");
 	switch (wmd->mix_set) {
 		case MOD_WVG_SET_A:
 			/* All vertices in first vgroup. */
@@ -354,12 +354,12 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob, DerivedMesh *der
 		return dm;
 	}
 	if (numIdx != -1) {
-		indices = MEM_mallocN(sizeof(int) * numIdx, "WeightVGMix Modifier, indices");
+		indices = MEM_malloc_arrayN(numIdx, sizeof(int), "WeightVGMix Modifier, indices");
 		memcpy(indices, tidx, sizeof(int) * numIdx);
-		dw1 = MEM_mallocN(sizeof(MDeformWeight *) * numIdx, "WeightVGMix Modifier, dw1");
+		dw1 = MEM_malloc_arrayN(numIdx, sizeof(MDeformWeight *), "WeightVGMix Modifier, dw1");
 		memcpy(dw1, tdw1, sizeof(MDeformWeight *) * numIdx);
 		MEM_freeN(tdw1);
-		dw2 = MEM_mallocN(sizeof(MDeformWeight *) * numIdx, "WeightVGMix Modifier, dw2");
+		dw2 = MEM_malloc_arrayN(numIdx, sizeof(MDeformWeight *), "WeightVGMix Modifier, dw2");
 		memcpy(dw2, tdw2, sizeof(MDeformWeight *) * numIdx);
 		MEM_freeN(tdw2);
 	}
@@ -372,8 +372,8 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob, DerivedMesh *der
 	}
 	MEM_freeN(tidx);
 
-	org_w = MEM_mallocN(sizeof(float) * numIdx, "WeightVGMix Modifier, org_w");
-	new_w = MEM_mallocN(sizeof(float) * numIdx, "WeightVGMix Modifier, new_w");
+	org_w = MEM_malloc_arrayN(numIdx, sizeof(float), "WeightVGMix Modifier, org_w");
+	new_w = MEM_malloc_arrayN(numIdx, sizeof(float), "WeightVGMix Modifier, new_w");
 
 	/* Mix weights. */
 	for (i = 0; i < numIdx; i++) {
diff --git a/source/blender/modifiers/intern/MOD_weightvgproximity.c b/source/blender/modifiers/intern/MOD_weightvgproximity.c
index 16ed743a1c..3904532a9b 100644
--- a/source/blender/modifiers/intern/MOD_weightvgproximity.c
+++ b/source/blender/modifiers/intern/MOD_weightvgproximity.c
@@ -460,9 +460,9 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob, DerivedMesh *der
 
 	/* Find out which vertices to work on (all vertices in vgroup), and get their relevant weight.
 	 */
-	tidx = MEM_mallocN(sizeof(int) * numVerts, "WeightVGProximity Modifier, tidx");
-	tw = MEM_mallocN(sizeof(float) * numVerts, "WeightVGProximity Modifier, tw");
-	tdw = MEM_mallocN(sizeof(MDeformWeight *) * numVerts, "WeightVGProximity Modifier, tdw");
+	tidx = MEM_malloc_arrayN(numVerts, sizeof(int), "WeightVGProximity Modifier, tidx");
+	tw = MEM_malloc_arrayN(numVerts, sizeof(float), "WeightVGProximity Modifier, tw");
+	tdw = MEM_malloc_arrayN(numVerts, sizeof(MDeformWeight *), "WeightVGProximity Modifier, tdw");
 	for (i = 0; i < numVerts; i++) {
 		MDeformWeight *_dw = defvert_find_index(&dvert[i], defgrp_index);
 		if (_dw) {
@@ -479,11 +479,11 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob, DerivedMesh *der
 		return dm;
 	}
 	if (numIdx != numVerts) {
-		indices = MEM_mallocN(sizeof(int) * numIdx, "WeightVGProximity Modifier, indices");
+		indices = MEM_malloc_arrayN(numIdx, sizeof(int), "WeightVGProximity Modifier, indices");
 		memcpy(indices, tidx, sizeof(int) * numIdx);
-		org_w = MEM_mallocN(sizeof(float) * numIdx, "WeightVGProximity Modifier, org_w");
+		org_w = MEM_malloc_arrayN(numIdx, sizeof(float), "WeightVGProximity Modifier, org_w");
 		memcpy(org_w, tw, sizeof(float) * numIdx);
-		dw = MEM_mallocN(sizeof(MDeformWeight *) * numIdx, "WeightVGProximity Modifier, dw");
+		dw = MEM_malloc_arrayN(numIdx, sizeof(MDeformWeight *), "WeightVGProximity Modifier, dw");
 		memcpy(dw, tdw, sizeof(MDeformWeight *) * numIdx);
 		MEM_freeN(tw);
 		MEM_freeN(tdw);
@@ -492,16 +492,16 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob, DerivedMesh *der
 		org_w = tw;
 		dw = tdw;
 	}
-	new_w = MEM_mallocN(sizeof(float) * numIdx, "WeightVGProximity Modifier, new_w");
+	new_w = MEM_malloc_arrayN(numIdx, sizeof(float), "WeightVGProximity Modifier, new_w");
 	MEM_freeN(tidx);
 
 	/* Get our vertex coordinates. */
-	v_cos = MEM_mallocN(sizeof(float[3]) * numIdx, "WeightVGProximity Modifier, v_cos");
+	v_cos = MEM_malloc_arrayN(numIdx, sizeof(float[3]), "WeightVGProximity Modifier, v_cos");
 	if (numIdx != numVerts) {
 		/* XXX In some situations, this code can be up to about 50 times more performant
 		 *     than simply using getVertCo for each affected vertex...
 		 */
-		float (*tv_cos)[3] = MEM_mallocN(sizeof(float[3]) * numVerts, "WeightVGProximity Modifier, tv_cos");
+		float (*tv_cos)[3] = MEM_malloc_arrayN(numVerts, sizeof(float[3]), "WeightVGProximity Modifier, tv_cos");
 		dm->getVertCos(dm, tv_cos);
 		for (i = 0; i < numIdx; i++)
 			copy_v3_v3(v_cos[i], tv_cos[indices[i]]);
@@ -540,9 +540,9 @@ static DerivedMesh *applyModifier(ModifierData *md, Object *ob, DerivedMesh *der
 			/* We must check that we do have a valid target_dm! */
 			if (target_dm) {
 				SpaceTransform loc2trgt;
-				float *dists_v = use_trgt_verts ? MEM_mallocN(sizeof(float) * numIdx, "dists_v") : NULL;
-				float *dists_e = use_trgt_edges ? MEM_mallocN(sizeof(float) * numIdx, "dists_e") : NULL;
-				float *dists_f = use_trgt_faces ? MEM_mallocN(sizeof(float) * numIdx, "dists_f") : NULL;
+				float *dists_v = use_trgt_verts ? MEM_malloc_arrayN(numIdx, sizeof(float), "dists_v") : NULL;
+				float *dists_e = use_trgt_edges ? MEM_malloc_arrayN(numIdx, sizeof(float), "dists_e") : NULL;
+				float *dists_f = use_trgt_faces ? MEM_malloc_arrayN(numIdx, sizeof(float), "dists_f") : NULL;
 
 				BLI_SPACE_TRANSFORM_SETUP(&loc2trgt, ob, obr);
 				get_vert2geom_distance(numIdx, v_cos, dists_v, dists_e, dists_f,
