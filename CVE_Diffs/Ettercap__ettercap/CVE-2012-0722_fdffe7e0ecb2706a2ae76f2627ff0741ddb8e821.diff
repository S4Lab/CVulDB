Ettercap__ettercap
commit fdffe7e0ecb2706a2ae76f2627ff0741ddb8e821
Author:     Emilio A. Escobar <eescobar@gmail.com>
AuthorDate: Wed Jan 9 21:23:47 2013 -0500
Commit:     Emilio A. Escobar <eescobar@gmail.com>
CommitDate: Wed Jan 9 21:23:47 2013 -0500

    Added --certificate and --private-key flags to allow users to utilize a custom Certificate and private key for SSL MiTM. Included patch to fix CVE-2012-0722

diff --git a/include/ec.h b/include/ec.h
index 463e36fd..069e3f1f 100644
--- a/include/ec.h
+++ b/include/ec.h
@@ -81,6 +81,11 @@
 
 #define SAFE_FREE(x) do{ if(x) { free(x); x = NULL; } }while(0)
 
+
+/* convert to string */
+#define EC_STRINGIFY(in) #in
+#define EC_TOSTRING(in) EC_STRINGIFY(in)
+
 #ifdef OS_LINUX
 #define __init       __attribute__((constructor(101)))
 #define __init_last  __attribute__((constructor(200))
diff --git a/include/ec_globals.h b/include/ec_globals.h
index 0fb1db2b..3a1a417e 100644
--- a/include/ec_globals.h
+++ b/include/ec_globals.h
@@ -84,6 +84,8 @@ struct ec_options {
    char *target1;
    char *target2;
    char *script;
+   char *ssl_cert;
+   char *ssl_pkey;
    FILE *msg_fd;
    int (*format)(const u_char *, size_t, u_char *);
    regex_t *regex;
diff --git a/include/ec_inet.h b/include/ec_inet.h
index 43b0ca5f..379192da 100644
--- a/include/ec_inet.h
+++ b/include/ec_inet.h
@@ -24,24 +24,22 @@
    #endif
 #endif
 
-enum {
-   NS_IN6ADDRSZ            = 16,
-   NS_INT16SZ              = 2,
-
-   ETH_ADDR_LEN            = 6,
-   TR_ADDR_LEN             = 6,
-   FDDI_ADDR_LEN           = 6,
-   MEDIA_ADDR_LEN          = 6,
+#define	NS_IN6ADDRSZ 16
+#define 	NS_INT16SZ = 2
+
+#define	ETH_ADDR_LEN 6
+#define	TR_ADDR_LEN 6
+#define	FDDI_ADDR_LEN 6
+#define	MEDIA_ADDR_LEN 6
    
-   IP_ADDR_LEN             = 4,
-   IP6_ADDR_LEN            = 16,
-   MAX_IP_ADDR_LEN         = IP6_ADDR_LEN,
-
-   ETH_ASCII_ADDR_LEN      = sizeof("ff:ff:ff:ff:ff:ff")+1,
-   IP_ASCII_ADDR_LEN       = sizeof("255.255.255.255")+1,
-   IP6_ASCII_ADDR_LEN      = sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")+1,
-   MAX_ASCII_ADDR_LEN      = IP6_ASCII_ADDR_LEN,                  
-};
+#define	IP_ADDR_LEN 4
+#define	IP6_ADDR_LEN 16
+#define	MAX_IP_ADDR_LEN IP6_ADDR_LEN
+
+#define	ETH_ASCII_ADDR_LEN 19 // sizeof("ff:ff:ff:ff:ff:ff")+1
+#define	IP_ASCII_ADDR_LEN 17 // sizeof("255.255.255.255")+1
+#define	IP6_ASCII_ADDR_LEN 47 // sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")+1
+#define	MAX_ASCII_ADDR_LEN IP6_ASCII_ADDR_LEN
 
 /*
  * Some predefined addresses here
diff --git a/man/ettercap.8.in b/man/ettercap.8.in
index 9295f223..b1bda7c6 100644
--- a/man/ettercap.8.in
+++ b/man/ettercap.8.in
@@ -196,6 +196,9 @@ cat tmp.new >> etter.ssl.crt
 rm \-f tmp.new tmp.csr
 .PP
 NOTE: SSL mitm is not available (for now) in bridged mode.
+.PP
+NOTE: You can use the --certificate/--private-key long options if you want to specify
+a different file rather than the etter.ssl.crt file.
 
 
 .SH OPTIONS
@@ -545,6 +548,10 @@ This option will print the list of all available network interfaces that can be
 used within ettercap. The option is particularly useful under windows where the
 name of the interface is not so obvious as under *nix.
 
+.TP
+\fB\-Y\fR, \fB\-\-secondary <interface list>\fR
+Specify a list of (or single) secondary interfaces to capture packets from.
+
 .TP
 \fB\-A\fR, \fB\-\-address <ADDRESS>\fR
 Use this <ADDRESS> instead of the one autodetected for the current iface. This
@@ -680,7 +687,13 @@ example:
 \fB\-a\fR, \fB\-\-config <CONFIG>\fR
 Loads an alternative config file instead of the default in /etc/etter.conf.
 This is useful if you have many preconfigured files for different situations.
+.TP
+\fB\-\-certificate <FILE>\fR
+Tells Ettercap to use the specified certificate file for the SSL MiTM attack.
 
+.TP
+\fB\-\-private-key <FILE>\fR
+Tells Ettercap to use the specified private key file for the SSL MiTM attack.
 
 
 .TP
diff --git a/src/ec_parser.c b/src/ec_parser.c
index 73971036..ac3ae9ce 100644
--- a/src/ec_parser.c
+++ b/src/ec_parser.c
@@ -74,6 +74,8 @@ void ec_usage(void)
    fprintf(stdout, "  -f, --pcapfilter <string>   set the pcap filter <string>\n");
    fprintf(stdout, "  -R, --reversed              use reversed TARGET matching\n");
    fprintf(stdout, "  -t, --proto <proto>         sniff only this proto (default is all)\n");
+   fprintf(stdout, "      --certificate <file>    certificate file to use for SSL MiTM\n");
+   fprintf(stdout, "      --private-key <file>    private key file to use for SSL MiTM\n");
    
    fprintf(stdout, "\nUser Interface Type:\n");
    fprintf(stdout, "  -T, --text                  use text only GUI\n");
@@ -181,6 +183,8 @@ void parse_options(int argc, char **argv)
       { "broadcast", required_argument, NULL, 'b' },
       { "promisc", no_argument, NULL, 'p' },
       { "gateway", required_argument, NULL, 'Y' },
+      { "certificate", required_argument, NULL, 0 },
+      { "private-key", required_argument, NULL, 0 },
 
       
       { 0 , 0 , 0 , 0}
@@ -196,12 +200,15 @@ void parse_options(int argc, char **argv)
    GBL_FORMAT = &ascii_format;
    GBL_OPTIONS->ssl_mitm = 1;
    GBL_OPTIONS->broadcast = 0;
+   GBL_OPTIONS->ssl_cert = NULL;
+   GBL_OPTIONS->ssl_pkey = NULL;
 
 /* OPTIONS INITIALIZED */
    
    optind = 0;
+   int option_index = 0;
 
-   while ((c = getopt_long (argc, argv, "A:a:bB:CchDdEe:F:f:GhIi:j:k:L:l:M:m:n:oP:pQqiRr:s:STt:UuV:vW:w:Y:z", long_options, (int *)0)) != EOF) {
+   while ((c = getopt_long (argc, argv, "A:a:bB:CchDdEe:F:f:GhIi:j:k:L:l:M:m:n:oP:pQqiRr:s:STt:UuV:vW:w:Y:z", long_options, &option_index)) != EOF) {
       /* used for parsing arguments */
       char *opt_end = optarg;
       while (opt_end && *opt_end) opt_end++;
@@ -412,6 +419,19 @@ void parse_options(int argc, char **argv)
                   clean_exit(0);
                   break;
 
+        /* Certificate and private key options */
+         case 0:
+		if (!strcmp(long_options[option_index].name, "certificate")) {
+			GBL_OPTIONS->ssl_cert = strdup(optarg);	
+		} else if (!strcmp(long_options[option_index].name, "private-key")) {
+			GBL_OPTIONS->ssl_pkey = strdup(optarg);
+		} else {
+			fprintf(stdout, "\nTry `%s --help' for more options.\n\n", GBL_PROGRAM);
+			clean_exit(-1);
+		}
+
+		break;
+
          case ':': // missing parameter
             fprintf(stdout, "\nTry `%s --help' for more options.\n\n", GBL_PROGRAM);
             clean_exit(-1);
diff --git a/src/ec_scan.c b/src/ec_scan.c
index cce36725..9455c3eb 100644
--- a/src/ec_scan.c
+++ b/src/ec_scan.c
@@ -630,7 +630,7 @@ int scan_load_hosts(char *filename)
    for (nhosts = 0; !feof(hf); nhosts++) {
       int proto;
 
-      if (fscanf(hf, "%s %s %s\n", ip, mac, name) != 3 ||
+      if (fscanf(hf, "%"EC_TOSTRING(MAX_ASCII_ADDR_LEN)"s %"EC_TOSTRING(ETH_ASCII_ADDR_LEN)"s %"EC_TOSTRING(MAX_HOSTNAME_LEN)"s\n", ip, mac, name) != 3 ||
          *ip == '#' || *mac == '#' || *name == '#')
          continue;
 
diff --git a/src/ec_sslwrap.c b/src/ec_sslwrap.c
index 5c876b3b..b0c444c2 100644
--- a/src/ec_sslwrap.c
+++ b/src/ec_sslwrap.c
@@ -672,14 +672,17 @@ static int sslw_sync_ssl(struct accepted_entry *ae)
       return -EINVALID;
    }
 
-   /* Create the fake certificate */
-   ae->cert = sslw_create_selfsigned(server_cert);  
-   X509_free(server_cert);
+   if (!GBL_OPTIONS->ssl_cert) {
+   	/* Create the fake certificate */
+   	ae->cert = sslw_create_selfsigned(server_cert);  
+   	X509_free(server_cert);
 
-   if (ae->cert == NULL)
-      return -EINVALID;
-   
-   SSL_use_certificate(ae->ssl[SSL_CLIENT], ae->cert);
+   	if (ae->cert == NULL)
+      		return -EINVALID;
+
+   	SSL_use_certificate(ae->ssl[SSL_CLIENT], ae->cert);
+
+   }
    
    if (sslw_ssl_accept(ae->ssl[SSL_CLIENT]) != ESUCCESS) 
       return -EINVALID;
@@ -1077,12 +1080,30 @@ static void sslw_init(void)
    ON_ERROR(ssl_ctx_client, NULL, "Could not create client SSL CTX");
    ON_ERROR(ssl_ctx_server, NULL, "Could not create server SSL CTX");
 
-   /* Get our private key from our cert file */
-   if (SSL_CTX_use_PrivateKey_file(ssl_ctx_client, INSTALL_DATADIR "/" EC_PROGRAM "/" CERT_FILE, SSL_FILETYPE_PEM) == 0) {
-      DEBUG_MSG("sslw -- SSL_CTX_use_PrivateKey_file -- trying ./share/%s",  CERT_FILE);
+   if(GBL_OPTIONS->ssl_pkey) {
+	/* Get our private key from the file specified from cmd-line */
+	DEBUG_MSG("Using custom private key %s", GBL_OPTIONS->ssl_pkey);
+	if (SSL_CTX_use_PrivateKey_file(ssl_ctx_client, GBL_OPTIONS->ssl_pkey, SSL_FILETYPE_PEM) == 0) {
+		FATAL_ERROR("Can't open \"%s\" file : %s", GBL_OPTIONS->ssl_pkey, strerror(errno));
+	}
+
+	if (GBL_OPTIONS->ssl_cert) {
+		if (SSL_CTX_use_certificate_file(ssl_ctx_client, GBL_OPTIONS->ssl_cert, SSL_FILETYPE_PEM) == 0) {
+			FATAL_ERROR("Can't open \"%s\" file : %s", GBL_OPTIONS->ssl_cert, strerror(errno));
+		}
+
+		if (!SSL_CTX_check_private_key(ssl_ctx_client)) {
+			FATAL_ERROR("Certificate \"%s\" does not match private key \"%s\"", GBL_OPTIONS->ssl_cert, GBL_OPTIONS->ssl_pkey);
+		}
+	}
+   } else {
+   	/* Get our private key from our cert file */
+   	if (SSL_CTX_use_PrivateKey_file(ssl_ctx_client, INSTALL_DATADIR "/" EC_PROGRAM "/" CERT_FILE, SSL_FILETYPE_PEM) == 0) {
+      		DEBUG_MSG("sslw -- SSL_CTX_use_PrivateKey_file -- trying ./share/%s",  CERT_FILE);
 
-      if (SSL_CTX_use_PrivateKey_file(ssl_ctx_client, "./share/" CERT_FILE, SSL_FILETYPE_PEM) == 0)
-         FATAL_ERROR("Can't open \"./share/%s\" file : %s", CERT_FILE, strerror(errno));
+      		if (SSL_CTX_use_PrivateKey_file(ssl_ctx_client, "./share/" CERT_FILE, SSL_FILETYPE_PEM) == 0)
+         		FATAL_ERROR("Can't open \"./share/%s\" file : %s", CERT_FILE, strerror(errno));
+   	}
    }
 
    dummy_ssl = SSL_new(ssl_ctx_client);
