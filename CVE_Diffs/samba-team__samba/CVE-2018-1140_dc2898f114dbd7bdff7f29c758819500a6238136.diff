samba-team__samba
commit dc2898f114dbd7bdff7f29c758819500a6238136
Author:     Andrew Bartlett <abartlet@samba.org>
AuthorDate: Mon May 21 15:23:53 2018 +1200
Commit:     Stefan Metzmacher <metze@samba.org>
CommitDate: Tue Aug 14 17:42:11 2018 +0200

    CVE-2018-1140 ldb_tdb: Check for DN validity in add, rename and search
    
    This ensures we fail with a good error code before an eventual ldb_dn_get_casefold() which
    would otherwise fail.
    
    Signed-off-by: Andrew Bartlett <abartlet@samba.org>
    Reviewed-by: Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
    BUG: https://bugzilla.samba.org/show_bug.cgi?id=13374

diff --git a/lib/ldb/ldb_tdb/ldb_search.c b/lib/ldb/ldb_tdb/ldb_search.c
index 832be9a598b..af66a097ad5 100644
--- a/lib/ldb/ldb_tdb/ldb_search.c
+++ b/lib/ldb/ldb_tdb/ldb_search.c
@@ -297,6 +297,14 @@ int ltdb_search_dn1(struct ldb_module *module, struct ldb_dn *dn, struct ldb_mes
 	};
 	TALLOC_CTX *tdb_key_ctx = NULL;
 
+	bool valid_dn = ldb_dn_validate(dn);
+	if (valid_dn == false) {
+		ldb_asprintf_errstring(ldb_module_get_ctx(module),
+				       "Invalid Base DN: %s",
+				       ldb_dn_get_linearized(dn));
+		return LDB_ERR_INVALID_DN_SYNTAX;
+	}
+
 	if (ltdb->cache->GUID_index_attribute == NULL ||
 		ldb_dn_is_special(dn)) {
 
@@ -791,6 +799,14 @@ int ltdb_search(struct ltdb_context *ctx)
 					       ldb_dn_get_linearized(req->op.search.base));
 		}
 			
+	} else if (ldb_dn_validate(req->op.search.base) == false) {
+
+		/* We don't want invalid base DNs here */
+		ldb_asprintf_errstring(ldb,
+				       "Invalid Base DN: %s",
+				       ldb_dn_get_linearized(req->op.search.base));
+		ret = LDB_ERR_INVALID_DN_SYNTAX;
+
 	} else {
 		/* If we are not checking the base DN life is easy */
 		ret = LDB_SUCCESS;
diff --git a/lib/ldb/ldb_tdb/ldb_tdb.c b/lib/ldb/ldb_tdb/ldb_tdb.c
index daf9a778f5b..a83bc34f58b 100644
--- a/lib/ldb/ldb_tdb/ldb_tdb.c
+++ b/lib/ldb/ldb_tdb/ldb_tdb.c
@@ -566,6 +566,16 @@ static int ltdb_add_internal(struct ldb_module *module,
 	struct ldb_context *ldb = ldb_module_get_ctx(module);
 	int ret = LDB_SUCCESS;
 	unsigned int i;
+	bool valid_dn = false;
+
+	/* Check the new DN is reasonable */
+	valid_dn = ldb_dn_validate(msg->dn);
+	if (valid_dn == false) {
+		ldb_asprintf_errstring(ldb_module_get_ctx(module),
+				       "Invalid DN in ADD: %s",
+				       ldb_dn_get_linearized(msg->dn));
+		return LDB_ERR_INVALID_DN_SYNTAX;
+	}
 
 	for (i=0;i<msg->num_elements;i++) {
 		struct ldb_message_element *el = &msg->elements[i];
@@ -1369,6 +1379,7 @@ static int ltdb_rename(struct ltdb_context *ctx)
 	int ret = LDB_SUCCESS;
 	TDB_DATA tdb_key, tdb_key_old;
 	struct ldb_dn *db_dn;
+	bool valid_dn = false;
 
 	ldb_request_set_state(req, LDB_ASYNC_PENDING);
 
@@ -1381,10 +1392,24 @@ static int ltdb_rename(struct ltdb_context *ctx)
 		return LDB_ERR_OPERATIONS_ERROR;
 	}
 
+	/* Check the new DN is reasonable */
+	valid_dn = ldb_dn_validate(req->op.rename.newdn);
+	if (valid_dn == false) {
+		ldb_asprintf_errstring(ldb_module_get_ctx(module),
+				       "Invalid New DN: %s",
+				       ldb_dn_get_linearized(req->op.rename.newdn));
+		return LDB_ERR_INVALID_DN_SYNTAX;
+	}
+
 	/* we need to fetch the old record to re-add under the new name */
 	ret = ltdb_search_dn1(module, req->op.rename.olddn, msg,
 			      LDB_UNPACK_DATA_FLAG_NO_DATA_ALLOC);
-	if (ret != LDB_SUCCESS) {
+	if (ret == LDB_ERR_INVALID_DN_SYNTAX) {
+		ldb_asprintf_errstring(ldb_module_get_ctx(module),
+				       "Invalid Old DN: %s",
+				       ldb_dn_get_linearized(req->op.rename.newdn));
+		return ret;
+	} else if (ret != LDB_SUCCESS) {
 		/* not finding the old record is an error */
 		return ret;
 	}
