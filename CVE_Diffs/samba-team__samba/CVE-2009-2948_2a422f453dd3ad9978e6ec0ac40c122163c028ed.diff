samba-team__samba
commit 2a422f453dd3ad9978e6ec0ac40c122163c028ed
Author:     Jeff Layton <jlayton@redhat.com>
AuthorDate: Fri Sep 25 07:03:07 2009 -0400
Commit:     Karolin Seeger <kseeger@samba.org>
CommitDate: Mon Sep 28 13:24:07 2009 +0200

    mount.cifs: don't leak passwords with verbose option
    
    When running mount.cifs with the --verbose option, it'll print out the
    option string that it passes to the kernel...including the mount
    password if there is one. Print a placeholder string instead to help
    ensure that this info can't be used for nefarious purposes.
    
    Also, the --verbose option printed the option string before it was
    completely assembled anyway. This patch should also make sure that
    the complete option string is printed out.
    
    Finally, strndup passwords passed in on the command line to ensure that
    they aren't shown by --verbose as well. Passwords used this way can
    never be truly kept private from other users on the machine of course,
    but it's simple enough to do it this way for completeness sake.
    
    Reported-by: Ronald Volgers <r.c.volgers@student.utwente.nl>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Steve French <sfrench@us.ibm.com>
    
    Part 2/2 of a fix for CVE-2009-2948.

diff --git a/source3/client/mount.cifs.c b/source3/client/mount.cifs.c
index 54d59cf6371..43dc7f618b6 100644
--- a/source3/client/mount.cifs.c
+++ b/source3/client/mount.cifs.c
@@ -390,9 +390,6 @@ static int parse_options(char ** optionsp, int * filesys_flags)
 		return 1;
 	data = *optionsp;
 
-	if(verboseflag)
-		printf("parsing options: %s\n", data);
-
 	/* BB fixme check for separator override BB */
 
 	if (getuid()) {
@@ -481,18 +478,27 @@ static int parse_options(char ** optionsp, int * filesys_flags)
 		} else if (strncmp(data, "pass", 4) == 0) {
 			if (!value || !*value) {
 				if(got_password) {
-					printf("\npassword specified twice, ignoring second\n");
+					fprintf(stderr, "\npassword specified twice, ignoring second\n");
 				} else
 					got_password = 1;
-			} else if (strnlen(value, 17) < 17) {
-				if(got_password)
-					printf("\nmount.cifs warning - password specified twice\n");
-				got_password = 1;
+			} else if (strnlen(value, MOUNT_PASSWD_SIZE) < MOUNT_PASSWD_SIZE) {
+				if (got_password) {
+					fprintf(stderr, "\nmount.cifs warning - password specified twice\n");
+				} else {
+					mountpassword = strndup(value, MOUNT_PASSWD_SIZE);
+					if (!mountpassword) {
+						fprintf(stderr, "mount.cifs error: %s", strerror(ENOMEM));
+						SAFE_FREE(out);
+						return 1;
+					}
+					got_password = 1;
+				}
 			} else {
-				printf("password too long\n");
+				fprintf(stderr, "password too long\n");
 				SAFE_FREE(out);
 				return 1;
 			}
+			goto nocopy;
 		} else if (strncmp(data, "sec", 3) == 0) {
 			if (value) {
 				if (!strncmp(value, "none", 4) ||
@@ -1395,15 +1401,6 @@ mount_retry:
 			strlcat(options,domain_name,options_size);
 		}
 	}
-	if(mountpassword) {
-		/* Commas have to be doubled, or else they will
-		look like the parameter separator */
-/*		if(sep is not set)*/
-		if(retry == 0)
-			check_for_comma(&mountpassword);
-		strlcat(options,",pass=",options_size);
-		strlcat(options,mountpassword,options_size);
-	}
 
 	strlcat(options,",ver=",options_size);
 	strlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);
@@ -1416,8 +1413,6 @@ mount_retry:
 		strlcat(options,",prefixpath=",options_size);
 		strlcat(options,prefixpath,options_size); /* no need to cat the / */
 	}
-	if(verboseflag)
-		printf("\nmount.cifs kernel mount options %s \n",options);
 
 	/* convert all '\\' to '/' in share portion so that /proc/mounts looks pretty */
 	replace_char(dev_name, '\\', '/', strlen(share_name));
@@ -1449,6 +1444,25 @@ mount_retry:
 		}
 	}
 
+	if(verboseflag)
+		fprintf(stderr, "\nmount.cifs kernel mount options: %s", options);
+
+	if (mountpassword) {
+		/*
+		 * Commas have to be doubled, or else they will
+		 * look like the parameter separator
+		 */
+		if(retry == 0)
+			check_for_comma(&mountpassword);
+		strlcat(options,",pass=",options_size);
+		strlcat(options,mountpassword,options_size);
+		if (verboseflag)
+			fprintf(stderr, ",pass=********");
+	}
+
+	if (verboseflag)
+		fprintf(stderr, "\n");
+
 	if (!fakemnt && mount(dev_name, mountpoint, "cifs", flags, options)) {
 		switch (errno) {
 		case ECONNREFUSED:
