MotorolaMobilityLLC__kernel-msm
commit 69e64fda642c1a0da9b1a79332c387e89940a18d
Author:     Rob Kubicki <w17311@motorola.com>
AuthorDate: Sat Oct 22 01:31:00 2016 +0530
Commit:     Srikanth A R <arsrikan@motorola.com>
CommitDate: Thu Oct 27 23:59:15 2016 -0500

    msm: camera: Alleviate stress on kernel heap.
    
    Kernel heap memory is being used to address a stack
    overflow security issue in CR# (CR) for
    CVE-2016-6741. However the kernel heap is being
    used in a way that degrades performance and fragments
    the heap.
    
    Use the dynamic memory in a more persistent way to
    reduce the number of allocs and frees while still
    addressing the stack overflow security concerns.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2016-6741
    
    Change-Id: I374647372efc20352298c5dd1ed064a06063fc31
    Signed-off-by: Rob Kubicki <w17311@motorola.com>
    Signed-off-by: Srikanth A R <arsrikan@motorola.com>
    Reviewed-on: https://gerrit.mot.com/913992
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c
old mode 100644
new mode 100755
index a0d7ba352fa5..c69588282b0f
--- a/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c
+++ b/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c
@@ -11,6 +11,7 @@
  */
 
 #include <soc/qcom/camera2.h>
+#include <linux/mutex.h>
 #include "msm_camera_i2c.h"
 
 #undef CDBG
@@ -26,6 +27,67 @@
 #define I2C_COMPARE_MISMATCH 1
 #define I2C_POLL_MAX_ITERATION 20
 
+static struct mutex tx_buf_lock = __MUTEX_INITIALIZER(tx_buf_lock);
+static struct mutex rx_buf_lock = __MUTEX_INITIALIZER(rx_buf_lock);
+
+static unsigned char *msm_camera_qup_get_txbuf(unsigned int size)
+{
+	static unsigned char *tx_buf;
+	static unsigned int tx_buf_len;
+
+	mutex_lock(&tx_buf_lock);
+
+	if (size > tx_buf_len) {
+		if (tx_buf != NULL)
+			kfree(tx_buf);
+		tx_buf = kzalloc(size, GFP_KERNEL);
+		if (tx_buf == NULL) {
+			tx_buf_len = 0;
+			pr_err("%s:%d no memory\n", __func__, __LINE__);
+			mutex_unlock(&tx_buf_lock);
+			return NULL;
+		}
+		tx_buf_len = size;
+	} else {
+		memset((void *)tx_buf, 0, tx_buf_len);
+	}
+	return tx_buf;
+}
+
+static void msm_camera_qup_release_txbuf(void)
+{
+	mutex_unlock(&tx_buf_lock);
+}
+
+static unsigned char *msm_camera_qup_get_rxbuf(unsigned int size)
+{
+	static unsigned char *rx_buf;
+	static unsigned int rx_buf_len;
+
+	mutex_lock(&rx_buf_lock);
+
+	if (size > rx_buf_len) {
+		if (rx_buf != NULL)
+			kfree(rx_buf);
+		rx_buf = kzalloc(size, GFP_KERNEL);
+		if (rx_buf == NULL) {
+			rx_buf_len = 0;
+			pr_err("%s:%d no memory\n", __func__, __LINE__);
+			mutex_unlock(&rx_buf_lock);
+			return NULL;
+		}
+		rx_buf_len = size;
+	} else {
+		memset((void *)rx_buf, 0, rx_buf_len);
+	}
+	return rx_buf;
+}
+
+static void msm_camera_qup_release_rxbuf(void)
+{
+	mutex_unlock(&rx_buf_lock);
+}
+
 static int32_t msm_camera_qup_i2c_rxdata(
 	struct msm_camera_i2c_client *dev_client, unsigned char *rxdata,
 	int data_length)
@@ -115,9 +177,10 @@ int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
 		return rc;
 	}
 
-	buf = kzalloc(client->addr_type+data_type, GFP_KERNEL);
-	if (!buf) {
-		pr_err("%s:%d no memory\n", __func__, __LINE__);
+	buf = msm_camera_qup_get_rxbuf(client->addr_type+data_type);
+
+	if (buf == NULL) {
+		pr_err("%s: no rx buffer memory\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -130,8 +193,7 @@ int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
 	rc = msm_camera_qup_i2c_rxdata(client, buf, data_type);
 	if (rc < 0) {
 		S_I2C_DBG("%s fail\n", __func__);
-		kfree(buf);
-		buf = NULL;
+		msm_camera_qup_release_rxbuf();
 		return rc;
 	}
 
@@ -141,8 +203,7 @@ int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
 		*data = buf[0] << 8 | buf[1];
 
 	S_I2C_DBG("%s addr = 0x%x data: 0x%x\n", __func__, addr, *data);
-	kfree(buf);
-	buf = NULL;
+	msm_camera_qup_release_rxbuf();
 	return rc;
 }
 
@@ -168,9 +229,10 @@ int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
 		return rc;
 	}
 
-	buf = kzalloc(client->addr_type+num_byte, GFP_KERNEL);
-	if (!buf) {
-		pr_err("%s:%d no memory\n", __func__, __LINE__);
+	buf = msm_camera_qup_get_rxbuf(client->addr_type+num_byte);
+
+	if (buf == NULL) {
+		pr_err("%s: no rx buffer memory\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -183,8 +245,7 @@ int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
 	rc = msm_camera_qup_i2c_rxdata(client, buf, num_byte);
 	if (rc < 0) {
 		S_I2C_DBG("%s fail\n", __func__);
-		kfree(buf);
-		buf = NULL;
+		msm_camera_qup_release_rxbuf();
 		return rc;
 	}
 
@@ -194,8 +255,7 @@ int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
 		S_I2C_DBG("Byte %d: 0x%x\n", i, buf[i]);
 		S_I2C_DBG("Data: 0x%x\n", data[i]);
 	}
-	kfree(buf);
-	buf = NULL;
+	msm_camera_qup_release_rxbuf();
 	return rc;
 }
 
@@ -204,7 +264,7 @@ int32_t msm_camera_qup_i2c_write(struct msm_camera_i2c_client *client,
 	enum msm_camera_i2c_data_type data_type)
 {
 	int32_t rc = -EFAULT;
-	unsigned char buf[client->addr_type+data_type];
+	unsigned char *buf = NULL;
 	uint8_t len = 0;
 
 	if ((client->addr_type != MSM_CAMERA_I2C_BYTE_ADDR
@@ -213,6 +273,13 @@ int32_t msm_camera_qup_i2c_write(struct msm_camera_i2c_client *client,
 		&& data_type != MSM_CAMERA_I2C_WORD_DATA))
 		return rc;
 
+	buf = msm_camera_qup_get_txbuf(client->addr_type+data_type);
+
+	if (buf == NULL) {
+		pr_err("%s: no tx buffer memory\n", __func__);
+		return -ENOMEM;
+	}
+
 	S_I2C_DBG("%s reg addr = 0x%x  addr_type: 0x%x  data type: %d\n",
 			  __func__, addr, client->addr_type, data_type);
 	if (client->addr_type == MSM_CAMERA_I2C_BYTE_ADDR) {
@@ -244,6 +311,7 @@ int32_t msm_camera_qup_i2c_write(struct msm_camera_i2c_client *client,
 	rc = msm_camera_qup_i2c_txdata(client, buf, len);
 	if (rc < 0)
 		S_I2C_DBG("%s fail\n", __func__);
+		msm_camera_qup_release_txbuf();
 	return rc;
 }
 
@@ -394,7 +462,7 @@ int32_t msm_camera_qup_i2c_write_seq(struct msm_camera_i2c_client *client,
 	uint32_t addr, uint8_t *data, uint32_t num_byte)
 {
 	int32_t rc = -EFAULT;
-	unsigned char buf[client->addr_type+num_byte];
+	unsigned char *buf = NULL;
 	uint8_t len = 0, i = 0;
 
 	if ((client->addr_type != MSM_CAMERA_I2C_BYTE_ADDR
@@ -402,6 +470,13 @@ int32_t msm_camera_qup_i2c_write_seq(struct msm_camera_i2c_client *client,
 		|| num_byte == 0)
 		return rc;
 
+	buf = msm_camera_qup_get_txbuf(client->addr_type+num_byte);
+
+	if (buf == NULL) {
+		pr_err("%s: no tx buffer memory\n", __func__);
+		return -ENOMEM;
+	}
+
 	S_I2C_DBG("%s reg addr = 0x%x num bytes: %d\n",
 			  __func__, addr, num_byte);
 	if (client->addr_type == MSM_CAMERA_I2C_BYTE_ADDR) {
@@ -431,6 +506,7 @@ int32_t msm_camera_qup_i2c_write_seq(struct msm_camera_i2c_client *client,
 	rc = msm_camera_qup_i2c_txdata(client, buf, len+num_byte);
 	if (rc < 0)
 		S_I2C_DBG("%s fail\n", __func__);
+	msm_camera_qup_release_txbuf();
 	return rc;
 }
 
