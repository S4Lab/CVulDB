MotorolaMobilityLLC__kernel-msm
commit a24c3dec0f2472e8b84459e2d5c8e4f74e6cf7a2
Author:     Jordan Crouse <jcrouse@codeaurora.org>
AuthorDate: Tue May 31 11:24:22 2016 -0600
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Tue May 2 05:50:53 2017 -0500

    msm: kgsl: Reserve a context ID slot but don't populate immediately
    
    When creating a context allocate an ID but don't populate the slot
    with the context pointer until we are done setup up the rest of the
    process. This avoids a race if somebody tries to free the same
    identifier before the create operation is complete.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2016-8479
    
    Change-Id: Ic0dedbadca5b4cc4ce567afad48a33078b549439
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Ashwin Pathmudi <jfxr63@motorola.com>
    Reviewed-on: https://gerrit.mot.com/944626
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Patrick Auchter <auchter@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index f8146f00d6c4..ebe096a33647 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -533,21 +533,18 @@ void kgsl_context_dump(struct kgsl_context *context)
 EXPORT_SYMBOL(kgsl_context_dump);
 
 /* Allocate a new context ID */
-int _kgsl_get_context_id(struct kgsl_device *device,
-		struct kgsl_context *context)
+static int _kgsl_get_context_id(struct kgsl_device *device)
 {
 	int id;
 
 	idr_preload(GFP_KERNEL);
 	write_lock(&device->context_lock);
-	id = idr_alloc(&device->context_idr, context, 1,
+	/* Allocate the slot but don't put a pointer in it yet */
+	id = idr_alloc(&device->context_idr, NULL, 1,
 		KGSL_MEMSTORE_MAX, GFP_NOWAIT);
 	write_unlock(&device->context_lock);
 	idr_preload_end();
 
-	if (id > 0)
-		context->id = id;
-
 	return id;
 }
 
@@ -571,7 +568,7 @@ int kgsl_context_init(struct kgsl_device_private *dev_priv,
 	char name[64];
 	int ret = 0, id;
 
-	id = _kgsl_get_context_id(device, context);
+	id = _kgsl_get_context_id(device);
 	if (id == -ENOSPC) {
 		/*
 		 * Before declaring that there are no contexts left try
@@ -580,7 +577,7 @@ int kgsl_context_init(struct kgsl_device_private *dev_priv,
 		 */
 
 		flush_workqueue(device->events_wq);
-		id = _kgsl_get_context_id(device, context);
+		id = _kgsl_get_context_id(device);
 	}
 
 	if (id < 0) {
@@ -592,6 +589,8 @@ int kgsl_context_init(struct kgsl_device_private *dev_priv,
 		return id;
 	}
 
+	context->id = id;
+
 	kref_init(&context->refcount);
 	/*
 	 * Get a refernce to the process private so its not destroyed, until
@@ -1805,6 +1804,12 @@ long kgsl_ioctl_drawctxt_create(struct kgsl_device_private *dev_priv,
 		goto done;
 	}
 	trace_kgsl_context_create(dev_priv->device, context, param->flags);
+
+	/* Commit the pointer to the context in context_idr */
+	write_lock(&device->context_lock);
+	idr_replace(&device->context_idr, context, context->id);
+	write_unlock(&device->context_lock);
+
 	param->drawctxt_id = context->id;
 done:
 	return result;
