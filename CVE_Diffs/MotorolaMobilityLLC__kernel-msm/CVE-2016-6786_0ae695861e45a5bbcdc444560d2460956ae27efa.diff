MotorolaMobilityLLC__kernel-msm
commit 0ae695861e45a5bbcdc444560d2460956ae27efa
Author:     Varun Shrivastava <varunshrivastava@motorola.com>
AuthorDate: Thu Nov 10 10:02:12 2016 +0530
Commit:     a7301c <a7301c@motorola.com>
CommitDate: Mon Nov 21 09:47:22 2016 -0600

    perf: Protect the pmu, attributes and context of a group leader
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2016-6786 CVE-2016-6787
    
    Change-Id: Ie667528a598bd3e8dba1111104823f94215d90d8
    Signed-off-by: Varun Shrivastava <varunshrivastava@motorola.com>
    Reviewed-on: https://gerrit.mot.com/919508
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Vijayakumar Gn <vijaygn@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 619d3240d25a..b10868f51332 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -317,6 +317,12 @@ struct perf_event {
 	int				nr_siblings;
 	int				group_flags;
 	struct perf_event		*group_leader;
+
+	/*
+	 * Protect the pmu, attributes and context of a group leader.
+	 * Note: does not protect the pointer to the group_leader.
+	 */
+	struct mutex			group_leader_mutex;
 	struct pmu			*pmu;
 
 	enum perf_event_active_state	state;
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 2d4d0c5bca33..d82fd9feaeeb 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -6631,6 +6631,7 @@ perf_event_alloc(struct perf_event_attr *attr, int cpu,
 	if (!group_leader)
 		group_leader = event;
 
+	mutex_init(&event->group_leader_mutex);
 	mutex_init(&event->child_mutex);
 	INIT_LIST_HEAD(&event->child_list);
 
@@ -7020,6 +7021,16 @@ SYSCALL_DEFINE5(perf_event_open,
 			group_leader = NULL;
 	}
 
+	/*
+	 * Take the group_leader's group_leader_mutex before observing
+	 * anything in the group leader that leads to changes in ctx,
+	 * many of which may be changing on another thread.
+	 * In particular, we want to take this lock before deciding
+	 * whether we need to move_group.
+	 */
+	if (group_leader)
+		mutex_lock(&group_leader->group_leader_mutex);
+
 	if (pid != -1 && !(flags & PERF_FLAG_PID_CGROUP)) {
 		task = find_lively_task_by_vpid(pid);
 		if (IS_ERR(task)) {
@@ -7202,6 +7213,8 @@ SYSCALL_DEFINE5(perf_event_open,
 		put_ctx(gctx);
 	}
 	mutex_unlock(&ctx->mutex);
+	if (group_leader)
+		mutex_unlock(&group_leader->group_leader_mutex);
 
 	put_online_cpus();
 
@@ -7237,6 +7250,8 @@ err_task:
 	if (task)
 		put_task_struct(task);
 err_group_fd:
+	if (group_leader)
+		mutex_unlock(&group_leader->group_leader_mutex);
 	fdput(group);
 err_fd:
 	put_unused_fd(event_fd);
