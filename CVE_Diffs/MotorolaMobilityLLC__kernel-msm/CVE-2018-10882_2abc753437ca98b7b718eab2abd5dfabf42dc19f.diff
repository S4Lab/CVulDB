MotorolaMobilityLLC__kernel-msm
commit 2abc753437ca98b7b718eab2abd5dfabf42dc19f
Author:     Theodore Ts'o <tytso@mit.edu>
AuthorDate: Tue Dec 25 10:39:05 2018 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Tue Jan 1 01:18:14 2019 -0600

    ext4: add more inode number paranoia checks
    
    If there is a directory entry pointing to a system inode (such as a
    journal inode), complain and declare the file system to be corrupted.
    
    Also, if the superblock's first inode number field is too small,
    refuse to mount the file system.
    
    This addresses CVE-2018-10882.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=200069
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2018-10882
    BUG: 116406626
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Change-Id: I4a6514457d23cd6cb697f6a50e3742243f9afd80
    Reviewed-on: https://gerrit.mot.com/1287123
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 21f6e66fd10f..6d26ac967484 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1416,11 +1416,6 @@ static inline struct timespec ext4_current_time(struct inode *inode)
 static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)
 {
 	return ino == EXT4_ROOT_INO ||
-		ino == EXT4_USR_QUOTA_INO ||
-		ino == EXT4_GRP_QUOTA_INO ||
-		ino == EXT4_BOOT_LOADER_INO ||
-		ino == EXT4_JOURNAL_INO ||
-		ino == EXT4_RESIZE_INO ||
 		(ino >= EXT4_FIRST_INO(sb) &&
 		 ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));
 }
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 8608ff4ced09..94ae15c5b8a4 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -3917,7 +3917,8 @@ static int __ext4_get_inode_loc(struct inode *inode,
 	int			inodes_per_block, inode_offset;
 
 	iloc->bh = NULL;
-	if (!ext4_valid_inum(sb, inode->i_ino))
+	if (inode->i_ino < EXT4_ROOT_INO ||
+	    inode->i_ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))
 		return -EIO;
 
 	iloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 50cc98283845..d4fbb293b2c4 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3789,6 +3789,11 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	} else {
 		sbi->s_inode_size = le16_to_cpu(es->s_inode_size);
 		sbi->s_first_ino = le32_to_cpu(es->s_first_ino);
+		if (sbi->s_first_ino < EXT4_GOOD_OLD_FIRST_INO) {
+			ext4_msg(sb, KERN_ERR, "invalid first ino: %u",
+				 sbi->s_first_ino);
+			goto failed_mount;
+		}
 		if ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||
 		    (!is_power_of_2(sbi->s_inode_size)) ||
 		    (sbi->s_inode_size > blocksize)) {
