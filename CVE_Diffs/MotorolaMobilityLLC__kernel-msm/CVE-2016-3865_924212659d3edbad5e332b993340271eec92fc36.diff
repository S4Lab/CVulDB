MotorolaMobilityLLC__kernel-msm
commit 924212659d3edbad5e332b993340271eec92fc36
Author:     Konstantin Makariev <kmakariev@motorola.com>
AuthorDate: Fri Sep 9 16:15:53 2016 -0500
Commit:     a7301c <a7301c@motorola.com>
CommitDate: Fri Sep 7 11:22:36 2018 -0500

    input: synaptics_mmi: security fixes
    
    Apply stack overflow and elevation of privelege vulnerabilities
    patches to Synaptics MMI driver. Original patches suggested in:
    
     * CVE-2016-3865/A-28799389
     * CVE-2016-3940/A-30141991
     * CVE-2016-6672/A-30537088
    
    have been modified for improved performance.
    
    Change-Id: Iefe0985a118b344fa48331bcf8f700e234658e3c
    Signed-off-by: Konstantin Makariev <kmakariev@motorola.com>
    Reviewed-on: https://gerrit.mot.com/897828
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Reviewed-by: Alexander Filonenko <alexf@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_i2c.c b/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_i2c.c
index f31119a6a587..d65fad22053e 100644
--- a/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_i2c.c
+++ b/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_i2c.c
@@ -3454,6 +3454,7 @@ static ssize_t synaptics_rmi4_test_irq_data_contig_store(struct device *dev,
 	return count;
 }
 #endif
+
 static ssize_t synaptics_rmi4_0dbutton_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -4038,6 +4039,30 @@ static int synaptics_rmi4_set_page(struct synaptics_rmi4_data *rmi4_data,
 	return (retval == PAGE_SELECT_LEN) ? retval : -EIO;
 }
 
+int alloc_buffer(struct temp_buffer *tb, size_t count)
+{
+	if (tb->buf_size != 0) {
+		kfree(tb->buf);
+		tb->buf = NULL;
+		tb->buf_size = 0;
+	}
+
+	if (count > MAX_READ_WRITE_SIZE) {
+		pr_err("%s: Max buffer size exceeded\n", __func__);
+		return 1;
+	}
+
+	if (count < MIN_READ_WRITE_BUF_SIZE)
+		count = MIN_READ_WRITE_BUF_SIZE;
+
+	tb->buf = kzalloc(count, GFP_KERNEL);
+	if (!tb->buf)
+		return 1;
+
+	tb->buf_size = count;
+	return 0;
+}
+
  /**
  * synaptics_rmi4_i2c_read()
  *
@@ -4116,15 +4141,8 @@ static int synaptics_rmi4_i2c_write(struct synaptics_rmi4_data *rmi4_data,
 {
 	int retval;
 	unsigned char retry = SYN_I2C_RETRY_TIMES;
-	unsigned char buf[length + 1];
-	struct i2c_msg msg[] = {
-		{
-			.addr = rmi4_data->i2c_client->addr,
-			.flags = 0,
-			.len = length + 1,
-			.buf = buf,
-		}
-	};
+	struct temp_buffer *tb = &rmi4_data->write_buf;
+	struct i2c_msg msg[1];
 
 	mutex_lock(&(rmi4_data->rmi4_io_ctrl_mutex));
 
@@ -4132,8 +4150,18 @@ static int synaptics_rmi4_i2c_write(struct synaptics_rmi4_data *rmi4_data,
 	if (retval != PAGE_SELECT_LEN)
 		goto exit;
 
-	buf[0] = addr & MASK_8BIT;
-	memcpy(&buf[1], &data[0], length);
+	if (tb->buf_size < (length+1) && alloc_buffer(tb, length+1) != 0) {
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	msg[0].addr = rmi4_data->i2c_client->addr;
+	msg[0].flags = 0;
+	msg[0].len = length + 1;
+	msg[0].buf = tb->buf;
+
+	*(tb->buf) = addr & MASK_8BIT;
+	memcpy(tb->buf+1, &data[0], length);
 
 	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
 		if (i2c_transfer(rmi4_data->i2c_client->adapter, msg, 1) == 1) {
diff --git a/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_i2c.h b/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_i2c.h
index aaf27d48f059..86a75b0ce18d 100644
--- a/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_i2c.h
+++ b/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_i2c.h
@@ -434,6 +434,14 @@ struct reporting_ctrl {
 	unsigned int events_cnt;
 };
 
+#define MAX_READ_WRITE_SIZE 8096
+#define MIN_READ_WRITE_BUF_SIZE 256
+
+struct temp_buffer {
+	unsigned char *buf;
+	unsigned short buf_size;
+};
+
 /*
  * struct synaptics_rmi4_data - rmi4 device instance data
  * @i2c_client: pointer to associated i2c client
@@ -559,6 +567,8 @@ struct synaptics_rmi4_data {
 	uint8_t *touch_data;
 	uint16_t touch_data_size;
 
+	struct temp_buffer write_buf;
+
 #if defined(CONFIG_DYNAMIC_DEBUG) || defined(DEBUG)
 	/* TEST OPTIONS */
 	int test_irq_delay_ms;
@@ -630,6 +640,8 @@ int synaptics_rmi4_read_packet_regs(
 	struct synaptics_rmi4_data *rmi4_data,
 	struct synaptics_rmi4_func_packet_regs *regs);
 
+int alloc_buffer(struct temp_buffer *tb, size_t count);
+
 static inline int secure_memcpy(unsigned char *dest, unsigned int dest_size,
 		const unsigned char *src, unsigned int src_size,
 		unsigned int count)
diff --git a/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_rmi_dev.c b/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_rmi_dev.c
index 2ecab9268fb3..1912461c9a37 100644
--- a/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_rmi_dev.c
+++ b/drivers/input/touchscreen/synaptics_mmi/synaptics_dsx_rmi_dev.c
@@ -34,8 +34,6 @@
 #define DEVICE_CLASS_NAME "rmidev"
 #define DEV_NUMBER 1
 #define REG_ADDR_LIMIT 0xFFFF
-#define MAX_READ_WRITE_SIZE 8096
-#define MIN_READ_WRITE_BUF_SIZE 256
 
 static ssize_t rmidev_sysfs_data_show(struct file *data_file,
 		struct kobject *kobj, struct bin_attribute *attributes,
@@ -77,8 +75,7 @@ struct rmidev_data {
 	struct class *device_class;
 	struct mutex file_mutex;
 	struct rmidev_handle *rmi_dev;
-	unsigned char *tmpbuf;
-	size_t tmpbuf_size;
+	struct temp_buffer data_buf;
 };
 
 static struct bin_attribute attr_data = {
@@ -319,32 +316,6 @@ clean_up:
 	return newpos;
 }
 
-static int alloc_tmpbuf(struct file *filp, size_t count)
-{
-	struct rmidev_data *dev_data = filp->private_data;
-
-	if (dev_data->tmpbuf_size != 0)	{
-		kfree(dev_data->tmpbuf);
-		dev_data->tmpbuf = NULL;
-		dev_data->tmpbuf_size = 0;
-	}
-
-	if (count > MAX_READ_WRITE_SIZE) {
-		pr_err("%s: Max buffer size exceeded\n", __func__);
-		return 1;
-	}
-
-	if (count < MIN_READ_WRITE_BUF_SIZE)
-		count = MIN_READ_WRITE_BUF_SIZE;
-
-	dev_data->tmpbuf = kzalloc(count, GFP_KERNEL);
-	if (!dev_data->tmpbuf)
-		return 1;
-
-	dev_data->tmpbuf_size = count;
-	return 0;
-}
-
 /*
  * rmidev_read: - use to read data from rmi device
  *
@@ -358,6 +329,7 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 {
 	ssize_t retval;
 	struct rmidev_data *dev_data = filp->private_data;
+	struct temp_buffer *tb;
 
 	if (IS_ERR(dev_data)) {
 		pr_err("%s: Pointer of char device data is invalid", __func__);
@@ -370,19 +342,22 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
+	tb = &dev_data->data_buf;
 	mutex_lock(&(dev_data->file_mutex));
 
-	if (dev_data->tmpbuf_size < count && alloc_tmpbuf(filp, count) != 0)
-		return -ENOMEM;
+	if (tb->buf_size < count && alloc_buffer(tb, count) != 0) {
+		retval = -ENOMEM;
+		goto clean_up;
+        }
 
 	retval = rmidev->fn_ptr->read(rmidev->rmi4_data,
 			*f_pos,
-			dev_data->tmpbuf,
+			tb->buf,
 			count);
 	if (retval < 0)
 		goto clean_up;
 
-	if (copy_to_user(buf, dev_data->tmpbuf, count))
+	if (copy_to_user(buf, tb->buf, count))
 		retval = -EFAULT;
 	else
 		*f_pos += retval;
@@ -406,6 +381,7 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 {
 	ssize_t retval;
 	struct rmidev_data *dev_data = filp->private_data;
+	struct temp_buffer *tb;
 
 	if (IS_ERR(dev_data)) {
 		pr_err("%s: Pointer of char device data is invalid", __func__);
@@ -418,25 +394,27 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
+	tb = &dev_data->data_buf;
 	mutex_lock(&(dev_data->file_mutex));
 
-	if (dev_data->tmpbuf_size < count && alloc_tmpbuf(filp, count) != 0) {
+	if (tb->buf_size < count && alloc_buffer(tb, count) != 0) {
 		retval = -ENOMEM;
 		goto clean_up;
 	}
 
-	if (copy_from_user(dev_data->tmpbuf, buf, count)) {
+	if (copy_from_user(tb->buf, buf, count)) {
 		retval = -EFAULT;
 		goto clean_up;
 	}
 
 	retval = rmidev->fn_ptr->write(rmidev->rmi4_data,
 			*f_pos,
-			dev_data->tmpbuf,
+			tb->buf,
 			count);
 	if (retval >= 0)
 		*f_pos += retval;
 
+clean_up:
 	mutex_unlock(&(dev_data->file_mutex));
 
 	return retval;
