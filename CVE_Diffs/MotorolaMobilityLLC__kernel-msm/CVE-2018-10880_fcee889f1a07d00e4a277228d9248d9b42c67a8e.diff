MotorolaMobilityLLC__kernel-msm
commit fcee889f1a07d00e4a277228d9248d9b42c67a8e
Author:     Ben Hutchings <ben@decadent.org.uk>
AuthorDate: Tue Dec 25 14:36:25 2018 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Wed Mar 20 05:34:27 2019 -0500

    ext4: never move the system.data xattr out of the inode body
    
    When expanding the extra isize space, we must never move the
    system.data xattr out of the inode body.  For performance reasons, it
    doesn't make any sense, and the inline data implementation assumes
    that system.data xattr is never in the external xattr block.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=200005
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2018-10880
    BUG: 116406509
    
    Change-Id: I0a92aeb753306b98d6e94f43eaae1146a147dbe6
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-on: https://gerrit.mot.com/1286960
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index 3fadfabcac39..b0544114a3b9 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -1424,6 +1424,11 @@ static int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,
 		last = IFIRST(header);
 		/* Find the entry best suited to be pushed into EA block */
 		for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
+			/* never move system.data out of the inode */
+			if ((last->e_name_len == 4) &&
+			    (last->e_name_index == EXT4_XATTR_INDEX_SYSTEM) &&
+			    !memcmp(last->e_name, "data", 4))
+				continue;
 			total_size =
 			EXT4_XATTR_SIZE(le32_to_cpu(last->e_value_size)) +
 					EXT4_XATTR_LEN(last->e_name_len);
