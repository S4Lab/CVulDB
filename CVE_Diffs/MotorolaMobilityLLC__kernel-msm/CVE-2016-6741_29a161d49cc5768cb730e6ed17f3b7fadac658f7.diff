MotorolaMobilityLLC__kernel-msm
commit 29a161d49cc5768cb730e6ed17f3b7fadac658f7
Author:     Samyukta Mogily <smogily@codeaurora.org>
AuthorDate: Thu Sep 8 12:05:52 2016 +0000
Commit:     chenlh4 <chenlh4@lenovo.com>
CommitDate: Tue Nov 28 20:31:48 2017 +0800

    msm camera: Restructure data handling to be more robust
    
    Use dynamic array allocation instead of static array to
    prevent stack overflow.
    User-supplied number of bytes may result in integer overflow.
    To fix this we check that the num_byte isn't above 8K size.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2016-6741
    
    Change-Id: I7f69175b673fb8f8164e86a796a9b8edcc7bff35
    Signed-off-by: Samyukta Mogily <smogily@codeaurora.org>
    Signed-off-by: Srikanth A R <arsrikan@motorola.com>
    Reviewed-on: https://gerrit.mot.com/911285
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Robert Kubicki <w17311@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/drivers/media/platform/msm/camera_v2_2016/sensor/io/msm_camera_cci_i2c.c b/drivers/media/platform/msm/camera_v2_2016/sensor/io/msm_camera_cci_i2c.c
index 16f34df1d73d..5fbb47ed0cc3 100644
--- a/drivers/media/platform/msm/camera_v2_2016/sensor/io/msm_camera_cci_i2c.c
+++ b/drivers/media/platform/msm/camera_v2_2016/sensor/io/msm_camera_cci_i2c.c
@@ -69,6 +69,12 @@ int32_t msm_camera_cci_i2c_read_seq(struct msm_camera_i2c_client *client,
 		|| num_byte == 0)
 		return rc;
 
+	if (num_byte > I2C_REG_DATA_MAX) {
+			pr_err("%s: Error num_byte:0x%x exceeds 8K max supported:0x%x\n",
+			__func__, num_byte, I2C_REG_DATA_MAX);
+		return rc;
+	}
+
 	buf = kzalloc(num_byte, GFP_KERNEL);
 	if (!buf) {
 		pr_err("%s:%d no memory\n", __func__, __LINE__);
diff --git a/drivers/media/platform/msm/camera_v2_2016/sensor/io/msm_camera_qup_i2c.c b/drivers/media/platform/msm/camera_v2_2016/sensor/io/msm_camera_qup_i2c.c
index 049da64ed0b8..8aa0d3492982 100644
--- a/drivers/media/platform/msm/camera_v2_2016/sensor/io/msm_camera_qup_i2c.c
+++ b/drivers/media/platform/msm/camera_v2_2016/sensor/io/msm_camera_qup_i2c.c
@@ -73,7 +73,7 @@ int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
 	enum msm_camera_i2c_data_type data_type)
 {
 	int32_t rc = -EFAULT;
-	unsigned char buf[client->addr_type+data_type];
+	unsigned char *buf = NULL;
 
 	if ((client->addr_type != MSM_CAMERA_I2C_BYTE_ADDR
 		&& client->addr_type != MSM_CAMERA_I2C_WORD_ADDR)
@@ -81,6 +81,17 @@ int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
 		&& data_type != MSM_CAMERA_I2C_WORD_DATA))
 		return rc;
 
+	if (client->addr_type > UINT_MAX - data_type) {
+			pr_err("%s: integer overflow prevented\n", __func__);
+			return rc;
+	}
+
+	buf = kzalloc(client->addr_type+data_type, GFP_KERNEL);
+	if (!buf) {
+			pr_err("%s:%d no memory\n", __func__, __LINE__);
+			return -ENOMEM;
+	}
+
 	if (client->addr_type == MSM_CAMERA_I2C_BYTE_ADDR) {
 		buf[0] = addr;
 	} else if (client->addr_type == MSM_CAMERA_I2C_WORD_ADDR) {
@@ -90,6 +101,8 @@ int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
 	rc = msm_camera_qup_i2c_rxdata(client, buf, data_type);
 	if (rc < 0) {
 		S_I2C_DBG("%s fail\n", __func__);
+		kfree(buf);
+		buf = NULL;
 		return rc;
 	}
 
@@ -99,6 +112,8 @@ int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
 		*data = buf[0] << 8 | buf[1];
 
 	S_I2C_DBG("%s addr = 0x%x data: 0x%x\n", __func__, addr, *data);
+	kfree(buf);
+	buf = NULL;
 	return rc;
 }
 
@@ -106,7 +121,7 @@ int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
 	uint32_t addr, uint8_t *data, uint32_t num_byte)
 {
 	int32_t rc = -EFAULT;
-	unsigned char buf[client->addr_type+num_byte];
+	unsigned char *buf = NULL;
 	int i;
 
 	if ((client->addr_type != MSM_CAMERA_I2C_BYTE_ADDR
@@ -114,6 +129,22 @@ int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
 		|| num_byte == 0)
 		return rc;
 
+	if (num_byte > I2C_REG_DATA_MAX) {
+			pr_err("%s: Error num_byte:0x%x exceeds 8K max supported:0x%x\n",
+					__func__, num_byte, I2C_REG_DATA_MAX);
+			return rc;
+	}
+	if (client->addr_type > UINT_MAX - num_byte) {
+			pr_err("%s: integer overflow prevented\n", __func__);
+			return rc;
+	}
+
+	buf = kzalloc(client->addr_type+num_byte, GFP_KERNEL);
+	if (!buf) {
+			pr_err("%s:%d no memory\n", __func__, __LINE__);
+			return -ENOMEM;
+	}
+
 	if (client->addr_type == MSM_CAMERA_I2C_BYTE_ADDR) {
 		buf[0] = addr;
 	} else if (client->addr_type == MSM_CAMERA_I2C_WORD_ADDR) {
@@ -123,6 +154,8 @@ int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
 	rc = msm_camera_qup_i2c_rxdata(client, buf, num_byte);
 	if (rc < 0) {
 		S_I2C_DBG("%s fail\n", __func__);
+		kfree(buf);
+		buf = NULL;
 		return rc;
 	}
 
@@ -132,6 +165,8 @@ int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
 		S_I2C_DBG("Byte %d: 0x%x\n", i, buf[i]);
 		S_I2C_DBG("Data: 0x%x\n", data[i]);
 	}
+	kfree(buf);
+	buf = NULL;
 	return rc;
 }
 
