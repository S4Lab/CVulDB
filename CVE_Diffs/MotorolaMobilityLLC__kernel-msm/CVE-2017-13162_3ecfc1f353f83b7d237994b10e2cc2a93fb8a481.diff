MotorolaMobilityLLC__kernel-msm
commit 3ecfc1f353f83b7d237994b10e2cc2a93fb8a481
Author:     Todd Kjos <tkjos@google.com>
AuthorDate: Fri Sep 29 13:25:33 2017 -0700
Commit:     lulu2 <lulu2@lenovo.com>
CommitDate: Wed May 9 17:55:09 2018 +0800

    ANDROID: binder: fix OOB write in __binder_update_page_range
    
    commit e12f1f1c65a9 ("binder: always allocate/map first
    BINDER_MIN_ALLOC pages") introduced a vulnerability where
    the alloc->pages array can be accessed beyond the allocated
    elements. For this to occur, the passed-in VMA range must
    be < BINDER_MIN_ALLOC pages (which cannot happen for normal
    use cases). BINDER_MIN_ALLOC is set to 6 pages, so mmap'ing
    1 page results in OOB accesses.
    
    The fix is to return an error if binder_mmap is called with
    a VMA size less than BINDER_MIN_ALLOC.
    
    Mot-CRs-fixed: (CR)
    CVE-fixed: CVE-2017-13162
    Bug: 64216036
    Test: verified fixed with submitter's test program
    Change-Id: I4b6dbf3f466fea46e587d6a33f724ee4fe7f1368
    Signed-off-by: Todd Kjos <tkjos@google.com>
    Reviewed-on: https://gerrit.mot.com/1090144
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/staging/android/binder_alloc.c b/drivers/staging/android/binder_alloc.c
index e8c351a89f02..966ccb64c726 100644
--- a/drivers/staging/android/binder_alloc.c
+++ b/drivers/staging/android/binder_alloc.c
@@ -669,6 +669,11 @@ int binder_alloc_mmap_handler(struct binder_alloc *alloc,
 		}
 	}
 #endif
+	if (vma->vm_end - vma->vm_start < BINDER_MIN_ALLOC) {
+		ret = -EINVAL;
+		failure_string = "VMA size < BINDER_MIN_ALLOC";
+		goto err_vma_too_small;
+	}
 	alloc->pages = kzalloc(sizeof(alloc->pages[0]) *
 				   ((vma->vm_end - vma->vm_start) / PAGE_SIZE),
 			       GFP_KERNEL);
@@ -709,6 +714,7 @@ err_alloc_buf_struct_failed:
 	kfree(alloc->pages);
 	alloc->pages = NULL;
 err_alloc_pages_failed:
+err_vma_too_small:
 	mutex_lock(&binder_alloc_mmap_lock);
 	vfree(alloc->buffer);
 	alloc->buffer = NULL;
