MotorolaMobilityLLC__kernel-msm
commit 86872a6121a6007b816bad6bc14a7202b0b34a21
Author:     Vineet Angadi V <vineetv@motorola.com>
AuthorDate: Tue Feb 7 14:40:35 2017 +0530
Commit:     Xu Zhang <zhangxu21@lenovo.com>
CommitDate: Fri Mar 31 02:35:35 2017 -0500

    Subject: netlink: Fix dump skb leak/double free
    
    When we free cb->skb after a dump, we do it after releasing the
    lock.  This means that a new dump could have started in the time
    being and we'll end up freeing their skb instead of ours.
    
    This patch saves the skb and module before we unlock so we free
    the right memory.
    
    Mot-CRs-fixed:IKSIMP-1634
    CVE-Fixed:CVE-2016-9806
    
    Fixes: 16b304f3404f ("netlink: Eliminate kmalloc in netlink dump operation.")
    Reported-by: Baozeng Ding <sploving1@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    
    Change-Id: I18287b371c8636e134a74344c96fd29df1dadded
    Signed-off-by: Vineet Angadi V <vineetv@motorola.com>
    Reviewed-on: https://gerrit.mot.com/948119
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Varun Shrivastava <varunshrivastava@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>
    (cherry picked from commit 8fe10fea5f95ed872285aa7f39ca1d641026dc8a)
    Reviewed-on: https://gerrit.mot.com/971559
    Reviewed-by: Xu Zhang <zhangxu21@lenovo.com>
    SLTApproved: Xu Zhang <zhangxu21@lenovo.com>
    Submit-Approved: Xu Zhang <zhangxu21@lenovo.com>

diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index 7e0888fb04e0..0ffa5bb303c4 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -2630,6 +2630,7 @@ static int netlink_dump(struct sock *sk)
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
+    struct module *module;
 	int len, err = -ENOBUFS;
 	int alloc_size;
 
@@ -2699,9 +2700,11 @@ static int netlink_dump(struct sock *sk)
 		cb->done(cb);
 
 	nlk->cb_running = false;
+    module = cb->module;
+    skb = cb->skb;
 	mutex_unlock(nlk->cb_mutex);
-	module_put(cb->module);
-	consume_skb(cb->skb);
+	module_put(module);
+	consume_skb(skb);
 	return 0;
 
 errout_skb:
