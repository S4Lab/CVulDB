MotorolaMobilityLLC__kernel-msm
commit 7ca0bf8b38769bd5eb5602000e5e200a275e0b57
Author:     Will Deacon <will.deacon@arm.com>
AuthorDate: Thu Aug 10 13:19:09 2017 +0100
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Wed Mar 21 05:06:27 2018 -0500

    FROMLIST: arm64: mm: Move ASID from TTBR0 to TTBR1
    
    In preparation for mapping kernelspace and userspace with different
    ASIDs, move the ASID to TTBR1 and update switch_mm to context-switch
    TTBR0 via an invalid mapping (the zero page).
    
    Mot-CRs-fixed: (CR)
    CVE-fixed: CVE-2017-5754
    Bug: 69856074
    
    Reviewed-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Laura Abbott <labbott@redhat.com>
    Tested-by: Shanker Donthineni <shankerd@codeaurora.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    (cherry picked from git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux.git
     commit 7655abb953860485940d4de74fb45a8192149bb6)
    
    Change-Id: Id8a18e16dfab5c8b7bc31174b14100142a6af3b0
    [ghackmann@google.com: adjust context]
    Signed-off-by: Greg Hackmann <ghackmann@google.com>
    Reviewed-on: https://gerrit.mot.com/1132550
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key
    Reviewed-by: Vijayakumar Gn <vijaygn@motorola.com>

diff --git a/arch/arm64/include/asm/mmu_context.h b/arch/arm64/include/asm/mmu_context.h
index 0802f08919aa..0d5a55929dab 100644
--- a/arch/arm64/include/asm/mmu_context.h
+++ b/arch/arm64/include/asm/mmu_context.h
@@ -63,6 +63,13 @@ static inline void cpu_set_reserved_ttbr0(void)
 	: "r" (ttbr));
 }
 
+static inline void cpu_switch_mm(pgd_t *pgd, struct mm_struct *mm)
+{
+	BUG_ON(pgd == swapper_pg_dir);
+	cpu_set_reserved_ttbr0();
+	cpu_do_switch_mm(virt_to_phys(pgd),mm);
+}
+
 /*
  * TCR.T0SZ value to use when the ID map is active. Usually equals
  * TCR_T0SZ(VA_BITS), unless system RAM is positioned very high in
diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h
index 5e50782f625d..bfe379d13b83 100644
--- a/arch/arm64/include/asm/pgtable-hwdef.h
+++ b/arch/arm64/include/asm/pgtable-hwdef.h
@@ -164,6 +164,8 @@
 #define TCR_TG1_16K		(UL(1) << 30)
 #define TCR_TG1_4K		(UL(2) << 30)
 #define TCR_TG1_64K		(UL(3) << 30)
+
+#define TCR_A1			(UL(1) << 22)
 #define TCR_ASID16		(UL(1) << 36)
 #define TCR_TBI0		(UL(1) << 37)
 
diff --git a/arch/arm64/include/asm/proc-fns.h b/arch/arm64/include/asm/proc-fns.h
index b5240e868784..d35dcebb121e 100644
--- a/arch/arm64/include/asm/proc-fns.h
+++ b/arch/arm64/include/asm/proc-fns.h
@@ -35,12 +35,6 @@ extern u64 cpu_do_resume(phys_addr_t ptr, u64 idmap_ttbr);
 
 #include <asm/memory.h>
 
-#define cpu_switch_mm(pgd,mm)				\
-do {							\
-	BUG_ON(pgd == swapper_pg_dir);			\
-	cpu_do_switch_mm(virt_to_phys(pgd),mm);		\
-} while (0)
-
 #define cpu_get_pgd()					\
 ({							\
 	unsigned long pg;				\
diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S
index d579089a1649..3cbf35a95821 100644
--- a/arch/arm64/mm/proc.S
+++ b/arch/arm64/mm/proc.S
@@ -127,9 +127,12 @@ ENDPROC(cpu_do_resume)
  *	- pgd_phys - physical address of new TTB
  */
 ENTRY(cpu_do_switch_mm)
+	mrs	x2, ttbr1_el1
 	mmid	x1, x1				// get mm->context.id
-	bfi	x0, x1, #48, #16		// set the ASID
-	msr	ttbr0_el1, x0			// set TTBR0
+	bfi	x2, x1, #48, #16		// set the ASID
+	msr	ttbr1_el1, x2			// in TTBR1 (since TCR.A1 is set)
+	isb
+	msr	ttbr0_el1, x0			// now update TTBR0
 	isb
 	ret
 ENDPROC(cpu_do_switch_mm)
@@ -182,7 +185,7 @@ ENTRY(__cpu_setup)
 	 * both user and kernel.
 	 */
 	ldr	x10, =TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \
-			TCR_TG_FLAGS | TCR_ASID16 | TCR_TBI0
+			TCR_TG_FLAGS | TCR_ASID16 | TCR_TBI0 | TCR_A1
 	tcr_set_idmap_t0sz	x10, x9
 
 	/*
