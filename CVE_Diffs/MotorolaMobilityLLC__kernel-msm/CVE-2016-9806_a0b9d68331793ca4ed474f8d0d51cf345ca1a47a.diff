MotorolaMobilityLLC__kernel-msm
commit a0b9d68331793ca4ed474f8d0d51cf345ca1a47a
Author:     Vineet Angadi V <vineetv@motorola.com>
AuthorDate: Tue Feb 7 14:40:35 2017 +0530
Commit:     jinyou liu <liujy7@motorola.com>
CommitDate: Wed Mar 22 03:03:52 2017 -0500

    Subject: netlink: Fix dump skb leak/double free
    
    When we free cb->skb after a dump, we do it after releasing the
    lock.  This means that a new dump could have started in the time
    being and we'll end up freeing their skb instead of ours.
    
    This patch saves the skb and module before we unlock so we free
    the right memory.
    
    Mot-CRs-fixed:(CR)
    CVE-Fixed:CVE-2016-9806
    
    Fixes: 16b304f3404f ("netlink: Eliminate kmalloc in netlink dump operation.")
    Reported-by: Baozeng Ding <sploving1@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    
    Change-Id: I18287b371c8636e134a74344c96fd29df1dadded
    Signed-off-by: Vineet Angadi V <vineetv@motorola.com>
    Reviewed-on: https://gerrit.mot.com/948119
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Varun Shrivastava <varunshrivastava@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>
    (cherry picked from commit 8fe10fea5f95ed872285aa7f39ca1d641026dc8a)
    Reviewed-on: https://gerrit.mot.com/966119
    Reviewed-by: jinyou liu <liujy7@motorola.com>
    SLTApproved: jinyou liu <liujy7@motorola.com>
    Submit-Approved: jinyou liu <liujy7@motorola.com>

diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index 7e0888fb04e0..0ffa5bb303c4 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -2630,6 +2630,7 @@ static int netlink_dump(struct sock *sk)
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
+    struct module *module;
 	int len, err = -ENOBUFS;
 	int alloc_size;
 
@@ -2699,9 +2700,11 @@ static int netlink_dump(struct sock *sk)
 		cb->done(cb);
 
 	nlk->cb_running = false;
+    module = cb->module;
+    skb = cb->skb;
 	mutex_unlock(nlk->cb_mutex);
-	module_put(cb->module);
-	consume_skb(cb->skb);
+	module_put(module);
+	consume_skb(skb);
 	return 0;
 
 errout_skb:
