MotorolaMobilityLLC__kernel-msm
commit 9be1f59293df0b056d8396aecf6beff903f7fcb7
Author:     Tony Truong <truong@codeaurora.org>
AuthorDate: Fri Jan 6 14:03:03 2017 -0800
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Tue Oct 31 00:45:09 2017 -0500

    msm: pcie: add bounds check for debugfs register write
    
    Via debugfs nodes, users have the option to read and write to
    any PCIe register. To ensure clients do not access registers
    outside the PCIe range, add checks to validate the offset clients
    provide.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2017-10997
    CRs-Fixed: 1103077
    Bug: 33039685
    
    Change-Id: Ia35cd04c57f01c21a47962be596bca395b5ca247
    Signed-off-by: Tony Truong <truong@codeaurora.org>
    Reviewed-on: https://gerrit.mot.com/1043685
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit 63d715ab3766aef79f04153b331874ffadf9913e)

diff --git a/drivers/pci/host/pci-msm.c b/drivers/pci/host/pci-msm.c
index f4e98e89a47f..5500455fe4ea 100644
--- a/drivers/pci/host/pci-msm.c
+++ b/drivers/pci/host/pci-msm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1698,8 +1698,15 @@ static void msm_pcie_sel_debug_testcase(struct msm_pcie_dev_t *dev,
 			dev->res[base_sel - 1].base,
 			wr_offset, wr_mask, wr_value);
 
-		msm_pcie_write_reg_field(dev->res[base_sel - 1].base,
-			wr_offset, wr_mask, wr_value);
+		base_sel_size = resource_size(dev->res[base_sel - 1].resource);
+
+		if (wr_offset >  base_sel_size - 4 ||
+			msm_pcie_check_align(dev, wr_offset))
+			pr_alert("PCIe: RC%d: Invalid wr_offset: 0x%x. wr_offset should be no more than 0x%x\n",
+				dev->rc_idx, wr_offset, base_sel_size - 4);
+		else
+			msm_pcie_write_reg_field(dev->res[base_sel - 1].base,
+				wr_offset, wr_mask, wr_value);
 
 		break;
 	case 13: /* dump all registers of base_sel */
