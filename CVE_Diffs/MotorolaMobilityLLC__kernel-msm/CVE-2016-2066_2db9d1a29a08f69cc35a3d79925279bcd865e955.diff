MotorolaMobilityLLC__kernel-msm
commit 2db9d1a29a08f69cc35a3d79925279bcd865e955
Author:     Neeraj Kumar <neerajk@motorola.com>
AuthorDate: Thu May 26 18:11:33 2016 +0530
Commit:     Neeraj Kumar <neerajk@motorola.com>
CommitDate: Wed Jun 1 02:33:40 2016 -0500

    CVE-2016-2066.2469: Elevation of Privilege Vulnerability
    in Qualcomm Sound Driver for 8916
    
    Android Partner Security Bulletin for May 2016
    -------------------------------
    From d7d5ac0a1c7069cf119481b0c3881e2ecb7838fe Mon Sep 17 00:00:00 2001
    From: Ashish Jain <ashishj@codeaurora.org>
    Date: Fri, 15 Apr 2016 15:33:14 +0530
    Subject: ASoC: msm: qdsp6v2: DAP: Fix buffer overflow
    Add check to avoid out of bound access.
    Check return value of get_user api.
    CRs-Fixed: 997025
    Change-Id: Ibbace116ac206007fa1928555838285304737737
    Signed-off-by: Ashish Jain <ashishj@codeaurora.org>
    -------------------------------
    -------------------------------
    From 01de2d9d37b905c4891d2ebf60ffe5bbc69921d5 Mon Sep 17 00:00:00 2001
    From: Patrick Daly <pdaly@codeaurora.org>
    Date: Thu, 28 May 2015 18:05:54 -0700
    Subject: ASoC: msm: qdsp6v2: DAP: Fix unprotected userspace access
    Use get_user() & friends to access userspace addresses.
    Change-Id: I9741a60e53f6253da27913175e9b8c4abbf50db9
    Signed-off-by: Patrick Daly <pdaly@codeaurora.org>
    Signed-off-by: Pradnya Chaphekar <pradnyac@codeaurora.org>
    -------------------------------
    
    Change-Id: I91213fec797b769c3d67ea4c636ffbd2e5a09756
    Reviewed-on: http://gerrit.mot.com/861243
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Jonathan Eklund <jeklund@motorola.com>
    Reviewed-by: Kiran Kumar Krishna <kiran@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/sound/soc/msm/qdsp6v2/msm-ds2-dap-config.c b/sound/soc/msm/qdsp6v2/msm-ds2-dap-config.c
index c87d09a38a83..f62cf38234cc 100644
--- a/sound/soc/msm/qdsp6v2/msm-ds2-dap-config.c
+++ b/sound/soc/msm/qdsp6v2/msm-ds2-dap-config.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
@@ -1354,11 +1354,17 @@ end:
 static int msm_ds2_dap_handle_commands(u32 cmd, void *arg)
 {
 	int ret  = 0, port_id = 0;
+	int32_t data;
 	struct dolby_param_data *dolby_data = (struct dolby_param_data *)arg;
+	if (get_user(data, &dolby_data->data[0])) {
+		pr_debug("%s error getting data\n", __func__);
+		ret = -EFAULT;
+		goto end;
+	}
 
 	pr_debug("%s: param_id %d,be_id %d,device_id 0x%x,length %d,data %d\n",
 		 __func__, dolby_data->param_id, dolby_data->be_id,
-		dolby_data->device_id, dolby_data->length, dolby_data->data[0]);
+		dolby_data->device_id, dolby_data->length, data);
 
 	switch (dolby_data->param_id) {
 	case DAP_CMD_COMMIT_ALL:
@@ -1370,18 +1376,18 @@ static int msm_ds2_dap_handle_commands(u32 cmd, void *arg)
 	break;
 
 	case DAP_CMD_USE_CACHE_FOR_INIT:
-		ds2_dap_params_states.use_cache = dolby_data->data[0];
+		ds2_dap_params_states.use_cache = data;
 	break;
 
 	case DAP_CMD_SET_BYPASS:
 		pr_debug("%s: bypass %d bypass type %d, data %d\n", __func__,
 			 ds2_dap_params_states.dap_bypass,
 			 ds2_dap_params_states.dap_bypass_type,
-			 dolby_data->data[0]);
+			 data);
 		/* Do not perform bypass operation if bypass state is same*/
-		if (ds2_dap_params_states.dap_bypass == dolby_data->data[0])
+		if (ds2_dap_params_states.dap_bypass == data)
 			break;
-		ds2_dap_params_states.dap_bypass = dolby_data->data[0];
+		ds2_dap_params_states.dap_bypass = data;
 		/* hard bypass */
 		if (ds2_dap_params_states.dap_bypass_type == DAP_HARD_BYPASS)
 			msm_ds2_dap_handle_bypass(dolby_data);
@@ -1390,7 +1396,7 @@ static int msm_ds2_dap_handle_commands(u32 cmd, void *arg)
 	break;
 
 	case DAP_CMD_SET_BYPASS_TYPE:
-		if (dolby_data->data[0] == true)
+		if (data == true)
 			ds2_dap_params_states.dap_bypass_type =
 				DAP_HARD_BYPASS;
 		else
@@ -1429,6 +1435,7 @@ static int msm_ds2_dap_set_param(u32 cmd, void *arg)
 {
 	int rc = 0, idx, i, j, off, port_id = 0, cdev = 0;
 	int32_t num_device = 0;
+	int32_t data;
 	int32_t dev_arr[DS2_DSP_SUPPORTED_ENDP_DEVICE] = {0};
 	struct dolby_param_data *dolby_data =  (struct dolby_param_data *)arg;
 
@@ -1468,14 +1475,27 @@ static int msm_ds2_dap_set_param(u32 cmd, void *arg)
 			goto end;
 		}
 
+		off = ds2_dap_params_offset[idx];
+		if ((dolby_data->length <= 0) ||
+			(dolby_data->length > TOTAL_LENGTH_DS2_PARAM - off)) {
+			pr_err("%s: invalid length %d at idx %d\n",
+				__func__, dolby_data->length, idx);
+			rc = -EINVAL;
+			goto end;
+		}
+
+
 		/* cache the parameters */
 		ds2_dap_params[cdev].dap_params_modified[idx] += 1;
 		for (j = 0; j <  dolby_data->length; j++) {
-			off = ds2_dap_params_offset[idx];
-			ds2_dap_params[cdev].params_val[off + j] =
-							dolby_data->data[j];
+			if (get_user(data, &dolby_data->data[j])) {
+				pr_debug("%s:error getting data\n", __func__);
+				rc = -EFAULT;
+				goto end;
+			}
+			ds2_dap_params[cdev].params_val[off + j] = data;
 				pr_debug("%s:off %d,val[i/p:o/p]-[%d / %d]\n",
-					 __func__, off, dolby_data->data[j],
+					 __func__, off, data,
 					 ds2_dap_params[cdev].
 					 params_val[off + j]);
 		}
