MotorolaMobilityLLC__kernel-msm
commit 6aa54fd5a2926904813b402cc427989eb0765212
Author:     Mark Rutland <mark.rutland@arm.com>
AuthorDate: Thu Nov 3 20:23:11 2016 +0000
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Thu Jun 14 06:06:31 2018 -0500

    UPSTREAM: arm64: make cpu number a percpu variable
    
    In the absence of CONFIG_THREAD_INFO_IN_TASK, core code maintains
    thread_info::cpu, and low-level architecture code can access this to
    build raw_smp_processor_id(). With CONFIG_THREAD_INFO_IN_TASK, core code
    maintains task_struct::cpu, which for reasons of hte header soup is not
    accessible to low-level arch code.
    
    Instead, we can maintain a percpu variable containing the cpu number.
    
    For both the old and new implementation of raw_smp_processor_id(), we
    read a syreg into a GPR, add an offset, and load the result. As the
    offset is now larger, it may not be folded into the load, but otherwise
    the assembly shouldn't change much.
    
    Mot-CRs-fixed: (CR)
    CVE-fixed: CVE-2018-9384
    Bug: 74356909
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Laura Abbott <labbott@redhat.com>
    Cc: James Morse <james.morse@arm.com>
    Cc: Suzuki K Poulose <suzuki.poulose@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    
    Bug: 66351489
    Change-Id: I6c254befc365285599c7711f6f57b7e9067e4aae
    (cherry picked from commit 57c82954e77fa12c1023e87210d2ede77aaa0058)
    Signed-off-by: Zubin Mithra <zsm@google.com>
    Reviewed-on: https://gerrit.mot.com/1182366
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit c1349291d8ccbf3f13a8ca5c5ca0759b35dda169)

diff --git a/arch/arm64/include/asm/smp.h b/arch/arm64/include/asm/smp.h
index 2013a4dc5124..d7e851c5bc42 100644
--- a/arch/arm64/include/asm/smp.h
+++ b/arch/arm64/include/asm/smp.h
@@ -16,11 +16,20 @@
 #ifndef __ASM_SMP_H
 #define __ASM_SMP_H
 
+#include <asm/percpu.h>
+
 #include <linux/threads.h>
 #include <linux/cpumask.h>
 #include <linux/thread_info.h>
 
-#define raw_smp_processor_id() (current_thread_info()->cpu)
+DECLARE_PER_CPU_READ_MOSTLY(int, cpu_number);
+
+/*
+ * We don't use this_cpu_read(cpu_number) as that has implicit writes to
+ * preempt_count, and associated (compiler) barriers, that we'd like to avoid
+ * the expense of. If we're preemptible, the value can be stale at use anyway.
+ */
+#define raw_smp_processor_id() (*this_cpu_ptr(&cpu_number))
 
 struct seq_file;
 
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index 1d9b298200a1..c12d6b63b223 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -59,6 +59,9 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/ipi.h>
 
+DEFINE_PER_CPU_READ_MOSTLY(int, cpu_number);
+EXPORT_PER_CPU_SYMBOL(cpu_number);
+
 /*
  * as from 2.5, kernels no longer have an init_tasks structure
  * so we need some other way of telling a new secondary core
@@ -632,6 +635,8 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 		if (max_cpus == 0)
 			break;
 
+		per_cpu(cpu_number, cpu) = cpu;
+
 		if (cpu == smp_processor_id())
 			continue;
 
