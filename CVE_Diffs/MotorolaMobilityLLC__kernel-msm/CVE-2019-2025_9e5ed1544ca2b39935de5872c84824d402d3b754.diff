MotorolaMobilityLLC__kernel-msm
commit 9e5ed1544ca2b39935de5872c84824d402d3b754
Author:     Todd Kjos <tkjos@android.com>
AuthorDate: Wed Feb 13 14:57:55 2019 +0530
Commit:     Carlos Pinho <cpinho@motorola.com>
CommitDate: Fri Oct 11 21:32:59 2019 -0300

    binder: fix race that allows malicious free of live buffer
    
    Malicious code can attempt to free buffers using the BC_FREE_BUFFER
    ioctl to binder. There are protections against a user freeing a buffer
    while in use by the kernel, however there was a window where
    BC_FREE_BUFFER could be used to free a recently allocated buffer that
    was not completely initialized. This resulted in a use-after-free
    detected by KASAN with a malicious test program.
    
    This window is closed by setting the buffer's allow_user_free attribute
    to 0 when the buffer is allocated or when the user has previously freed
    it instead of waiting for the caller to set it. The problem was that
    when the struct buffer was recycled, allow_user_free was stale and set
    to 1 allowing a free to go through.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed:  CVE-2019-2025
    BUG: 116855682
    
    Change-Id: Ic3a2684dcca5465314f0aab3aee7269524ff1519
    Signed-off-by: Todd Kjos <tkjos@google.com>
    Acked-by: Arve Hjønnevåg <arve@android.com>
    Cc: stable <stable@vger.kernel.org> # 4.14
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1308226
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Shi-Yong Li <a22381@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/android/binder_alloc.c b/drivers/android/binder_alloc.c
index 74d6f8b9b8b9..b6fcf4db116a 100644
--- a/drivers/android/binder_alloc.c
+++ b/drivers/android/binder_alloc.c
@@ -151,7 +151,7 @@ static struct binder_buffer *binder_alloc_prepare_to_free_locked(
 			 * Guard against user threads attempting to
 			 * free the buffer when in use by kernel or
 			 * after it's already been freed.
-			 */
+			*/
 			if (!buffer->allow_user_free)
 				return ERR_PTR(-EPERM);
 			buffer->allow_user_free = 0;
