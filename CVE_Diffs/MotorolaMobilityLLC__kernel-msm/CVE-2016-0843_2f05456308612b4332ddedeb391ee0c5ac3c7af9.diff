MotorolaMobilityLLC__kernel-msm
commit 2f05456308612b4332ddedeb391ee0c5ac3c7af9
Author:     allen1_huang <allen1_huang@asus.com>
AuthorDate: Wed May 4 17:20:08 2016 +0800
Commit:     Wu, Meng-Hui <menghui_wu@asus.com>
CommitDate: Thu May 5 21:10:55 2016 +0800

    privilege vulnerability in Qualcomm performance module
    
    CVE: CVE-2016-0843
    Bug: ANDROID-25801197
    Severity: Critical
    Updated versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1
    Date reported: Nov 19, 2015
    
    An elevation of privilege vulnerability in the performance event manager
    component for ARM processors from Qualcomm could enable a local
    malicious application to execute arbitrary code within the kernel. This
    issue is rated as a Critical severity due to the possibility of a local
    permanent device compromise and the device would possibly need to be
    repaired by re-flashing the operating system.
    
    Change-Id: Iad30e4fe8d177b28891460a887f77a913ee61d23
    Reviewed-on: http://mcrd1-22-pc.corpnet.asus/code-review/master/228312
    Reviewed-by: allen1_huang <allen1_huang@asus.com>
    Tested-by: allen1_huang <allen1_huang@asus.com>
    Reviewed-on: http://mcrd1-22-pc.corpnet.asus/code-review/master/228800
    Reviewed-by: Wu, Meng-Hui <menghui_wu@asus.com>
    Tested-by: Wu, Meng-Hui <menghui_wu@asus.com>

diff --git a/arch/arm/mach-msm/perf_event_msm_krait_l2.c b/arch/arm/mach-msm/perf_event_msm_krait_l2.c
old mode 100644
new mode 100755
index 47816c9c04a8..8b44bc52fedb
--- a/arch/arm/mach-msm/perf_event_msm_krait_l2.c
+++ b/arch/arm/mach-msm/perf_event_msm_krait_l2.c
@@ -17,6 +17,7 @@
 #include <linux/spinlock.h>
 
 #include <mach/msm-krait-l2-accessors.h>
+#define PMU_CODES_SIZE 64
 
 /*
  * The L2 PMU is shared between all CPU's, so protect
@@ -24,7 +25,7 @@
  */
 struct pmu_constraints {
 	u64 pmu_bitmap;
-	u8 codes[64];
+	u8 codes[PMU_CODES_SIZE];
 	raw_spinlock_t lock;
 } l2_pmu_constraints = {
 	.pmu_bitmap = 0,
@@ -427,7 +428,7 @@ static int msm_l2_test_set_ev_constraint(struct perf_event *event)
 	u8 group = evt_type & 0x0000F;
 	u8 code = (evt_type & 0x00FF0) >> 4;
 	unsigned long flags;
-	u32 err = 0;
+	int err = 0;
 	u64 bitmap_t;
 	u32 shift_idx;
 
@@ -443,6 +444,10 @@ static int msm_l2_test_set_ev_constraint(struct perf_event *event)
 	raw_spin_lock_irqsave(&l2_pmu_constraints.lock, flags);
 
 	shift_idx = ((reg * 4) + group);
+	if (shift_idx >= PMU_CODES_SIZE) {
+		err =  -EINVAL;
+		goto out;
+	}
 
 	bitmap_t = 1 << shift_idx;
 
@@ -484,12 +489,17 @@ static int msm_l2_clear_ev_constraint(struct perf_event *event)
 	unsigned long flags;
 	u64 bitmap_t;
 	u32 shift_idx;
+	int err = 1;
 
 	if (evt_prefix == L2_TRACECTR_PREFIX)
 		return 1;
 	raw_spin_lock_irqsave(&l2_pmu_constraints.lock, flags);
 
 	shift_idx = ((reg * 4) + group);
+	if (shift_idx >= PMU_CODES_SIZE) {
+		err = -EINVAL;
+		goto out;
+	}
 
 	bitmap_t = 1 << shift_idx;
 
@@ -499,8 +509,9 @@ static int msm_l2_clear_ev_constraint(struct perf_event *event)
 	/* Clear code. */
 	l2_pmu_constraints.codes[shift_idx] = -1;
 
+out:
 	raw_spin_unlock_irqrestore(&l2_pmu_constraints.lock, flags);
-	return 1;
+	return err;
 }
 
 int get_num_events(void)
