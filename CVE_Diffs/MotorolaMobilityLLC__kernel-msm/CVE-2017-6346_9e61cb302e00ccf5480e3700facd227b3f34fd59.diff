MotorolaMobilityLLC__kernel-msm
commit 9e61cb302e00ccf5480e3700facd227b3f34fd59
Author:     Eric Dumazet <edumazet@google.com>
AuthorDate: Thu Jun 8 00:58:29 2017 +0200
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Wed Sep 13 01:05:21 2017 -0500

    packet: fix races in fanout_add()
    
    commit d199fab63c11998a602205f7ee7ff7c05c97164b upstream.
    
    Multiple threads can call fanout_add() at the same time.
    
    We need to grab fanout_mutex earlier to avoid races that could
    lead to one thread freeing po->rollover that was set by another thread.
    
    Do the same in fanout_release(), for peace of mind, and to help us
    finding lockdep issues earlier.
    
    [js] no rollover in 3.12
    
    Mot-CRs-fixed: (CR)
    CVE-fixed: CVE-2017-6346
    Bug : 37897645
    
    Fixes: dc99f600698d ("packet: Add fanout support.")
    Fixes: 0648ab70afe6 ("packet: rollover prepare: per-socket state")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Willy Tarreau <w@1wt.eu>
    (cherry picked from commit 2a272abc4e543f488b3a73292ee75a06f20d077a)
    Bug: 37897645
    
    Change-Id: I0eb463aaaa997cda9fad112007bd095e0dff139a
    Reviewed-on: https://gerrit.mot.com/1045044
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 67fb12231209..18b2bf40d30d 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -1430,13 +1430,16 @@ static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 		return -EINVAL;
 	}
 
+	mutex_lock(&fanout_mutex);
+
+	err = -EINVAL;
 	if (!po->running)
-		return -EINVAL;
+		goto out;
 
+	err = -EALREADY;
 	if (po->fanout)
-		return -EALREADY;
+		goto out;
 
-	mutex_lock(&fanout_mutex);
 	match = NULL;
 	list_for_each_entry(f, &fanout_list, list) {
 		if (f->id == id &&
@@ -1492,17 +1495,16 @@ static void fanout_release(struct sock *sk)
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f;
 
-	f = po->fanout;
-	if (!f)
-		return;
-
 	mutex_lock(&fanout_mutex);
-	po->fanout = NULL;
+	f = po->fanout;
+	if (f) {
+		po->fanout = NULL;
 
-	if (atomic_dec_and_test(&f->sk_ref)) {
-		list_del(&f->list);
-		dev_remove_pack(&f->prot_hook);
-		kfree(f);
+		if (atomic_dec_and_test(&f->sk_ref)) {
+			list_del(&f->list);
+			dev_remove_pack(&f->prot_hook);
+			kfree(f);
+		}
 	}
 	mutex_unlock(&fanout_mutex);
 }
