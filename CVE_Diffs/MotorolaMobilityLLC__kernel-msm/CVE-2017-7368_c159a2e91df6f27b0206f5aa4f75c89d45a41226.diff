MotorolaMobilityLLC__kernel-msm
commit c159a2e91df6f27b0206f5aa4f75c89d45a41226
Author:     Yeleswarapu Nagaradhesh <nagaradh@codeaurora.org>
AuthorDate: Thu May 18 15:16:14 2017 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Tue Jun 6 03:06:34 2017 -0500

    ASoC: msm: acquire lock in ioctl
    
    If two ioctls are triggered with different commands,
    there is a possibility to access freed confidence level
    memory. To resolve this acquire lock in ioctl.
    Also release mutex lock properly in error cases.
    
    Mot-CRs-fixed: (CR)
    CVE-fixed: CVE-2017-7368
    Bug-Id: A-33452365
    CRs-Fixed: 1103085
    Change-Id: I7d6b2eff21c8297e5f0755a0c141254be32f777d
    Signed-off-by: Yeleswarapu Nagaradhesh <nagaradh@codeaurora.org>
    ---
    Reviewed-on: https://gerrit.mot.com/997272
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Vrushali Prakash Bhosale <wkvq37@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/sound/soc/msm/qdsp6v2/msm-lsm-client.c b/sound/soc/msm/qdsp6v2/msm-lsm-client.c
index a1c25a551a54..11c2eff6cfc9 100644
--- a/sound/soc/msm/qdsp6v2/msm-lsm-client.c
+++ b/sound/soc/msm/qdsp6v2/msm-lsm-client.c
@@ -1,5 +1,5 @@
 /*
-` * Copyright (c) 2013-2016, Linux Foundation. All rights reserved.
+` * Copyright (c) 2013-2017, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -83,6 +83,7 @@ struct lsm_priv {
 	atomic_t buf_count;
 	atomic_t read_abort;
 	wait_queue_head_t period_wait;
+	struct mutex lsm_api_lock;
 	int appl_cnt;
 	int dma_write;
 };
@@ -531,10 +532,18 @@ static int msm_lsm_ioctl_shared(struct snd_pcm_substream *substream,
 	case SNDRV_LSM_EVENT_STATUS:
 		pr_debug("%s: Get event status\n", __func__);
 		atomic_set(&prtd->event_wait_stop, 0);
+
+		/*
+		 * Release the api lock before wait to allow
+		 * other IOCTLs to be invoked while waiting
+		 * for event
+		 */
+		mutex_unlock(&prtd->lsm_api_lock);
 		rc = wait_event_freezable(prtd->event_wait,
 				(cmpxchg(&prtd->event_avail, 1, 0) ||
 				 (xchg = atomic_cmpxchg(&prtd->event_wait_stop,
 							1, 0))));
+		mutex_lock(&prtd->lsm_api_lock);
 		pr_debug("%s: wait_event_freezable %d event_wait_stop %d\n",
 			 __func__, rc, xchg);
 		if (!rc && !xchg) {
@@ -746,9 +755,15 @@ static int msm_lsm_ioctl_compat(struct snd_pcm_substream *substream,
 			  unsigned int cmd, void __user *arg)
 {
 	struct snd_pcm_runtime *runtime;
+	struct lsm_priv *prtd;
 	int err = 0;
 	u32 size = 0;
 
+	runtime = substream->runtime;
+	prtd = runtime->private_data;
+
+	mutex_lock(&prtd->lsm_api_lock);
+
 	if (PCM_RUNTIME_CHECK(substream))
 		return -ENXIO;
 	runtime = substream->runtime;
@@ -785,14 +800,16 @@ static int msm_lsm_ioctl_compat(struct snd_pcm_substream *substream,
 		if (copy_from_user(&userarg32, arg, sizeof(userarg32))) {
 			pr_err("%s: err copyuser ioctl %s\n",
 			__func__, "SNDRV_LSM_EVENT_STATUS");
-			return -EFAULT;
+			err = -EFAULT;
+			goto done;
 		}
 		size = sizeof(*user) + userarg32.payload_size;
 		user = kmalloc(size, GFP_KERNEL);
 		if (!user) {
 			pr_err("%s: Allocation failed event status size %d\n",
 			__func__, size);
-			return -EFAULT;
+			err = -EFAULT;
+			goto done;
 		} else {
 			cmd = SNDRV_LSM_EVENT_STATUS;
 			user->payload_size = userarg32.payload_size;
@@ -822,6 +839,7 @@ static int msm_lsm_ioctl_compat(struct snd_pcm_substream *substream,
 			pr_err("%s: failed to copy payload %d",
 			__func__, size);
 			err = -EFAULT;
+			goto done;
 		}
 		kfree(user);
 		kfree(user32);
@@ -900,6 +918,8 @@ static int msm_lsm_ioctl_compat(struct snd_pcm_substream *substream,
 		err = msm_lsm_ioctl_shared(substream, cmd, arg);
 		break;
 	}
+done:
+	mutex_unlock(&prtd->lsm_api_lock);
 	return err;
 }
 #else
@@ -911,11 +931,17 @@ static int msm_lsm_ioctl(struct snd_pcm_substream *substream,
 {
 	int err = 0;
 	u32 size = 0;
+	struct snd_pcm_runtime *runtime;
+	struct lsm_priv *prtd;
+
+	runtime = substream->runtime;
+	prtd = runtime->private_data;
 
 	if (!substream) {
 		pr_err("%s: Invalid params\n", __func__);
 		return -EINVAL;
 	}
+	mutex_lock(&prtd->lsm_api_lock);
 	switch (cmd) {
 	case SNDRV_LSM_REG_SND_MODEL_V2: {
 		struct snd_lsm_sound_model_v2 snd_model_v2;
@@ -980,7 +1006,8 @@ static int msm_lsm_ioctl(struct snd_pcm_substream *substream,
 		if (copy_from_user(&userarg, arg, sizeof(userarg))) {
 			pr_err("%s: err copyuser event_status\n",
 			__func__);
-			return -EFAULT;
+			err = -EFAULT;
+			goto done;
 		}
 		size = sizeof(struct snd_lsm_event_status) +
 		userarg.payload_size;
@@ -988,7 +1015,8 @@ static int msm_lsm_ioctl(struct snd_pcm_substream *substream,
 		if (!user) {
 			pr_err("%s: Allocation failed event status size %d\n",
 			__func__, size);
-			return -EFAULT;
+			err = -EFAULT;
+			goto done;
 		} else {
 			user->payload_size = userarg.payload_size;
 			err = msm_lsm_ioctl_shared(substream, cmd, user);
@@ -1008,12 +1036,14 @@ static int msm_lsm_ioctl(struct snd_pcm_substream *substream,
 		kfree(user);
 		if (err)
 			pr_err("%s: lsmevent failed %d", __func__, err);
-		return err;
+		goto done;
 	}
 	default:
 		err = msm_lsm_ioctl_shared(substream, cmd, arg);
 	break;
 	}
+	done:
+	mutex_unlock(&prtd->lsm_api_lock);
 	return err;
 }
 
@@ -1030,6 +1060,7 @@ static int msm_lsm_open(struct snd_pcm_substream *substream)
 		       __func__);
 		return -ENOMEM;
 	}
+	mutex_init(&prtd->lsm_api_lock);
 	spin_lock_init(&prtd->event_lock);
 	init_waitqueue_head(&prtd->event_wait);
 	init_waitqueue_head(&prtd->period_wait);
@@ -1136,6 +1167,7 @@ static int msm_lsm_close(struct snd_pcm_substream *substream)
 	kfree(prtd->event_status);
 	prtd->event_status = NULL;
 	spin_unlock_irqrestore(&prtd->event_lock, flags);
+	mutex_destroy(&prtd->lsm_api_lock);
 	kfree(prtd);
 	runtime->private_data = NULL;
 
