MotorolaMobilityLLC__kernel-msm
commit 4f77998f175727668832f94cf339f77a3b8ebf56
Author:     Rajesh Kemisetti <rajeshk@codeaurora.org>
AuthorDate: Wed Jun 19 20:53:52 2019 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Thu Nov 14 02:06:15 2019 -0600

    msm: kgsl: Add missing check for snapshot IB dump
    
    During ringbuffer parsing, same IB can exist multiple times
    but size validation happens only for the first time.
    This leads to out of bound access if the subsequent sizes are
    greater than the allocated size.
    
    Add a check to make sure that requested size is within the
    allocated range.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-10571
    CRs-Fixed: 2363085
    
    Change-Id: Ie5d3c02c1669de2e6188821399e985f0991aa57c
    Signed-off-by: Rajesh Kemisetti <rajeshk@codeaurora.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1399905
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Bang Nguyen <bangnguyen@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/gpu/msm/adreno_snapshot.c b/drivers/gpu/msm/adreno_snapshot.c
index 4e6a4a466cc9..eda28ab15aec 100644
--- a/drivers/gpu/msm/adreno_snapshot.c
+++ b/drivers/gpu/msm/adreno_snapshot.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2018 The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2019 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -70,6 +70,19 @@ void kgsl_snapshot_push_object(struct kgsl_process_private *process,
 	for (index = 0; index < objbufptr; index++) {
 		if (objbuf[index].gpuaddr == gpuaddr &&
 			objbuf[index].entry->priv == process) {
+			/*
+			 * Check if newly requested size is within the
+			 * allocated range or not, otherwise continue
+			 * with previous size.
+			 */
+			if (!kgsl_gpuaddr_in_memdesc(
+				&objbuf[index].entry->memdesc,
+				gpuaddr, dwords << 2)) {
+				KGSL_CORE_ERR(
+					"snapshot: IB 0x%016llx size is not within the memdesc range\n",
+					gpuaddr);
+				return;
+			}
 
 			objbuf[index].size = max_t(uint64_t,
 						objbuf[index].size,
