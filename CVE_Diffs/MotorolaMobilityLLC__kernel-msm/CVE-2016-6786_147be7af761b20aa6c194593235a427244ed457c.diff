MotorolaMobilityLLC__kernel-msm
commit 147be7af761b20aa6c194593235a427244ed457c
Author:     Varun Shrivastava <varunshrivastava@motorola.com>
AuthorDate: Fri Nov 11 11:25:53 2016 +0530
Commit:     a7301c <a7301c@motorola.com>
CommitDate: Mon Dec 5 17:06:55 2016 -0600

    perf: Protect the pmu, attributes and context of a group leader
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2016-6786 CVE-2016-6787
    
    Change-Id: Ib82862252091c29a8beaa6d2dc94b3722f0b9b5d
    Signed-off-by: Varun Shrivastava <varunshrivastava@motorola.com>
    Reviewed-on: https://gerrit.mot.com/919500
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Vijayakumar Gn <vijaygn@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index c1a2bd14ff1b..93474a4d9247 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -339,6 +339,12 @@ struct perf_event {
 	int				nr_siblings;
 	int				group_flags;
 	struct perf_event		*group_leader;
+
+	/*
+	 * Protect the pmu, attributes and context of a group leader.
+	 * Note: does not protect the pointer to the group_leader.
+	 */
+	struct mutex			group_leader_mutex;
 	struct pmu			*pmu;
 
 	enum perf_event_active_state	state;
diff --git a/kernel/events/core.c b/kernel/events/core.c
index e68911b6d878..5d665905fa5f 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -7142,6 +7142,7 @@ perf_event_alloc(struct perf_event_attr *attr, int cpu,
 	if (!group_leader)
 		group_leader = event;
 
+	mutex_init(&event->group_leader_mutex);
 	mutex_init(&event->child_mutex);
 	INIT_LIST_HEAD(&event->child_list);
 
@@ -7506,6 +7507,16 @@ SYSCALL_DEFINE5(perf_event_open,
 			group_leader = NULL;
 	}
 
+	/*
+	 * Take the group_leader's group_leader_mutex before observing
+	 * anything in the group leader that leads to changes in ctx,
+	 * many of which may be changing on another thread.
+	 * In particular, we want to take this lock before deciding
+	 * whether we need to move_group.
+	 */
+	if (group_leader)
+		mutex_lock(&group_leader->group_leader_mutex);
+
 	if (pid != -1 && !(flags & PERF_FLAG_PID_CGROUP)) {
 		task = find_lively_task_by_vpid(pid);
 		if (IS_ERR(task)) {
@@ -7697,6 +7708,8 @@ SYSCALL_DEFINE5(perf_event_open,
 		put_ctx(gctx);
 	}
 	mutex_unlock(&ctx->mutex);
+	if (group_leader)
+		mutex_unlock(&group_leader->group_leader_mutex);
 
 	put_online_cpus();
 
@@ -7733,6 +7746,8 @@ err_task:
 	if (task)
 		put_task_struct(task);
 err_group_fd:
+	if (group_leader)
+		mutex_unlock(&group_leader->group_leader_mutex);
 	fdput(group);
 err_fd:
 	put_unused_fd(event_fd);
