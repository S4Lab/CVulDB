MotorolaMobilityLLC__kernel-msm
commit fb23cf2949ab43fd543d0c8d3ffb1ab0e64eb6aa
Author:     Florian Westphal <fw@strlen.de>
AuthorDate: Mon Feb 19 01:24:15 2018 +0100
Commit:     Jignesh Patel <jignesh@motorola.com>
CommitDate: Mon Jul 16 23:09:41 2018 -0500

    netfilter: ebtables: CONFIG_COMPAT: don't trust userland offsets
    
    We need to make sure the offsets are not out of range of the
    total size.
    Also check that they are in ascending order.
    
    The WARN_ON triggered by syzkaller (it sets panic_on_warn) is
    changed to also bail out, no point in continuing parsing.
    
    Briefly tested with simple ruleset of
    -A INPUT --limit 1/s' --log
    plus jump to custom chains using 32bit ebtables binary.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2018-1068
    Bug fixed: 77902350
    
    Change-Id: Ieff60e5e7df7a54204de2a7b5381ff8284479b88
    Reported-by: <syzbot+845a53d13171abf8bf29@syzkaller.appspotmail.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1208177
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Ling Jin <lingjin@motorola.com>
    Submit-Approved: Jira Key

diff --git a/net/bridge/netfilter/ebtables.c b/net/bridge/netfilter/ebtables.c
index 6651a7797d46..8cd7c567fa03 100644
--- a/net/bridge/netfilter/ebtables.c
+++ b/net/bridge/netfilter/ebtables.c
@@ -2010,7 +2010,9 @@ static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,
 		if (match_kern)
 			match_kern->match_size = ret;
 
-		WARN_ON(type == EBT_COMPAT_TARGET && size_left);
+		if (WARN_ON(type == EBT_COMPAT_TARGET && size_left))
+			return -EINVAL;
+
 		match32 = (struct compat_ebt_entry_mwt *) buf;
 	}
 
@@ -2067,6 +2069,15 @@ static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,
 	 *
 	 * offsets are relative to beginning of struct ebt_entry (i.e., 0).
 	 */
+	for (i = 0; i < 4 ; ++i) {
+		if (offsets[i] >= *total)
+			return -EINVAL;
+		if (i == 0)
+			continue;
+		if (offsets[i - 1] > offsets[i])
+			return -EINVAL;
+	}
+
 	for (i = 0, j = 1 ; j < 4 ; j++, i++) {
 		struct compat_ebt_entry_mwt *match32;
 		unsigned int size;
