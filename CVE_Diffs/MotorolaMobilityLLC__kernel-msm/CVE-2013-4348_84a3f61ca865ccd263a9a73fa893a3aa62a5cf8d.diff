MotorolaMobilityLLC__kernel-msm
commit 84a3f61ca865ccd263a9a73fa893a3aa62a5cf8d
Author:     Jason Wang <jasowang@redhat.com>
AuthorDate: Fri Nov 1 07:01:10 2013 +0000
Commit:     Choon Lee Seah <andyseah@motorola.com>
CommitDate: Tue Dec 17 01:13:29 2013 -0600

    net: flow_dissector: fail on evil iph->ihl
    
    CVE-2013-4348
    The skb_flow_dissect function in net/core/flow_dissector.c in the Linux
    kernel through 3.12 allows remote attackers to cause a denial of service
    (infinite loop) via a small value in the IHL field of a packet with IPIP
    encapsulation.
    
    We don't validate iph->ihl which may lead a dead loop if we meet a IPIP
    skb whose iph->ihl is zero. Fix this by failing immediately when iph->ihl
    is evil (less than 5).
    
    This issue were introduced by commit ec5efe7946280d1e84603389a1030ccec0a767ae
    (rps: support IPIP encapsulation).
    
    Change-Id: I5b03af9ac175fcd73d696dc0d42233d4a740f567
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Petr Matousek <pmatouse@redhat.com>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Andy Seah <dntc46@motorola.com>
    Reviewed-on: http://gerrit.pcs.mot.com/589412
    Submit-Approved: Jira Key <jirakey@motorola.com>
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Joel Voss <jvoss@motorola.com>
    Reviewed-by: Christopher Fries <c.fries@motorola.com>
    SLTApproved: Christopher Fries <c.fries@motorola.com>
    Reviewed-on: http://gerrit.pcs.mot.com/589833
    SLTApproved: Maulik Desai <amd093@motorola.com>
    Reviewed-by: Maulik Desai <amd093@motorola.com>

diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index a225089df5b6..f378b38fdf19 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -35,7 +35,7 @@ again:
 		struct iphdr _iph;
 ip:
 		iph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);
-		if (!iph)
+		if (!iph || iph->ihl < 5)
 			return false;
 
 		if (ip_is_fragment(iph))
