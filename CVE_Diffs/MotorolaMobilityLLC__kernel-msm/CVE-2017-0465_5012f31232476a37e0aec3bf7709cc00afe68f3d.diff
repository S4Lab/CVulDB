MotorolaMobilityLLC__kernel-msm
commit 5012f31232476a37e0aec3bf7709cc00afe68f3d
Author:     Sathish Ambley <sathishambley@codeaurora.org>
AuthorDate: Thu Apr 13 14:42:58 2017 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Thu May 4 01:02:05 2017 -0500

    IKSIMP-3480: msm: ADSPRPC: Check for buffer overflow condition
    
    The buffer length that is being passed could result in overflow
    condition causing invalid memory to be accessed.
    
    CVE-fixed: CVE-2017-0465
    Bug-Id: A-34112914
    Change-Id: I3e23f31b8cb61f8e77d09a39fab4a2d4c222cf25
    Signed-off-by: Sathish Ambley <sathishambley@codeaurora.org>
    --
    Reviewed-on: https://gerrit.mot.com/979416
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Vrushali Prakash Bhosale <wkvq37@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/drivers/char/adsprpc.c b/drivers/char/adsprpc.c
index 71b7d65d807e..3fde99d8a7d4 100644
--- a/drivers/char/adsprpc.c
+++ b/drivers/char/adsprpc.c
@@ -456,9 +456,9 @@ static int overlap_ptr_cmp(const void *a, const void *b)
 	return st == 0 ? ed : st;
 }
 
-static void context_build_overlap(struct smq_invoke_ctx *ctx)
+static int context_build_overlap(struct smq_invoke_ctx *ctx)
 {
-	int i;
+	int i, err = 0;
 	remote_arg_t *lpra = ctx->lpra;
 	int inbufs = REMOTE_SCALARS_INBUFS(ctx->sc);
 	int outbufs = REMOTE_SCALARS_OUTBUFS(ctx->sc);
@@ -467,6 +467,11 @@ static void context_build_overlap(struct smq_invoke_ctx *ctx)
 	for (i = 0; i < nbufs; ++i) {
 		ctx->overs[i].start = (uintptr_t)lpra[i].buf.pv;
 		ctx->overs[i].end = ctx->overs[i].start + lpra[i].buf.len;
+		if (lpra[i].buf.len) {
+			VERIFY(err, ctx->overs[i].end > ctx->overs[i].start);
+			if (err)
+				goto bail;
+		}
 		ctx->overs[i].raix = i;
 		ctx->overps[i] = &ctx->overs[i];
 	}
@@ -492,6 +497,8 @@ static void context_build_overlap(struct smq_invoke_ctx *ctx)
 			max = *ctx->overps[i];
 		}
 	}
+bail:
+	return err;
 }
 
 #define K_COPY_FROM_USER(err, kernel, dst, src, size) \
@@ -556,8 +563,11 @@ static int context_alloc(struct fastrpc_file *fl, uint32_t kernel,
 			goto bail;
 	}
 	ctx->sc = invoke->sc;
-	if (bufs)
-		context_build_overlap(ctx);
+	if (bufs) {
+		VERIFY(err, 0 == context_build_overlap(ctx));
+		if (err)
+			goto bail;
+	}
 	ctx->retval = -1;
 	ctx->pid = current->pid;
 	ctx->tgid = current->tgid;
