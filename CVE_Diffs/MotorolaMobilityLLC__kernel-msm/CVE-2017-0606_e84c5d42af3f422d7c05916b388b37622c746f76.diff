MotorolaMobilityLLC__kernel-msm
commit e84c5d42af3f422d7c05916b388b37622c746f76
Author:     Banajit Goswami <bgoswami@codeaurora.org>
AuthorDate: Wed Jun 13 11:57:50 2018 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Mon Jul 30 02:33:16 2018 -0500

    ASoC: msm: q6dspv2: fix APR deregistration logic in ASM during ADSP SSR
    
    When ADSP subsystem restart is triggered, apr_reset is called
    from the ASM callback function, which internally calls
    apr_deregister. At the same time, user space will clean up
    all existing audio sessions when ADSP SSR happens. To avoid
    any race condition, make sure only the ASM callback function
    is allowed to handle the APR deregistration process, while the
    other (session close) skips the step.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2017-0606
    CRs-fixed: 2148210,2022490
    Bug: 34088848
    
    Change-Id: I0c395c19d177e66a03fbb4cee3dd4b34f84e2d10
    Signed-off-by: Banajit Goswami <bgoswami@codeaurora.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1192509
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/sound/soc/msm/qdsp6v2/q6asm.c b/sound/soc/msm/qdsp6v2/q6asm.c
index cf637a2af77f..f4ee5a465ec7 100644
--- a/sound/soc/msm/qdsp6v2/q6asm.c
+++ b/sound/soc/msm/qdsp6v2/q6asm.c
@@ -999,12 +999,14 @@ void q6asm_audio_client_free(struct audio_client *ac)
 	}
 
 	rtac_set_asm_handle(ac->session, NULL);
-	apr_deregister(ac->apr2);
-	apr_deregister(ac->apr);
-	q6asm_mmap_apr_dereg();
-	ac->apr2 = NULL;
-	ac->apr = NULL;
-	ac->mmap_apr = NULL;
+	if (!atomic_read(&ac->reset)) {
+		apr_deregister(ac->apr2);
+		apr_deregister(ac->apr);
+		q6asm_mmap_apr_dereg();
+		ac->apr2 = NULL;
+		ac->apr = NULL;
+		ac->mmap_apr = NULL;
+	}
 	q6asm_session_free(ac);
 
 	pr_debug("%s: APR De-Register\n", __func__);
@@ -1419,7 +1421,6 @@ static int32_t q6asm_srvc_callback(struct apr_client_data *data, void *priv)
 			}
 			pr_debug("%s: Clearing custom topology\n", __func__);
 		}
-		this_mmap.apr = NULL;
 
 		cal_utils_clear_cal_block_q6maps(ASM_MAX_CAL_TYPES, cal_data);
 		common_client.mmap_apr = NULL;
@@ -1631,8 +1632,10 @@ static int32_t q6asm_callback(struct apr_client_data *data, void *priv)
 	if (data->opcode == RESET_EVENTS) {
 		mutex_lock(&ac->cmd_lock);
 		atomic_set(&ac->reset, 1);
-		if (ac->apr == NULL)
+		if (ac->apr == NULL) {
 			ac->apr = ac->apr2;
+			ac->apr2 = NULL;
+		}
 		pr_debug("%s: Reset event is received: %d %d apr[%pK]\n",
 			__func__,
 			data->reset_event, data->reset_proc, ac->apr);
