MotorolaMobilityLLC__kernel-msm
commit cda572fde8b0ea7dbf6d3465052581fa5added0a
Author:     Will Deacon <will.deacon@arm.com>
AuthorDate: Tue Nov 14 14:33:28 2017 +0000
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Wed Mar 28 03:21:27 2018 -0500

    FROMLIST: arm64: tls: Avoid unconditional zeroing of tpidrro_el0 for native tasks
    
    When unmapping the kernel at EL0, we use tpidrro_el0 as a scratch register
    during exception entry from native tasks and subsequently zero it in
    the kernel_ventry macro. We can therefore avoid zeroing tpidrro_el0
    in the context-switch path for native tasks using the entry trampoline.
    
    Mot-CRs-fixed: (CR)
    CVE-fixed: CVE-2017-5754
    Bug: 69856074
    
    Reviewed-by: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Laura Abbott <labbott@redhat.com>
    Tested-by: Shanker Donthineni <shankerd@codeaurora.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    (cherry picked from git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux.git
     commit 18011eac28c7cb31c87b86b7d0e5b01894405c7f)
    
    Change-Id: Ief7b4099f055420a7a23c8dcf497269192f5fb58
    [ghackmann@google.com:
     - adjust context
     - replace task_user_tls() accessor with equivalent field from 3.18]
    Signed-off-by: Greg Hackmann <ghackmann@google.com>
    Reviewed-on: https://gerrit.mot.com/1132560
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index f08af2aa63d0..6a51e47a17f8 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -410,25 +410,18 @@ int copy_thread(unsigned long clone_flags, unsigned long stack_start,
 
 static void tls_thread_switch(struct task_struct *next)
 {
-	unsigned long tpidr, tpidrro;
-
 	if (!is_compat_task()) {
+		unsigned long tpidr;
 		asm("mrs %0, tpidr_el0" : "=r" (tpidr));
 		current->thread.tp_value = tpidr;
 	}
 
-	if (is_compat_thread(task_thread_info(next))) {
-		tpidr = 0;
-		tpidrro = next->thread.tp_value;
-	} else {
-		tpidr = next->thread.tp_value;
-		tpidrro = 0;
-	}
+	if (is_compat_thread(task_thread_info(next)))
+		write_sysreg(next->thread.tp_value, tpidrro_el0);
+	else if (!arm64_kernel_unmapped_at_el0())
+		write_sysreg(0, tpidrro_el0);
 
-	asm(
-	"	msr	tpidr_el0, %0\n"
-	"	msr	tpidrro_el0, %1"
-	: : "r" (tpidr), "r" (tpidrro));
+	write_sysreg(next->thread.tp_value, tpidr_el0);
 }
 
 /* Restore the UAO state depending on next's addr_limit */
