MotorolaMobilityLLC__kernel-msm
commit 49bc9ea8c034c18527bf550c881ffc13c8465ebb
Author:     Zhao Xuewen <zhaoxuewen@huawei.com>
AuthorDate: Tue Apr 12 20:09:57 2016 +0800
Commit:     Zhao Xuewen <zhaoxuewen@huawei.com>
CommitDate: Tue Apr 12 20:09:57 2016 +0800

    haptic driver:Elevation of Privilege in Texas Instrument Haptic Driver
    
    There is not a parameter check for parameter len, which is passed from user space.
    This vulnerability could trigger arbitrary code execution in the kernel.
    
    CVE-2016-2409 Bug:ANDROID-25981545
    
    Change-Id: I3f99a49e83765742b7e3897caa6851a6410e0f97
    Signed-off-by: Zhao Xuewen <zhaoxuewen@huawei.com>

diff --git a/drivers/haptics/drv2605.c b/drivers/haptics/drv2605.c
index f3bbcda91c0b..738fccb820e6 100644
--- a/drivers/haptics/drv2605.c
+++ b/drivers/haptics/drv2605.c
@@ -51,9 +51,9 @@ static int drv2605_reg_read(struct drv2605_data *pDrv2605data, unsigned int reg)
 {
 	unsigned int val;
 	int ret;
-	
+
 	ret = regmap_read(pDrv2605data->regmap, reg, &val);
-    
+
 	if (ret < 0)
 		return ret;
 	else
@@ -149,16 +149,16 @@ static void setAudioHapticsEnabled(struct drv2605_data *pDrv2605data, int enable
 		if(pDrv2605data->work_mode != WORK_AUDIO2HAPTIC){
 			pDrv2605data->vibrator_is_playing = YES;
 			drv2605_change_mode(pDrv2605data, WORK_IDLE, DEV_READY);
-			
-			drv2605_set_bits(pDrv2605data, 
-					Control1_REG, 
-					Control1_REG_AC_COUPLE_MASK, 
+
+			drv2605_set_bits(pDrv2605data,
+					Control1_REG,
+					Control1_REG_AC_COUPLE_MASK,
 					AC_COUPLE_ENABLED );
-					
-			drv2605_set_bits(pDrv2605data, 
-					Control3_REG, 
-					Control3_REG_PWMANALOG_MASK, 
-					INPUT_ANALOG);	
+
+			drv2605_set_bits(pDrv2605data,
+					Control3_REG,
+					Control3_REG_PWMANALOG_MASK,
+					INPUT_ANALOG);
 
 			drv2605_change_mode(pDrv2605data, WORK_AUDIO2HAPTIC, DEV_READY);
 			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_AUDIO2HAPTIC);
@@ -168,18 +168,18 @@ static void setAudioHapticsEnabled(struct drv2605_data *pDrv2605data, int enable
 		if(pDrv2605data->work_mode == WORK_AUDIO2HAPTIC){
 			pDrv2605data->vibrator_is_playing = NO;
 			drv2605_change_mode(pDrv2605data, WORK_IDLE, DEV_READY);
-						
-			drv2605_set_bits(pDrv2605data, 
-					Control1_REG, 
-					Control1_REG_AC_COUPLE_MASK, 
+
+			drv2605_set_bits(pDrv2605data,
+					Control1_REG,
+					Control1_REG_AC_COUPLE_MASK,
 					AC_COUPLE_DISABLED );
-					
-			drv2605_set_bits(pDrv2605data, 
-					Control3_REG, 
-					Control3_REG_PWMANALOG_MASK, 
-					INPUT_PWM);	
-					
-			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);		
+
+			drv2605_set_bits(pDrv2605data,
+					Control3_REG,
+					Control3_REG_PWMANALOG_MASK,
+					INPUT_PWM);
+
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
 			drv2605_change_mode(pDrv2605data, WORK_IDLE, DEV_STANDBY); // Disable audio-to-haptics
 		}
     }
@@ -196,16 +196,16 @@ static void play_effect(struct drv2605_data *pDrv2605data)
     while((drv2605_reg_read(pDrv2605data, GO_REG) == GO) && (pDrv2605data->should_stop == NO)){
         schedule_timeout_interruptible(msecs_to_jiffies(GO_BIT_POLL_INTERVAL));
 	}
-	
+
 	if(pDrv2605data->should_stop == YES){
 		drv2605_set_go_bit(pDrv2605data, STOP);
 	}
-  
+
     if (pDrv2605data->audio_haptics_enabled){
         setAudioHapticsEnabled(pDrv2605data, YES);
     } else {
         drv2605_change_mode(pDrv2605data, WORK_IDLE, DEV_STANDBY);
-		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);		
+		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
 		pDrv2605data->vibrator_is_playing = NO;
 		wake_unlock(&pDrv2605data->wklock);
     }
@@ -218,7 +218,7 @@ static void play_Pattern_RTP(struct drv2605_data *pDrv2605data)
 		if(pDrv2605data->repeat_times == 0){
 			drv2605_change_mode(pDrv2605data, WORK_IDLE, DEV_STANDBY);
 			pDrv2605data->vibrator_is_playing = NO;
-			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);	
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
 			wake_unlock(&pDrv2605data->wklock);
 		}else{
 			hrtimer_start(&pDrv2605data->timer, ns_to_ktime((u64)pDrv2605data->silience_time * NSEC_PER_MSEC), HRTIMER_MODE_REL);
@@ -235,17 +235,17 @@ static void play_Seq_RTP(struct drv2605_data *pDrv2605data)
 	if(pDrv2605data->RTPSeq.RTPindex < pDrv2605data->RTPSeq.RTPCounts){
 		int RTPTime = pDrv2605data->RTPSeq.RTPData[pDrv2605data->RTPSeq.RTPindex] >> 8;
 		int RTPVal = pDrv2605data->RTPSeq.RTPData[pDrv2605data->RTPSeq.RTPindex] & 0x00ff ;
-			
+
 		pDrv2605data->vibrator_is_playing = YES;
 		pDrv2605data->RTPSeq.RTPindex++;
 		drv2605_change_mode(pDrv2605data, WORK_SEQ_RTP_ON, DEV_READY);
 		drv2605_set_rtp_val(pDrv2605data,  RTPVal);
-							
+
 		hrtimer_start(&pDrv2605data->timer, ns_to_ktime((u64)RTPTime * NSEC_PER_MSEC), HRTIMER_MODE_REL);
 	}else{
 		drv2605_change_mode(pDrv2605data, WORK_IDLE, DEV_STANDBY);
 		pDrv2605data->vibrator_is_playing = NO;
-		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);	
+		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
 		wake_unlock(&pDrv2605data->wklock);
 	}
 }
@@ -259,8 +259,8 @@ static void vibrator_off(struct drv2605_data *pDrv2605data)
 			pDrv2605data->vibrator_is_playing = NO;
 			drv2605_set_go_bit(pDrv2605data, STOP);
 			drv2605_change_mode(pDrv2605data, WORK_IDLE, DEV_STANDBY);
-			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);				
-			wake_unlock(&pDrv2605data->wklock);		
+			switch_set_state(&pDrv2605data->sw_dev, SW_STATE_IDLE);
+			wake_unlock(&pDrv2605data->wklock);
 		}
     }
 }
@@ -269,7 +269,7 @@ static void drv2605_stop(struct drv2605_data *pDrv2605data)
 {
 	if(pDrv2605data->vibrator_is_playing){
 		if(pDrv2605data->work_mode == WORK_AUDIO2HAPTIC){
-			setAudioHapticsEnabled(pDrv2605data, NO);		
+			setAudioHapticsEnabled(pDrv2605data, NO);
 		}else if((pDrv2605data->work_mode == WORK_VIBRATOR)
 				||(pDrv2605data->work_mode == WORK_PATTERN_RTP_ON)
 				||(pDrv2605data->work_mode == WORK_PATTERN_RTP_OFF)
@@ -281,7 +281,7 @@ static void drv2605_stop(struct drv2605_data *pDrv2605data)
 		}else{
 			printk("%s, err mode=%d \n", __FUNCTION__, pDrv2605data->work_mode);
 		}
-	}	
+	}
 }
 
 static int vibrator_get_time(struct timed_output_dev *dev)
@@ -299,13 +299,13 @@ static int vibrator_get_time(struct timed_output_dev *dev)
 static void vibrator_enable( struct timed_output_dev *dev, int value)
 {
 	struct drv2605_data *pDrv2605data = container_of(dev, struct drv2605_data, to_dev);
-	
-	pDrv2605data->should_stop = YES;	
+
+	pDrv2605data->should_stop = YES;
 	hrtimer_cancel(&pDrv2605data->timer);
 	cancel_work_sync(&pDrv2605data->vibrator_work);
 
     mutex_lock(&pDrv2605data->lock);
-	
+
 	drv2605_stop(pDrv2605data);
 
     if (value > 0) {
@@ -315,12 +315,12 @@ static void vibrator_enable( struct timed_output_dev *dev, int value)
 		mdelay(WAKE_STANDBY_DELAY);
 		drv2605_change_mode(pDrv2605data, WORK_VIBRATOR, DEV_READY);
 		pDrv2605data->vibrator_is_playing = YES;
-		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);			
+		switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
 
 		value = (value>MAX_TIMEOUT)?MAX_TIMEOUT:value;
         hrtimer_start(&pDrv2605data->timer, ns_to_ktime((u64)value * NSEC_PER_MSEC), HRTIMER_MODE_REL);
     }
-	
+
 	mutex_unlock(&pDrv2605data->lock);
 	mdelay(WAKE_STANDBY_DELAY);
 }
@@ -330,7 +330,7 @@ static enum hrtimer_restart vibrator_timer_func(struct hrtimer *timer)
 	struct drv2605_data *pDrv2605data = container_of(timer, struct drv2605_data, timer);
 
     schedule_work(&pDrv2605data->vibrator_work);
-	
+
     return HRTIMER_NORESTART;
 }
 
@@ -339,7 +339,7 @@ static void vibrator_work_routine(struct work_struct *work)
 	struct drv2605_data *pDrv2605data = container_of(work, struct drv2605_data, vibrator_work);
 
 	mutex_lock(&pDrv2605data->lock);
-	
+
 	if((pDrv2605data->work_mode == WORK_VIBRATOR)
 		||(pDrv2605data->work_mode == WORK_RTP)){
 		vibrator_off(pDrv2605data);
@@ -350,7 +350,7 @@ static void vibrator_work_routine(struct work_struct *work)
 	}else if((pDrv2605data->work_mode == WORK_SEQ_RTP_ON)||(pDrv2605data->work_mode == WORK_SEQ_RTP_OFF)){
 		play_Seq_RTP(pDrv2605data);
 	}
-	
+
 	mutex_unlock(&pDrv2605data->lock);
 }
 
@@ -359,7 +359,7 @@ static int dev2605_open (struct inode * i_node, struct file * filp)
 	if(pDRV2605data == NULL){
 		return -ENODEV;
 	}
-	
+
 	filp->private_data = pDRV2605data;
 	return 0;
 }
@@ -368,18 +368,20 @@ static ssize_t dev2605_read(struct file* filp, char* buff, size_t length, loff_t
 {
 	struct drv2605_data *pDrv2605data = (struct drv2605_data *)filp->private_data;
 	int ret = 0;
+	ssize_t tocopy = 0;
+	int len = (int) length;
 
-	if(pDrv2605data->ReadLen > 0){
-		ret = copy_to_user(buff, pDrv2605data->ReadBuff, pDrv2605data->ReadLen);
-		if (ret != 0){
-			printk("%s, copy_to_user err=%d \n", __FUNCTION__, ret);
-		}else{
-			ret = pDrv2605data->ReadLen;
-		}
-		pDrv2605data->ReadLen = 0;
+	if(length < 1) return -EINVAL;
+
+	tocopy = min(len, pDrv2605data->ReadLen);
+	if(tocopy < 1) return -EFAULT;
+
+	if(copy_to_user(buff, pDrv2605data->ReadBuff, tocopy)){
+		printk("%s, copy_to_user err=%d \n", __FUNCTION__, ret);
+		return -EFAULT;
 	}
-	
-    return ret;
+
+	return tocopy;
 }
 
 static bool isforDebug(int cmd){
@@ -388,121 +390,148 @@ static bool isforDebug(int cmd){
 		||(cmd == HAPTIC_CMDID_REG_SETBIT));
 }
 
-static ssize_t dev2605_write(struct file* filp, const char* buff, size_t len, loff_t* off)
+static ssize_t dev2605_write(struct file* filp, const char* buff, size_t length, loff_t* off)
 {
 	struct drv2605_data *pDrv2605data = (struct drv2605_data *)filp->private_data;
-	
+	ssize_t ret = 0;
+	int len = (int) length;
+	if(len < 1) return -EINVAL;
+
 	if(isforDebug(buff[0])){
 	}else{
-		pDrv2605data->should_stop = YES;	
+		pDrv2605data->should_stop = YES;
 		hrtimer_cancel(&pDrv2605data->timer);
 		cancel_work_sync(&pDrv2605data->vibrator_work);
 	}
-	
+
     mutex_lock(&pDrv2605data->lock);
-	
+
 	if(isforDebug(buff[0])){
 	}else{
 		drv2605_stop(pDrv2605data);
 	}
-	
+
     switch(buff[0])
     {
         case HAPTIC_CMDID_PLAY_SINGLE_EFFECT:
         case HAPTIC_CMDID_PLAY_EFFECT_SEQUENCE:
-		{	
-            memset(&pDrv2605data->sequence, 0, WAVEFORM_SEQUENCER_MAX);
-            if (!copy_from_user(&pDrv2605data->sequence, &buff[1], len - 1))
-            {
-				if(pDrv2605data->audio_haptics_enabled == NO){
-					wake_lock(&pDrv2605data->wklock);
+		{
+			if(len < 2) ret = -EINVAL;
+			else{
+				memset(&pDrv2605data->sequence, 0, WAVEFORM_SEQUENCER_MAX);
+				if (!copy_from_user(&pDrv2605data->sequence, &buff[1],
+					min(len - 1, WAVEFORM_SEQUENCER_MAX)))
+				{
+					if(pDrv2605data->audio_haptics_enabled == NO){
+						wake_lock(&pDrv2605data->wklock);
+					}
+					pDrv2605data->should_stop = NO;
+					drv2605_change_mode(pDrv2605data, WORK_SEQ_PLAYBACK, DEV_IDLE);
+					schedule_work(&pDrv2605data->vibrator_work);
+					ret = min(len - 1, WAVEFORM_SEQUENCER_MAX);
+				}else{
+					ret = -EFAULT;
 				}
-				pDrv2605data->should_stop = NO;
-				drv2605_change_mode(pDrv2605data, WORK_SEQ_PLAYBACK, DEV_IDLE);
-                schedule_work(&pDrv2605data->vibrator_work);
-            }
+			}
             break;
         }
         case HAPTIC_CMDID_PLAY_TIMED_EFFECT:
-        {	
+        {
             unsigned int value = 0;
-            value = buff[2];
-            value <<= 8;
-            value |= buff[1];
-		
-            if (value > 0)
-            {
-				if(pDrv2605data->audio_haptics_enabled == NO){			
-					wake_lock(&pDrv2605data->wklock);
+			if(len < 3) ret = -EINVAL;
+			else{
+				value = buff[2];
+				value <<= 8;
+				value |= buff[1];
+
+				if (value > 0)
+				{
+					if(pDrv2605data->audio_haptics_enabled == NO){
+						wake_lock(&pDrv2605data->wklock);
+					}
+					switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
+					pDrv2605data->vibrator_is_playing = YES;
+					value = (value > MAX_TIMEOUT)?MAX_TIMEOUT:value;
+					drv2605_change_mode(pDrv2605data, WORK_RTP, DEV_READY);
+
+					hrtimer_start(&pDrv2605data->timer, ns_to_ktime((u64)value * NSEC_PER_MSEC), HRTIMER_MODE_REL);
 				}
-				switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
-				pDrv2605data->vibrator_is_playing = YES;
-  				value = (value > MAX_TIMEOUT)?MAX_TIMEOUT:value;
-				drv2605_change_mode(pDrv2605data, WORK_RTP, DEV_READY);
-				
-				hrtimer_start(&pDrv2605data->timer, ns_to_ktime((u64)value * NSEC_PER_MSEC), HRTIMER_MODE_REL);
-            }
+
+				ret = 3;
+			}
             break;
         }
 
        case HAPTIC_CMDID_PATTERN_RTP:
         {
 			unsigned char strength = 0;
-
-			pDrv2605data->vibration_time = (int)((((int)buff[2])<<8) | (int)buff[1]);
-			pDrv2605data->silience_time = (int)((((int)buff[4])<<8) | (int)buff[3]);
-			strength = buff[5];
-			pDrv2605data->repeat_times = buff[6];
-			
-            if(pDrv2605data->vibration_time > 0){
-				if(pDrv2605data->audio_haptics_enabled == NO){
-					wake_lock(&pDrv2605data->wklock);			
+			if(len < 7) ret = -EINVAL;
+			else{
+				pDrv2605data->vibration_time = (int)((((int)buff[2])<<8) | (int)buff[1]);
+				pDrv2605data->silience_time = (int)((((int)buff[4])<<8) | (int)buff[3]);
+				strength = buff[5];
+				pDrv2605data->repeat_times = buff[6];
+
+				if(pDrv2605data->vibration_time > 0){
+					if(pDrv2605data->audio_haptics_enabled == NO){
+						wake_lock(&pDrv2605data->wklock);
+					}
+					switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
+					pDrv2605data->vibrator_is_playing = YES;
+					if(pDrv2605data->repeat_times > 0)
+						pDrv2605data->repeat_times--;
+					if (pDrv2605data->vibration_time > MAX_TIMEOUT)
+						pDrv2605data->vibration_time = MAX_TIMEOUT;
+					drv2605_change_mode(pDrv2605data, WORK_PATTERN_RTP_ON, DEV_READY);
+					drv2605_set_rtp_val(pDrv2605data, strength);
+
+					hrtimer_start(&pDrv2605data->timer, ns_to_ktime((u64)pDrv2605data->vibration_time * NSEC_PER_MSEC), HRTIMER_MODE_REL);
 				}
-				switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
-				pDrv2605data->vibrator_is_playing = YES;
-                if(pDrv2605data->repeat_times > 0)
-					pDrv2605data->repeat_times--;
-                if (pDrv2605data->vibration_time > MAX_TIMEOUT)
-                    pDrv2605data->vibration_time = MAX_TIMEOUT;
-				drv2605_change_mode(pDrv2605data, WORK_PATTERN_RTP_ON, DEV_READY);
-				drv2605_set_rtp_val(pDrv2605data, strength);
-				
-                hrtimer_start(&pDrv2605data->timer, ns_to_ktime((u64)pDrv2605data->vibration_time * NSEC_PER_MSEC), HRTIMER_MODE_REL);
-            }
+
+				ret = 7;
+			}
             break;
-        }		
- 		
+        }
+
 		case HAPTIC_CMDID_RTP_SEQUENCE:
 		{
-            memset(&pDrv2605data->RTPSeq, 0, sizeof(struct RTP_Seq));
-			if(((len-1)%2) == 0){
-				pDrv2605data->RTPSeq.RTPCounts = (len-1)/2;
-				if((pDrv2605data->RTPSeq.RTPCounts <= MAX_RTP_SEQ)&&(pDrv2605data->RTPSeq.RTPCounts>0)){
-					if(copy_from_user(pDrv2605data->RTPSeq.RTPData, &buff[1], pDrv2605data->RTPSeq.RTPCounts*2) != 0){
-						printk("%s, rtp_seq copy seq err\n", __FUNCTION__);	
-						break;
-					}
-					
-					if(pDrv2605data->audio_haptics_enabled == NO){
-						wake_lock(&pDrv2605data->wklock);
+			if(len < 5) ret = -EINVAL;
+			else{
+				memset(&pDrv2605data->RTPSeq, 0, sizeof(struct RTP_Seq));
+				if(((len-1)%2) == 0){
+					pDrv2605data->RTPSeq.RTPCounts = (len-1)/2;
+					if((pDrv2605data->RTPSeq.RTPCounts <= MAX_RTP_SEQ)&&(pDrv2605data->RTPSeq.RTPCounts>0)){
+						if(copy_from_user(pDrv2605data->RTPSeq.RTPData, &buff[1], pDrv2605data->RTPSeq.RTPCounts*2) != 0){
+							printk("%s, rtp_seq copy seq err\n", __FUNCTION__);
+							ret = -EFAULT;
+							break;
+						}
+
+						if(pDrv2605data->audio_haptics_enabled == NO){
+							wake_lock(&pDrv2605data->wklock);
+						}
+						switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
+						drv2605_change_mode(pDrv2605data, WORK_SEQ_RTP_OFF, DEV_IDLE);
+						schedule_work(&pDrv2605data->vibrator_work);
+						ret = len;
+					}else{
+						ret = -EINVAL;
+						printk("%s, rtp_seq count error,maximum=%d\n", __FUNCTION__,MAX_RTP_SEQ);
 					}
-					switch_set_state(&pDrv2605data->sw_dev, SW_STATE_RTP_PLAYBACK);
-					drv2605_change_mode(pDrv2605data, WORK_SEQ_RTP_OFF, DEV_IDLE);
-					schedule_work(&pDrv2605data->vibrator_work);
 				}else{
-					printk("%s, rtp_seq count error,maximum=%d\n", __FUNCTION__,MAX_RTP_SEQ);
+					printk("%s, rtp_seq len error\n", __FUNCTION__);
+					ret = -EINVAL;
 				}
-			}else{
-				printk("%s, rtp_seq len error\n", __FUNCTION__);
 			}
 			break;
 		}
-		
+
         case HAPTIC_CMDID_STOP:
         {
+			ret = len;
             break;
         }
-		
+
         case HAPTIC_CMDID_AUDIOHAPTIC_ENABLE:
         {
 			if(pDrv2605data->audio_haptics_enabled == NO){
@@ -510,69 +539,85 @@ static ssize_t dev2605_write(struct file* filp, const char* buff, size_t len, lo
 			}
 			pDrv2605data->audio_haptics_enabled = YES;
 			setAudioHapticsEnabled(pDrv2605data, YES);
+			ret = len;
             break;
         }
-		
+
         case HAPTIC_CMDID_AUDIOHAPTIC_DISABLE:
         {
 			if(pDrv2605data->audio_haptics_enabled == YES){
 				pDrv2605data->audio_haptics_enabled = NO;
-				wake_unlock(&pDrv2605data->wklock);	
+				wake_unlock(&pDrv2605data->wklock);
 			}
+			ret = len;
             break;
         }
-		
+
 		case HAPTIC_CMDID_REG_READ:
 		{
 			if(len == 2){
 				pDrv2605data->ReadLen = 1;
 				pDrv2605data->ReadBuff[0] = drv2605_reg_read(pDrv2605data, buff[1]);
+				ret = len;
 			}else if(len == 3){
 				pDrv2605data->ReadLen = (buff[2]>MAX_READ_BYTES)?MAX_READ_BYTES:buff[2];
 				drv2605_bulk_read(pDrv2605data, buff[1], pDrv2605data->ReadLen, pDrv2605data->ReadBuff);
+				ret = len;
 			}else{
 				printk("%s, reg_read len error\n", __FUNCTION__);
+				ret = -EINVAL;
 			}
 			break;
 		}
-		
+
 		case HAPTIC_CMDID_REG_WRITE:
 		{
 			if((len-1) == 2){
-				drv2605_reg_write(pDrv2605data, buff[1], buff[2]);	
+				drv2605_reg_write(pDrv2605data, buff[1], buff[2]);
+				ret = len;
 			}else if((len-1)>2){
 				unsigned char *data = (unsigned char *)kzalloc(len-2, GFP_KERNEL);
 				if(data != NULL){
 					if(copy_from_user(data, &buff[2], len-2) != 0){
-						printk("%s, reg copy err\n", __FUNCTION__);	
+						printk("%s, reg copy err\n", __FUNCTION__);
+						ret = -EFAULT;
 					}else{
 						drv2605_bulk_write(pDrv2605data, buff[1], len-2, data);
+						ret = len;
 					}
 					kfree(data);
+				}else{
+					ret = -ENOMEM;
 				}
 			}else{
 				printk("%s, reg_write len error\n", __FUNCTION__);
+				ret = -EINVAL;
 			}
 			break;
 		}
-		
+
 		case HAPTIC_CMDID_REG_SETBIT:
 		{
-			int i=1;			
-			for(i=1; i< len; ){
-				drv2605_set_bits(pDrv2605data, buff[i], buff[i+1], buff[i+2]);
-				i += 3;
+			if(len < 4) ret = -EINVAL;
+			else{
+				int i=1;
+				for(i=1; i< len; ){
+					drv2605_set_bits(pDrv2605data, buff[i], buff[i+1], buff[i+2]);
+					i += 3;
+				}
+				ret = len;
 			}
 			break;
-		}		
+		}
     default:
 		printk("%s, unknown HAPTIC cmd\n", __FUNCTION__);
+		ret = -EINVAL;
       break;
     }
 
     mutex_unlock(&pDrv2605data->lock);
 
-    return len;
+    return ret;
 }
 
 
@@ -585,40 +630,40 @@ static struct file_operations fops =
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 void drv2605_early_suspend(struct early_suspend *h){
-	struct drv2605_data *pDrv2605data = container_of(h, struct drv2605_data, early_suspend); 
+	struct drv2605_data *pDrv2605data = container_of(h, struct drv2605_data, early_suspend);
 
-	pDrv2605data->should_stop = YES;	
+	pDrv2605data->should_stop = YES;
 	hrtimer_cancel(&pDrv2605data->timer);
 	cancel_work_sync(&pDrv2605data->vibrator_work);
-	
-	mutex_lock(&pDrv2605data->lock);	
-	
+
+	mutex_lock(&pDrv2605data->lock);
+
 	drv2605_stop(pDrv2605data);
 	if(pDrv2605data->audio_haptics_enabled == YES){
 		wake_unlock(&pDrv2605data->wklock);
 	}
-	
+
 	mutex_unlock(&pDrv2605data->lock);
     return ;
 }
 
 void drv2605_late_resume(struct early_suspend *h) {
-	struct drv2605_data *pDrv2605data = container_of(h, struct drv2605_data, early_suspend); 
-	
-	mutex_lock(&pDrv2605data->lock);	
+	struct drv2605_data *pDrv2605data = container_of(h, struct drv2605_data, early_suspend);
+
+	mutex_lock(&pDrv2605data->lock);
 	if(pDrv2605data->audio_haptics_enabled == YES){
 		wake_lock(&pDrv2605data->wklock);
 		setAudioHapticsEnabled(pDrv2605data, YES);
 	}
 	mutex_unlock(&pDrv2605data->lock);
-    return ; 
+    return ;
  }
 #endif
- 
+
 static int Haptics_init(struct drv2605_data *pDrv2605data)
 {
     int reval = -ENOMEM;
-   
+
     pDrv2605data->version = MKDEV(0,0);
     reval = alloc_chrdev_region(&pDrv2605data->version, 0, 1, HAPTICS_DEVICE_NAME);
     if (reval < 0)
@@ -656,8 +701,8 @@ static int Haptics_init(struct drv2605_data *pDrv2605data)
 	if (reval < 0) {
 		printk(KERN_ALERT"drv2605: fail to register switch\n");
 		goto fail4;
-	}	
-	
+	}
+
 	pDrv2605data->to_dev.name = "vibrator";
 	pDrv2605data->to_dev.get_time = vibrator_get_time;
 	pDrv2605data->to_dev.enable = vibrator_enable;
@@ -673,15 +718,15 @@ static int Haptics_init(struct drv2605_data *pDrv2605data)
 	pDrv2605data->early_suspend.resume = drv2605_late_resume;
 	pDrv2605data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 1;
 	register_early_suspend(&pDrv2605data->early_suspend);
-#endif  
-	
+#endif
+
     hrtimer_init(&pDrv2605data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
     pDrv2605data->timer.function = vibrator_timer_func;
     INIT_WORK(&pDrv2605data->vibrator_work, vibrator_work_routine);
-    
+
     wake_lock_init(&pDrv2605data->wklock, WAKE_LOCK_SUSPEND, "vibrator");
     mutex_init(&pDrv2605data->lock);
-	
+
     return 0;
 
 fail4:
@@ -689,9 +734,9 @@ fail4:
 fail3:
 	device_destroy(pDrv2605data->class, pDrv2605data->version);
 fail2:
-    class_destroy(pDrv2605data->class);	
+    class_destroy(pDrv2605data->class);
 fail1:
-    unregister_chrdev_region(pDrv2605data->version, 1);	
+    unregister_chrdev_region(pDrv2605data->version, 1);
 fail0:
     return reval;
 }
@@ -702,9 +747,9 @@ static void dev_init_platform_data(struct drv2605_data *pDrv2605data)
 	struct actuator_data actuator = pDrv2605Platdata->actuator;
 	struct audio2haptics_data a2h = pDrv2605Platdata->a2h;
 	unsigned char temp = 0;
-	
+
 	drv2605_select_library(pDrv2605data, actuator.g_effect_bank);
-	
+
 	//OTP memory saves data from 0x16 to 0x1a
 	if(pDrv2605data->OTP == 0) {
 		if(actuator.rated_vol != 0){
@@ -718,15 +763,15 @@ static void dev_init_platform_data(struct drv2605_data *pDrv2605data)
 		}else{
 			printk("%s, ERROR OverDriveVol ZERO\n", __FUNCTION__);
 		}
-		
-		drv2605_set_bits(pDrv2605data, 
-						FEEDBACK_CONTROL_REG, 
-						FEEDBACK_CONTROL_DEVICE_TYPE_MASK, 
+
+		drv2605_set_bits(pDrv2605data,
+						FEEDBACK_CONTROL_REG,
+						FEEDBACK_CONTROL_DEVICE_TYPE_MASK,
 						(actuator.device_type == LRA)?FEEDBACK_CONTROL_MODE_LRA:FEEDBACK_CONTROL_MODE_ERM);
 	}else{
 		printk("%s, OTP programmed\n", __FUNCTION__);
 	}
-	
+
 	if(pDrv2605Platdata->loop == OPEN_LOOP){
 		temp = BIDIR_INPUT_BIDIRECTIONAL;
 	}else{
@@ -739,18 +784,18 @@ static void dev_init_platform_data(struct drv2605_data *pDrv2605data)
 
 	if(actuator.device_type == LRA){
 		unsigned char DriveTime = 5*(1000 - actuator.LRAFreq)/actuator.LRAFreq;
-		drv2605_set_bits(pDrv2605data, 
-				Control1_REG, 
-				Control1_REG_DRIVE_TIME_MASK, 
-				DriveTime);	
+		drv2605_set_bits(pDrv2605data,
+				Control1_REG,
+				Control1_REG_DRIVE_TIME_MASK,
+				DriveTime);
 		printk("%s, LRA = %d, DriveTime=0x%x\n", __FUNCTION__, actuator.LRAFreq, DriveTime);
 	}
-	
-	drv2605_set_bits(pDrv2605data, 
-				Control2_REG, 
-				Control2_REG_BIDIR_INPUT_MASK, 
-				temp);	
-		
+
+	drv2605_set_bits(pDrv2605data,
+				Control2_REG,
+				Control2_REG_BIDIR_INPUT_MASK,
+				temp);
+
 	if((pDrv2605Platdata->loop == OPEN_LOOP)&&(actuator.device_type == LRA))
 	{
 		temp = LRA_OpenLoop_Enabled;
@@ -782,10 +827,10 @@ static void dev_init_platform_data(struct drv2605_data *pDrv2605data)
 			drv2605_reg_write(pDrv2605data, REAL_TIME_PLAYBACK_REG, 0xff);
 		}
 	}
-	drv2605_set_bits(pDrv2605data, 
-					Control3_REG, 
-					Control3_REG_LOOP_MASK|Control3_REG_FORMAT_MASK, 
-					temp);	
+	drv2605_set_bits(pDrv2605data,
+					Control3_REG,
+					Control3_REG_LOOP_MASK|Control3_REG_FORMAT_MASK,
+					temp);
 
 	//for audio to haptics
 	if(pDrv2605Platdata->GpioTrigger == 0)	//not used as external trigger
@@ -800,10 +845,10 @@ static void dev_init_platform_data(struct drv2605_data *pDrv2605data)
 static int dev_auto_calibrate(struct drv2605_data *pDrv2605data)
 {
 	int err = 0, status=0;
-	
+
 	drv2605_change_mode(pDrv2605data, WORK_CALIBRATION, DEV_READY);
 	drv2605_set_go_bit(pDrv2605data, GO);
-			
+
 	/* Wait until the procedure is done */
 	drv2605_poll_go_bit(pDrv2605data);
 	/* Read status */
@@ -815,7 +860,7 @@ static int dev_auto_calibrate(struct drv2605_data *pDrv2605data)
 	drv2605_reg_read(pDrv2605data, AUTO_CALI_RESULT_REG);
 	drv2605_reg_read(pDrv2605data, AUTO_CALI_BACK_EMF_RESULT_REG);
 	drv2605_reg_read(pDrv2605data, FEEDBACK_CONTROL_REG);
-	
+
 	return err;
 }
 
@@ -829,7 +874,7 @@ static int drv2605_probe(struct i2c_client* client, const struct i2c_device_id*
 {
 	struct drv2605_data *pDrv2605data;
 	struct drv2605_platform_data *pDrv2605Platdata = client->dev.platform_data;
-	
+
 	int err = 0;
 	int status = 0;
 	int emfstatus = 0;
@@ -859,7 +904,7 @@ static int drv2605_probe(struct i2c_client* client, const struct i2c_device_id*
 	if(pDrv2605data->PlatData.GpioTrigger){
 		err = gpio_request(pDrv2605data->PlatData.GpioTrigger,HAPTICS_DEVICE_NAME"Trigger");
 		if(err < 0){
-			printk(KERN_ERR"%s: GPIO request Trigger error\n", __FUNCTION__);				
+			printk(KERN_ERR"%s: GPIO request Trigger error\n", __FUNCTION__);
 			goto exit_gpio_request_failed;
 		}
 	}
@@ -867,7 +912,7 @@ static int drv2605_probe(struct i2c_client* client, const struct i2c_device_id*
 	if(pDrv2605data->PlatData.GpioEnable){
 		err = gpio_request(pDrv2605data->PlatData.GpioEnable,HAPTICS_DEVICE_NAME"Enable");
 		if(err < 0){
-			printk(KERN_ERR"%s: GPIO request enable error\n", __FUNCTION__);					
+			printk(KERN_ERR"%s: GPIO request enable error\n", __FUNCTION__);
 			goto exit_gpio_request_failed;
 		}
 
@@ -923,11 +968,11 @@ static int drv2605_probe(struct i2c_client* client, const struct i2c_device_id*
 		printk("%s, FEEDBACK_CONTROL_REG 0x36\n", __FUNCTION__);
 	}
 	schedule_timeout_interruptible(msecs_to_jiffies(STANDBY_WAKE_DELAY));
-	
+
 	pDrv2605data->OTP = 0;
-	
+
 	dev_init_platform_data(pDrv2605data);
-	
+
 	if (pDrv2605data->OTP == 0)
 	{
 		err = dev_auto_calibrate(pDrv2605data);
@@ -953,7 +998,7 @@ exit_gpio_request_failed:
 	if(pDrv2605data->PlatData.GpioEnable){
 		gpio_free(pDrv2605data->PlatData.GpioEnable);
 	}
-	
+
     printk(KERN_ERR"%s failed, err=%d\n",__FUNCTION__, err);
 	return err;
 }
@@ -972,12 +1017,12 @@ static int drv2605_remove(struct i2c_client* client)
 	if(pDrv2605data->PlatData.GpioEnable)
 		gpio_free(pDrv2605data->PlatData.GpioEnable);
 
-#ifdef CONFIG_HAS_EARLYSUSPEND		
+#ifdef CONFIG_HAS_EARLYSUSPEND
 	unregister_early_suspend(&pDrv2605data->early_suspend);
 #endif
-	
+
     printk(KERN_ALERT"drv2605 remove");
-	
+
     return 0;
 }
 
@@ -1019,18 +1064,18 @@ MODULE_DESCRIPTION("Driver for "HAPTICS_DEVICE_NAME);
 
 /******************************************************************************
  FUNCTION: vibrator_ctrl_kernel
- 
+
  DESCRIPTION: vibrator control interface in kernel
                       value:vibrate time, unit ms
  ******************************************************************************/
 void vibrator_ctrl_kernel(int value)
 {
-    pDRV2605data->should_stop = YES;	
+    pDRV2605data->should_stop = YES;
     hrtimer_cancel(&pDRV2605data->timer);
     cancel_work_sync(&pDRV2605data->vibrator_work);
 
     mutex_lock(&pDRV2605data->lock);
-    
+
     drv2605_stop(pDRV2605data);
 
     if (value > 0) {
@@ -1045,7 +1090,7 @@ void vibrator_ctrl_kernel(int value)
         value = (value>MAX_TIMEOUT)?MAX_TIMEOUT:value;
         hrtimer_start(&pDRV2605data->timer, ns_to_ktime((u64)value * NSEC_PER_MSEC), HRTIMER_MODE_REL);
     }
-    
+
     mutex_unlock(&pDRV2605data->lock);
 }
 
