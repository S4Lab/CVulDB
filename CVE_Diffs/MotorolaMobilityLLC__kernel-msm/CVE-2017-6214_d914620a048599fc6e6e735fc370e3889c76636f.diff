MotorolaMobilityLLC__kernel-msm
commit d914620a048599fc6e6e735fc370e3889c76636f
Author:     Vineet Angadi V <vineetv@motorola.com>
AuthorDate: Fri Aug 11 17:38:32 2017 +0530
Commit:     Charles Barros <charlesb@motorola.com>
CommitDate: Tue Jan 23 14:57:46 2018 -0200

    tcp: avoid infinite loop in tcp_splice_read()
    
    Splicing from TCP socket is vulnerable when a packet with URG flag is
    received and stored into receive queue.
    
    __tcp_splice_read() returns 0, and sk_wait_data() immediately
    returns since there is the problematic skb in queue.
    
    This is a nice way to burn cpu (aka infinite loop) and trigger
    soft lockups.
    
    Again, this gem was found by syzkaller tool.
    
    Mot-CRs-fixed:(CR)
    CVE-Fixed:CVE-2017-6214
    
    Change-Id: If34d59c6a575d4eb4a68b54dd155a9016ae7c039
    Fixes: 9c55e01c0cc8 ("[TCP]: Splice receive support.")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov  <dvyukov@google.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Vineet Angadi V <vineetv@motorola.com>
    Change-Id: I569237de9d1c689d3147125adbe95df450466f99
    Reviewed-on: https://gerrit.mot.com/1040492
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit 68252a9e06ece5efbcd4c5800df34bdf1d17b667)

diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 4fcfaf869314..6a885415620c 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -785,6 +785,12 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
 				ret = -EAGAIN;
 				break;
 			}
+			/* if __tcp_splice_read() got nothing while we have
+			* an skb in receive queue, we do not want to loop.
+			* This might happen with URG data.
+			*/
+			if (!skb_queue_empty(&sk->sk_receive_queue))
+				break;
 			sk_wait_data(sk, &timeo);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);
