MotorolaMobilityLLC__kernel-msm
commit 8e3305d024e9dc3286d4fc9485db3e953c8ba678
Author:     Karthikeyan Mani <kmani@codeaurora.org>
AuthorDate: Tue Mar 21 17:34:20 2017 +0530
Commit:     Neeraj Kumar <neerajk@motorola.com>
CommitDate: Wed Mar 22 04:03:30 2017 -0500

    ASoC: msm: qdsp6v2: Fix out-of-bounds access in put functions
    
    Add out of bounds check in routing put functions
    for the mux value before accessing the texts
    pointer of soc_enum struct with mux as index.
    
    CVE-fixed: CVE-2017-0586
    CRs-fixed: 1097569
    Bug: 33649808
    Change-Id: Ib9ef8d398f0765754b0f79666963fac043b66077
    Signed-off-by: Karthikeyan Mani <kmani@codeaurora.org>
    Signed-off-by: Haynes Mathew Owens <hOwens@codeaurora.org>
    ---
    Reviewed-on: https://gerrit.mot.com/965691
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Vrushali Prakash Bhosale <wkvq37@motorola.com>
    Reviewed-by: Bang Nguyen <bangnguyen@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
index 926c69455fc5..b0f3bf15175a 100644
--- a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1750,8 +1750,14 @@ static int msm_routing_ec_ref_rx_put(struct snd_kcontrol *kcontrol,
 	int ec_ref_port_id;
 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	int mux = ucontrol->value.enumerated.item[0];
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 
+	if (mux >= e->max) {
+		pr_err("%s: Invalid mux value %d\n", __func__, mux);
+		return -EINVAL;
+	}
+
 	mutex_lock(&routing_lock);
 	switch (ucontrol->value.integer.value[0]) {
 	case 0:
@@ -1869,9 +1875,14 @@ static int msm_routing_ext_ec_put(struct snd_kcontrol *kcontrol,
 	int ret = 0;
 	bool state = false;
 
+	if (mux >= e->max) {
+		pr_err("%s: Invalid mux value %d\n", __func__, mux);
+		return -EINVAL;
+	}
+
 	pr_debug("%s: msm_route_ec_ref_rx = %d value = %ld\n",
-		 __func__, msm_route_ext_ec_ref,
-		 ucontrol->value.integer.value[0]);
+		__func__, msm_route_ext_ec_ref,
+		ucontrol->value.integer.value[0]);
 
 	mutex_lock(&routing_lock);
 	switch (ucontrol->value.integer.value[0]) {
