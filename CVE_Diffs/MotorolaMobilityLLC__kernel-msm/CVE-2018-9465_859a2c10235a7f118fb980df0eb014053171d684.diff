MotorolaMobilityLLC__kernel-msm
commit 859a2c10235a7f118fb980df0eb014053171d684
Author:     Todd Kjos <tkjos@google.com>
AuthorDate: Fri Jul 13 13:17:11 2018 +0530
Commit:     Jignesh Patel <jignesh@motorola.com>
CommitDate: Wed Jul 18 22:57:05 2018 -0500

    binder: fix proc->files use-after-free
    
    proc->files cleanup is initiated by binder_vma_close. Therefore
    a reference on the binder_proc is not enough to prevent the
    files_struct from being released while the binder_proc still has
    a reference. This can lead to an attempt to dereference the
    stale pointer obtained from proc->files prior to proc->files
    cleanup. This has been seen once in task_get_unused_fd_flags()
    when __alloc_fd() is called with a stale "files".
    
    The fix is to always use get_files_struct() to obtain struct_files
    so that the refcount on the files_struct is used to prevent
    a premature free. proc->files is removed since we get it every
    time.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2018-9465
    Bug fixed: 69164715
    
    Change-Id: Ia646a3aba448d730508ab118b46925657ffd2290
    Signed-off-by: Todd Kjos <tkjos@google.com>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1209292
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Shi-Yong Li <a22381@motorola.com>
    Reviewed-by: Ling Jin <lingjin@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index caf7a8ee53f6..abc28e2ac0ad 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -325,9 +325,8 @@ struct binder_buffer {
 };
 
 enum binder_deferred_state {
-	BINDER_DEFERRED_PUT_FILES    = 0x01,
-	BINDER_DEFERRED_FLUSH        = 0x02,
-	BINDER_DEFERRED_RELEASE      = 0x04,
+	BINDER_DEFERRED_FLUSH        = 0x01,
+	BINDER_DEFERRED_RELEASE      = 0x02,
 };
 
 struct binder_proc {
@@ -413,18 +412,26 @@ struct binder_transaction {
 static void
 binder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer);
 
+static struct files_struct *binder_get_files_struct(struct binder_proc *proc)
+{
+	return get_files_struct(proc->tsk);
+}
+
 static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
 {
-	struct files_struct *files = proc->files;
+	struct files_struct *files;
 	unsigned long rlim_cur;
 	unsigned long irqs;
 	int ret;
 
+	files = binder_get_files_struct(proc);
 	if (files == NULL)
 		return -ESRCH;
 
-	if (!lock_task_sighand(proc->tsk, &irqs))
-		return -EMFILE;
+	if (!lock_task_sighand(proc->tsk, &irqs)) {
+		ret = -EMFILE;
+		goto err;
+	}
 
 	rlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);
 	unlock_task_sighand(proc->tsk, &irqs);
@@ -432,7 +439,8 @@ static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
 	preempt_enable_no_resched();
 	ret = __alloc_fd(files, 0, rlim_cur, flags);
 	preempt_disable();
-
+err:
+	put_files_struct(files);
 	return ret;
 }
 
@@ -442,8 +450,12 @@ static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)
 static void task_fd_install(
 	struct binder_proc *proc, unsigned int fd, struct file *file)
 {
-	if (proc->files)
-		__fd_install(proc->files, fd, file);
+	struct files_struct *files = binder_get_files_struct(proc);
+
+	if (files) {
+		__fd_install(files, fd, file);
+		put_files_struct(files);
+	}
 }
 
 /*
@@ -451,18 +463,20 @@ static void task_fd_install(
  */
 static long task_close_fd(struct binder_proc *proc, unsigned int fd)
 {
+	struct files_struct *files = binder_get_files_struct(proc);
 	int retval;
 
-	if (proc->files == NULL)
+	if (files == NULL)
 		return -ESRCH;
 
-	retval = __close_fd(proc->files, fd);
+	retval = __close_fd(files, fd);
 	/* can't restart close syscall because file table entry was cleared */
 	if (unlikely(retval == -ERESTARTSYS ||
 		     retval == -ERESTARTNOINTR ||
 		     retval == -ERESTARTNOHAND ||
 		     retval == -ERESTART_RESTARTBLOCK))
 		retval = -EINTR;
+	put_files_struct(files);
 
 	return retval;
 }
@@ -3458,7 +3472,6 @@ static void binder_vma_close(struct vm_area_struct *vma)
 		     (unsigned long)pgprot_val(vma->vm_page_prot));
 	proc->vma = NULL;
 	proc->vma_vm_mm = NULL;
-	binder_defer_work(proc, BINDER_DEFERRED_PUT_FILES);
 }
 
 static int binder_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
@@ -3552,7 +3565,6 @@ static int binder_mmap(struct file *filp, struct vm_area_struct *vma)
 	binder_insert_free_buffer(proc, buffer);
 	proc->free_async_space = proc->buffer_size / 2;
 	barrier();
-	proc->files = get_files_struct(current);
 	proc->vma = vma;
 	proc->vma_vm_mm = vma->vm_mm;
 
@@ -3720,7 +3732,6 @@ static void binder_deferred_release(struct binder_proc *proc)
 		active_transactions, page_count;
 
 	BUG_ON(proc->vma);
-	BUG_ON(proc->files);
 
 	hlist_del(&proc->proc_node);
 
@@ -3822,7 +3833,6 @@ static void binder_deferred_release(struct binder_proc *proc)
 static void binder_deferred_func(struct work_struct *work)
 {
 	struct binder_proc *proc;
-	struct files_struct *files;
 	struct binder_context *context =
 		container_of(work, struct binder_context, deferred_work);
 
@@ -3847,13 +3857,6 @@ static void binder_deferred_func(struct work_struct *work)
 		}
 		mutex_unlock(&context->binder_deferred_lock);
 
-		files = NULL;
-		if (defer & BINDER_DEFERRED_PUT_FILES) {
-			files = proc->files;
-			if (files)
-				proc->files = NULL;
-		}
-
 		if (defer & BINDER_DEFERRED_FLUSH)
 			binder_deferred_flush(proc);
 
@@ -3863,8 +3866,6 @@ static void binder_deferred_func(struct work_struct *work)
 		trace_binder_unlock(__func__);
 		mutex_unlock(&context->binder_main_lock);
 		preempt_enable_no_resched();
-		if (files)
-			put_files_struct(files);
 	} while (proc);
 }
 
