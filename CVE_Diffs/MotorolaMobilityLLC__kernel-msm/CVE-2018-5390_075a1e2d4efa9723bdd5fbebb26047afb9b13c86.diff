MotorolaMobilityLLC__kernel-msm
commit 075a1e2d4efa9723bdd5fbebb26047afb9b13c86
Author:     Eric Dumazet <edumazet@google.com>
AuthorDate: Fri Jul 27 12:27:06 2018 +0200
Commit:     Marcos Fukai Inoue <marcosi@motorola.com>
CommitDate: Tue Dec 11 09:57:03 2018 -0600

    UPSTREAM: tcp: avoid collapses in tcp_prune_queue() if possible
    
    [ Upstream commit f4a3313d8e2ca9fd8d8f45e40a2903ba782607e7 ]
    
    Right after a TCP flow is created, receiving tiny out of order
    packets allways hit the condition :
    
    if (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)
            tcp_clamp_window(sk);
    
    tcp_clamp_window() increases sk_rcvbuf to match sk_rmem_alloc
    (guarded by tcp_rmem[2])
    
    Calling tcp_collapse_ofo_queue() in this case is not useful,
    and offers a O(N^2) surface attack to malicious peers.
    
    Better not attempt anything before full queue capacity is reached,
    forcing attacker to spend lots of resource and allow us to more
    easily detect the abuse.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed:  CVE-2018-5390
    
    Change-Id: Ib4fabbd6f22b51fd6eea66a0f3b210543d3ebe01
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Soheil Hassas Yeganeh <soheil@google.com>
    Acked-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Chenbo Feng <fengc@google.com>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1280302
    SME-Granted: SME Approvals Granted
    Submit-Approved: Jira Key
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    SLTApproved: Marcos Fukai Inoue <marcosi@motorola.com>

diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index bf3cef3615b6..63a4e2049e42 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -4687,6 +4687,9 @@ static int tcp_prune_queue(struct sock *sk)
 	else if (sk_under_memory_pressure(sk))
 		tp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U * tp->advmss);
 
+	if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)
+		return 0;
+
 	tcp_collapse_ofo_queue(sk);
 	if (!skb_queue_empty(&sk->sk_receive_queue))
 		tcp_collapse(sk, &sk->sk_receive_queue,
