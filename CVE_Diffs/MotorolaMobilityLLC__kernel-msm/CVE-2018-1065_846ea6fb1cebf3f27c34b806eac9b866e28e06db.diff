MotorolaMobilityLLC__kernel-msm
commit 846ea6fb1cebf3f27c34b806eac9b866e28e06db
Author:     Florian Westphal <fw@strlen.de>
AuthorDate: Fri Jun 8 14:10:03 2018 +0530
Commit:     chenyt9 <chenyt9@lenovo.com>
CommitDate: Thu Nov 28 17:31:28 2019 +0800

    netfilter: add back stackpointer size checks
    
    The rationale for removing the check is only correct for rulesets
    generated by ip(6)tables.
    
    In iptables, a jump can only occur to a user-Defenderined chain, i.e.
    because we size the stack based on number of user-Defenderined chains we
    cannot exceed stack size.
    
    However, the underlying binary format has no such restriction,
    and the validation step only ensures that the jump target is a
    valid rule start point.
    
    IOW, its possible to build a rule blob that has no user-Defenderined
    chains but does contain a jump.
    
    If this happens, no jump stack gets allocated and crash occurs
    because no jumpstack was allocated.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2018-1065
    Bug: 76206188
    
    Change-Id: Id0fadbd02c149a256f5d45d3a4f7a212cc6dd8eb
    Fixes: 7814b6ec6d0d6 ("netfilter: xtables: don't save/restore jumpstack offset")
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1189184
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Konstantin Makariev <kmakariev@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit da953ddd7f1d03f400b6541790a2bca22bd1c0d8)

diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c
index 6e3e0e8b1ce3..cff58f7ee559 100644
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@ -329,6 +329,10 @@ unsigned int arpt_do_table(struct sk_buff *skb,
 			}
 			if (table_base + v
 			    != arpt_next_entry(e)) {
+				if (unlikely(stackidx >= private->stacksize)) {
+					verdict = NF_DROP;
+					break;
+				}
 				jumpstack[stackidx++] = e;
 			}
 
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index a399c5419622..760c81dfbee8 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -408,6 +408,10 @@ ipt_do_table(struct sk_buff *skb,
 			}
 			if (table_base + v != ipt_next_entry(e) &&
 			    !(e->ip.flags & IPT_F_GOTO)) {
+				if (unlikely(stackidx >= private->stacksize)) {
+					verdict = NF_DROP;
+					break;
+				}
 				jumpstack[stackidx++] = e;
 				pr_debug("Pushed %p into pos %u\n",
 					 e, stackidx - 1);
diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c
index 6fd784643d6e..3d616c6733e5 100644
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@ -429,6 +429,10 @@ ip6t_do_table(struct sk_buff *skb,
 			}
 			if (table_base + v != ip6t_next_entry(e) &&
 			    !(e->ipv6.flags & IP6T_F_GOTO)) {
+				if (unlikely(stackidx >= private->stacksize)) {
+					verdict = NF_DROP;
+					break;
+				}
 				jumpstack[stackidx++] = e;
 			}
 
