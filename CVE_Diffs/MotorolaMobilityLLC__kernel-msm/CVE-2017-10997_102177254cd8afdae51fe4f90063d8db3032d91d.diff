MotorolaMobilityLLC__kernel-msm
commit 102177254cd8afdae51fe4f90063d8db3032d91d
Author:     Tony Truong <truong@codeaurora.org>
AuthorDate: Fri Jan 6 14:03:03 2017 -0800
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Tue Sep 5 00:06:41 2017 -0500

    msm: pcie: add bounds check for debugfs register write
    
    Via debugfs nodes, users have the option to read and write to
    any PCIe register. To ensure clients do not access registers
    outside the PCIe range, add checks to validate the offset clients
    provide.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2017-10997
    CRs-Fixed: 1103077
    Bug: 33039685
    
    Change-Id: Ia35cd04c57f01c21a47962be596bca395b5ca247
    Signed-off-by: Tony Truong <truong@codeaurora.org>
    Reviewed-on: https://gerrit.mot.com/1043687
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit db3a9026631abc80d3e4ea7bbbd1f621474caef7)

diff --git a/drivers/pci/host/pci-msm.c b/drivers/pci/host/pci-msm.c
index 32d71d0f2ba2..58c0019a3670 100644
--- a/drivers/pci/host/pci-msm.c
+++ b/drivers/pci/host/pci-msm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1691,8 +1691,15 @@ static void msm_pcie_sel_debug_testcase(struct msm_pcie_dev_t *dev,
 			dev->res[base_sel - 1].base,
 			wr_offset, wr_mask, wr_value);
 
-		msm_pcie_write_reg_field(dev->res[base_sel - 1].base,
-			wr_offset, wr_mask, wr_value);
+		base_sel_size = resource_size(dev->res[base_sel - 1].resource);
+
+		if (wr_offset >  base_sel_size - 4 ||
+			msm_pcie_check_align(dev, wr_offset))
+			pr_alert("PCIe: RC%d: Invalid wr_offset: 0x%x. wr_offset should be no more than 0x%x\n",
+				dev->rc_idx, wr_offset, base_sel_size - 4);
+		else
+			msm_pcie_write_reg_field(dev->res[base_sel - 1].base,
+				wr_offset, wr_mask, wr_value);
 
 		break;
 	case 13: /* dump all registers of base_sel */
