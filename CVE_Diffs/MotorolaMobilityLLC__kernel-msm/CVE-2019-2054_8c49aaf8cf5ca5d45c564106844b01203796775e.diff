MotorolaMobilityLLC__kernel-msm
commit 8c49aaf8cf5ca5d45c564106844b01203796775e
Author:     Kees Cook <keescook@chromium.org>
AuthorDate: Wed Jun 1 19:29:15 2016 -0700
Commit:     Jignesh Patel <jignesh@motorola.com>
CommitDate: Tue Apr 23 22:40:25 2019 -0500

    seccomp: recheck the syscall after RET_TRACE
    
    When RET_TRACE triggers, a tracer may change a syscall into something that
    should be filtered by seccomp. This re-runs seccomp after a trace event
    to make sure things continue to pass.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-2054
    BUG: 119769499
    
    Change-Id: Ibf1eb8fa3c2cb9dba3274f16e92ddf97e8ffcbce
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Perry Lutomirski <luto@kernel.org>
    Reviewed-on: https://gerrit.mot.com/1334241
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Shi-Yong Li <a22381@motorola.com>
    Reviewed-by: Ling Jin <lingjin@motorola.com>
    Submit-Approved: Jira Key

diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index 44af84e3bc75..49eafa463853 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -581,7 +581,8 @@ void secure_computing_strict(int this_syscall)
 #else
 
 #ifdef CONFIG_SECCOMP_FILTER
-static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
+static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,
+			    const bool recheck_after_trace)
 {
 	u32 filter_ret, action;
 	int data;
@@ -613,6 +614,10 @@ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
 		goto skip;
 
 	case SECCOMP_RET_TRACE:
+		/* We've been put in this state by the ptracer already. */
+		if (recheck_after_trace)
+			return 0;
+
 		/* ENOSYS these calls if there is no tracer attached. */
 		if (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {
 			syscall_set_return_value(current,
@@ -636,6 +641,15 @@ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
 		if (this_syscall < 0)
 			goto skip;
 
+		/*
+		 * Recheck the syscall, since it may have changed. This
+		 * intentionally uses a NULL struct seccomp_data to force
+		 * a reload of all registers. This does not goto skip since
+		 * a skip would have already been reported.
+		 */
+		if (__seccomp_filter(this_syscall, NULL, true))
+			return -1;
+
 		return 0;
 
 	case SECCOMP_RET_ALLOW:
@@ -654,7 +668,8 @@ skip:
 	return -1;
 }
 #else
-static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
+static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,
+			    const bool recheck_after_trace)
 {
 	BUG();
 }
@@ -677,7 +692,7 @@ int __secure_computing(const struct seccomp_data *sd)
 		__secure_computing_strict(this_syscall);  /* may call do_exit */
 		return 0;
 	case SECCOMP_MODE_FILTER:
-		return __seccomp_filter(this_syscall, sd);
+		return __seccomp_filter(this_syscall, sd, false);
 	default:
 		BUG();
 	}
