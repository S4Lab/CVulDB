MotorolaMobilityLLC__kernel-msm
commit 3e34aead68ff58a39d228fe7ff79c58561e22cc2
Author:     Banajit Goswami <bgoswami@codeaurora.org>
AuthorDate: Mon Apr 10 19:56:25 2017 -0700
Commit:     lulu2 <lulu2@lenovo.com>
CommitDate: Thu Jul 12 10:44:16 2018 +0800

    soc: q6dspv2: apr: fix client registration refcount
    
    Audio Packet Router (APR) is used by multiple audio services
    to communicate between APSS and ADSP. These audio services
    registers for service level APR communication (port 0xFFFFFFFF),
    or for session level APR communication (using port 0x101 etc.).
    The services might choose to call apr_register for any port at
    random. The expectation is that the refcounting for the number
    of ports registered with APR for any specific service, is handled
    irrespective of the order in which registrations are done. The
    current logic fails to handle the refcounting when apr_register
    is called for 0xFFFFFFFF before other session based ports. Fix
    this correctly using the service count (svc_cnt) variable in apr_svc.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2017-0606
    CRs-fixed: 2148210,2022490
    Bug: 34088848
    
    Change-Id: I2fcd1269facf24d509db0d90314e0d2545a2ad67
    Signed-off-by: Banajit Goswami <bgoswami@codeaurora.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1192671
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/soc/qcom/qdsp6v2/apr.c b/drivers/soc/qcom/qdsp6v2/apr.c
index 62519a60f36b..bacf3133f89b 100644
--- a/drivers/soc/qcom/qdsp6v2/apr.c
+++ b/drivers/soc/qcom/qdsp6v2/apr.c
@@ -459,19 +459,19 @@ struct apr_svc *apr_register(char *dest, char *svc_name, apr_fn svc_fn,
 			mutex_unlock(&svc->m_lock);
 			return NULL;
 		}
-		if (!svc->port_cnt && !svc->svc_cnt)
+		if (!svc->svc_cnt)
 			clnt->svc_cnt++;
 		svc->port_cnt++;
 		svc->port_fn[temp_port] = svc_fn;
 		svc->port_priv[temp_port] = priv;
+		svc->svc_cnt++;
 	} else {
 		if (!svc->fn) {
-			if (!svc->port_cnt && !svc->svc_cnt)
+			if (!svc->svc_cnt)
 				clnt->svc_cnt++;
 			svc->fn = svc_fn;
-			if (svc->port_cnt)
-				svc->svc_cnt++;
 			svc->priv = priv;
+			svc->svc_cnt++;
 		}
 	}
 
@@ -674,29 +674,28 @@ int apr_deregister(void *handle)
 	if (!handle)
 		return -EINVAL;
 
+	if (!svc->svc_cnt) {
+		pr_err("%s: svc already deregistered. svc = %pK\n",
+			__func__, svc);
+		return -EINVAL;
+	}
+
 	mutex_lock(&svc->m_lock);
 	dest_id = svc->dest_id;
 	client_id = svc->client_id;
 	clnt = &client[dest_id][client_id];
 
-	if (svc->port_cnt > 0 || svc->svc_cnt > 0) {
+	if (svc->svc_cnt > 0) {
 		if (svc->port_cnt)
 			svc->port_cnt--;
-		else if (svc->svc_cnt)
-			svc->svc_cnt--;
-		if (!svc->port_cnt && !svc->svc_cnt) {
+		svc->svc_cnt--;
+		if (!svc->svc_cnt) {
 			client[dest_id][client_id].svc_cnt--;
-			svc->need_reset = 0x0;
-		}
-	} else if (client[dest_id][client_id].svc_cnt > 0) {
-		client[dest_id][client_id].svc_cnt--;
-		if (!client[dest_id][client_id].svc_cnt) {
-			svc->need_reset = 0x0;
 			pr_debug("%s: service is reset %pK\n", __func__, svc);
 		}
 	}
 
-	if (!svc->port_cnt && !svc->svc_cnt) {
+	if (!svc->svc_cnt) {
 		svc->priv = NULL;
 		svc->id = 0;
 		svc->fn = NULL;
