MotorolaMobilityLLC__kernel-msm
commit 8994b5a4c0a2859ee337dd1d8c41d3a7e99fd8b3
Author:     Todd Kjos <tkjos@google.com>
AuthorDate: Thu Aug 8 10:26:06 2019 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Mon Oct 21 00:26:55 2019 -0500

    binder: check for overflow when alloc for security context
    
    When allocating space in the target buffer for the security context,
    make sure the extra_buffers_size doesn't overflow. This can only
    happen if the given size is invalid, but an overflow can turn it
    into a valid size. Fail the transaction if an overflow is detected.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-2181
    Bug: 130571081
    
    Change-Id: Ibaec652d2073491cc426a4a24004a848348316bf
    Signed-off-by: Todd Kjos <tkjos@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-by: Shi-Yong Li <a22381@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1435525
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Ling Jin <lingjin@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit 4ab5dfc1cc74fd24a3566bf7b35c8712f28d0464)

diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index c4768f7f0c85..65dc26cf8dac 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -3129,6 +3129,7 @@ static void binder_transaction(struct binder_proc *proc,
 
 	if (target_node && target_node->txn_security_ctx) {
 		u32 secid;
+		size_t added_size;
 
 		security_task_getsecid(proc->tsk, &secid);
 		ret = security_secid_to_secctx(secid, &secctx, &secctx_sz);
@@ -3138,7 +3139,15 @@ static void binder_transaction(struct binder_proc *proc,
 			return_error_line = __LINE__;
 			goto err_get_secctx_failed;
 		}
-		extra_buffers_size += ALIGN(secctx_sz, sizeof(u64));
+		added_size = ALIGN(secctx_sz, sizeof(u64));
+		extra_buffers_size += added_size;
+		if (extra_buffers_size < added_size) {
+			/* integer overflow of extra_buffers_size */
+			return_error = BR_FAILED_REPLY;
+			return_error_param = EINVAL;
+			return_error_line = __LINE__;
+			goto err_bad_extra_size;
+		}
 	}
 
 	trace_binder_transaction(reply, t, target_node);
@@ -3440,6 +3449,7 @@ err_copy_data_failed:
 	t->buffer->transaction = NULL;
 	binder_alloc_free_buf(&target_proc->alloc, t->buffer);
 err_binder_alloc_buf_failed:
+err_bad_extra_size:
 	if (secctx)
 		security_release_secctx(secctx, secctx_sz);
 err_get_secctx_failed:
