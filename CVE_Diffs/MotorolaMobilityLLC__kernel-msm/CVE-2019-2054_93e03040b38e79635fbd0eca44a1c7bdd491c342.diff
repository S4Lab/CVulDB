MotorolaMobilityLLC__kernel-msm
commit 93e03040b38e79635fbd0eca44a1c7bdd491c342
Author:     Kees Cook <keescook@chromium.org>
AuthorDate: Wed Jun 1 19:29:15 2016 -0700
Commit:     chenyt9 <chenyt9@lenovo.com>
CommitDate: Tue Aug 20 14:01:01 2019 +0800

    seccomp: recheck the syscall after RET_TRACE
    
    When RET_TRACE triggers, a tracer may change a syscall into something that
    should be filtered by seccomp. This re-runs seccomp after a trace event
    to make sure things continue to pass.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-2054
    BUG: 119769499
    
    Change-Id: Ie3d1de5a2659cb374f8d8c505f3e9f86e86e4746
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Reviewed-on: https://gerrit.mot.com/1334293
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Shi-Yong Li <a22381@motorola.com>
    Reviewed-by: Ling Jin <lingjin@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit 81722bdb267b459bdeb5a3c2fb35fa2006fe04b3)

diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index 308d4572e84e..3279fb1967a6 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -601,7 +601,8 @@ void secure_computing_strict(int this_syscall)
 #else
 
 #ifdef CONFIG_SECCOMP_FILTER
-static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
+static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,
+			    const bool recheck_after_trace)
 {
 	u32 filter_ret, action;
 	int data;
@@ -633,6 +634,10 @@ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
 		goto skip;
 
 	case SECCOMP_RET_TRACE:
+		/* We've been put in this state by the ptracer already. */
+		if (recheck_after_trace)
+			return 0;
+
 		/* ENOSYS these calls if there is no tracer attached. */
 		if (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {
 			syscall_set_return_value(current,
@@ -656,6 +661,15 @@ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
 		if (this_syscall < 0)
 			goto skip;
 
+		/*
+		 * Recheck the syscall, since it may have changed. This
+		 * intentionally uses a NULL struct seccomp_data to force
+		 * a reload of all registers. This does not goto skip since
+		 * a skip would have already been reported.
+		 */
+		if (__seccomp_filter(this_syscall, NULL, true))
+			return -1;
+
 		return 0;
 
 	case SECCOMP_RET_ALLOW:
@@ -674,7 +688,8 @@ skip:
 	return -1;
 }
 #else
-static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd)
+static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,
+			    const bool recheck_after_trace)
 {
 	BUG();
 }
@@ -691,7 +706,7 @@ int __secure_computing(const struct seccomp_data *sd)
 		__secure_computing_strict(this_syscall);  /* may call do_exit */
 		return 0;
 	case SECCOMP_MODE_FILTER:
-		return __seccomp_filter(this_syscall, sd);
+		return __seccomp_filter(this_syscall, sd, false);
 	default:
 		BUG();
 	}
