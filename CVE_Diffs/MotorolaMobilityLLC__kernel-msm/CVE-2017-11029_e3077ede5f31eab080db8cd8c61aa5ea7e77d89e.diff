MotorolaMobilityLLC__kernel-msm
commit e3077ede5f31eab080db8cd8c61aa5ea7e77d89e
Author:     Ravi kumar Koyyana <rkoyyana@codeaurora.org>
AuthorDate: Mon Mar 27 17:44:36 2017 -0700
Commit:     lulu2 <lulu2@lenovo.com>
CommitDate: Wed May 9 17:54:58 2018 +0800

    msm: camera2: cpp: Fix iommu_attach/detach compat_ioctl issue
    
    When the Camera application exercises the  V4L2  ioctl operations, CPP
    driver would attempt to the copy  user space buffer  contents into the
    internal kernel buffer.  If an invalid length of the user space buffer
    is passed onto the driver, it could trigger buffer overflow condition.
    
    Thus, fix this by copying user space buffer contents into kernel space
    buffer of the  driver for further processing, only after checking for
    proper length of user space buffer.
    
    CRs-fixed: 2025367
    CVE-fixed: CVE-2017-11029
    Mot-CRs-fixed: (CR)
    
    Change-Id: I85cf4a961884c7bb0d036299b886044aef7baf7c
    Signed-off-by: Ravi kumar Koyyana <rkoyyana@codeaurora.org>
    Signed-off-by: Srikanth A R <arsrikan@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1072132
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/media/platform/msm/camera_v2_2016/pproc/cpp/msm_cpp.c b/drivers/media/platform/msm/camera_v2_2016/pproc/cpp/msm_cpp.c
index d7b451009ad6..8a77b1c192a3 100644
--- a/drivers/media/platform/msm/camera_v2_2016/pproc/cpp/msm_cpp.c
+++ b/drivers/media/platform/msm/camera_v2_2016/pproc/cpp/msm_cpp.c
@@ -2675,13 +2675,15 @@ end:
 	return rc;
 }
 
-static int msm_cpp_validate_input(unsigned int cmd, void *arg,
+static int msm_cpp_validate_ioctl_input(unsigned int cmd, void *arg,
 	struct msm_camera_v4l2_ioctl_t **ioctl_ptr)
 {
 	switch (cmd) {
 	case MSM_SD_SHUTDOWN:
 	case MSM_SD_NOTIFY_FREEZE:
 	case MSM_SD_UNNOTIFY_FREEZE:
+	case VIDIOC_MSM_CPP_IOMMU_ATTACH:
+	case VIDIOC_MSM_CPP_IOMMU_DETACH:
 		break;
 	default: {
 		if (ioctl_ptr == NULL) {
@@ -2690,8 +2692,9 @@ static int msm_cpp_validate_input(unsigned int cmd, void *arg,
 		}
 
 		*ioctl_ptr = arg;
-		if ((*ioctl_ptr == NULL) ||
-			((*ioctl_ptr)->ioctl_ptr == NULL)) {
+		if (((*ioctl_ptr) == NULL) ||
+			((*ioctl_ptr)->ioctl_ptr == NULL) ||
+			((*ioctl_ptr)->len == 0)) {
 			pr_err("Wrong arg %pK\n", arg);
 			return -EINVAL;
 		}
@@ -2717,7 +2720,7 @@ long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
 		pr_err("cpp_dev is null\n");
 		return -EINVAL;
 	}
-	rc = msm_cpp_validate_input(cmd, arg, &ioctl_ptr);
+	rc = msm_cpp_validate_ioctl_input(cmd, arg, &ioctl_ptr);
 	if (rc != 0) {
 		pr_err("input validation failed\n");
 		return rc;
@@ -3207,7 +3210,7 @@ STREAM_BUFF_END:
 			(cpp_dev->stream_cnt == 0)) {
 			rc = cam_smmu_ops(cpp_dev->iommu_hdl, CAM_SMMU_DETACH);
 			if (rc < 0) {
-				pr_err("%s:%dError iommu atach failed\n",
+				pr_err("%s:%dError iommu detach failed\n",
 					__func__, __LINE__);
 				rc = -EINVAL;
 				break;
@@ -3216,6 +3219,7 @@ STREAM_BUFF_END:
 		} else {
 			pr_err("%s:%d IOMMMU attach triggered in invalid state\n",
 				__func__, __LINE__);
+			rc = -EINVAL;
 		}
 		break;
 	}
@@ -3842,7 +3846,8 @@ static long msm_cpp_subdev_fops_compat_ioctl(struct file *file,
 	default:
 		pr_err_ratelimited("%s: unsupported compat type :%x LOAD %lu\n",
 				__func__, cmd, VIDIOC_MSM_CPP_LOAD_FIRMWARE);
-		break;
+		mutex_unlock(&cpp_dev->mutex);
+		return -EINVAL;
 	}
 
 	mutex_unlock(&cpp_dev->mutex);
@@ -3873,7 +3878,7 @@ static long msm_cpp_subdev_fops_compat_ioctl(struct file *file,
 	default:
 		pr_err_ratelimited("%s: unsupported compat type :%d\n",
 				__func__, cmd);
-		break;
+		return -EINVAL;
 	}
 
 	up32_ioctl.id = kp_ioctl.id;
