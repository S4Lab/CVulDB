MotorolaMobilityLLC__kernel-msm
commit 765eaec61cf526fabdfe52cdea1ef6aa9415b993
Author:     Pachipulusu Bhanu Prakash <bhprakas@motorola.com>
AuthorDate: Thu Oct 17 12:30:14 2019 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Thu Nov 28 04:48:47 2019 -0600

    ext4: zero out the unused memory region in the extent tree block
    
    This commit zeroes out the unused memory region in the buffer_head
    corresponding to the extent metablock after writing the extent header
    and the corresponding extent node entries.
    
    This is done to prevent random uninitialized data from getting into
    the filesystem when the extent block is synced.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-11833
    BUG:133041647
    
    Signed-off-by: Sriram Rajagopalan <sriramr@arista.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    
    Change-Id: I1283272a4b40572ba78d1ac36560782181ee0829
    Signed-off-by: Pachipulusu Bhanu Prakash <bhprakas@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1438318
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit 7d30bc55c1eebad9ebd442811178120df8fa13d6)

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 5592b7726241..8f1d5e484ad6 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -1047,6 +1047,7 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 	__le32 border;
 	ext4_fsblk_t *ablocks = NULL; /* array of allocated blocks */
 	int err = 0;
+	size_t ext_size = 0;
 
 	/* make decision: where to split? */
 	/* FIXME: now decision is simplest: at current extent */
@@ -1137,7 +1138,10 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 		memmove(ex, path[depth].p_ext, sizeof(struct ext4_extent) * m);
 		le16_add_cpu(&neh->eh_entries, m);
 	}
-
+	/* zero out unused area in the extent block */
+	ext_size = sizeof(struct ext4_extent_header) +
+		sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);
+	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
 	ext4_extent_block_csum_set(inode, neh);
 	set_buffer_uptodate(bh);
 	unlock_buffer(bh);
@@ -1217,6 +1221,11 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 				sizeof(struct ext4_extent_idx) * m);
 			le16_add_cpu(&neh->eh_entries, m);
 		}
+		/* zero out unused area in the extent block */
+		ext_size = sizeof(struct ext4_extent_header) +
+		   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));
+		memset(bh->b_data + ext_size, 0,
+			inode->i_sb->s_blocksize - ext_size);
 		ext4_extent_block_csum_set(inode, neh);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
@@ -1282,7 +1291,7 @@ static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
 	ext4_fsblk_t newblock, goal = 0;
 	struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;
 	int err = 0;
-
+	size_t ext_size = 0;
 	/* Try to prepend new index to old one */
 	if (ext_depth(inode))
 		goal = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));
@@ -1308,9 +1317,10 @@ static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
 	}
 
 	/* move top-level index/leaf into new block */
-	memmove(bh->b_data, EXT4_I(inode)->i_data,
-		sizeof(EXT4_I(inode)->i_data));
-
+	ext_size = sizeof(EXT4_I(inode)->i_data);
+	memmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);
+	/* zero out unused area in the extent block */
+	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
 	/* set size of new block */
 	neh = ext_block_hdr(bh);
 	/* old root could have indexes or leaves
