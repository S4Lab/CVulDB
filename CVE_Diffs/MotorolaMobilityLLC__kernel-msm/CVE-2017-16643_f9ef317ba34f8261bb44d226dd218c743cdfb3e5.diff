MotorolaMobilityLLC__kernel-msm
commit f9ef317ba34f8261bb44d226dd218c743cdfb3e5
Author:     Dmitry Torokhov <dmitry.torokhov@gmail.com>
AuthorDate: Tue Oct 24 09:39:43 2017 -0700
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Tue May 29 07:03:07 2018 -0500

    Input: gtco - fix potential out-of-bound access
    
    parse_hid_report_descriptor() has a while (i < length) loop, which
    only guarantees that there's at least 1 byte in the buffer, but the
    loop body can read multiple bytes which causes out-of-bounds access.
    
    Mot-CRs-fixed: (CR)
    CVE-fixed: CVE-2017-16643
    Bug: 69916367
    
    Change-Id: I53fa91947daa68d9c5aae377356c9177b30f45e5
    Reported-by: Andrey Konovalov <andreyknvl@google.com>
    Reviewed-by: Andrey Konovalov <andreyknvl@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Reviewed-on: https://gerrit.mot.com/1165436
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key
    (cherry picked from commit 26563913d3a145d0b4216fa398c37043dc507ffa)

diff --git a/drivers/input/tablet/gtco.c b/drivers/input/tablet/gtco.c
index 858045694e9d..cc02bba5029d 100644
--- a/drivers/input/tablet/gtco.c
+++ b/drivers/input/tablet/gtco.c
@@ -231,13 +231,17 @@ static void parse_hid_report_descriptor(struct gtco *device, char * report,
 
 	/* Walk  this report and pull out the info we need */
 	while (i < length) {
-		prefix = report[i];
-
-		/* Skip over prefix */
-		i++;
+		prefix = report[i++];
 
 		/* Determine data size and save the data in the proper variable */
-		size = PREF_SIZE(prefix);
+		size = (1U << PREF_SIZE(prefix)) >> 1;
+		if (size && i + size >= length) {
+			dev_err(ddev,
+				"Not enough data (need %d, have %d)\n",
+				i + size, length);
+			break;
+		}
+
 		switch (size) {
 		case 1:
 			data = report[i];
@@ -245,8 +249,7 @@ static void parse_hid_report_descriptor(struct gtco *device, char * report,
 		case 2:
 			data16 = get_unaligned_le16(&report[i]);
 			break;
-		case 3:
-			size = 4;
+		case 4:
 			data32 = get_unaligned_le32(&report[i]);
 			break;
 		}
