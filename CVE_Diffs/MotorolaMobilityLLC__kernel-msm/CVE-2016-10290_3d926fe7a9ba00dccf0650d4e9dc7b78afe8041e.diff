MotorolaMobilityLLC__kernel-msm
commit 3d926fe7a9ba00dccf0650d4e9dc7b78afe8041e
Author:     Sahitya Tummala <stummala@codeaurora.org>
AuthorDate: Fri Feb 3 13:24:19 2017 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Wed May 31 08:43:07 2017 -0500

    uio: fix potential use after free issue when accessing debug_buffer
    
    The variable debug_buffer is a global variable which is allocated
    and free'd when open/close is called on debugfs file -
    "/sys/kernel/debug/rmt_storage/info". The current code doesn't
    have locks to handle concurrent accesses to the above file.
    This results into use after free issue when debug_buffer is
    accessed by two threads at the same time. Fix this by adding
    a mutex lock to protect this global variable.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2016-10290
    
    Change-Id: I6bc3f0ae2d7fca3ca9fe8561612f5863b6c3268a
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Varun Shrivastava <varunshrivastava@motorola.com>
    Reviewed-on: https://gerrit.mot.com/978125
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/drivers/uio/msm_sharedmem/sharedmem_qmi.c b/drivers/uio/msm_sharedmem/sharedmem_qmi.c
index 3b04c582cb3b..a5a0a6639f11 100644
--- a/drivers/uio/msm_sharedmem/sharedmem_qmi.c
+++ b/drivers/uio/msm_sharedmem/sharedmem_qmi.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2015, 2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -51,6 +51,7 @@ static struct dentry *dir_ent;
 
 static u32 rfsa_count;
 static u32 rmts_count;
+static struct mutex dbg_buf_lock;      /* mutex for debug_buffer */
 
 static DECLARE_RWSEM(sharedmem_list_lock); /* declare list lock semaphore */
 
@@ -276,21 +277,29 @@ static u32 fill_debug_info(char *buffer, u32 buffer_size)
 static int debug_open(struct inode *inode, struct file *file)
 {
 	u32 buffer_size;
-	if (debug_buffer != NULL)
+	mutex_lock(&dbg_buf_lock);
+	if (debug_buffer != NULL) {
+		mutex_unlock(&dbg_buf_lock);
 		return -EBUSY;
+	}
 	buffer_size = DEBUG_BUF_SIZE;
 	debug_buffer = kzalloc(buffer_size, GFP_KERNEL);
-	if (debug_buffer == NULL)
+	if (debug_buffer == NULL) {
+		mutex_unlock(&dbg_buf_lock);
 		return -ENOMEM;
+	}
 	debug_data_size = fill_debug_info(debug_buffer, buffer_size);
+	mutex_unlock(&dbg_buf_lock);
 	return 0;
 }
 
 static int debug_close(struct inode *inode, struct file *file)
 {
+	mutex_lock(&dbg_buf_lock);
 	kfree(debug_buffer);
 	debug_buffer = NULL;
 	debug_data_size = 0;
+	mutex_unlock(&dbg_buf_lock);
 	return 0;
 }
 
@@ -321,6 +330,7 @@ static void debugfs_init(void)
 {
 	struct dentry *f_ent;
 
+	mutex_init(&dbg_buf_lock);
 	dir_ent = debugfs_create_dir("rmt_storage", NULL);
 	if (IS_ERR(dir_ent)) {
 		pr_err("Failed to create debug_fs directory\n");
@@ -349,6 +359,7 @@ static void debugfs_init(void)
 static void debugfs_exit(void)
 {
 	debugfs_remove_recursive(dir_ent);
+	mutex_destroy(&dbg_buf_lock);
 }
 
 static void sharedmem_qmi_svc_recv_msg(struct work_struct *work)
