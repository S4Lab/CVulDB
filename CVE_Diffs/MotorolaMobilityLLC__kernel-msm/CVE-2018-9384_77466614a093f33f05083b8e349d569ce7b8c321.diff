MotorolaMobilityLLC__kernel-msm
commit 77466614a093f33f05083b8e349d569ce7b8c321
Author:     Oleg Nesterov <oleg@redhat.com>
AuthorDate: Thu Sep 15 22:45:44 2016 -0700
Commit:     a7301c <a7301c@motorola.com>
CommitDate: Fri Sep 21 11:37:48 2018 -0500

    UPSTREAM: kthread: Pin the stack via try_get_task_stack()/put_task_stack() in to_live_kthread() function
    
    get_task_struct(tsk) no longer pins tsk->stack so all users of
    to_live_kthread() should do try_get_task_stack/put_task_stack to protect
    "struct kthread" which lives on kthread's stack.
    
    TODO: Kill to_live_kthread(), perhaps we can even kill "struct kthread" too,
    and rework kthread_stop(), it can use task_work_add() to sync with the exiting
    kernel thread.
    
    CVE-fixed: CVE-2018-9384
    Bug: 74356909
    
    Message-Id: <20160629180357.GA7178@redhat.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Perry Lutomirski <luto@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jann Horn <jann@thejh.net>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/cb9b16bbc19d4aea4507ab0552e4644c1211d130.1474003868.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    
    Bug: 66351489
    Change-Id: Icf8e69f1a9b3c5658da8b6159a44eeb7e16356ba
    (cherry picked from commit 23196f2e5f5d810578a772785807dcdc2b9fdce9)
    Signed-off-by: Zubin Mithra <zsm@google.com>
    Reviewed-on: https://gerrit.mot.com/1232697
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/kernel/kthread.c b/kernel/kthread.c
index 7989b21f901c..abbe034b0150 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -64,7 +64,7 @@ static inline struct kthread *to_kthread(struct task_struct *k)
 static struct kthread *to_live_kthread(struct task_struct *k)
 {
 	struct completion *vfork = ACCESS_ONCE(k->vfork_done);
-	if (likely(vfork))
+	if (likely(vfork) && try_get_task_stack(k))
 		return __to_kthread(vfork);
 	return NULL;
 }
@@ -423,8 +423,10 @@ void kthread_unpark(struct task_struct *k)
 {
 	struct kthread *kthread = to_live_kthread(k);
 
-	if (kthread)
+	if (kthread) {
 		__kthread_unpark(k, kthread);
+		put_task_stack(k);
+	}
 }
 
 /**
@@ -452,6 +454,7 @@ int kthread_park(struct task_struct *k)
 				wait_for_completion(&kthread->parked);
 			}
 		}
+		put_task_stack(k);
 		ret = 0;
 	}
 	return ret;
@@ -486,6 +489,7 @@ int kthread_stop(struct task_struct *k)
 		__kthread_unpark(k, kthread);
 		wake_up_process(k);
 		wait_for_completion(&kthread->exited);
+		put_task_stack(k);
 	}
 	ret = k->exit_code;
 	put_task_struct(k);
