MotorolaMobilityLLC__kernel-msm
commit 76878f53dde4defdc13672829ed8028d0f2531f8
Author:     Greg Kroah-Hartman <gregkh@linuxfoundation.org>
AuthorDate: Tue Jan 29 10:15:02 2019 +0530
Commit:     a7301c <a7301c@motorola.com>
CommitDate: Wed Mar 13 21:28:40 2019 -0500

    Make file credentials available to the seqfile interfaces
    
    A lot of seqfile users seem to be using things like %pK that uses the
    credentials of the current process, but that is actually completely
    wrong for filesystem interfaces.
    
    The unix semantics for permission checking files is to check permissions
    at _open_ time, not at read or write time, and that is not just a small
    detail: passing off stdin/stdout/stderr to a suid application and making
    the actual IO happen in privileged context is a classic exploit
    technique.
    
    So if we want to be able to look at permissions at read time, we need to
    use the file open credentials, not the current ones.  Normal file
    accesses can just use "f_cred" (or any of the helper functions that do
    that, like file_ns_capable()), but the seqfile interfaces do not have
    any such options.
    
    It turns out that seq_file _does_ save away the user_ns information of
    the file, though.  Since user_ns is just part of the full credential
    information, replace that special case with saving off the cred pointer
    instead, and suddenly seq_file has all the permission information it
    needs.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-2001
    BUG: 117422211
    
    Change-Id: I25f4b6b0112ee14aa5c399c46a3527a5de6bd0dc
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Jann Horn <jannh@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-on: https://gerrit.mot.com/1302494
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/fs/seq_file.c b/fs/seq_file.c
index fbcadd731e45..a113bf851c84 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -71,9 +71,10 @@ int seq_open(struct file *file, const struct seq_operations *op)
 	memset(p, 0, sizeof(*p));
 	mutex_init(&p->lock);
 	p->op = op;
-#ifdef CONFIG_USER_NS
-	p->user_ns = file->f_cred->user_ns;
-#endif
+
+	/* No refcounting: the lifetime of 'p' is constrained
+	to the lifetime of the file.*/
+	p->file = file;
 
 	/*
 	 * Wrappers around seq_open(e.g. swaps_open) need to be
diff --git a/include/linux/seq_file.h b/include/linux/seq_file.h
index 611db59c52c5..c7a4cd5fda08 100644
--- a/include/linux/seq_file.h
+++ b/include/linux/seq_file.h
@@ -7,13 +7,10 @@
 #include <linux/mutex.h>
 #include <linux/cpumask.h>
 #include <linux/nodemask.h>
+#include <linux/fs.h>
+#include <linux/cred.h>
 
 struct seq_operations;
-struct file;
-struct path;
-struct inode;
-struct dentry;
-struct user_namespace;
 
 struct seq_file {
 	char *buf;
@@ -27,9 +24,7 @@ struct seq_file {
 	struct mutex lock;
 	const struct seq_operations *op;
 	int poll_event;
-#ifdef CONFIG_USER_NS
-	struct user_namespace *user_ns;
-#endif
+	const struct file *file;
 	void *private;
 };
 
@@ -151,7 +146,7 @@ int seq_put_decimal_ll(struct seq_file *m, char delimiter,
 static inline struct user_namespace *seq_user_ns(struct seq_file *seq)
 {
 #ifdef CONFIG_USER_NS
-	return seq->user_ns;
+	return seq->file->f_cred->user_ns;
 #else
 	extern struct user_namespace init_user_ns;
 	return &init_user_ns;
