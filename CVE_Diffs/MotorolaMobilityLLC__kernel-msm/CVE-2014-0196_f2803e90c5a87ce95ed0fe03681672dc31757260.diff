MotorolaMobilityLLC__kernel-msm
commit f2803e90c5a87ce95ed0fe03681672dc31757260
Author:     Peter Hurley <peter@hurleysoftware.com>
AuthorDate: Sat May 3 14:04:59 2014 +0200
Commit:     Anandappan Chakravarthy <pjwt34@motorola.com>
CommitDate: Tue Jun 10 00:17:38 2014 -0500

    n_tty: Fix n_tty_write crash when echoing in raw mode
    
    The tty atomic_write_lock does not provide an exclusion guarantee for
    the tty driver if the termios settings are LECHO & !OPOST.  And since
    it is unexpected and not allowed to call TTY buffer helpers like
    tty_insert_flip_string concurrently, this may lead to crashes when
    concurrect writers call pty_write. In that case the following two
    writers:
    * the ECHOing from a workqueue and
    * pty_write from the process
    race and can overflow the corresponding TTY buffer like follows.
    
    If we look into tty_insert_flip_string_fixed_flag, there is:
      int space = __tty_buffer_request_room(port, goal, flags);
      struct tty_buffer *tb = port->buf.tail;
      ...
      memcpy(char_buf_ptr(tb, tb->used), chars, space);
      ...
      tb->used += space;
    
    so the race of the two can result in something like this:
                  A                                B
    __tty_buffer_request_room
                                      __tty_buffer_request_room
    memcpy(buf(tb->used), ...)
    tb->used += space;
                                      memcpy(buf(tb->used), ...) ->BOOM
    
    B's memcpy is past the tty_buffer due to the previous A's tb->used
    increment.
    
    Since the N_TTY line discipline input processing can output
    concurrently with a tty write, obtain the N_TTY ldisc output_lock to
    serialize echo output with normal tty writes.  This ensures the tty
    buffer helper tty_insert_flip_string is not called concurrently and
    everything is fine.
    
    Note that this is nicely reproducible by an ordinary user using
    forkpty and some setup around that (raw termios + ECHO). And it is
    present in kernels at least after commit
    d945cb9cce20ac7143c2de8d88b187f62db99bdc (pty: Rework the pty layer to
    use the normal buffering logic) in 2.6.31-rc3.
    
    js: add more info to the commit log
    js: switch to bool
    js: lock unconditionally
    js: lock only the tty->ops->write call
    
    Change-Id: I4e8f56ba9aab025b259c34d5128b3d83ffb1fc54
    References: CVE-2014-0196
    Reported-and-tested-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andy Seah <dntc46@motorola.com>
    Reviewed-on: http://gerrit.mot.com/641231
    Submit-Approved: Jira Key <jirakey@motorola.com>
    Tested-by: Jira Key <jirakey@motorola.com>
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    Reviewed-by: Joel Voss <jvoss@motorola.com>
    Reviewed-by: Christopher Fries <cfries@motorola.com>
    SLTApproved: Christopher Fries <cfries@motorola.com>
    (cherry picked from commit fcf4c97b502c4bcb62a5a4f4c006bf69ab60629a)
    
    Conflicts:
            drivers/tty/n_tty.c
    Change-Id: I73721e74193b18e14c58a575179aff73289ecabb
    Reviewed-on: http://gerrit.mot.com/642323
    Submit-Approved: Jira Key <jirakey@motorola.com>
    Tested-by: Jira Key <jirakey@motorola.com>
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    Reviewed-by: Anandappan Chakravarthy <pjwt34@motorola.com>

diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index 3fcbff65060e..2bc094492c96 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -1994,8 +1994,12 @@ static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
 			if (tty->ops->flush_chars)
 				tty->ops->flush_chars(tty);
 		} else {
+			struct n_tty_data *ldata = tty->disc_data;
+
 			while (nr > 0) {
+				mutex_lock(&tty->output_lock);
 				c = tty->ops->write(tty, b, nr);
+				mutex_unlock(&tty->output_lock);
 				if (c < 0) {
 					retval = c;
 					goto break_out;
