MotorolaMobilityLLC__kernel-msm
commit 134f245456d0bd2dc62e9accf92cd11f0ae42c82
Author:     Florian Westphal <fw@strlen.de>
AuthorDate: Mon Feb 19 01:24:15 2018 +0100
Commit:     chenyt9 <chenyt9@lenovo.com>
CommitDate: Tue Dec 10 15:03:48 2019 +0800

    netfilter: ebtables: CONFIG_COMPAT: don't trust userland offsets
    
    We need to make sure the offsets are not out of range of the
    total size.
    Also check that they are in ascending order.
    
    The WARN_ON triggered by syzkaller (it sets panic_on_warn) is
    changed to also bail out, no point in continuing parsing.
    
    Briefly tested with simple ruleset of
    -A INPUT --limit 1/s' --log
    plus jump to custom chains using 32bit ebtables binary.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2018-1068
    Bug fixed: 77902350
    
    Change-Id: I536dc48e60731693d0381505ede5144769749220
    Reported-by: <syzbot+845a53d13171abf8bf29@syzkaller.appspotmail.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1208135
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Ling Jin <lingjin@motorola.com>
    Submit-Approved: Jira Key

diff --git a/net/bridge/netfilter/ebtables.c b/net/bridge/netfilter/ebtables.c
index d9a8c05d995d..90f9e13944bd 100644
--- a/net/bridge/netfilter/ebtables.c
+++ b/net/bridge/netfilter/ebtables.c
@@ -2019,7 +2019,9 @@ static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,
 		if (match_kern)
 			match_kern->match_size = ret;
 
-		WARN_ON(type == EBT_COMPAT_TARGET && size_left);
+		if (WARN_ON(type == EBT_COMPAT_TARGET && size_left))
+			return -EINVAL;
+
 		match32 = (struct compat_ebt_entry_mwt *) buf;
 	}
 
@@ -2076,6 +2078,15 @@ static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,
 	 *
 	 * offsets are relative to beginning of struct ebt_entry (i.e., 0).
 	 */
+	for (i = 0; i < 4 ; ++i) {
+		if (offsets[i] >= *total)
+			return -EINVAL;
+		if (i == 0)
+			continue;
+		if (offsets[i - 1] > offsets[i])
+			return -EINVAL;
+	}
+
 	for (i = 0, j = 1 ; j < 4 ; j++, i++) {
 		struct compat_ebt_entry_mwt *match32;
 		unsigned int size;
