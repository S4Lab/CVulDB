MotorolaMobilityLLC__kernel-msm
commit 45fb1f6f51f7822f91feac8404e93bfe3d7bf009
Author:     Sunil Khatri <sunilkh@codeaurora.org>
AuthorDate: Tue May 2 19:21:34 2017 +0530
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Wed Aug 9 03:25:01 2017 -0500

    msm: kgsl: Fix kgsl memory allocation and free race condition
    
    When allocating userspace memory keep reference to memory
    allocation till it is completely initialized and info is send back
    to userspace
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2017-8262
    Change-Id: Id72c82bf98c094ecbd4722813c732a998dcbb188
    Signed-off-by: Tarun Karra <tkarra@codeaurora.org>
    Signed-off-by: Sunil Khatri <sunilkh@codeaurora.org>
    Signed-off-by: Ashwin Pathmudi <jfxr63@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1012869
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Reviewed-by: Bang Nguyen <bangnguyen@motorola.com>
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index ebe096a33647..37646c4594f7 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2008-2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -230,8 +230,11 @@ kgsl_mem_entry_create(void)
 {
 	struct kgsl_mem_entry *entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 
-	if (entry)
+	if (entry) {
 		kref_init(&entry->refcount);
+		/* put this ref in the caller functions after init */
+		kref_get(&entry->refcount);
+	}
 
 	return entry;
 }
@@ -2421,6 +2424,9 @@ long kgsl_ioctl_gpuobj_import(struct kgsl_device_private *dev_priv,
 	trace_kgsl_mem_map(entry, fd);
 
 	kgsl_mem_entry_commit_process(private, entry);
+
+	/* put the extra refcount for kgsl_mem_entry_create() */
+	kgsl_mem_entry_put(entry);
 	return 0;
 
 unmap:
@@ -2693,6 +2699,9 @@ long kgsl_ioctl_map_user_mem(struct kgsl_device_private *dev_priv,
 	trace_kgsl_mem_map(entry, param->fd);
 
 	kgsl_mem_entry_commit_process(private, entry);
+
+	/* put the extra refcount for kgsl_mem_entry_create() */
+	kgsl_mem_entry_put(entry);
 	return result;
 
 error_attach:
@@ -3133,6 +3142,8 @@ long kgsl_ioctl_gpuobj_alloc(struct kgsl_device_private *dev_priv,
 	param->mmapsize = kgsl_memdesc_mmapsize(&entry->memdesc);
 	param->id = entry->id;
 
+	/* put the extra refcount for kgsl_mem_entry_create() */
+	kgsl_mem_entry_put(entry);
 	return 0;
 }
 
@@ -3156,6 +3167,8 @@ long kgsl_ioctl_gpumem_alloc(struct kgsl_device_private *dev_priv,
 	param->size = (size_t) entry->memdesc.size;
 	param->flags = (unsigned int) entry->memdesc.flags;
 
+	/* put the extra refcount for kgsl_mem_entry_create() */
+	kgsl_mem_entry_put(entry);
 	return 0;
 }
 
@@ -3179,6 +3192,8 @@ long kgsl_ioctl_gpumem_alloc_id(struct kgsl_device_private *dev_priv,
 		kgsl_memdesc_mmapsize(&entry->memdesc);
 	param->gpuaddr = (unsigned long) entry->memdesc.gpuaddr;
 
+	/* put the extra refcount for kgsl_mem_entry_create() */
+	kgsl_mem_entry_put(entry);
 	return 0;
 }
 
