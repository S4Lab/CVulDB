MotorolaMobilityLLC__kernel-msm
commit 869db36f036d3dcf94e095318feb597a7b75162a
Author:     Ben Romberger <bromberg@codeaurora.org>
AuthorDate: Wed Feb 8 10:15:23 2017 -0200
Commit:     Marina Silva <mgsilva@motorola.com>
CommitDate: Mon Feb 13 16:34:22 2017 +0000

    ASoC: msm: qdsp6v2: Change audio drivers to use %pK
    
    Change all qdsp6v2 audio driver to use %pK instead
    of %p. %pK hides addresses when the users doesn't
    have kernel permissions. If address information
    is needed echo 0 > /proc/sys/kernel/kptr_restrict.
    
    Change-Id: Ie81b3ce77856e0533a2d86fed22b7a4d4c5ba770
    Mot-CRs-fixed:(CR)
    CVE-Fixed:CVE-2016-8410

diff --git a/drivers/soc/qcom/qdsp6v2/apr.c b/drivers/soc/qcom/qdsp6v2/apr.c
index 51fa2c801854..3d263b05b610 100644
--- a/drivers/soc/qcom/qdsp6v2/apr.c
+++ b/drivers/soc/qcom/qdsp6v2/apr.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -445,7 +445,7 @@ void apr_cb_func(void *buf, int len, void *priv)
 	pr_debug("\n*****************\n");
 
 	if (!buf || len <= APR_HDR_SIZE) {
-		pr_err("APR: Improper apr pkt received:%p %d\n", buf, len);
+		pr_err("APR: Improper apr pkt received:%pK %d\n", buf, len);
 		return;
 	}
 	hdr = buf;
@@ -531,7 +531,7 @@ void apr_cb_func(void *buf, int len, void *priv)
 		return;
 	}
 	pr_debug("svc_idx = %d\n", i);
-	pr_debug("%x %x %x %p %p\n", c_svc->id, c_svc->dest_id,
+	pr_debug("%x %x %x %pK %pK\n", c_svc->id, c_svc->dest_id,
 		 c_svc->client_id, c_svc->fn, c_svc->priv);
 	data.payload_size = hdr->pkt_size - hdr_size;
 	data.opcode = hdr->opcode;
@@ -595,7 +595,7 @@ static void apr_reset_deregister(struct work_struct *work)
 			container_of(work, struct apr_reset_work, work);
 
 	handle = apr_reset->handle;
-	pr_debug("%s:handle[%p]\n", __func__, handle);
+	pr_debug("%s:handle[%pK]\n", __func__, handle);
 	apr_deregister(handle);
 	kfree(apr_reset);
 }
@@ -628,7 +628,7 @@ int apr_deregister(void *handle)
 		client[dest_id][client_id].svc_cnt--;
 		if (!client[dest_id][client_id].svc_cnt) {
 			svc->need_reset = 0x0;
-			pr_debug("%s: service is reset %p\n", __func__, svc);
+			pr_debug("%s: service is reset %pK\n", __func__, svc);
 		}
 	}
 
@@ -656,7 +656,7 @@ void apr_reset(void *handle)
 
 	if (!handle)
 		return;
-	pr_debug("%s: handle[%p]\n", __func__, handle);
+	pr_debug("%s: handle[%pK]\n", __func__, handle);
 
 	if (apr_reset_workqueue == NULL) {
 		pr_err("%s: apr_reset_workqueue is NULL\n", __func__);
diff --git a/drivers/soc/qcom/qdsp6v2/msm_audio_ion.c b/drivers/soc/qcom/qdsp6v2/msm_audio_ion.c
index ab6dc9762f83..dd110bbc5ee8 100644
--- a/drivers/soc/qcom/qdsp6v2/msm_audio_ion.c
+++ b/drivers/soc/qcom/qdsp6v2/msm_audio_ion.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -95,11 +95,11 @@ int msm_audio_ion_alloc(const char *name, struct ion_client **client,
 		pr_err("%s: ION memory mapping for AUDIO failed\n", __func__);
 		goto err_ion_handle;
 	}
-	pr_debug("%s: mapped address = %p, size=%zd\n", __func__,
-		*vaddr, bufsz);
+	pr_debug("%s: mapped address = %pK, size=%zd\n", __func__,
+		 *vaddr, bufsz);
 
 	if (bufsz != 0) {
-		pr_debug("%s: memset to 0 %p %zd\n", __func__, *vaddr, bufsz);
+		pr_debug("%s: memset to 0 %pK %zd\n", __func__, *vaddr, bufsz);
 		memset((void *)*vaddr, 0, bufsz);
 	}
 
@@ -144,8 +144,8 @@ int msm_audio_ion_import(const char *name, struct ion_client **client,
 	bufsz should be 0 and fd shouldn't be 0 as of now
 	*/
 	*handle = ion_import_dma_buf(*client, fd);
-	pr_debug("%s: DMA Buf name=%s, fd=%d handle=%p\n", __func__,
-							name, fd, *handle);
+	pr_debug("%s: DMA Buf name=%s, fd=%d handle=%pK\n", __func__,
+		 name, fd, *handle);
 	if (IS_ERR_OR_NULL((void *) (*handle))) {
 		pr_err("%s: ion import dma buffer failed\n",
 				__func__);
@@ -198,8 +198,8 @@ int msm_audio_ion_free(struct ion_client *client, struct ion_handle *handle)
 	}
 	if (msm_audio_ion_data.smmu_enabled) {
 		/* Need to populate book kept infomation */
-		pr_debug("client=%p, domain=%p, domain_id=%d, group=%p",
-			client, msm_audio_ion_data.domain,
+		pr_debug("client=%pK, domain=%pK, domain_id=%d, group=%pK",
+			 client, msm_audio_ion_data.domain,
 			msm_audio_ion_data.domain_id, msm_audio_ion_data.group);
 
 		ion_unmap_iommu(client, handle,
@@ -263,11 +263,11 @@ int msm_audio_ion_mmap(struct audio_buffer *ab,
 				offset = 0;
 			}
 			len = min(len, remainder);
-			pr_debug("vma=%p, addr=%x len=%ld vm_start=%x vm_end=%x vm_page_prot=%ld\n",
-				vma, (unsigned int)addr, len,
-				(unsigned int)vma->vm_start,
-				(unsigned int)vma->vm_end,
-				(unsigned long int)vma->vm_page_prot);
+			pr_debug("vma=%pK, addr=%x len=%ld vm_start=%x vm_end=%x vm_page_prot=%ld\n",
+				 vma, (unsigned int)addr, len,
+				 (unsigned int)vma->vm_start,
+				 (unsigned int)vma->vm_end,
+				 (unsigned long int)vma->vm_page_prot);
 			remap_pfn_range(vma, addr, page_to_pfn(page), len,
 					vma->vm_page_prot);
 			addr += len;
@@ -286,11 +286,11 @@ int msm_audio_ion_mmap(struct audio_buffer *ab,
 				, __func__ , ret);
 			return ret;
 		}
-		pr_debug("phys=%pa len=%zd\n", &phys_addr, phys_len);
-		pr_debug("vma=%p, vm_start=%x vm_end=%x vm_pgoff=%ld vm_page_prot=%ld\n",
-			vma, (unsigned int)vma->vm_start,
-			(unsigned int)vma->vm_end, vma->vm_pgoff,
-			(unsigned long int)vma->vm_page_prot);
+		pr_debug("phys=%pK len=%zd\n", &phys_addr, phys_len);
+		pr_debug("vma=%pK, vm_start=%x vm_end=%x vm_pgoff=%ld vm_page_prot=%ld\n",
+			 vma, (unsigned int)vma->vm_start,
+			 (unsigned int)vma->vm_end, vma->vm_pgoff,
+			 (unsigned long int)vma->vm_page_prot);
 		va_len = vma->vm_end - vma->vm_start;
 		if ((offset > phys_len) || (va_len > phys_len-offset)) {
 			pr_err("wrong offset size %ld, lens= %zd, va_len=%zd\n",
@@ -323,8 +323,8 @@ struct ion_client *msm_audio_ion_client_create(const char *name)
 
 void msm_audio_ion_client_destroy(struct ion_client *client)
 {
-	pr_debug("%s: client = %p smmu_enabled = %d\n", __func__,
-		client, msm_audio_ion_data.smmu_enabled);
+	pr_debug("%s: client = %pK smmu_enabled = %d\n", __func__,
+		 client, msm_audio_ion_data.smmu_enabled);
 
 	ion_client_destroy(client);
 }
@@ -345,8 +345,8 @@ int msm_audio_ion_import_legacy(const char *name, struct ion_client *client,
 	bufsz should be 0 and fd shouldn't be 0 as of now
 	*/
 	*handle = ion_import_dma_buf(client, fd);
-	pr_debug("%s: DMA Buf name=%s, fd=%d handle=%p\n", __func__,
-							name, fd, *handle);
+	pr_debug("%s: DMA Buf name=%s, fd=%d handle=%pK\n", __func__,
+		 name, fd, *handle);
 	if (IS_ERR_OR_NULL((void *)(*handle))) {
 		pr_err("%s: ion import dma buffer failed\n",
 			__func__);
@@ -411,7 +411,7 @@ int msm_audio_ion_cache_operations(struct audio_buffer *abuff, int cache_op)
 	int msm_cache_ops = 0;
 
 	if (!abuff) {
-		pr_err("Invalid params: %p, %p\n", __func__, abuff);
+		pr_err("Invalid params: %pK, %pK\n", __func__, abuff);
 		return -EINVAL;
 	}
 	rc = ion_handle_get_flags(abuff->client, abuff->handle,
@@ -457,14 +457,15 @@ static int msm_audio_ion_get_phys(struct ion_client *client,
 			pr_err("%s: ION map iommu failed %d\n", __func__, rc);
 			return rc;
 		}
-		pr_debug("client=%p, domain=%p, domain_id=%d, group=%p",
-			client, msm_audio_ion_data.domain,
-			msm_audio_ion_data.domain_id, msm_audio_ion_data.group);
+		pr_debug("client=%pK, domain=%pK, domain_id=%d, group=%pK",
+			 client, msm_audio_ion_data.domain,
+			 msm_audio_ion_data.domain_id,
+			 msm_audio_ion_data.group);
 	} else {
 		/* SMMU is disabled*/
 		rc = ion_phys(client, handle, addr, len);
 	}
-	pr_debug("phys=%pa, len=%zd, rc=%d\n", &(*addr), *len, rc);
+	pr_debug("phys=%pK, len=%zd, rc=%d\n", &(*addr), *len, rc);
 	return rc;
 }
 
@@ -502,19 +503,19 @@ static int msm_audio_ion_probe(struct platform_device *pdev)
 		msm_audio_ion_data.domain =
 			iommu_group_get_iommudata(msm_audio_ion_data.group);
 		if (IS_ERR_OR_NULL(msm_audio_ion_data.domain)) {
-			pr_err("Failed to get domain data for group %p",
-					msm_audio_ion_data.group);
+			pr_err("Failed to get domain data for group %pK",
+			       msm_audio_ion_data.group);
 			goto fail_group;
 		}
 		msm_audio_ion_data.domain_id =
 				msm_find_domain_no(msm_audio_ion_data.domain);
 		if (msm_audio_ion_data.domain_id < 0) {
-			pr_err("Failed to get domain index for domain %p",
-					msm_audio_ion_data.domain);
+			pr_err("Failed to get domain index for domain %pK",
+			       msm_audio_ion_data.domain);
 			goto fail_group;
 		}
-		pr_debug("domain=%p, domain_id=%d, group=%p",
-			msm_audio_ion_data.domain,
+		pr_debug("domain=%pK, domain_id=%d, group=%pK",
+			 msm_audio_ion_data.domain,
 			msm_audio_ion_data.domain_id, msm_audio_ion_data.group);
 
 		/* iommu_attach_group() will make AXI clock ON. For future PL
@@ -537,8 +538,8 @@ fail_group:
 
 static int msm_audio_ion_remove(struct platform_device *pdev)
 {
-	pr_debug("%s: msm audio ion is unloaded, domain=%p, group=%p\n",
-		__func__, msm_audio_ion_data.domain, msm_audio_ion_data.group);
+	pr_debug("%s: msm audio ion is unloaded, domain=%pK, group=%pK\n",
+		 __func__, msm_audio_ion_data.domain, msm_audio_ion_data.group);
 	iommu_detach_group(msm_audio_ion_data.domain, msm_audio_ion_data.group);
 
 	return 0;
diff --git a/sound/soc/msm/qdsp6v2/audio_cal_utils.c b/sound/soc/msm/qdsp6v2/audio_cal_utils.c
index 4a56ce6d1f4f..82d755199e9f 100644
--- a/sound/soc/msm/qdsp6v2/audio_cal_utils.c
+++ b/sound/soc/msm/qdsp6v2/audio_cal_utils.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -574,12 +574,12 @@ static struct cal_block_data *create_cal_block(struct cal_type_data *cal_type,
 		goto err;
 	}
 	cal_block->buffer_number = basic_cal->cal_hdr.buffer_number;
-	pr_debug("%s: created block for cal type %d, buf num %d, map handle %d, map size %zd paddr 0x%pa!\n",
-		__func__, cal_type->info.reg.cal_type,
-		cal_block->buffer_number,
-		cal_block->map_data.ion_map_handle,
-		cal_block->map_data.map_size,
-		&cal_block->cal_data.paddr);
+	pr_debug("%s: created block for cal type %d, buf num %d, map handle %d, map size %zd paddr 0x%pK!\n",
+		 __func__, cal_type->info.reg.cal_type,
+		 cal_block->buffer_number,
+		 cal_block->map_data.ion_map_handle,
+		 cal_block->map_data.map_size,
+		 &cal_block->cal_data.paddr);
 done:
 	return cal_block;
 err:
diff --git a/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
index e9aba43a632e..389c78b07d56 100644
--- a/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-compr-q6-v2.c
@@ -192,8 +192,8 @@ static void compr_event_handler(uint32_t opcode,
 		pr_debug("%s:writing %d bytes of buffer[%d] to dsp 2\n",
 				__func__, prtd->pcm_count, prtd->out_head);
 		temp = buf[0].phys + (prtd->out_head * prtd->pcm_count);
-		pr_debug("%s:writing buffer[%d] from 0x%pa\n",
-			__func__, prtd->out_head, &temp);
+		pr_debug("%s:writing buffer[%d] from 0x%pK\n",
+			 __func__, prtd->out_head, &temp);
 
 		if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
 			time_stamp_flag = SET_TIMESTAMP;
@@ -243,7 +243,7 @@ static void compr_event_handler(uint32_t opcode,
 		break;
 	case ASM_DATA_EVENT_READ_DONE_V2: {
 		pr_debug("ASM_DATA_EVENT_READ_DONE\n");
-		pr_debug("buf = %p, data = 0x%X, *data = %p,\n"
+		pr_debug("buf = %pK, data = 0x%X, *data = %pK,\n"
 			 "prtd->pcm_irq_pos = %d\n",
 				prtd->audio_client->port[OUT].buf,
 			 *(uint32_t *)prtd->audio_client->port[OUT].buf->data,
@@ -253,11 +253,11 @@ static void compr_event_handler(uint32_t opcode,
 		memcpy(prtd->audio_client->port[OUT].buf->data +
 			   prtd->pcm_irq_pos, (ptrmem + READDONE_IDX_SIZE),
 			   COMPRE_CAPTURE_HEADER_SIZE);
-		pr_debug("buf = %p, updated data = 0x%X, *data = %p\n",
-				prtd->audio_client->port[OUT].buf,
-			*(uint32_t *)(prtd->audio_client->port[OUT].buf->data +
-				prtd->pcm_irq_pos),
-				prtd->audio_client->port[OUT].buf->data);
+		pr_debug("buf = %pK, updated data = 0x%X, *data = %pK\n",
+			 prtd->audio_client->port[OUT].buf,
+			 *(uint32_t *)(prtd->audio_client->port[OUT].buf->data +
+			 prtd->pcm_irq_pos),
+			 prtd->audio_client->port[OUT].buf->data);
 		if (!atomic_read(&prtd->start))
 			break;
 		pr_debug("frame size=%d, buffer = 0x%X\n",
@@ -269,8 +269,8 @@ static void compr_event_handler(uint32_t opcode,
 		}
 		buf = prtd->audio_client->port[OUT].buf;
 
-		pr_debug("pcm_irq_pos=%d, buf[0].phys = 0x%pa\n",
-				prtd->pcm_irq_pos, &buf[0].phys);
+		pr_debug("pcm_irq_pos=%d, buf[0].phys = 0x%pK\n",
+			 prtd->pcm_irq_pos, &buf[0].phys);
 		read_param.len = prtd->pcm_count - COMPRE_CAPTURE_HEADER_SIZE;
 		read_param.paddr = buf[0].phys +
 			prtd->pcm_irq_pos + COMPRE_CAPTURE_HEADER_SIZE;
@@ -295,9 +295,9 @@ static void compr_event_handler(uint32_t opcode,
 			pr_debug("%s: writing %d bytes of buffer[%d] to dsp\n",
 				__func__, prtd->pcm_count, prtd->out_head);
 			buf = prtd->audio_client->port[IN].buf;
-			pr_debug("%s: writing buffer[%d] from 0x%pa head %d count %d\n",
-				__func__, prtd->out_head, &buf[0].phys,
-				prtd->pcm_count, prtd->out_head);
+			pr_debug("%s: writing buffer[%d] from 0x%pK head %d count %d\n",
+				 __func__, prtd->out_head, &buf[0].phys,
+				 prtd->pcm_count, prtd->out_head);
 			if (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)
 				time_stamp_flag = SET_TIMESTAMP;
 			else
@@ -603,7 +603,7 @@ static int msm_compr_capture_prepare(struct snd_pcm_substream *substream)
 			read_param.paddr = buf[i].phys
 					+ COMPRE_CAPTURE_HEADER_SIZE;
 			pr_debug("Push buffer [%d] to DSP, "\
-					"paddr: %pa, vaddr: %p\n",
+					"paddr: %pK, vaddr: %pK\n",
 					i, &read_param.paddr,
 					buf[i].data);
 			q6asm_async_read(prtd->audio_client, &read_param);
@@ -964,7 +964,7 @@ static int msm_compr_hw_params(struct snd_pcm_substream *substream,
 	dma_buf->addr =  buf[0].phys;
 	dma_buf->bytes = runtime->hw.buffer_bytes_max;
 
-	pr_debug("%s: buf[%p]dma_buf->area[%p]dma_buf->addr[%pa]\n"
+	pr_debug("%s: buf[%pK]dma_buf->area[%pK]dma_buf->addr[%pK]\n"
 		 "dma_buf->bytes[%zd]\n", __func__,
 		 (void *)buf, (void *)dma_buf->area,
 		 &dma_buf->addr, dma_buf->bytes);
diff --git a/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
index d549c49465b9..456f3361d762 100644
--- a/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
@@ -1734,7 +1734,7 @@ static int msm_compr_get_caps(struct snd_compr_stream *cstream,
 		memcpy(arg, &prtd->compr_cap, sizeof(struct snd_compr_caps));
 	} else {
 		ret = -EINVAL;
-		pr_err("%s: arg (0x%p), prtd (0x%p)\n", __func__, arg, prtd);
+		pr_err("%s: arg (0x%pK), prtd (0x%pK)\n", __func__, arg, prtd);
 	}
 
 	return ret;
diff --git a/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c
index 35373c387ce7..433515343684 100644
--- a/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1611,7 +1611,7 @@ static int msm_auxpcm_dev_probe(struct platform_device *pdev)
 		goto fail_pdata_nomem;
 	}
 
-	dev_dbg(&pdev->dev, "%s: dev %p, dai_data %p, auxpcm_pdata %p\n",
+	dev_dbg(&pdev->dev, "%s: dev %pK, dai_data %pK, auxpcm_pdata %pK\n",
 		__func__, &pdev->dev, dai_data, auxpcm_pdata);
 
 	rc = of_property_read_u32_array(pdev->dev.of_node,
diff --git a/sound/soc/msm/qdsp6v2/msm-dts-eagle.c b/sound/soc/msm/qdsp6v2/msm-dts-eagle.c
index 206999d6e82d..716a430f0f07 100644
--- a/sound/soc/msm/qdsp6v2/msm-dts-eagle.c
+++ b/sound/soc/msm/qdsp6v2/msm-dts-eagle.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -457,10 +457,12 @@ static int _sendcache_pre(struct audio_client *ac)
 	if (offset > (UINT_MAX - size))
 		err = -EINVAL;
 	if ((_depc_size == 0) || !_depc || (size == 0) ||
-		cmd == 0 || ((offset + size) > _depc_size) || (err != 0)) {
-		eagle_precache_err("%s: primary device %i cache index %i general error - cache size = %u, cache ptr = %p, offset = %u, size = %u, cmd = %i",
-			__func__, _device_primary, cidx, _depc_size, _depc,
-			offset, size, cmd);
+		cmd == 0 || ((offset + size) >= _depc_size) || (err != 0)) {
+		eagle_precache_err("%s: primary device %i cache index %i general
+				   error - cache size = %u, cache ptr = %pK,
+				   offset = %u, size = %u, cmd = %i", __func__,
+				   device_primary, cidx, _depc_size, _depc,
+				   offset, size, cmd);
 		return -EINVAL;
 	}
 
@@ -996,11 +998,13 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 	}
 	case DTS_EAGLE_IOCTL_SET_CACHE_SIZE: {
 		u32 size = 0;
-		eagle_ioctl_info("%s: called with control 0x%X (allocate param cache)",
-			__func__, cmd);
+		eagle_ioctl_info("%s: called with control 0x%X
+				 (allocate param cache)", __func__, cmd);
 		if (copy_from_user((void *)&size, (void *)arg, sizeof(size))) {
-			eagle_ioctl_err("%s: error copying size (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, &size, sizeof(size));
+			eagle_ioctl_err("%s: error copying size (src:%pK,
+					tgt:%pK, size:%zu)",
+					__func__, (void *)arg, &size,
+					sizeof(size));
 			return -EFAULT;
 		} else if (size > DEPC_MAX_SIZE) {
 			eagle_ioctl_err("%s: cache size %u not allowed (min 0, max %u)",
@@ -1039,8 +1043,10 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 		eagle_ioctl_info("%s: control 0x%X (get param)",
 			__func__, cmd);
 		if (copy_from_user((void *)&depd, (void *)arg, sizeof(depd))) {
-			eagle_ioctl_err("%s: error copying dts_eagle_param_desc (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, &depd, sizeof(depd));
+			eagle_ioctl_err("%s: error copying dts_eagle_param_desc
+					(src:%pK, tgt:%pK, size:%zu)",
+					__func__, (void *)arg, &depd,
+					sizeof(depd));
 			return -EFAULT;
 		}
 		if (depd.device & DTS_EAGLE_FLAG_IOCTL_PRE) {
@@ -1110,8 +1116,10 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 		eagle_ioctl_info("%s: control 0x%X (set param)",
 			__func__, cmd);
 		if (copy_from_user((void *)&depd, (void *)arg, sizeof(depd))) {
-			eagle_ioctl_err("%s: error copying dts_eagle_param_desc (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, &depd, sizeof(depd));
+			eagle_ioctl_err("%s: error copying dts_eagle_param_desc
+					(src:%pK, tgt:%pK, size:%zu)",
+					__func__, (void *)arg, &depd,
+					sizeof(depd));
 			return -EFAULT;
 		}
 		if (depd.device & DTS_EAGLE_FLAG_IOCTL_PRE) {
@@ -1135,17 +1143,20 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 		if (offset > (UINT_MAX - depd.size))
 			err = -EINVAL;
 		if ((err != 0) || ((offset + depd.size) > _depc_size)) {
-			eagle_ioctl_err("%s: invalid size %u and/or offset %u for parameter (target cache block %i with offset %i, global cache is size %u)",
-				__func__, depd.size, offset, tgt,
-				_c_bl[tgt][CBD_OFFSG], _depc_size);
+			eagle_ioctl_err("%s: invalid size %u and/or offset %u
+					for parameter (target cache block %i
+					with offset %i, global cache is size
+					%u)", __func__, depd.size, offset, tgt,
+					_c_bl[tgt][CBD_OFFSG], _depc_size);
 			return -EINVAL;
 		}
 		if (copy_from_user((void *)&_depc[offset],
 				   (void *)(((char *)arg)+sizeof(depd)),
 					depd.size)) {
-			eagle_ioctl_err("%s: error copying param to cache (src:%p, tgt:%p, size:%u)",
-				__func__, ((char *)arg)+sizeof(depd),
-				&_depc[offset], depd.size);
+			eagle_ioctl_err("%s: error copying param to cache
+					(src:%pK, tgt:%pK, size:%u)",
+					__func__, ((char *)arg)+sizeof(depd),
+					&_depc[offset], depd.size);
 			return -EFAULT;
 		}
 		eagle_ioctl_dbg("%s: param info: param = 0x%X, size = %u, offset = %i, device = %u, cache block %i, global offset = %u, first bytes as integer = %i",
@@ -1162,8 +1173,9 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 		eagle_ioctl_info("%s: with control 0x%X (set param cache block)",
 			 __func__, cmd);
 		if (copy_from_user((void *)b_, (void *)arg, sizeof(b_))) {
-			eagle_ioctl_err("%s: error copying cache block data (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, b_, sizeof(b_));
+			eagle_ioctl_err("%s: error copying cache block data
+					(src:%pK, tgt:%pK, size:%zu)",
+					__func__, (void *)arg, b_, sizeof(b_));
 			return -EFAULT;
 		}
 		cb = b_[0];
@@ -1193,8 +1205,10 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 		eagle_ioctl_dbg("%s: with control 0x%X (set active device)",
 			 __func__, cmd);
 		if (copy_from_user((void *)data, (void *)arg, sizeof(data))) {
-			eagle_ioctl_err("%s: error copying active device data (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, data, sizeof(data));
+			eagle_ioctl_err("%s: error copying active device data
+					(src:%pK, tgt:%pK, size:%zu)",
+					__func__, (void *)arg, data,
+					sizeof(data));
 			return -EFAULT;
 		}
 		if (data[1] != 0) {
@@ -1215,8 +1229,10 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 			 __func__, cmd);
 		if (copy_from_user((void *)&target, (void *)arg,
 				   sizeof(target))) {
-			eagle_ioctl_err("%s: error reading license index. (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, &target, sizeof(target));
+			eagle_ioctl_err("%s: error reading license index.
+					(src:%pK, tgt:%pK, size:%zu)",
+					__func__, (void *)arg, &target,
+					sizeof(target));
 			return -EFAULT;
 		}
 		size_only = target & (1<<31) ? 1 : 0;
@@ -1262,8 +1278,10 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 				cmd);
 		if (copy_from_user((void *)target, (void *)arg,
 				   sizeof(target))) {
-			eagle_ioctl_err("%s: error reading license index (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, target, sizeof(target));
+			eagle_ioctl_err("%s: error reading license index
+					(src:%pK, tgt:%pK, size:%zu)",
+					__func__, (void *)arg, target,
+					sizeof(target));
 			return -EFAULT;
 		}
 		if (target[0] >= SEC_BLOB_MAX_CNT) {
@@ -1305,7 +1323,8 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 				(void *)&(((u32 *)_sec_blob[target[0]])[1]),
 				(void *)(((char *)arg)+sizeof(target)),
 				target[1])) {
-			eagle_ioctl_err("%s: error copying license to index %u, size %u (src:%p, tgt:%p, size:%u)",
+			eagle_ioctl_err("%s: error copying license to index %u,
+					size %u (src:%pK, tgt:%pK, size:%u)",
 					__func__, target[0], target[1],
 					((char *)arg)+sizeof(target),
 					&(((u32 *)_sec_blob[target[0]])[1]),
@@ -1322,8 +1341,10 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 				cmd);
 		if (copy_from_user((void *)&target, (void *)arg,
 				   sizeof(target))) {
-			eagle_ioctl_err("%s: error reading license index (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, &target, sizeof(target));
+			eagle_ioctl_err("%s: error reading license index
+					(src:%pK, tgt:%pK, size:%zu)",
+					__func__, (void *)arg, &target,
+					sizeof(target));
 			return -EFAULT;
 		}
 		if (target >= SEC_BLOB_MAX_CNT) {
@@ -1352,8 +1373,10 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 				__func__, cmd);
 		if (copy_from_user((void *)&spec, (void *)arg,
 					sizeof(spec))) {
-			eagle_ioctl_err("%s: error reading volume command specifier (src:%p, tgt:%p, size:%zu)",
-				__func__, (void *)arg, &spec, sizeof(spec));
+			eagle_ioctl_err("%s: error reading volume command
+					specifier (src:%pK, tgt:%pK, size:%zu)",
+					__func__, (void *)arg, &spec,
+					sizeof(spec));
 			return -EFAULT;
 		}
 		if (spec & 0x80000000) {
@@ -1374,10 +1397,12 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 			if (copy_from_user((void *)&_vol_cmds_d[idx],
 					(void *)(((char *)arg) + sizeof(int)),
 					sizeof(struct vol_cmds_d))) {
-				eagle_ioctl_err("%s: error reading volume command descriptor (src:%p, tgt:%p, size:%zu)",
-					__func__, ((char *)arg) + sizeof(int),
-					&_vol_cmds_d[idx],
-					sizeof(struct vol_cmds_d));
+				eagle_ioctl_err("%s: error reading volume
+						command descriptor (src:%pK,
+						tgt:%pK, size:%zu)", __func__,
+						((char *)arg) + sizeof(int),
+						&_vol_cmds_d[idx],
+						sizeof(struct vol_cmds_d));
 				return -EFAULT;
 			}
 			eagle_ioctl_dbg("%s: setting volume command %i spec (size %zu): %i %i %i %i",
@@ -1387,10 +1412,12 @@ int msm_dts_eagle_ioctl(unsigned int cmd, unsigned long arg)
 			if (copy_from_user((void *)_vol_cmds[idx],
 					(void *)(((char *)arg) + (sizeof(int) +
 					sizeof(struct vol_cmds_d))), size)) {
-				eagle_ioctl_err("%s: error reading volume command string (src:%p, tgt:%p, size:%i)",
-					__func__, ((char *)arg) + (sizeof(int) +
-					sizeof(struct vol_cmds_d)),
-					_vol_cmds[idx], size);
+				eagle_ioctl_err("%s: error reading volume
+						command string (src:%pK,
+						tgt:%pK, size:%i)", __func__,
+						((char *)arg) + (sizeof(int) +
+						sizeof(struct vol_cmds_d)),
+						_vol_cmds[idx], size);
 				return -EFAULT;
 			}
 		} else {
diff --git a/sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c b/sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c
index b70229dd2e31..4c7a53117fd6 100644
--- a/sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c
+++ b/sound/soc/msm/qdsp6v2/msm-dts-srs-tm-config.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2014, 2016 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
diff --git a/sound/soc/msm/qdsp6v2/msm-lsm-client.c b/sound/soc/msm/qdsp6v2/msm-lsm-client.c
index c8271dc222bb..ed8b43a3a50a 100644
--- a/sound/soc/msm/qdsp6v2/msm-lsm-client.c
+++ b/sound/soc/msm/qdsp6v2/msm-lsm-client.c
@@ -95,8 +95,8 @@ static int msm_lsm_queue_lab_buffer(struct lsm_priv *prtd, int i)
 	struct snd_soc_pcm_runtime *rtd;
 
 	if (!prtd || !prtd->lsm_client) {
-		pr_err("%s: Invalid params prtd %p lsm client %p\n",
-			__func__, prtd, ((!prtd) ? NULL : prtd->lsm_client));
+		pr_err("%s: Invalid params prtd %pK lsm client %pK\n",
+		       __func__, prtd, ((!prtd) ? NULL : prtd->lsm_client));
 		return -EINVAL;
 	}
 	if (!prtd->substream || !prtd->substream->private_data) {
@@ -109,7 +109,8 @@ static int msm_lsm_queue_lab_buffer(struct lsm_priv *prtd, int i)
 	if (!prtd->lsm_client->lab_buffer ||
 		i >= prtd->lsm_client->hw_params.period_count) {
 		dev_err(rtd->dev,
-			"%s: Lab buffer not setup %p incorrect index %d period count %d\n",
+			"%s: Lab buffer not setup %pK incorrect index
+			%d period count %d\n",
 			__func__, prtd->lsm_client->lab_buffer, i,
 			prtd->lsm_client->hw_params.period_count);
 		return -EINVAL;
@@ -136,8 +137,8 @@ static int lsm_lab_buffer_sanity(struct lsm_priv *prtd,
 	struct snd_soc_pcm_runtime *rtd;
 
 	if (!prtd || !read_done || !index) {
-		pr_err("%s: Invalid params prtd %p read_done %p index %p\n",
-			__func__, prtd, read_done, index);
+		pr_err("%s: Invalid params prtd %pK read_done %pK index %pK\n",
+		       __func__, prtd, read_done, index);
 		return -EINVAL;
 	}
 
@@ -150,7 +151,7 @@ static int lsm_lab_buffer_sanity(struct lsm_priv *prtd,
 
 	if (!prtd->lsm_client->lab_enable || !prtd->lsm_client->lab_buffer) {
 		dev_err(rtd->dev,
-			"%s: Lab not enabled %d invalid lab buffer %p\n",
+			"%s: Lab not enabled %d invalid lab buffer %pK\n",
 			__func__, prtd->lsm_client->lab_enable,
 			prtd->lsm_client->lab_buffer);
 		return -EINVAL;
@@ -163,7 +164,7 @@ static int lsm_lab_buffer_sanity(struct lsm_priv *prtd,
 			(prtd->lsm_client->lab_buffer[i].mem_map_handle ==
 			read_done->mem_map_handle)) {
 			dev_dbg(rtd->dev,
-				"%s: Buffer found %pa memmap handle %d\n",
+				"%s: Buffer found %pK memmap handle %d\n",
 				__func__, &prtd->lsm_client->lab_buffer[i].phys,
 			prtd->lsm_client->lab_buffer[i].mem_map_handle);
 			if (read_done->total_size >
@@ -210,7 +211,8 @@ static void lsm_event_handler(uint32_t opcode, uint32_t token,
 		if (prtd->lsm_client->session != token ||
 		    !read_done) {
 			dev_err(rtd->dev,
-				"%s: EVENT_READ_DONE invalid callback, session %d callback %d payload %p",
+				"%s: EVENT_READ_DONE invalid callback, session
+				%d callback %d payload %pK",
 				__func__, prtd->lsm_client->session,
 				token, read_done);
 			return;
@@ -302,7 +304,7 @@ static int msm_lsm_lab_buffer_alloc(struct lsm_priv *lsm, int alloc)
 	int ret = 0;
 	struct snd_dma_buffer *dma_buf = NULL;
 	if (!lsm) {
-		pr_err("%s: Invalid param lsm %p\n", __func__, lsm);
+		pr_err("%s: Invalid param lsm %pK\n", __func__, lsm);
 		return -EINVAL;
 	}
 	if (alloc) {
@@ -773,7 +775,7 @@ static int msm_lsm_ioctl_shared(struct snd_pcm_substream *substream,
 			   snd_model_v2.data, snd_model_v2.data_size)) {
 			dev_err(rtd->dev,
 				"%s: copy from user data failed\n"
-			       "data %p size %d\n", __func__,
+			       "data %pK size %d\n", __func__,
 			       snd_model_v2.data, snd_model_v2.data_size);
 			q6lsm_snd_model_buf_free(prtd->lsm_client);
 			rc = -EFAULT;
@@ -1804,7 +1806,7 @@ static int msm_lsm_hw_params(struct snd_pcm_substream *substream,
 
 	if (!prtd || !params) {
 		dev_err(rtd->dev,
-			"%s: invalid params prtd %p params %p",
+			"%s: invalid params prtd %pK params %pK",
 			 __func__, prtd, params);
 		return -EINVAL;
 	}
@@ -1846,7 +1848,7 @@ static snd_pcm_uframes_t msm_lsm_pcm_pointer(
 
 	if (!prtd) {
 		dev_err(rtd->dev,
-			"%s: Invalid param %p\n", __func__, prtd);
+			"%s: Invalid param %pK\n", __func__, prtd);
 		return 0;
 	}
 
@@ -1874,7 +1876,7 @@ static int msm_lsm_pcm_copy(struct snd_pcm_substream *substream, int ch,
 
 	if (!prtd) {
 		dev_err(rtd->dev,
-			"%s: Invalid param %p\n", __func__, prtd);
+			"%s: Invalid param %pK\n", __func__, prtd);
 		return -EINVAL;
 	}
 
diff --git a/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c
index 2c543a4ad2ac..331c1abada85 100644
--- a/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
@@ -381,7 +381,7 @@ static int msm_afe_open(struct snd_pcm_substream *substream)
 		pr_err("Failed to allocate memory for msm_audio\n");
 		return -ENOMEM;
 	} else
-		pr_debug("prtd %p\n", prtd);
+		pr_debug("prtd %pK\n", prtd);
 
 	mutex_init(&prtd->lock);
 	spin_lock_init(&prtd->dsp_lock);
@@ -600,7 +600,7 @@ static int msm_afe_hw_params(struct snd_pcm_substream *substream,
 		return -ENOMEM;
 	}
 
-	pr_debug("%s:buf = %p\n", __func__, buf);
+	pr_debug("%s:buf = %pK\n", __func__, buf);
 	dma_buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	dma_buf->dev.dev = substream->pcm->card->dev;
 	dma_buf->private_data = NULL;
diff --git a/sound/soc/msm/qdsp6v2/msm-pcm-host-voice-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-host-voice-v2.c
index b4b34c8c2cc4..a6fef398824b 100644
--- a/sound/soc/msm/qdsp6v2/msm-pcm-host-voice-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-host-voice-v2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2014, 2016 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -504,7 +504,7 @@ static int hpcm_allocate_shared_memory(struct hpcm_drv *prtd)
 
 	sess->tp_mem_table.size = sizeof(struct vss_imemory_table_t);
 
-	pr_debug("%s: data %p phys %pa\n", __func__,
+	pr_debug("%s: data %pK phys %pK\n", __func__,
 		 sess->tp_mem_table.data, &sess->tp_mem_table.phys);
 
 	/* Split 4096 block into four 1024 byte blocks for each dai */
@@ -682,7 +682,7 @@ void hpcm_notify_evt_processing(uint8_t *data, char *session,
 	}
 
 	if (tp == NULL || tmd == NULL) {
-		pr_err("%s: tp = %p or tmd = %p is null\n", __func__,
+		pr_err("%s: tp = %pK or tmd = %pK is null\n", __func__,
 		       tp, tmd);
 
 		return;
diff --git a/sound/soc/msm/qdsp6v2/msm-pcm-lpa-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-lpa-v2.c
index 5a528195a325..a888d43ff136 100644
--- a/sound/soc/msm/qdsp6v2/msm-pcm-lpa-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-lpa-v2.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2014, 2016 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -132,8 +132,8 @@ static void event_handler(uint32_t opcode,
 		pr_debug("%s:writing %d bytes of buffer[%d] to dsp 2\n",
 				__func__, prtd->pcm_count, prtd->out_head);
 		temp = buf[0].phys + (prtd->out_head * prtd->pcm_count);
-		pr_debug("%s:writing buffer[%d] from 0x%pa\n",
-				__func__, prtd->out_head, &temp);
+		pr_debug("%s:writing buffer[%d] from 0x%pK\n",
+			 __func__, prtd->out_head, &temp);
 		if (prtd->meta_data_mode) {
 			memcpy(&output_meta_data, (char *)(buf->data +
 			prtd->out_head * prtd->pcm_count),
@@ -623,7 +623,7 @@ static int msm_pcm_hw_params(struct snd_pcm_substream *substream,
 	if (buf == NULL || buf[0].data == NULL)
 		return -ENOMEM;
 
-	pr_debug("%s:buf = %p\n", __func__, buf);
+	pr_debug("%s:buf = %pK\n", __func__, buf);
 	dma_buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	dma_buf->dev.dev = substream->pcm->card->dev;
 	dma_buf->private_data = NULL;
diff --git a/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c
index 596d1837e4ed..207e9caf5d81 100644
--- a/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c
@@ -701,8 +701,8 @@ static int msm_pcm_capture_copy(struct snd_pcm_substream *substream,
 		pr_debug("%s: pcm stopped in_count 0\n", __func__);
 		return 0;
 	}
-	pr_debug("Checking if valid buffer is available...%p\n",
-						data);
+	pr_debug("Checking if valid buffer is available...%pK\n",
+		 data);
 	data = q6asm_is_cpu_buf_avail(OUT, prtd->audio_client, &size, &idx);
 	bufptr = data;
 	pr_debug("Size = %d\n", size);
@@ -858,7 +858,7 @@ static int msm_pcm_hw_params(struct snd_pcm_substream *substream,
 	if (buf == NULL || buf[0].data == NULL)
 		return -ENOMEM;
 
-	pr_debug("%s:buf = %p\n", __func__, buf);
+	pr_debug("%s:buf = %pK\n", __func__, buf);
 	dma_buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	dma_buf->dev.dev = substream->pcm->card->dev;
 	dma_buf->private_data = NULL;
diff --git a/sound/soc/msm/qdsp6v2/q6adm.c b/sound/soc/msm/qdsp6v2/q6adm.c
index d8d712560ddd..b196e212eac1 100644
--- a/sound/soc/msm/qdsp6v2/q6adm.c
+++ b/sound/soc/msm/qdsp6v2/q6adm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -321,8 +321,8 @@ int adm_dts_eagle_get(int port_id, int copp_idx, int param_id,
 	}
 
 	if (size <= 0 || !data) {
-		pr_err("DTS_EAGLE_ADM - %s: invalid size %i or pointer %p.\n",
-			__func__, size, data);
+		pr_err("DTS_EAGLE_ADM - %s: invalid size %i or pointer %pK.\n",
+		       __func__, size, data);
 		return -EINVAL;
 	}
 
@@ -902,8 +902,8 @@ static int32_t adm_callback(struct apr_client_data *data, void *priv)
 	payload = data->payload;
 
 	if (data->opcode == RESET_EVENTS) {
-		pr_debug("%s: Reset event is received: %d %d apr[%p]\n",
-			__func__,
+		pr_debug("%s: Reset event is received: %d %d apr[%pK]\n",
+			 __func__,
 			data->reset_event, data->reset_proc, this_adm.apr);
 		if (this_adm.apr) {
 			apr_reset(this_adm.apr);
@@ -1255,8 +1255,8 @@ static void remap_cal_data(struct cal_block_data *cal_block, int cal_index)
 			pr_err("%s: ADM mmap did not work! size = %zd ret %d\n",
 				__func__,
 				cal_block->map_data.map_size, ret);
-			pr_debug("%s: ADM mmap did not work! addr = 0x%pa, size = %zd ret %d\n",
-				__func__,
+			pr_debug("%s: ADM mmap did not work! addr = 0x%pK, size = %zd ret %d\n",
+				 __func__,
 				&cal_block->cal_data.paddr,
 				cal_block->map_data.map_size, ret);
 			goto done;
@@ -1317,8 +1317,8 @@ static void send_adm_custom_topology(void)
 	adm_top.payload_size = cal_block->cal_data.size;
 
 	atomic_set(&this_adm.adm_stat, 0);
-	pr_debug("%s: Sending ADM_CMD_ADD_TOPOLOGIES payload = 0x%pa, size = %d\n",
-		__func__, &cal_block->cal_data.paddr,
+	pr_debug("%s: Sending ADM_CMD_ADD_TOPOLOGIES payload = 0x%pK, size = %d\n",
+		 __func__, &cal_block->cal_data.paddr,
 		adm_top.payload_size);
 	result = apr_send_pkt(this_adm.apr, (uint32_t *)&adm_top);
 	if (result < 0) {
@@ -1389,15 +1389,15 @@ static int send_adm_cal_block(int port_id, int copp_idx,
 	adm_params.payload_size = cal_block->cal_data.size;
 
 	atomic_set(&this_adm.copp.stat[port_idx][copp_idx], 0);
-	pr_debug("%s: Sending SET_PARAMS payload = 0x%pa, size = %d\n",
-		__func__, &cal_block->cal_data.paddr,
+	pr_debug("%s: Sending SET_PARAMS payload = 0x%pK, size = %d\n",
+		 __func__, &cal_block->cal_data.paddr,
 		adm_params.payload_size);
 	result = apr_send_pkt(this_adm.apr, (uint32_t *)&adm_params);
 	if (result < 0) {
 		pr_err("%s: Set params failed port 0x%x result %d\n",
 				__func__, port_id, result);
-		pr_debug("%s: Set params failed port = 0x%x payload = 0x%pa result %d\n",
-			__func__, port_id, &cal_block->cal_data.paddr, result);
+		pr_debug("%s: Set params failed port = 0x%x payload = 0x%pK result %d\n",
+			 __func__, port_id, &cal_block->cal_data.paddr, result);
 		result = -EINVAL;
 		goto done;
 	}
@@ -1408,8 +1408,8 @@ static int send_adm_cal_block(int port_id, int copp_idx,
 	if (!result) {
 		pr_err("%s: Set params timed out port = 0x%x\n",
 				__func__, port_id);
-		pr_debug("%s: Set params timed out port = 0x%x, payload = 0x%pa\n",
-			__func__, port_id, &cal_block->cal_data.paddr);
+		pr_debug("%s: Set params timed out port = 0x%x, payload = 0x%pK\n",
+			 __func__, port_id, &cal_block->cal_data.paddr);
 		result = -EINVAL;
 		goto done;
 	}
@@ -2073,10 +2073,10 @@ int adm_map_rtac_block(struct rtac_cal_block_data *cal_block)
 		pr_err("%s: RTAC mmap did not work! size = %d result %d\n",
 			__func__,
 			cal_block->map_data.map_size, result);
-		pr_debug("%s: RTAC mmap did not work! addr = 0x%pa, size = %d\n",
-			__func__,
-			&cal_block->cal_data.paddr,
-			cal_block->map_data.map_size);
+		pr_debug("%s: RTAC mmap did not work! addr = 0x%pK, size = %d\n",
+			 __func__,
+			 &cal_block->cal_data.paddr,
+			 cal_block->map_data.map_size);
 		goto done;
 	}
 
diff --git a/sound/soc/msm/qdsp6v2/q6afe.c b/sound/soc/msm/qdsp6v2/q6afe.c
index 383184556843..2d911c3a60d7 100644
--- a/sound/soc/msm/qdsp6v2/q6afe.c
+++ b/sound/soc/msm/qdsp6v2/q6afe.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -103,9 +103,9 @@ static int32_t afe_callback(struct apr_client_data *data, void *priv)
 		return -EINVAL;
 	}
 	if (data->opcode == RESET_EVENTS) {
-		pr_debug("%s: reset event = %d %d apr[%p]\n",
-			__func__,
-			data->reset_event, data->reset_proc, this_afe.apr);
+		pr_debug("%s: reset event = %d %d apr[%pK]\n",
+			 __func__,
+			 data->reset_event, data->reset_proc, this_afe.apr);
 
 		cal_utils_clear_cal_block_q6maps(MAX_AFE_CAL_TYPES,
 			this_afe.cal_data);
@@ -137,9 +137,9 @@ static int32_t afe_callback(struct apr_client_data *data, void *priv)
 
 		if ((data->payload_size < sizeof(this_afe.calib_data))
 			|| !payload || (data->token >= AFE_MAX_PORTS)) {
-			pr_err("%s: Error: size %d payload %p token %d\n",
-				__func__, data->payload_size,
-				payload, data->token);
+			pr_err("%s: Error: size %d payload %pK token %d\n",
+			       __func__, data->payload_size,
+			       payload, data->token);
 			return -EINVAL;
 		}
 		memcpy(&this_afe.calib_data, payload,
@@ -456,9 +456,9 @@ static int afe_send_cal_block(u16 port_id, struct cal_block_data *cal_block)
 		upper_32_bits(cal_block->cal_data.paddr);
 	afe_cal.param.mem_map_handle = cal_block->map_data.q6map_handle;
 
-	pr_debug("%s: AFE cal sent for device port = 0x%x, cal size = %zd, cal addr = 0x%pa\n",
-		__func__, port_id,
-		cal_block->cal_data.size, &cal_block->cal_data.paddr);
+	pr_debug("%s: AFE cal sent for device port = 0x%x, cal size = %zd, cal addr = 0x%pK\n",
+		 __func__, port_id,
+		 cal_block->cal_data.size, &cal_block->cal_data.paddr);
 
 	result = afe_apr_send_pkt(&afe_cal, &this_afe.wait[index]);
 	if (result)
@@ -696,10 +696,10 @@ static void remap_cal_data(struct cal_block_data *cal_block, int cal_index)
 			pr_err("%s: mmap did not work! size = %zd ret %d\n",
 				__func__,
 				cal_block->map_data.map_size, ret);
-			pr_debug("%s: mmap did not work! addr = 0x%pa, size = %zd\n",
-				__func__,
-				&cal_block->cal_data.paddr,
-				cal_block->map_data.map_size);
+			pr_debug("%s: mmap did not work! addr = 0x%pK, size = %zd\n",
+				 __func__,
+				 &cal_block->cal_data.paddr,
+				 cal_block->map_data.map_size);
 			goto done;
 		}
 		cal_block->map_data.q6map_handle = atomic_read(&this_afe.
@@ -2371,7 +2371,7 @@ int q6afe_audio_client_buf_alloc_contiguous(unsigned int dir,
 	size_t len;
 
 	if (!(ac) || ((dir != IN) && (dir != OUT))) {
-		pr_err("%s: ac %p dir %d\n", __func__, ac, dir);
+		pr_err("%s: ac %pK dir %d\n", __func__, ac, dir);
 		return -EINVAL;
 	}
 
@@ -2423,10 +2423,10 @@ int q6afe_audio_client_buf_alloc_contiguous(unsigned int dir,
 			buf[cnt].used = dir ^ 1;
 			buf[cnt].size = bufsz;
 			buf[cnt].actual_size = bufsz;
-			pr_debug("%s:  data[%p]phys[%pa][%p]\n", __func__,
-				   buf[cnt].data,
-				   &buf[cnt].phys,
-				   &buf[cnt].phys);
+			pr_debug("%s:  data[%pK]phys[%pK][%pK]\n", __func__,
+				 buf[cnt].data,
+				 &buf[cnt].phys,
+				 &buf[cnt].phys);
 		}
 		cnt++;
 	}
@@ -2517,8 +2517,8 @@ int afe_cmd_memory_map(phys_addr_t dma_addr_p, u32 dma_buf_sz)
 	mregion_pl->shm_addr_msw = upper_32_bits(dma_addr_p);
 	mregion_pl->mem_size_bytes = dma_buf_sz;
 
-	pr_debug("%s: dma_addr_p 0x%pa , size %d\n", __func__,
-					&dma_addr_p, dma_buf_sz);
+	pr_debug("%s: dma_addr_p 0x%pK , size %d\n", __func__,
+		 &dma_addr_p, dma_buf_sz);
 	atomic_set(&this_afe.state, 1);
 	atomic_set(&this_afe.status, 0);
 	this_afe.mmap_handle = 0;
@@ -2635,13 +2635,13 @@ int q6afe_audio_client_buf_free_contiguous(unsigned int dir,
 	cnt = port->max_buf_cnt - 1;
 
 	if (port->buf[0].data) {
-		pr_debug("%s: data[%p]phys[%pa][%p] , client[%p] handle[%p]\n",
-			__func__,
-			port->buf[0].data,
-			&port->buf[0].phys,
-			&port->buf[0].phys,
-			port->buf[0].client,
-			port->buf[0].handle);
+		pr_debug("%s: data[%pK]phys[%pK][%pK] , client[%pK] handle[%pK]\n",
+			 __func__,
+			 port->buf[0].data,
+			 &port->buf[0].phys,
+			 &port->buf[0].phys,
+			 port->buf[0].client,
+			 port->buf[0].handle);
 		msm_audio_ion_free(port->buf[0].client, port->buf[0].handle);
 		port->buf[0].client = NULL;
 		port->buf[0].handle = NULL;
@@ -4119,10 +4119,10 @@ static int afe_map_cal_data(int32_t cal_type,
 		pr_err("%s: mmap did not work! size = %zd ret %d\n",
 			__func__,
 			cal_block->map_data.map_size, ret);
-		pr_debug("%s: mmap did not work! addr = 0x%pa, size = %zd\n",
-			__func__,
-			&cal_block->cal_data.paddr,
-			cal_block->map_data.map_size);
+		pr_debug("%s: mmap did not work! addr = 0x%pK, size = %zd\n",
+			 __func__,
+			 &cal_block->cal_data.paddr,
+			 cal_block->map_data.map_size);
 	}
 	cal_block->map_data.q6map_handle = atomic_read(&this_afe.
 		mem_map_cal_handles[cal_index]);
@@ -4253,9 +4253,9 @@ int afe_map_rtac_block(struct rtac_cal_block_data *cal_block)
 	result = afe_cmd_memory_map(cal_block->cal_data.paddr,
 		cal_block->map_data.map_size);
 	if (result < 0) {
-		pr_err("%s: afe_cmd_memory_map failed for addr = 0x%pa, size = %d, err %d\n",
-			__func__, &cal_block->cal_data.paddr,
-			cal_block->map_data.map_size, result);
+		pr_err("%s: afe_cmd_memory_map failed for addr = 0x%pK, size = %d, err %d\n",
+		       __func__, &cal_block->cal_data.paddr,
+		       cal_block->map_data.map_size, result);
 		return result;
 	}
 	cal_block->map_data.map_handle = this_afe.mmap_handle;
diff --git a/sound/soc/msm/qdsp6v2/q6asm.c b/sound/soc/msm/qdsp6v2/q6asm.c
index 621231972a4d..2f66a34eef16 100644
--- a/sound/soc/msm/qdsp6v2/q6asm.c
+++ b/sound/soc/msm/qdsp6v2/q6asm.c
@@ -445,10 +445,10 @@ static int q6asm_map_cal_memory(struct cal_block_data *cal_block)
 	result = q6asm_memory_map_regions(&common_client,
 			IN, cal_block->map_data.map_size, 1, 1);
 	if (result < 0) {
-		pr_err("%s: mmap did not work! addr = 0x%pa, size = %zd\n",
-			__func__,
-			&cal_block->cal_data.paddr,
-			cal_block->map_data.map_size);
+		pr_err("%s: mmap did not work! addr = 0x%pK, size = %zd\n",
+		       __func__,
+		       &cal_block->cal_data.paddr,
+		       cal_block->map_data.map_size);
 		goto done;
 	}
 
@@ -585,8 +585,8 @@ int send_asm_custom_topology(struct audio_client *ac)
 	result = apr_send_pkt(ac->apr, (uint32_t *) &asm_top);
 	if (result < 0) {
 
-		pr_err("%s: Set topologies failed payload = 0x%pa\n",
-			__func__, &cal_block->cal_data.paddr);
+		pr_err("%s: Set topologies failed payload = 0x%pK\n",
+		       __func__, &cal_block->cal_data.paddr);
 		goto unmap;
 
 	}
@@ -595,8 +595,8 @@ int send_asm_custom_topology(struct audio_client *ac)
 			(atomic_read(&ac->mem_state) <= 0), 5*HZ);
 	if (!result) {
 
-		pr_err("%s: Set topologies failed after timedout payload = 0x%pa\n",
-			__func__, &cal_block->cal_data.paddr);
+		pr_err("%s: Set topologies failed after timedout payload = 0x%pK\n",
+		       __func__, &cal_block->cal_data.paddr);
 		result = -ETIMEDOUT;
 		goto unmap;
 	}
@@ -668,10 +668,10 @@ int q6asm_map_rtac_block(struct rtac_cal_block_data *cal_block)
 	result = q6asm_memory_map_regions(&common_client,
 			OUT, cal_block->map_data.map_size, 1, 1);
 	if (result < 0) {
-		pr_err("%s: mmap did not work! addr = 0x%pa, size = %d\n",
-			__func__,
-			&cal_block->cal_data.paddr,
-			cal_block->map_data.map_size);
+		pr_err("%s: mmap did not work! addr = 0x%pK, size = %d\n",
+		       __func__,
+		       &cal_block->cal_data.paddr,
+		       cal_block->map_data.map_size);
 		goto done;
 	}
 
@@ -804,13 +804,14 @@ int q6asm_audio_client_buf_free_contiguous(unsigned int dir,
 	}
 
 	if (port->buf[0].data) {
-		pr_debug("%s:data[%p]phys[%pa][%p] , client[%p] handle[%p]\n",
-			__func__,
-			(void *)port->buf[0].data,
-			&port->buf[0].phys,
-			(void *)&port->buf[0].phys,
-			(void *)port->buf[0].client,
-			(void *)port->buf[0].handle);
+		pr_debug("%s:data[%pK]phys[%pK][%pK] ,
+			 client[%pK] handle[%pK]\n",
+			 __func__,
+			 (void *)port->buf[0].data,
+			 &port->buf[0].phys,
+			 (void *)&port->buf[0].phys,
+			 (void *)port->buf[0].client,
+			 (void *)port->buf[0].handle);
 		if (!rc || atomic_read(&ac->reset))
 			msm_audio_ion_free(port->buf[0].client,
 					   port->buf[0].handle);
@@ -1183,10 +1184,10 @@ int q6asm_audio_client_buf_alloc_contiguous(unsigned int dir,
 			buf[cnt].used = dir ^ 1;
 			buf[cnt].size = bufsz;
 			buf[cnt].actual_size = bufsz;
-			pr_debug("%s data[%p]phys[%pa][%p]\n", __func__,
-				   (void *)buf[cnt].data,
-				   &buf[cnt].phys,
-				   (void *)&buf[cnt].phys);
+			pr_debug("%s data[%pK]phys[%pK][%pK]\n", __func__,
+				 (void *)buf[cnt].data,
+				 &buf[cnt].phys,
+				 (void *)&buf[cnt].phys);
 		}
 		cnt++;
 	}
@@ -1225,11 +1226,11 @@ static int32_t q6asm_srvc_callback(struct apr_client_data *data, void *priv)
 
 	if (data->opcode == RESET_EVENTS) {
 
-		pr_debug("%s: Reset event is received: %d %d apr[%p]\n",
-				__func__,
-				data->reset_event,
-				data->reset_proc,
-				this_mmap.apr);
+		pr_debug("%s: Reset event is received: %d %d apr[%pK]\n",
+			 __func__,
+			 data->reset_event,
+			 data->reset_proc,
+			 this_mmap.apr);
 		atomic_set(&this_mmap.ref_cnt, 0);
 		apr_reset(this_mmap.apr);
 		this_mmap.apr = NULL;
@@ -1404,8 +1405,8 @@ static int32_t q6asm_callback(struct apr_client_data *data, void *priv)
 		atomic_set(&ac->reset, 1);
 		if (ac->apr == NULL)
 			ac->apr = ac->apr2;
-		pr_debug("q6asm_callback: Reset event is received: %d %d apr[%p]\n",
-				data->reset_event, data->reset_proc, ac->apr);
+		pr_debug("q6asm_callback: Reset event is received: %d %d apr[%pK]\n",
+			 data->reset_event, data->reset_proc, ac->apr);
 		if (ac->cb)
 			ac->cb(data->opcode, data->token,
 				(uint32_t *)data->payload, ac->priv);
@@ -1535,8 +1536,9 @@ static int32_t q6asm_callback(struct apr_client_data *data, void *priv)
 			payload[0] ||
 			upper_32_bits(port->buf[data->token].phys) !=
 			payload[1]) {
-				pr_debug("%s: Expected addr %pa\n",
-				__func__, &port->buf[data->token].phys);
+				pr_debug("%s: Expected addr %pK\n",
+					 __func__,
+					 &port->buf[data->token].phys);
 				pr_err("%s: rxedl[%x] rxedu [%x]\n",
 					__func__, payload[0], payload[1]);
 				spin_unlock_irqrestore(&port->dsp_lock,
@@ -1607,8 +1609,8 @@ static int32_t q6asm_callback(struct apr_client_data *data, void *priv)
 			payload[READDONE_IDX_BUFADD_LSW] ||
 			upper_32_bits(port->buf[token].phys) !=
 			payload[READDONE_IDX_BUFADD_MSW]) {
-				pr_debug("%s: Expected addr %pa\n",
-					__func__, &port->buf[token].phys);
+				pr_debug("%s: Expected addr %pK\n",
+					 __func__, &port->buf[token].phys);
 				pr_err("%s: rxedl[%x] rxedu[%x]\n", __func__,
 				payload[READDONE_IDX_BUFADD_LSW],
 				payload[READDONE_IDX_BUFADD_MSW]);
@@ -1690,11 +1692,11 @@ void *q6asm_is_cpu_buf_avail(int dir, struct audio_client *ac, uint32_t *size,
 		*size = port->buf[idx].actual_size;
 		*index = port->cpu_buf;
 		data = port->buf[idx].data;
-		pr_debug("%s:session[%d]index[%d] data[%p]size[%d]\n",
-						__func__,
-						ac->session,
-						port->cpu_buf,
-						data, *size);
+		pr_debug("%s:session[%d]index[%d] data[%pK]size[%d]\n",
+			 __func__,
+			 ac->session,
+			 port->cpu_buf,
+			 data, *size);
 		/* By default increase the cpu_buf cnt
 		user accesses this function,increase cpu
 		buf(to avoid another api)*/
@@ -3482,8 +3484,8 @@ int q6asm_memory_map(struct audio_client *ac, phys_addr_t buf_add, int dir,
 
 	ac->port[dir].tmp_hdl = 0;
 	port = &ac->port[dir];
-	pr_debug("%s, buf_add 0x%pa, bufsz: %d\n", __func__,
-		&buf_add, bufsz);
+	pr_debug("%s, buf_add 0x%pK, bufsz: %d\n", __func__,
+		 &buf_add, bufsz);
 	mregions->shm_addr_lsw = lower_32_bits(buf_add);
 	mregions->shm_addr_msw = upper_32_bits(buf_add);
 	mregions->mem_size_bytes = bufsz;
@@ -3660,8 +3662,8 @@ static int q6asm_memory_map_regions(struct audio_client *ac, int dir,
 	q6asm_add_mmaphdr(ac, &mmap_regions->hdr, cmd_size, TRUE,
 					((ac->session << 8) | dir));
 	atomic_set(&ac->mem_state, 1);
-	pr_debug("mmap_region=0x%p token=0x%x\n",
-		mmap_regions, ((ac->session << 8) | dir));
+	pr_debug("mmap_region=0x%pK token=0x%x\n",
+		 mmap_regions, ((ac->session << 8) | dir));
 
 	mmap_regions->hdr.opcode = ASM_CMD_SHARED_MEM_MAP_REGIONS;
 	mmap_regions->mem_pool_id = ADSP_MEMORY_MAP_SHMEM8_4K_POOL;
@@ -3715,9 +3717,9 @@ static int q6asm_memory_map_regions(struct audio_client *ac, int dir,
 		buffer_node[i].mmap_hdl = ac->port[dir].tmp_hdl;
 		list_add_tail(&buffer_node[i].list,
 			&ac->port[dir].mem_map_handle);
-		pr_debug("%s: i=%d, bufadd[i] = 0x%pa, maphdl[i] = 0x%x\n",
-			__func__, i, &buffer_node[i].buf_phys_addr,
-			buffer_node[i].mmap_hdl);
+		pr_debug("%s: i=%d, bufadd[i] = 0x%pK, maphdl[i] = 0x%x\n",
+			 __func__, i, &buffer_node[i].buf_phys_addr,
+			 buffer_node[i].mmap_hdl);
 	}
 	ac->port[dir].tmp_hdl = 0;
 	mutex_unlock(&ac->cmd_lock);
@@ -3933,8 +3935,8 @@ int q6asm_dts_eagle_set(struct audio_client *ac, int param_id, int size,
 	}
 
 	if (!ac || ac->apr == NULL || size <= 0 || !data) {
-		pr_err("DTS_EAGLE_ASM - %s: APR handle NULL, invalid size %i or pointer %p.\n",
-			__func__, size, data);
+		pr_err("DTS_EAGLE_ASM - %s: APR handle NULL, invalid size %i or pointer %pK.\n",
+		       __func__, size, data);
 		return -EINVAL;
 	}
 
@@ -4334,13 +4336,13 @@ int q6asm_read(struct audio_client *ac)
 		}
 		ab = &port->buf[dsp_buf];
 
-		pr_debug("%s:session[%d]dsp-buf[%d][%p]cpu_buf[%d][%pa]\n",
-					__func__,
-					ac->session,
-					dsp_buf,
-					(void *)port->buf[dsp_buf].data,
-					port->cpu_buf,
-					&port->buf[port->cpu_buf].phys);
+		pr_debug("%s:session[%d]dsp-buf[%d][%pK]cpu_buf[%d][%pK]\n",
+			 __func__,
+			 ac->session,
+			 dsp_buf,
+			 (void *)port->buf[dsp_buf].data,
+			 port->cpu_buf,
+			 &port->buf[port->cpu_buf].phys);
 
 		read.hdr.opcode = ASM_DATA_CMD_READ_V2;
 		read.buf_addr_lsw = lower_32_bits(ab->phys);
@@ -4396,13 +4398,13 @@ int q6asm_read_nolock(struct audio_client *ac)
 		dsp_buf = port->dsp_buf;
 		ab = &port->buf[dsp_buf];
 
-		pr_debug("%s:session[%d]dsp-buf[%d][%p]cpu_buf[%d][%pa]\n",
-					__func__,
-					ac->session,
-					dsp_buf,
-					(void *)port->buf[dsp_buf].data,
-					port->cpu_buf,
-					&port->buf[port->cpu_buf].phys);
+		pr_debug("%s:session[%d]dsp-buf[%d][%pK]cpu_buf[%d][%pK]\n",
+			 __func__,
+			 ac->session,
+			 dsp_buf,
+			 (void *)port->buf[dsp_buf].data,
+			 port->cpu_buf,
+			 &port->buf[port->cpu_buf].phys);
 
 		read.hdr.opcode = ASM_DATA_CMD_READ_V2;
 		read.buf_addr_lsw = lower_32_bits(ab->phys);
@@ -4480,11 +4482,12 @@ int q6asm_async_write(struct audio_client *ac,
 	else
 		lbuf_phys_addr = param->paddr;
 
-	pr_debug("%s: token[0x%x], buf_addr_lsw[0x%x], buf_size[0x%x], ts_msw[0x%x], ts_lsw[0x%x], lbuf_phys_addr: 0x[%pa]\n",
-		__func__,
-		write.hdr.token, write.buf_addr_lsw,
-		write.buf_size, write.timestamp_msw,
-		write.timestamp_lsw, &lbuf_phys_addr);
+	pr_debug("%s: token[0x%x], buf_addr_lsw[0x%x], buf_size[0x%x],
+		 ts_msw[0x%x], ts_lsw[0x%x], lbuf_phys_addr: 0x[%pK]\n",
+		 __func__,
+		 write.hdr.token, write.buf_addr_lsw,
+		 write.buf_size, write.timestamp_msw,
+		 write.timestamp_lsw, &lbuf_phys_addr);
 
 	/* Use 0xFF00 for disabling timestamps */
 	if (param->flags == 0xFF00)
@@ -4617,14 +4620,15 @@ int q6asm_write(struct audio_client *ac, uint32_t len, uint32_t msw_ts,
 						list);
 		write.mem_map_handle = buf_node->mmap_hdl;
 
-		pr_debug("%s:ab->phys[%pa]bufadd[0x%x] token[0x%x]buf_id[0x%x]buf_size[0x%x]mmaphdl[0x%x]"
-						, __func__,
-						&ab->phys,
-						write.buf_addr_lsw,
-						write.hdr.token,
-						write.seq_id,
-						write.buf_size,
-						write.mem_map_handle);
+		pr_debug("%s:ab->phys[%pK]bufadd[0x%x]
+			 token[0x%x]buf_id[0x%x]buf_size[0x%x]mmaphdl[0x%x]"
+			 , __func__,
+			 &ab->phys,
+			 write.buf_addr_lsw,
+			 write.hdr.token,
+			 write.seq_id,
+			 write.buf_size,
+			 write.mem_map_handle);
 		mutex_unlock(&port->lock);
 
 		config_debug_fs_write(ab);
@@ -4684,14 +4688,15 @@ int q6asm_write_nolock(struct audio_client *ac, uint32_t len, uint32_t msw_ts,
 			write.flags = (0x80000000 | flags);
 		port->dsp_buf = (port->dsp_buf + 1) & (port->max_buf_cnt - 1);
 
-		pr_debug("%s:ab->phys[%pa]bufadd[0x%x]token[0x%x] buf_id[0x%x]buf_size[0x%x]mmaphdl[0x%x]"
-							, __func__,
-							&ab->phys,
-							write.buf_addr_lsw,
-							write.hdr.token,
-							write.seq_id,
-							write.buf_size,
-							write.mem_map_handle);
+		pr_debug("%s:ab->phys[%pK]bufadd[0x%x]token[0x%x]
+			 buf_id[0x%x]buf_size[0x%x]mmaphdl[0x%x]"
+			 , __func__,
+			 &ab->phys,
+			 write.buf_addr_lsw,
+			 write.hdr.token,
+			 write.seq_id,
+			 write.buf_size,
+			 write.mem_map_handle);
 
 		rc = apr_send_pkt(ac->apr, (uint32_t *) &write);
 		if (rc < 0) {
diff --git a/sound/soc/msm/qdsp6v2/q6core.c b/sound/soc/msm/qdsp6v2/q6core.c
index 917e1de3f0c5..a8fe2b7935cc 100644
--- a/sound/soc/msm/qdsp6v2/q6core.c
+++ b/sound/soc/msm/qdsp6v2/q6core.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2014, 2016 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -188,7 +188,7 @@ void ocm_core_open(void)
 	if (q6core_lcl.core_handle_q == NULL)
 		q6core_lcl.core_handle_q = apr_register("ADSP", "CORE",
 					aprv2_core_fn_q, 0xFFFFFFFF, NULL);
-	pr_debug("%s: Open_q %p\n", __func__, q6core_lcl.core_handle_q);
+	pr_debug("%s: Open_q %pK\n", __func__, q6core_lcl.core_handle_q);
 	if (q6core_lcl.core_handle_q == NULL)
 		pr_err("%s: Unable to register CORE\n", __func__);
 }
@@ -340,8 +340,8 @@ int core_dts_eagle_set(int size, char *data)
 
 	pr_debug("DTS_EAGLE_CORE - %s\n", __func__);
 	if (size <= 0 || !data) {
-		pr_err("DTS_EAGLE_CORE - %s: invalid size %i or pointer %p.\n",
-			__func__, size, data);
+		pr_err("DTS_EAGLE_CORE - %s: invalid size %i or pointer %pK.\n",
+		       __func__, size, data);
 		return -EINVAL;
 	}
 
@@ -386,8 +386,8 @@ int core_dts_eagle_get(int id, int size, char *data)
 
 	pr_debug("DTS_EAGLE_CORE - %s\n", __func__);
 	if (size <= 0 || !data) {
-		pr_err("DTS_EAGLE_CORE - %s: invalid size %i or pointer %p.\n",
-			__func__, size, data);
+		pr_err("DTS_EAGLE_CORE - %s: invalid size %i or pointer %pK.\n",
+		       __func__, size, data);
 		return -EINVAL;
 	}
 	ocm_core_open();
diff --git a/sound/soc/msm/qdsp6v2/q6lsm.c b/sound/soc/msm/qdsp6v2/q6lsm.c
index c1c4fd431e0a..49f54571bbfc 100644
--- a/sound/soc/msm/qdsp6v2/q6lsm.c
+++ b/sound/soc/msm/qdsp6v2/q6lsm.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2015, Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2016, Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -134,8 +134,8 @@ static int q6lsm_callback(struct apr_client_data *data, void *priv)
 	uint32_t *payload;
 
 	if (!client || !data) {
-		pr_err("%s: client %p data %p\n",
-			__func__, client, data);
+		pr_err("%s: client %pK data %pK\n",
+		       __func__, client, data);
 		WARN_ON(1);
 		return -EINVAL;
 	}
@@ -854,8 +854,8 @@ int q6lsm_register_sound_model(struct lsm_client *client,
 	rmb();
 	cmd.mem_map_handle = client->sound_model.mem_map_handle;
 
-	pr_debug("%s: addr %pa, size %d, handle 0x%x\n", __func__,
-		&client->sound_model.phys, cmd.model_size, cmd.mem_map_handle);
+	pr_debug("%s: addr %pK, size %d, handle 0x%x\n", __func__,
+		 &client->sound_model.phys, cmd.model_size, cmd.mem_map_handle);
 	rc = q6lsm_apr_send_pkt(client, client->apr, &cmd, true, NULL);
 	if (rc)
 		pr_err("%s: Failed cmd op[0x%x]rc[%d]\n", __func__,
@@ -928,8 +928,8 @@ static int q6lsm_memory_map_regions(struct lsm_client *client,
 	int rc;
 	int cmd_size = 0;
 
-	pr_debug("%s: dma_addr_p 0x%pa, dma_buf_sz %d, mmap_p 0x%p, session %d\n",
-		__func__, &dma_addr_p, dma_buf_sz, mmap_p,
+	pr_debug("%s: dma_addr_p 0x%pK, dma_buf_sz %d, mmap_p 0x%pK, session %d\n",
+		 __func__, &dma_addr_p, dma_buf_sz, mmap_p,
 		client->session);
 	if (CHECK_SESSION(client->session)) {
 		pr_err("%s: session[%d]", __func__, client->session);
@@ -1208,9 +1208,9 @@ int q6lsm_snd_model_buf_alloc(struct lsm_client *client, size_t len,
 	if (cal_block == NULL)
 		goto fail;
 
-	pr_debug("%s:Snd Model len = %zd cal size %zd phys addr %pa", __func__,
-		len, cal_block->cal_data.size,
-		&cal_block->cal_data.paddr);
+	pr_debug("%s:Snd Model len = %zd cal size %zd phys addr %pK", __func__,
+		 len, cal_block->cal_data.size,
+		 &cal_block->cal_data.paddr);
 	if (!cal_block->cal_data.paddr) {
 		pr_err("%s: No LSM calibration set for session", __func__);
 		rc = -EINVAL;
@@ -1263,8 +1263,8 @@ int q6lsm_snd_model_buf_alloc(struct lsm_client *client, size_t len,
 	memcpy((client->sound_model.data + pad_zero +
 		client->sound_model.size),
 	       (uint32_t *)cal_block->cal_data.kvaddr, client->lsm_cal_size);
-	pr_debug("%s: Copy cal start virt_addr %p phy_addr %pa\n"
-			 "Offset cal virtual Addr %p\n", __func__,
+	pr_debug("%s: Copy cal start virt_addr %pK phy_addr %pK\n"
+			 "Offset cal virtual Addr %pK\n", __func__,
 			 client->sound_model.data, &client->sound_model.phys,
 			 (pad_zero + client->sound_model.data +
 			 client->sound_model.size));
@@ -1582,7 +1582,7 @@ int q6lsm_lab_control(struct lsm_client *client, u32 enable)
 	u32 param_size;
 
 	if (!client) {
-		pr_err("%s: invalid param client %p\n", __func__, client);
+		pr_err("%s: invalid param client %pK\n", __func__, client);
 		return -EINVAL;
 	}
 	/* enable/disable lab on dsp */
@@ -1639,7 +1639,7 @@ int q6lsm_stop_lab(struct lsm_client *client)
 {
 	int rc = 0;
 	if (!client) {
-		pr_err("%s: invalid param client %p\n", __func__, client);
+		pr_err("%s: invalid param client %pK\n", __func__, client);
 		return -EINVAL;
 	}
 	rc = q6lsm_cmd(client, LSM_SESSION_CMD_EOB, true);
@@ -1652,8 +1652,8 @@ int q6lsm_read(struct lsm_client *client, struct lsm_cmd_read *read)
 {
 	int rc = 0;
 	if (!client || !read) {
-		pr_err("%s: Invalid params client %p read %p\n", __func__,
-			client, read);
+		pr_err("%s: Invalid params client %pK read %pK\n", __func__,
+		       client, read);
 		return -EINVAL;
 	}
 	pr_debug("%s: read call memmap handle %x address %x%x size %d\n",
@@ -1722,11 +1722,11 @@ int q6lsm_lab_buffer_alloc(struct lsm_client *client, bool alloc)
 			kfree(client->lab_buffer);
 			client->lab_buffer = NULL;
 		} else {
-			pr_debug("%s: Memory map handle %x phys %pa size %d\n",
-				__func__,
-				client->lab_buffer[0].mem_map_handle,
-				&client->lab_buffer[0].phys,
-				client->hw_params.buf_sz);
+			pr_debug("%s: Memory map handle %x phys %pK size %d\n",
+				 __func__,
+				 client->lab_buffer[0].mem_map_handle,
+				 &client->lab_buffer[0].phys,
+				 client->hw_params.buf_sz);
 			for (i = 0; i < client->hw_params.period_count; i++) {
 				client->lab_buffer[i].phys =
 				client->lab_buffer[0].phys +
diff --git a/sound/soc/msm/qdsp6v2/q6voice.c b/sound/soc/msm/qdsp6v2/q6voice.c
index 8b7c4fa7d373..b7a1801c5e6d 100644
--- a/sound/soc/msm/qdsp6v2/q6voice.c
+++ b/sound/soc/msm/qdsp6v2/q6voice.c
@@ -1,4 +1,4 @@
-/*  Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/*  Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -312,8 +312,8 @@ static struct voice_data *voice_get_session(u32 session_id)
 		break;
 	}
 
-	pr_debug("%s:session_id 0x%x session handle %p\n",
-		__func__, session_id, v);
+	pr_debug("%s:session_id 0x%x session handle %pK\n",
+		 __func__, session_id, v);
 
 	return v;
 }
@@ -2866,10 +2866,10 @@ static int voice_map_cal_memory(struct cal_block_data *cal_block,
 		cal_block->map_data.map_size,
 		VOC_CAL_MEM_MAP_TOKEN);
 	if (result < 0) {
-		pr_err("%s: Mmap did not work! addr = 0x%pa, size = %zd\n",
-			__func__,
-			&cal_block->cal_data.paddr,
-			cal_block->map_data.map_size);
+		pr_err("%s: Mmap did not work! addr = 0x%pK, size = %zd\n",
+		       __func__,
+		       &cal_block->cal_data.paddr,
+		       cal_block->map_data.map_size);
 
 		goto done_unlock;
 	}
@@ -2899,10 +2899,10 @@ static int remap_cal_data(struct cal_block_data *cal_block,
 			goto done;
 		}
 	} else {
-		pr_debug("%s:  Cal block 0x%pa, size %zd already mapped. Q6 map handle = %d\n",
-			__func__, &cal_block->cal_data.paddr,
-			cal_block->map_data.map_size,
-			cal_block->map_data.q6map_handle);
+		pr_debug("%s:  Cal block 0x%pK, size %zd already mapped. Q6 map handle = %d\n",
+			 __func__, &cal_block->cal_data.paddr,
+			 cal_block->map_data.map_size,
+			 cal_block->map_data.q6map_handle);
 	}
 done:
 	return ret;
@@ -3097,10 +3097,10 @@ int voc_map_rtac_block(struct rtac_cal_block_data *cal_block)
 	if (!is_rtac_memory_allocated()) {
 		result = voice_alloc_rtac_mem_map_table();
 		if (result < 0) {
-			pr_err("%s: RTAC alloc mem map table did not work! addr = 0x%pa, size = %d\n",
-				__func__,
-				&cal_block->cal_data.paddr,
-				cal_block->map_data.map_size);
+			pr_err("%s: RTAC alloc mem map table did not work! addr = 0x%pK, size = %d\n",
+			       __func__,
+			       &cal_block->cal_data.paddr,
+			       cal_block->map_data.map_size);
 
 			goto done_unlock;
 		}
@@ -3112,10 +3112,10 @@ int voc_map_rtac_block(struct rtac_cal_block_data *cal_block)
 		cal_block->map_data.map_size,
 		VOC_RTAC_MEM_MAP_TOKEN);
 	if (result < 0) {
-		pr_err("%s: RTAC mmap did not work! addr = 0x%pa, size = %d\n",
-			__func__,
-			&cal_block->cal_data.paddr,
-			cal_block->map_data.map_size);
+		pr_err("%s: RTAC mmap did not work! addr = 0x%pK, size = %d\n",
+		       __func__,
+		       &cal_block->cal_data.paddr,
+		       cal_block->map_data.map_size);
 
 		free_rtac_map_table();
 		goto done_unlock;
@@ -4209,7 +4209,7 @@ int voc_start_record(uint32_t port_id, uint32_t set, uint32_t session_id)
 
 			break;
 		}
-		pr_debug("%s: port_id: %d, set: %d, v: %p\n",
+		pr_debug("%s: port_id: %d, set: %d, v: %pK\n",
 			 __func__, port_id, set, v);
 
 		mutex_lock(&v->lock);
@@ -6102,16 +6102,16 @@ static int voice_alloc_oob_shared_mem(void)
 		cnt++;
 	}
 
-	pr_debug("%s buf[0].data:[%p], buf[0].phys:[%pa], &buf[0].phys:[%p],\n",
+	pr_debug("%s buf[0].data:[%pK], buf[0].phys:[%pK], &buf[0].phys:[%pK],\n",
 		 __func__,
 		(void *)v->shmem_info.sh_buf.buf[0].data,
 		&v->shmem_info.sh_buf.buf[0].phys,
 		(void *)&v->shmem_info.sh_buf.buf[0].phys);
-	pr_debug("%s: buf[1].data:[%p], buf[1].phys[%pa], &buf[1].phys[%p]\n",
-		__func__,
-		(void *)v->shmem_info.sh_buf.buf[1].data,
-		&v->shmem_info.sh_buf.buf[1].phys,
-		(void *)&v->shmem_info.sh_buf.buf[1].phys);
+	pr_debug("%s: buf[1].data:[%pK], buf[1].phys[%pK], &buf[1].phys[%pK]\n",
+		 __func__,
+		 (void *)v->shmem_info.sh_buf.buf[1].data,
+		 &v->shmem_info.sh_buf.buf[1].phys,
+		 (void *)&v->shmem_info.sh_buf.buf[1].phys);
 
 	memset((void *)v->shmem_info.sh_buf.buf[0].data, 0, (bufsz * bufcnt));
 
@@ -6149,7 +6149,7 @@ static int voice_alloc_oob_mem_table(void)
 	}
 
 	v->shmem_info.memtbl.size = sizeof(struct vss_imemory_table_t);
-	pr_debug("%s data[%p]phys[%pa][%p]\n", __func__,
+	pr_debug("%s data[%pK]phys[%pK][%pK]\n", __func__,
 		 (void *)v->shmem_info.memtbl.data,
 		 &v->shmem_info.memtbl.phys,
 		 (void *)&v->shmem_info.memtbl.phys);
@@ -6399,7 +6399,7 @@ static int voice_alloc_cal_mem_map_table(void)
 	}
 
 	common.cal_mem_map_table.size = sizeof(struct vss_imemory_table_t);
-	pr_debug("%s: data %p phys %pa\n", __func__,
+	pr_debug("%s: data %pK phys %pK\n", __func__,
 		 common.cal_mem_map_table.data,
 		 &common.cal_mem_map_table.phys);
 
@@ -6426,7 +6426,7 @@ static int voice_alloc_rtac_mem_map_table(void)
 	}
 
 	common.rtac_mem_map_table.size = sizeof(struct vss_imemory_table_t);
-	pr_debug("%s: data %p phys %pa\n", __func__,
+	pr_debug("%s: data %pK phys %pK\n", __func__,
 		 common.rtac_mem_map_table.data,
 		 &common.rtac_mem_map_table.phys);
 
diff --git a/sound/soc/msm/qdsp6v2/rtac.c b/sound/soc/msm/qdsp6v2/rtac.c
index c4ea2e5034de..a0656b54fbff 100644
--- a/sound/soc/msm/qdsp6v2/rtac.c
+++ b/sound/soc/msm/qdsp6v2/rtac.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -172,7 +172,7 @@ int rtac_allocate_cal_buffer(uint32_t cal_type)
 	}
 
 	if (rtac_cal[cal_type].cal_data.paddr != 0) {
-		pr_err("%s: memory already allocated! cal_type %d, paddr 0x%pa\n",
+		pr_err("%s: memory already allocated! cal_type %d, paddr 0x%pK\n",
 		       __func__, cal_type, &rtac_cal[cal_type].cal_data.paddr);
 		result = -EPERM;
 		goto done;
@@ -191,11 +191,11 @@ int rtac_allocate_cal_buffer(uint32_t cal_type)
 		goto done;
 	}
 
-	pr_debug("%s: cal_type %d, paddr 0x%pa, kvaddr 0x%p, map_size 0x%x\n",
-		__func__, cal_type,
-		&rtac_cal[cal_type].cal_data.paddr,
-		rtac_cal[cal_type].cal_data.kvaddr,
-		rtac_cal[cal_type].map_data.map_size);
+	pr_debug("%s: cal_type %d, paddr 0x%pK, kvaddr 0x%pK, map_size 0x%x\n",
+		 __func__, cal_type,
+		 &rtac_cal[cal_type].cal_data.paddr,
+		 rtac_cal[cal_type].cal_data.kvaddr,
+		 rtac_cal[cal_type].map_data.map_size);
 done:
 	return result;
 }
@@ -221,7 +221,7 @@ int rtac_free_cal_buffer(uint32_t cal_type)
 	result = msm_audio_ion_free(rtac_cal[cal_type].map_data.ion_client,
 				rtac_cal[cal_type].map_data.ion_handle);
 	if (result < 0) {
-		pr_err("%s: ION free for RTAC failed! cal_type %d, paddr 0x%pa\n",
+		pr_err("%s: ION free for RTAC failed! cal_type %d, paddr 0x%pK\n",
 		       __func__, cal_type, &rtac_cal[cal_type].cal_data.paddr);
 		goto done;
 	}
@@ -652,7 +652,7 @@ static int get_voice_index(u32 mode, u32 handle)
 /* ADM APR */
 void rtac_set_adm_handle(void *handle)
 {
-	pr_debug("%s: handle = %p\n", __func__, handle);
+	pr_debug("%s: handle = %pK\n", __func__, handle);
 
 	mutex_lock(&rtac_adm_apr_mutex);
 	rtac_adm_apr_data.apr_handle = handle;
@@ -710,7 +710,7 @@ u32 send_adm_apr(void *buf, u32 opcode)
 
 	if (copy_from_user(&user_buf_size, (void *)buf,
 						sizeof(user_buf_size))) {
-		pr_err("%s: Copy from user failed! buf = 0x%p\n",
+		pr_err("%s: Copy from user failed! buf = 0x%pK\n",
 		       __func__, buf);
 		goto done;
 	}
@@ -805,9 +805,9 @@ u32 send_adm_apr(void *buf, u32 opcode)
 	memcpy(rtac_adm_buffer, &adm_params, sizeof(adm_params));
 	atomic_set(&rtac_adm_apr_data.cmd_state, 1);
 
-	pr_debug("%s: Sending RTAC command ioctl 0x%x, paddr 0x%pa\n",
-		__func__, opcode,
-		&rtac_cal[ADM_RTAC_CAL].cal_data.paddr);
+	pr_debug("%s: Sending RTAC command ioctl 0x%x, paddr 0x%pK\n",
+		 __func__, opcode,
+		 &rtac_cal[ADM_RTAC_CAL].cal_data.paddr);
 
 	result = apr_send_pkt(rtac_adm_apr_data.apr_handle,
 					(uint32_t *)rtac_adm_buffer);
@@ -916,7 +916,7 @@ u32 send_rtac_asm_apr(void *buf, u32 opcode)
 
 	if (copy_from_user(&user_buf_size, (void *)buf,
 						sizeof(user_buf_size))) {
-		pr_err("%s: Copy from user failed! buf = 0x%p\n",
+		pr_err("%s: Copy from user failed! buf = 0x%pK\n",
 		       __func__, buf);
 		goto done;
 	}
@@ -1011,9 +1011,9 @@ u32 send_rtac_asm_apr(void *buf, u32 opcode)
 	memcpy(rtac_asm_buffer, &asm_params, sizeof(asm_params));
 	atomic_set(&rtac_asm_apr_data[session_id].cmd_state, 1);
 
-	pr_debug("%s: Sending RTAC command ioctl 0x%x, paddr 0x%pa\n",
-		__func__, opcode,
-		&rtac_cal[ASM_RTAC_CAL].cal_data.paddr);
+	pr_debug("%s: Sending RTAC command ioctl 0x%x, paddr 0x%pK\n",
+		 __func__, opcode,
+		 &rtac_cal[ASM_RTAC_CAL].cal_data.paddr);
 
 	result = apr_send_pkt(rtac_asm_apr_data[session_id].apr_handle,
 				(uint32_t *)rtac_asm_buffer);
@@ -1143,7 +1143,7 @@ static u32 send_rtac_afe_apr(void *buf, uint32_t opcode)
 
 	if (copy_from_user(&user_afe_buf, (void *)buf,
 		sizeof(struct rtac_afe_user_data))) {
-		pr_err("%s: Copy from user failed! buf = 0x%p\n",
+		pr_err("%s: Copy from user failed! buf = 0x%pK\n",
 		       __func__, buf);
 		goto done;
 	}
@@ -1251,9 +1251,9 @@ static u32 send_rtac_afe_apr(void *buf, uint32_t opcode)
 
 	atomic_set(&rtac_afe_apr_data.cmd_state, 1);
 
-	pr_debug("%s: Sending RTAC command ioctl 0x%x, paddr 0x%pa\n",
-		__func__, opcode,
-		&rtac_cal[AFE_RTAC_CAL].cal_data.paddr);
+	pr_debug("%s: Sending RTAC command ioctl 0x%x, paddr 0x%pK\n",
+		 __func__, opcode,
+		 &rtac_cal[AFE_RTAC_CAL].cal_data.paddr);
 
 	result = apr_send_pkt(rtac_afe_apr_data.apr_handle,
 					(uint32_t *)rtac_afe_buffer);
@@ -1367,7 +1367,7 @@ u32 send_voice_apr(u32 mode, void *buf, u32 opcode)
 
 	if (copy_from_user(&user_buf_size, (void *)buf,
 						sizeof(user_buf_size))) {
-		pr_err("%s: Copy from user failed! buf = 0x%p\n",
+		pr_err("%s: Copy from user failed! buf = 0x%pK\n",
 		       __func__, buf);
 		goto done;
 	}
@@ -1463,9 +1463,9 @@ u32 send_voice_apr(u32 mode, void *buf, u32 opcode)
 	memcpy(rtac_voice_buffer, &voice_params, sizeof(voice_params));
 	atomic_set(&rtac_voice_apr_data[mode].cmd_state, 1);
 
-	pr_debug("%s: Sending RTAC command ioctl 0x%x, paddr 0x%pa\n",
-		__func__, opcode,
-		&rtac_cal[VOICE_RTAC_CAL].cal_data.paddr);
+	pr_debug("%s: Sending RTAC command ioctl 0x%x, paddr 0x%pK\n",
+		 __func__, opcode,
+		 &rtac_cal[VOICE_RTAC_CAL].cal_data.paddr);
 
 	result = apr_send_pkt(rtac_voice_apr_data[mode].apr_handle,
 					(uint32_t *)rtac_voice_buffer);
