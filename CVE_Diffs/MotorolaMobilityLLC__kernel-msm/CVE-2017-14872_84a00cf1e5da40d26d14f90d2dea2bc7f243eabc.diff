MotorolaMobilityLLC__kernel-msm
commit 84a00cf1e5da40d26d14f90d2dea2bc7f243eabc
Author:     Tharun Kumar Merugu <mtharu@codeaurora.org>
AuthorDate: Mon May 14 11:14:03 2018 +0530
Commit:     Jignesh Patel <jignesh@motorola.com>
CommitDate: Wed Jun 6 23:17:50 2018 -0500

    msm: adsprpc: Fix race conditions on same buffer
    
    Variable map may pointing to the same buffer on race conditions
    in functions fastrpc_internal_mmap and fastrpc_internal_munmap,
    use mutex to avoid race conditions on same buffer.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2017-14872
    CRs-Fixed: 2062648
    BUG: 72957546
    
    Change-Id: I96ed884c44a36f574677ba3ba189dfbf2ce3751d
    Acked-by: Krishnaiah Tadakamalla <ktadakam@qti.qualcomm.com>
    Signed-off-by: Tharun Kumar Merugu <mtharu@codeaurora.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1174783
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/char/adsprpc.c b/drivers/char/adsprpc.c
index 0628506fa4d3..44e6639e4ed8 100644
--- a/drivers/char/adsprpc.c
+++ b/drivers/char/adsprpc.c
@@ -220,6 +220,7 @@ struct fastrpc_file {
 	int cid;
 	int ssrcount;
 	struct fastrpc_apps *apps;
+	struct mutex map_mutex;
 };
 
 static struct fastrpc_apps gfa;
@@ -1444,6 +1445,7 @@ static int fastrpc_internal_munmap(struct fastrpc_file *fl,
 	int err = 0;
 	struct fastrpc_mmap *map = NULL;
 
+	mutex_lock(&fl->map_mutex);
 	if (!fastrpc_mmap_remove(fl, ud->vaddrout, ud->size,
 			&map)) {
 		VERIFY(err, !fastrpc_munmap_on_dsp(fl, map));
@@ -1454,6 +1456,7 @@ static int fastrpc_internal_munmap(struct fastrpc_file *fl,
 bail:
 	if (err && map)
 		fastrpc_mmap_add(map);
+	mutex_unlock(&fl->map_mutex);
 	return err;
 }
 
@@ -1575,9 +1578,13 @@ static int fastrpc_internal_mmap(struct fastrpc_file *fl,
 {
 	struct fastrpc_mmap *map = NULL;
 	int err = 0;
+
+	mutex_lock(&fl->map_mutex);
 	if (!fastrpc_mmap_find(fl, ud->fd, (uintptr_t)ud->vaddrin, ud->size,
-			       ud->flags, &map))
+			       ud->flags, &map)){
+		mutex_unlock(&fl->map_mutex);
 		return 0;
+	}
 
 	VERIFY(err, !fastrpc_mmap_create(fl, ud->fd,
 			(uintptr_t)ud->vaddrin, ud->size, ud->flags, &map));
@@ -1590,6 +1597,7 @@ static int fastrpc_internal_mmap(struct fastrpc_file *fl,
  bail:
 	if (err && map)
 		fastrpc_mmap_free(map);
+	mutex_unlock(&fl->map_mutex);
 	return err;
 }
 
@@ -1639,6 +1647,9 @@ static int fastrpc_file_free(struct fastrpc_file *fl)
 
 static int fastrpc_device_release(struct inode *inode, struct file *file)
 {
+	struct fastrpc_file *fl = (struct fastrpc_file *)file->private_data;
+
+	mutex_destroy(&fl->map_mutex);
 	fastrpc_file_free((struct fastrpc_file *)file->private_data);
 	file->private_data = NULL;
 	return 0;
@@ -1656,7 +1667,7 @@ static int fastrpc_device_open(struct inode *inode, struct file *filp)
 		return err;
 
 	filp->private_data = fl;
-
+	mutex_init(&fl->map_mutex);
 	mutex_lock(&me->smd_mutex);
 
 	context_list_ctor(&fl->clst);
