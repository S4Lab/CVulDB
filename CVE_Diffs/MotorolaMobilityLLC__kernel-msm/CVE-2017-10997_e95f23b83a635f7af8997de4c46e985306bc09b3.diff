MotorolaMobilityLLC__kernel-msm
commit e95f23b83a635f7af8997de4c46e985306bc09b3
Author:     Tony Truong <truong@codeaurora.org>
AuthorDate: Fri Jan 6 14:03:03 2017 -0800
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Tue Sep 26 02:33:01 2017 -0500

    msm: pcie: add bounds check for debugfs register write
    
    Via debugfs nodes, users have the option to read and write to
    any PCIe register. To ensure clients do not access registers
    outside the PCIe range, add checks to validate the offset clients
    provide.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2017-10997
    CRs-Fixed: 1103077
    Bug: 33039685
    
    Change-Id: Ia35cd04c57f01c21a47962be596bca395b5ca247
    Signed-off-by: Tony Truong <truong@codeaurora.org>
    Reviewed-on: https://gerrit.mot.com/1043675
    SME-Granted: SME Approvals Granted
    SLTApproved: Slta Waiver
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/pci/host/pci-msm.c b/drivers/pci/host/pci-msm.c
index f6fc378cc479..0f4392374b37 100644
--- a/drivers/pci/host/pci-msm.c
+++ b/drivers/pci/host/pci-msm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1413,8 +1413,15 @@ static void msm_pcie_sel_debug_testcase(struct msm_pcie_dev_t *dev,
 			dev->res[base_sel - 1].base,
 			wr_offset, wr_mask, wr_value);
 
-		msm_pcie_write_reg_field(dev->res[base_sel - 1].base,
-			wr_offset, wr_mask, wr_value);
+		base_sel_size = resource_size(dev->res[base_sel - 1].resource);
+
+		if (wr_offset >  base_sel_size - 4 ||
+			msm_pcie_check_align(dev, wr_offset))
+			pr_alert("PCIe: RC%d: Invalid wr_offset: 0x%x. wr_offset should be no more than 0x%x\n",
+				dev->rc_idx, wr_offset, base_sel_size - 4);
+		else
+			msm_pcie_write_reg_field(dev->res[base_sel - 1].base,
+				wr_offset, wr_mask, wr_value);
 
 		break;
 	case 13: /* dump all registers of base_sel */
