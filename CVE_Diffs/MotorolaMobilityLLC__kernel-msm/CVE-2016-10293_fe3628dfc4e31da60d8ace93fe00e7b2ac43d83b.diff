MotorolaMobilityLLC__kernel-msm
commit fe3628dfc4e31da60d8ace93fe00e7b2ac43d83b
Author:     Yang Xu <yangxu@codeaurora.org>
AuthorDate: Thu Oct 29 17:46:15 2015 +0800
Commit:     Ashwin Kumar Pathmudi <jfxr63@motorola.com>
CommitDate: Thu Apr 13 05:46:19 2017 -0500

    msm: mdss: Add debugfs support for panel command data type
    
    Register debugfs node to read from and write to the panel command
    data type. The default data type is DCS_LONG_WRITE 0x39.
    
    Give following command in adb shell to read panel register:
            cat /sys/kernel/debug/mdp/panel_cmd_data_type
    To write panel command data type:
            echo "command_data_type" >
                    /sys/kernel/debug/mdp/panel_cmd_data_type
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2016-10293
    Change-Id: I6dbe5bccb3142e93400825eddf7f05180acfc710
    Signed-off-by: Yang Xu <yangxu@codeaurora.org>
    Reviewed-on: https://gerrit.mot.com/978200
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Bang Nguyen <bangnguyen@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/drivers/video/msm/mdss/mdss_debug.c b/drivers/video/msm/mdss/mdss_debug.c
index 1d0d588b249f..31b2037fedce 100644
--- a/drivers/video/msm/mdss/mdss_debug.c
+++ b/drivers/video/msm/mdss/mdss_debug.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2009-2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -126,12 +126,10 @@ static ssize_t panel_debug_base_reg_write(struct file *file,
 		const char __user *user_buf, size_t count, loff_t *ppos)
 {
 	struct mdss_debug_base *dbg = file->private_data;
-
-	u32 cnt, tmp, i;
-	u32 len = 0;
 	char buf[PANEL_TX_MAX_BUF] = {0x0};
-	char *p = NULL;
 	char reg[PANEL_TX_MAX_BUF] = {0x0};
+	u32 len = 0, step = 0, value = 0;
+	char *bufp;
 
 	struct mdss_data_type *mdata = mdss_res;
 	struct mdss_mdp_ctl *ctl = mdata->ctl_off + 0;
@@ -139,18 +137,13 @@ static ssize_t panel_debug_base_reg_write(struct file *file,
 	struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL;
 
 	struct dsi_cmd_desc dsi_write_cmd = {
-		{DTYPE_GEN_LWRITE, 1, 0, 0, 0, 0/*len*/}, reg};
+		{0/*data type*/, 1, 0, 0, 0, 0/* len */}, reg};
 	struct dcs_cmd_req cmdreq;
 
-	cmdreq.cmds = &dsi_write_cmd;
-	cmdreq.cmds_cnt = 1;
-	cmdreq.flags = CMD_REQ_COMMIT;
-	cmdreq.rlen = 0;
-	cmdreq.cb = NULL;
-
 	if (!dbg || !mdata)
 		return -ENODEV;
 
+	/* get command string from user */
 	if (count >= sizeof(buf))
 		return -EFAULT;
 
@@ -168,26 +161,38 @@ static ssize_t panel_debug_base_reg_write(struct file *file,
 
 	buf[count] = 0;	/* end of string */
 
-	len = count / 3;
-
+	bufp = buf;
+	while (sscanf(bufp, "%x%n", &value, &step) > 0) {
+		reg[len++] = value;
+		if (len >= PANEL_TX_MAX_BUF) {
+			pr_err("wrong input reg len\n");
+			return -EFAULT;
+		}
+		bufp += step;
+	}
 	if (len < PANEL_CMD_MIN_TX_COUNT) {
 		pr_err("wrong input reg len\n");
 		return -EFAULT;
 	}
 
-	for (i = 0; i < len; i++) {
-		p = buf + i * 3;
-		p[2] = 0;
-		pr_debug("p[%d] = %pK:%s\n", i, p, p);
-		cnt = sscanf(p, "%x", &tmp);
-		reg[i] = tmp;
-		pr_debug("reg[%d] = %x\n", i, (int)reg[i]);
-	}
+	/* put command to cmdlist */
+	dsi_write_cmd.dchdr.dtype = dbg->cmd_data_type;
+	dsi_write_cmd.dchdr.dlen = len;
+	dsi_write_cmd.payload = reg;
+
+	cmdreq.cmds = &dsi_write_cmd;
+	cmdreq.cmds_cnt = 1;
+	cmdreq.flags = CMD_REQ_COMMIT;
+	cmdreq.rlen = 0;
+	cmdreq.cb = NULL;
+
+	ctl = mdata->ctl_off + 0;
+	ctrl_pdata = container_of(ctl->panel_data,
+		struct mdss_dsi_ctrl_pdata, panel_data);
 
 	if (mdata->debug_inf.debug_enable_clock)
 		mdata->debug_inf.debug_enable_clock(1);
 
-	dsi_write_cmd.dchdr.dlen = len;
 	mdss_dsi_cmdlist_put(ctrl_pdata, &cmdreq);
 
 	if (mdata->debug_inf.debug_enable_clock)
@@ -281,7 +286,7 @@ int panel_debug_register_base(const char *name, void __iomem *base,
 	struct mdss_data_type *mdata = mdss_res;
 	struct mdss_debug_data *mdd;
 	struct mdss_debug_base *dbg;
-	struct dentry *ent_off, *ent_reg;
+	struct dentry *ent_off, *ent_reg, *ent_type;
 	char dn[PANEL_DATA_NODE_LEN] = "";
 	int prefix_len = 0;
 
@@ -298,10 +303,20 @@ int panel_debug_register_base(const char *name, void __iomem *base,
 	dbg->max_offset = max_offset;
 	dbg->off = 0x0a;
 	dbg->cnt = 0x01;
+	dbg->cmd_data_type = DTYPE_DCS_LWRITE;
 
 	if (name)
 		prefix_len = snprintf(dn, sizeof(dn), "%s_", name);
 
+	strlcpy(dn + prefix_len, "cmd_data_type", sizeof(dn) - prefix_len);
+	ent_type = debugfs_create_x8(dn, 0644, mdd->root,
+		(u8 *)&dbg->cmd_data_type);
+
+	if (IS_ERR_OR_NULL(ent_type)) {
+		pr_err("debugfs_create_file: data_type fail\n");
+		goto type_fail;
+	}
+
 	strlcpy(dn + prefix_len, "off", sizeof(dn) - prefix_len);
 	ent_off = debugfs_create_file(dn, 0644, mdd->root,
 					dbg, &panel_off_fops);
@@ -322,9 +337,12 @@ int panel_debug_register_base(const char *name, void __iomem *base,
 	list_add(&dbg->head, &mdd->base_list);
 
 	return 0;
+
 reg_fail:
 	debugfs_remove(ent_off);
 off_fail:
+	debugfs_remove(ent_type);
+type_fail:
 	kfree(dbg);
 	return -ENODEV;
 }
diff --git a/drivers/video/msm/mdss/mdss_debug.h b/drivers/video/msm/mdss/mdss_debug.h
index ef665e752dc4..1bb54d2fbacc 100644
--- a/drivers/video/msm/mdss/mdss_debug.h
+++ b/drivers/video/msm/mdss/mdss_debug.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2014, 2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -49,6 +49,7 @@ struct mdss_debug_base {
 	void __iomem *base;
 	size_t off;
 	size_t cnt;
+	u8 cmd_data_type;
 	size_t max_offset;
 	char *buf;
 	size_t buf_len;
