MotorolaMobilityLLC__kernel-msm
commit d4f220107d199539b33e7dae2a9036a6b76ea925
Author:     Divya Ponnusamy <pdivya@codeaurora.org>
AuthorDate: Fri May 6 13:24:37 2016 -0600
Commit:     Zhao Xuewen <zhaoxuewen@huawei.com>
CommitDate: Wed Jul 6 10:26:18 2016 +0800

    msm: kgsl: Avoid race condition in ioctl_syncsource_destroy
    
    If the ioctl syncsource_destroy is accessed by parallel
    threads, where the spinlock is acquired by threads after
    getting syncsource, then the simultaneous processes try
    to remove the already destroyed syncsource->refcount by
    the first thread that acquires this spinlock. This leads
    to race condition while removing syncsource->idr.
    
    Avoid separate lock inside getting syncsource, instead
    acquire spinlock before we get the syncsource in
    destroy ioctl so that the threads access the spinlock
    and operate on syncsource without use-after-free issue.
    
    CVE:CVE-2016-2503 Bug:ANDROID-28084795
    
    Change-Id: I6add3800c40cd09f6e6e0cf2720e69059bd83cbc
    Signed-off-by: Divya Ponnusamy <pdivya@codeaurora.org>

diff --git a/drivers/gpu/msm/kgsl_sync.c b/drivers/gpu/msm/kgsl_sync.c
index b4097a7b986f..ef19d4303189 100644
--- a/drivers/gpu/msm/kgsl_sync.c
+++ b/drivers/gpu/msm/kgsl_sync.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -402,19 +402,23 @@ long kgsl_ioctl_syncsource_create(struct kgsl_device_private *dev_priv,
 		goto out;
 	}
 
+	kref_init(&syncsource->refcount);
+	syncsource->private = private;
+
+	idr_preload(GFP_KERNEL);
 	mutex_lock(&private->process_private_mutex);
 	id = idr_alloc(&private->syncsource_idr, syncsource, 1, 0, GFP_KERNEL);
 	if (id > 0) {
-		kref_init(&syncsource->refcount);
 		syncsource->id = id;
-		syncsource->private = private;
-
 		param->id = id;
 		ret = 0;
 	} else {
 		ret = id;
 	}
+
 	mutex_unlock(&private->process_private_mutex);
+	idr_preload_end();
+
 out:
 	if (ret) {
 		if (syncsource && syncsource->oneshot)
@@ -472,25 +476,23 @@ long kgsl_ioctl_syncsource_destroy(struct kgsl_device_private *dev_priv,
 {
 	struct kgsl_syncsource_destroy *param = data;
 	struct kgsl_syncsource *syncsource = NULL;
-	struct kgsl_process_private *private;
-
-	syncsource = kgsl_syncsource_get(dev_priv->process_priv,
-				     param->id);
+	struct kgsl_process_private *private = dev_priv->process_priv;
 
-	if (syncsource == NULL)
-		return -EINVAL;
+	mutex_lock(&private->process_private_mutex);
+	syncsource = idr_find(&private->syncsource_idr, param->id);
 
-	private = syncsource->private;
+	if (syncsource) {
+		idr_remove(&private->syncsource_idr, param->id);
+		syncsource->id = 0;
+	}
 
-	mutex_lock(&private->process_private_mutex);
-	idr_remove(&private->syncsource_idr, param->id);
-	syncsource->id = 0;
 	mutex_unlock(&private->process_private_mutex);
 
+	if (syncsource == NULL)
+		return -EINVAL;
+
 	/* put reference from syncsource creation */
 	kgsl_syncsource_put(syncsource);
-	/* put reference from getting the syncsource above */
-	kgsl_syncsource_put(syncsource);
 	return 0;
 }
 
