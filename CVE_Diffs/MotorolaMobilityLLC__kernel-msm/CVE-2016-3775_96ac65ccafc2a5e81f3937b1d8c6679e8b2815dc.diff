MotorolaMobilityLLC__kernel-msm
commit 96ac65ccafc2a5e81f3937b1d8c6679e8b2815dc
Author:     Greg Kroah-Hartman <gregkh@linuxfoundation.org>
AuthorDate: Fri Feb 19 17:36:21 2016 -0800
Commit:     Zhao Xuewen <zhaoxuewen@huawei.com>
CommitDate: Wed Jul 6 10:15:43 2016 +0800

    AIO: properly check iovec sizes
    
    In Linus's tree, the iovec code has been reworked massively, but in
    older kernels the AIO layer should be checking this before passing the
    request on to other layers.
    
    Many thanks to Ben Hawkes of Google Project Zero for pointing out the
    issue.
    
    CVE:CVE-2016-3775 Bug:ANDROID-28588279
    
    Reported-by: Ben Hawkes <hawkes@google.com>
    Acked-by: Benjamin LaHaise <bcrl@kvack.org>
    Tested-by: Willy Tarreau <w@1wt.eu>
    [backported to 3.10 - willy]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/fs/aio.c b/fs/aio.c
index ebd06fd0de89..032b4d16eea8 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -977,12 +977,17 @@ static ssize_t aio_setup_vectored_rw(int rw, struct kiocb *kiocb, bool compat)
 
 static ssize_t aio_setup_single_vector(int rw, struct kiocb *kiocb)
 {
-	if (unlikely(!access_ok(!rw, kiocb->ki_buf, kiocb->ki_nbytes)))
-		return -EFAULT;
+	size_t len = kiocb->ki_nbytes;
+
+	if (len > MAX_RW_COUNT)
+		len = MAX_RW_COUNT;
+
+	if (unlikely(!access_ok(!rw, kiocb->ki_buf, len)))
+                return -EFAULT;
 
 	kiocb->ki_iovec = &kiocb->ki_inline_vec;
 	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
-	kiocb->ki_iovec->iov_len = kiocb->ki_nbytes;
+	kiocb->ki_iovec->iov_len = len;
 	kiocb->ki_nr_segs = 1;
 	return 0;
 }
