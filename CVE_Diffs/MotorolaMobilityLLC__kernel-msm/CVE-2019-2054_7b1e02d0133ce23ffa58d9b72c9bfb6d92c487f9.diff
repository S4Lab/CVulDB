MotorolaMobilityLLC__kernel-msm
commit 7b1e02d0133ce23ffa58d9b72c9bfb6d92c487f9
Author:     Kees Cook <keescook@chromium.org>
AuthorDate: Wed Aug 10 16:28:09 2016 -0700
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Sat May 18 21:44:40 2019 -0500

    seccomp: Fix tracer exit notifications during fatal signals
    
    This fixes a ptrace vs fatal pending signals bug as manifested in
    seccomp now that seccomp was reordered to happen after ptrace. The
    short version is that seccomp should not attempt to call do_exit()
    while fatal signals are pending under a tracer. The existing code was
    trying to be as defensively paranoid as possible, but it now ends up
    confusing ptrace. Instead, the syscall can just be skipped (which solves
    the original concern that the do_exit() was addressing) and normal signal
    handling, tracer notification, and process death can happen.
    
    Paraphrasing from the original bug report:
    
    If a tracee task is in a PTRACE_EVENT_SECCOMP trap, or has been resumed
    after such a trap but not yet been scheduled, and another task in the
    thread-group calls exit_group(), then the tracee task exits without the
    ptracer receiving a PTRACE_EVENT_EXIT notification. Test case here:
    https://gist.github.com/khuey/3c43ac247c72cef8c956ca73281c9be7
    
    The bug happens because when __seccomp_filter() detects
    fatal_signal_pending(), it calls do_exit() without dequeuing the fatal
    signal. When do_exit() sends the PTRACE_EVENT_EXIT notification and
    that task is descheduled, __schedule() notices that there is a fatal
    signal pending and changes its state from TASK_TRACED to TASK_RUNNING.
    That prevents the ptracer's waitpid() from returning the ptrace event.
    A more detailed analysis is here:
    https://github.com/mozilla/rr/issues/1762#issuecomment-237396255.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-2054
    BUG: 119769499
    
    Change-Id: Iac4c87a813e89ac70cb3d8f52c54bb58b186b6bd
    Reported-by: Robert O'Callahan <robert@ocallahan.org>
    Reported-by: Kyle Huey <khuey@kylehuey.com>
    Tested-by: Kyle Huey <khuey@kylehuey.com>
    Fixes: 93e35efb8de4 ("x86/ptrace: run seccomp after ptrace")
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: James Morris <james.l.morris@oracle.com>
    Reviewed-on: https://gerrit.mot.com/1334267
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Shi-Yong Li <a22381@motorola.com>
    Reviewed-by: Ling Jin <lingjin@motorola.com>
    Submit-Approved: Jira Key

diff --git a/kernel/seccomp.c b/kernel/seccomp.c
index 3279fb1967a6..77274e8d7144 100644
--- a/kernel/seccomp.c
+++ b/kernel/seccomp.c
@@ -650,12 +650,16 @@ static int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,
 		ptrace_event(PTRACE_EVENT_SECCOMP, data);
 		/*
 		 * The delivery of a fatal signal during event
-		 * notification may silently skip tracer notification.
-		 * Terminating the task now avoids executing a system
-		 * call that may not be intended.
+		 * notification may silently skip tracer notification,
+		 * which could leave us with a potentially unmodified
+		 * syscall that the tracer would have liked to have
+		 * changed. Since the process is about to die, we just
+		 * force the syscall to be skipped and let the signal
+		 * kill the process and correctly handle any tracer exit
+		 * notifications.
 		 */
 		if (fatal_signal_pending(current))
-			do_exit(SIGSYS);
+			goto skip;
 		/* Check if the tracer forced the syscall to be skipped. */
 		this_syscall = syscall_get_nr(current, task_pt_regs(current));
 		if (this_syscall < 0)
