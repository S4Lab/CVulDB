MotorolaMobilityLLC__kernel-msm
commit e1a2a5ff18af170a58ec60049d9ff1db5bb08d1f
Author:     ahmedsh <ahmedsh@codeaurora.org>
AuthorDate: Mon Jan 9 17:24:09 2017 -0500
Commit:     Xu Zhang <zhangxu21@lenovo.com>
CommitDate: Wed May 10 22:06:37 2017 -0500

    seemp: use local stack mem when encoding params
    
    Avoid race condition in driver when encoding param by
    reading contents from a local copy instead of msg buffer
    itself which can be mapped to user space.
    
    Mot-CRs-fixed:IKSIMP-2236
    CVE-fixed:CVE-2017-0462
    CRs-fixed:1102288
    
    Change-Id: I405ca6c7fcb0afa112e0851907b5dca805ac5411
    Signed-off-by: Ahmed Sheikh <ahmedsh@codeaurora.org>
    Signed-off-by: Amarendra Reddy <amarenr@motorola.com>
    Reviewed-on: https://gerrit.mot.com/953659
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>
    Reviewed-on: https://gerrit.mot.com/992763
    Reviewed-by: Xu Zhang <zhangxu21@lenovo.com>
    SLTApproved: Xu Zhang <zhangxu21@lenovo.com>
    Submit-Approved: Xu Zhang <zhangxu21@lenovo.com>

diff --git a/drivers/platform/msm/seemp_core/seemp_event_encoder.c b/drivers/platform/msm/seemp_core/seemp_event_encoder.c
index df56a84bc667..36901f5fbee7 100644
--- a/drivers/platform/msm/seemp_core/seemp_event_encoder.c
+++ b/drivers/platform/msm/seemp_core/seemp_event_encoder.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015, 2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -48,9 +48,15 @@ static void check_param_range(char *section_eq, bool param,
 
 void encode_seemp_params(struct seemp_logk_blk *blk)
 {
-	char *s = blk->payload.msg + 1;
+	struct seemp_logk_blk tmp;
+	char *s = 0;
+	char *msg_section_start = 0;
+	char *msg_section_eq = 0;
+	char *msg_s = 0;
 
-	blk->payload.msg[BLK_MAX_MSG_SZ - 1] = 0; /* zero-terminate */
+	memcpy(tmp.payload.msg, blk->payload.msg, BLK_MAX_MSG_SZ);
+	s = tmp.payload.msg + 1;
+	tmp.payload.msg[BLK_MAX_MSG_SZ - 1] = 0; /* zero-terminate */
 
 	while (true) {
 		char *section_start = s;
@@ -105,8 +111,13 @@ void encode_seemp_params(struct seemp_logk_blk *blk)
 			}
 		}
 
-		encode_seemp_section(section_start, section_eq, s, param,
-					numeric, id, numeric_value);
+		msg_section_start = blk->payload.msg + (section_start -
+				tmp.payload.msg);
+		msg_section_eq = blk->payload.msg + (section_eq -
+				tmp.payload.msg);
+		msg_s = blk->payload.msg + (s - tmp.payload.msg);
+		encode_seemp_section(msg_section_start, msg_section_eq,
+				msg_s, param, numeric, id, numeric_value);
 
 		if (*s == 0)
 			break;
