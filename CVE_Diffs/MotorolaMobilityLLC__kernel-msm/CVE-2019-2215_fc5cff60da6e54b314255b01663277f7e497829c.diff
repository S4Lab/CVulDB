MotorolaMobilityLLC__kernel-msm
commit fc5cff60da6e54b314255b01663277f7e497829c
Author:     Martijn Coenen <maco@android.com>
AuthorDate: Fri Jan 5 11:27:07 2018 +0100
Commit:     chenyt9 <chenyt9@lenovo.com>
CommitDate: Mon Dec 9 16:57:15 2019 +0800

    UPSTREAM: ANDROID: binder: remove waitqueue when thread exits.
    
    binder_poll() passes the thread->wait waitqueue that
    can be slept on for work. When a thread that uses
    epoll explicitly exits using BINDER_THREAD_EXIT,
    the waitqueue is freed, but it is never removed
    from the corresponding epoll data structure. When
    the process subsequently exits, the epoll cleanup
    code tries to access the waitlist, which results in
    a use-after-free.
    
    Prevent this by using POLLFREE when the thread exits.
    
    (cherry picked from commit f5cb779ba16334b45ba8946d6bfa6d9834d1527f)
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-2215
    
    Change-Id: Ib34b1cbb8ab2192d78c3d9956b2f963a66ecad2e
    Signed-off-by: Martijn Coenen <maco@android.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: stable <stable@vger.kernel.org> # 4.14
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1433119
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index 9426d543cb61..e02a5410afb5 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -4531,6 +4531,18 @@ static int binder_thread_release(struct binder_proc *proc,
 		if (t)
 			spin_lock(&t->lock);
 	}
+
+	/*
+	 * If this thread used poll, make sure we remove the waitqueue
+	 * from any epoll data structures holding it with POLLFREE.
+	 * waitqueue_active() is safe to use here because we're holding
+	 * the inner lock.
+	 */
+	if ((thread->looper & BINDER_LOOPER_STATE_POLL) &&
+	    waitqueue_active(&thread->wait)) {
+		wake_up_poll(&thread->wait, POLLHUP | POLLFREE);
+	}
+
 	binder_inner_proc_unlock(thread->proc);
 
 	if (send_reply)
