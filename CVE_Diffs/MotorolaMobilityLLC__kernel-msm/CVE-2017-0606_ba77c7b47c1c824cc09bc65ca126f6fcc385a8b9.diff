MotorolaMobilityLLC__kernel-msm
commit ba77c7b47c1c824cc09bc65ca126f6fcc385a8b9
Author:     Banajit Goswami <bgoswami@codeaurora.org>
AuthorDate: Mon Apr 10 19:56:25 2017 -0700
Commit:     Jignesh Patel <jignesh@motorola.com>
CommitDate: Sun Jul 1 22:50:11 2018 -0500

    soc: q6dspv2: apr: fix client registration refcount
    
    Audio Packet Router (APR) is used by multiple audio services
    to communicate between APSS and ADSP. These audio services
    registers for service level APR communication (port 0xFFFFFFFF),
    or for session level APR communication (using port 0x101 etc.).
    The services might choose to call apr_register for any port at
    random. The expectation is that the refcounting for the number
    of ports registered with APR for any specific service, is handled
    irrespective of the order in which registrations are done. The
    current logic fails to handle the refcounting when apr_register
    is called for 0xFFFFFFFF before other session based ports. Fix
    this correctly using the service count (svc_cnt) variable in apr_svc.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2017-0606
    CRs-fixed: 2148210,2022490
    Bug: 34088848
    
    Change-Id: I2fcd1269facf24d509db0d90314e0d2545a2ad67
    Signed-off-by: Banajit Goswami <bgoswami@codeaurora.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1192689
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/soc/qcom/qdsp6v2/apr.c b/drivers/soc/qcom/qdsp6v2/apr.c
index 45ed3b53678b..81fdb8430981 100644
--- a/drivers/soc/qcom/qdsp6v2/apr.c
+++ b/drivers/soc/qcom/qdsp6v2/apr.c
@@ -466,19 +466,19 @@ struct apr_svc *apr_register(char *dest, char *svc_name, apr_fn svc_fn,
 			mutex_unlock(&svc->m_lock);
 			return NULL;
 		}
-		if (!svc->port_cnt && !svc->svc_cnt)
+		if (!svc->svc_cnt)
 			clnt->svc_cnt++;
 		svc->port_cnt++;
 		svc->port_fn[temp_port] = svc_fn;
 		svc->port_priv[temp_port] = priv;
+		svc->svc_cnt++;
 	} else {
 		if (!svc->fn) {
-			if (!svc->port_cnt && !svc->svc_cnt)
+			if (!svc->svc_cnt)
 				clnt->svc_cnt++;
 			svc->fn = svc_fn;
-			if (svc->port_cnt)
-				svc->svc_cnt++;
 			svc->priv = priv;
+			svc->svc_cnt++;
 		}
 	}
 
@@ -679,29 +679,28 @@ int apr_deregister(void *handle)
 	if (!handle)
 		return -EINVAL;
 
+	if (!svc->svc_cnt) {
+		pr_err("%s: svc already deregistered. svc = %pK\n",
+			__func__, svc);
+		return -EINVAL;
+	}
+
 	mutex_lock(&svc->m_lock);
 	dest_id = svc->dest_id;
 	client_id = svc->client_id;
 	clnt = &client[dest_id][client_id];
 
-	if (svc->port_cnt > 0 || svc->svc_cnt > 0) {
+	if (svc->svc_cnt > 0) {
 		if (svc->port_cnt)
 			svc->port_cnt--;
-		else if (svc->svc_cnt)
-			svc->svc_cnt--;
-		if (!svc->port_cnt && !svc->svc_cnt) {
+		svc->svc_cnt--;
+		if (!svc->svc_cnt) {
 			client[dest_id][client_id].svc_cnt--;
-			svc->need_reset = 0x0;
-		}
-	} else if (client[dest_id][client_id].svc_cnt > 0) {
-		client[dest_id][client_id].svc_cnt--;
-		if (!client[dest_id][client_id].svc_cnt) {
-			svc->need_reset = 0x0;
 			pr_debug("%s: service is reset %pK\n", __func__, svc);
 		}
 	}
 
-	if (!svc->port_cnt && !svc->svc_cnt) {
+	if (!svc->svc_cnt) {
 		svc->priv = NULL;
 		svc->id = 0;
 		svc->fn = NULL;
