MotorolaMobilityLLC__kernel-msm
commit 3f70087d3abd4c9048a123557e5eb66e8dff7749
Author:     Eric Dumazet <edumazet@google.com>
AuthorDate: Fri Dec 2 09:44:53 2016 -0800
Commit:     Carlos Pinho <cpinho@motorola.com>
CommitDate: Thu Mar 16 14:53:03 2017 -0500

    net: avoid signed overflows for SO_{SND|RCV}BUFFORCE
    
    CAP_NET_ADMIN users should not be allowed to set negative
    sk_sndbuf or sk_rcvbuf values, as it can lead to various memory
    corruptions, crashes, OOM...
    
    Note that before commit 82981930125a ("net: cleanups in
    sock_setsockopt()"), the bug was even more serious, since SO_SNDBUF
    and SO_RCVBUF were vulnerable.
    
    This needs to be backported to all known linux kernels.
    
    Again, many thanks to syzkaller team for discovering this gem.
    
    Mot-CRs-fixed:(CR)
    CVE-Fixed:CVE-2016-9793
    
    Change-Id: I9e0dc916dfd5ad095f11b9b4447fc8f77824f15d
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Andrey Konovalov <andreyknvl@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Reviewed-on: https://gerrit.mot.com/948934
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/net/core/sock.c b/net/core/sock.c
index 2155eaa86b32..0f3567be54c3 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -727,7 +727,7 @@ int sock_setsockopt(struct socket *sock, int level, int optname,
 		val = min_t(u32, val, sysctl_wmem_max);
 set_sndbuf:
 		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
-		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
+		sk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);
 		/* Wake up sending tasks if we upped the value. */
 		sk->sk_write_space(sk);
 		break;
@@ -763,7 +763,7 @@ set_rcvbuf:
 		 * returning the value we actually used in getsockopt
 		 * is the most desirable behavior.
 		 */
-		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
+		sk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);
 		break;
 
 	case SO_RCVBUFFORCE:
