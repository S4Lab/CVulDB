MotorolaMobilityLLC__kernel-msm
commit 136c99c6bce11fb2ff5eb19f8db538def0237206
Author:     Alexander Filonenko <alexf@motorola.com>
AuthorDate: Mon Aug 8 15:14:50 2016 -0500
Commit:     PDO SCM Team <hudsoncm@motorola.com>
CommitDate: Tue Dec 20 13:03:56 2016 -0600

    input: synaptics: fix stack overflow
    
    Implement a fix for stack overflow CVE-2016-3865/A-28799389.
    
    Change-Id: I213a65bcd77dbc319919417a760efcf0005d3dbb
    Signed-off-by: Alexander Filonenko <alexf@motorola.com>
    Reviewed-on: http://gerrit.mot.com/891757
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>
    Signed-off-by: amarenr <amarenr@motorola.com>
    Reviewed-on: https://gerrit.mot.com/927875
    Reviewed-by: Konstantin Makariev <kmakariev@motorola.com>

diff --git a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_rmi_dev.c b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_rmi_dev.c
index 9d61eb110e2f..a4f59f164c75 100644
--- a/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_rmi_dev.c
+++ b/drivers/input/touchscreen/synaptics_dsx/synaptics_dsx_rmi_dev.c
@@ -34,6 +34,8 @@
 #define SYSFS_FOLDER_NAME "rmidev"
 #define DEV_NUMBER 1
 #define REG_ADDR_LIMIT 0xFFFF
+#define MAX_READ_WRITE_SIZE 4096
+#define MIN_READ_WRITE_BUF_SIZE 256
 
 static ssize_t rmidev_sysfs_data_show(struct file *data_file,
 		struct kobject *kobj, struct bin_attribute *attributes,
@@ -67,6 +69,8 @@ struct rmidev_data {
 	struct class *device_class;
 	struct mutex file_mutex;
 	struct rmidev_handle *rmi_dev;
+	unsigned char *tmpbuf;
+	size_t tmpbuf_size;
 };
 
 static struct bin_attribute attr_data = {
@@ -335,6 +339,32 @@ clean_up:
 	return newpos;
 }
 
+static int alloc_tmpbuf(struct file *filp, size_t count)
+{
+	struct rmidev_data *dev_data = filp->private_data;
+
+	if (dev_data->tmpbuf_size != 0) {
+		kfree(dev_data->tmpbuf);
+		dev_data->tmpbuf = NULL;
+		dev_data->tmpbuf_size = 0;
+	}
+
+	if (count > MAX_READ_WRITE_SIZE) {
+		pr_err("%s: Max buffer size exceeded\n", __func__);
+		return 1;
+	}
+
+	if (count < MIN_READ_WRITE_BUF_SIZE)
+		count = MIN_READ_WRITE_BUF_SIZE;
+
+	dev_data->tmpbuf = kzalloc(count, GFP_KERNEL);
+	if (!dev_data->tmpbuf)
+		return 1;
+
+	dev_data->tmpbuf_size = count;
+	return 0;
+}
+
 /*
  * rmidev_read: - use to read data from rmi device
  *
@@ -347,7 +377,6 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 		size_t count, loff_t *f_pos)
 {
 	ssize_t retval;
-	unsigned char *tmpbuf;
 	struct rmidev_data *dev_data = filp->private_data;
 
 	if (IS_ERR(dev_data)) {
@@ -361,27 +390,25 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
-	tmpbuf = kzalloc(count + 1, GFP_KERNEL);
-	if (!tmpbuf)
-		return -ENOMEM;
-
 	mutex_lock(&(dev_data->file_mutex));
 
+	if (dev_data->tmpbuf_size < count && alloc_tmpbuf(filp, count) != 0)
+		return -ENOMEM;
+
 	retval = synaptics_rmi4_reg_read(rmidev->rmi4_data,
 			*f_pos,
-			tmpbuf,
+			dev_data->tmpbuf,
 			count);
 	if (retval < 0)
 		goto clean_up;
 
-	if (copy_to_user(buf, tmpbuf, count))
+	if (copy_to_user(buf, dev_data->tmpbuf, count))
 		retval = -EFAULT;
 	else
 		*f_pos += retval;
 
 clean_up:
 	mutex_unlock(&(dev_data->file_mutex));
-	kfree(tmpbuf);
 	return retval;
 }
 
@@ -397,7 +424,6 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 		size_t count, loff_t *f_pos)
 {
 	ssize_t retval;
-	unsigned char *tmpbuf;
 	struct rmidev_data *dev_data = filp->private_data;
 
 	if (IS_ERR(dev_data)) {
@@ -411,25 +437,27 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
-	tmpbuf = kzalloc(count + 1, GFP_KERNEL);
-	if (!tmpbuf)
-		return -ENOMEM;
+	mutex_lock(&(dev_data->file_mutex));
+
+	if (dev_data->tmpbuf_size < count && alloc_tmpbuf(filp, count) != 0) {
+		retval = -ENOMEM;
+		goto clean_up;
+	}
 
-	if (copy_from_user(tmpbuf, buf, count)) {
-		kfree(tmpbuf);
-		return -EFAULT;
+	if (copy_from_user(dev_data->tmpbuf, buf, count)) {
+		retval = -EFAULT;
+		goto clean_up;
 	}
-	mutex_lock(&(dev_data->file_mutex));
 
 	retval = synaptics_rmi4_reg_write(rmidev->rmi4_data,
 			*f_pos,
-			tmpbuf,
+			dev_data->tmpbuf,
 			count);
 	if (retval >= 0)
 		*f_pos += retval;
 
+clean_up:
 	mutex_unlock(&(dev_data->file_mutex));
-	kfree(tmpbuf);
 	return retval;
 }
 
diff --git a/drivers/input/touchscreen/synaptics_dsx_rmi_dev.c b/drivers/input/touchscreen/synaptics_dsx_rmi_dev.c
index d230f63a4b76..1868d12edf07 100644
--- a/drivers/input/touchscreen/synaptics_dsx_rmi_dev.c
+++ b/drivers/input/touchscreen/synaptics_dsx_rmi_dev.c
@@ -33,6 +33,8 @@
 #define DEVICE_CLASS_NAME "rmidev"
 #define DEV_NUMBER 1
 #define REG_ADDR_LIMIT 0xFFFF
+#define MAX_READ_WRITE_SIZE 8096
+#define MIN_READ_WRITE_BUF_SIZE 256
 
 static ssize_t rmidev_sysfs_data_show(struct file *data_file,
 		struct kobject *kobj, struct bin_attribute *attributes,
@@ -74,7 +76,8 @@ struct rmidev_data {
 	struct class *device_class;
 	struct mutex file_mutex;
 	struct rmidev_handle *rmi_dev;
-	struct temp_buffer data_buf;
+	unsigned char *tmpbuf;
+	size_t tmpbuf_size;
 };
 
 static struct bin_attribute attr_data = {
@@ -315,6 +318,32 @@ clean_up:
 	return newpos;
 }
 
+static int alloc_tmpbuf(struct file *filp, size_t count)
+{
+	struct rmidev_data *dev_data = filp->private_data;
+
+	if (dev_data->tmpbuf_size != 0)	{
+		kfree(dev_data->tmpbuf);
+		dev_data->tmpbuf = NULL;
+		dev_data->tmpbuf_size = 0;
+	}
+
+	if (count > MAX_READ_WRITE_SIZE) {
+		pr_err("%s: Max buffer size exceeded\n", __func__);
+		return 1;
+	}
+
+	if (count < MIN_READ_WRITE_BUF_SIZE)
+		count = MIN_READ_WRITE_BUF_SIZE;
+
+	dev_data->tmpbuf = kzalloc(count, GFP_KERNEL);
+	if (!dev_data->tmpbuf)
+		return 1;
+
+	dev_data->tmpbuf_size = count;
+	return 0;
+}
+
 /*
  * rmidev_read: - use to read data from rmi device
  *
@@ -328,7 +357,6 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 {
 	ssize_t retval;
 	struct rmidev_data *dev_data = filp->private_data;
-	struct temp_buffer *tb;
 
 	if (IS_ERR(dev_data)) {
 		pr_err("%s: Pointer of char device data is invalid", __func__);
@@ -341,22 +369,19 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
-	tb = &dev_data->data_buf;
 	mutex_lock(&(dev_data->file_mutex));
 
-	if (tb->buf_size < count && alloc_buffer(tb, count) != 0) {
-		retval = -ENOMEM;
-		goto clean_up;
-	}
+	if (dev_data->tmpbuf_size < count && alloc_tmpbuf(filp, count) != 0)
+		return -ENOMEM;
 
 	retval = rmidev->fn_ptr->read(rmidev->rmi4_data,
 			*f_pos,
-			tb->buf,
+			dev_data->tmpbuf,
 			count);
 	if (retval < 0)
 		goto clean_up;
 
-	if (copy_to_user(buf, tb->buf, count))
+	if (copy_to_user(buf, dev_data->tmpbuf, count))
 		retval = -EFAULT;
 	else
 		*f_pos += retval;
@@ -379,7 +404,6 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 {
 	ssize_t retval;
 	struct rmidev_data *dev_data = filp->private_data;
-	struct temp_buffer *tb;
 
 	if (IS_ERR(dev_data)) {
 		pr_err("%s: Pointer of char device data is invalid", __func__);
@@ -392,22 +416,21 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
-	tb = &dev_data->data_buf;
 	mutex_lock(&(dev_data->file_mutex));
 
-	if (tb->buf_size < count && alloc_buffer(tb, count) != 0) {
+	if (dev_data->tmpbuf_size < count && alloc_tmpbuf(filp, count) != 0) {
 		retval = -ENOMEM;
 		goto clean_up;
 	}
 
-	if (copy_from_user(tb->buf, buf, count)) {
+	if (copy_from_user(dev_data->tmpbuf, buf, count)) {
 		retval = -EFAULT;
 		goto clean_up;
 	}
 
 	retval = rmidev->fn_ptr->write(rmidev->rmi4_data,
 			*f_pos,
-			tb->buf,
+			dev_data->tmpbuf,
 			count);
 	if (retval >= 0)
 		*f_pos += retval;
diff --git a/drivers/input/touchscreen/synaptics_rmi_dev.c b/drivers/input/touchscreen/synaptics_rmi_dev.c
index ff4f426df7d5..af063646510d 100644
--- a/drivers/input/touchscreen/synaptics_rmi_dev.c
+++ b/drivers/input/touchscreen/synaptics_rmi_dev.c
@@ -34,6 +34,8 @@
 #define DEVICE_CLASS_NAME "rmidev"
 #define DEV_NUMBER 1
 #define REG_ADDR_LIMIT 0xFFFF
+#define MAX_READ_WRITE_SIZE 8096
+#define MIN_READ_WRITE_BUF_SIZE 256
 
 static ssize_t rmidev_sysfs_open_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
@@ -70,6 +72,8 @@ struct rmidev_data {
 	struct class *device_class;
 	struct mutex file_mutex;
 	struct rmidev_handle *rmi_dev;
+	unsigned char *tmpbuf;
+	size_t tmpbuf_size;
 };
 
 static struct device_attribute attrs[] = {
@@ -279,6 +283,32 @@ clean_up:
 	return newpos;
 }
 
+static int alloc_tmpbuf(struct file *filp, size_t count)
+{
+	struct rmidev_data *dev_data = filp->private_data;
+
+	if (dev_data->tmpbuf_size != 0) {
+		kfree(dev_data->tmpbuf);
+		dev_data->tmpbuf = NULL;
+		dev_data->tmpbuf_size = 0;
+	}
+
+	if (count > MAX_READ_WRITE_SIZE) {
+		pr_err("%s: Max buffer size exceeded\n", __func__);
+		return 1;
+	}
+
+	if (count < MIN_READ_WRITE_BUF_SIZE)
+		count = MIN_READ_WRITE_BUF_SIZE;
+
+	dev_data->tmpbuf = kzalloc(count, GFP_KERNEL);
+	if (!dev_data->tmpbuf)
+		return 1;
+
+	dev_data->tmpbuf_size = count;
+	return 0;
+}
+
 /*
  * rmidev_read: - use to read data from rmi device
  *
@@ -291,7 +321,6 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 		size_t count, loff_t *f_pos)
 {
 	ssize_t retval;
-	unsigned char *tmpbuf;
 	struct rmidev_data *dev_data = filp->private_data;
 
 	if (IS_ERR(dev_data)) {
@@ -305,27 +334,25 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
-	tmpbuf = kzalloc(count + 1, GFP_KERNEL);
-	if (!tmpbuf)
-		return -ENOMEM;
-
 	mutex_lock(&(dev_data->file_mutex));
 
+	if (dev_data->tmpbuf_size < count && alloc_tmpbuf(filp, count) != 0)
+		return -ENOMEM;
+
 	retval = rmidev->fn_ptr->read(rmidev->rmi4_data,
 			*f_pos,
-			tmpbuf,
+			dev_data->tmpbuf,
 			count);
 	if (retval < 0)
 		goto clean_up;
 
-	if (copy_to_user(buf, tmpbuf, count))
+	if (copy_to_user(buf, dev_data->tmpbuf, count))
 		retval = -EFAULT;
 	else
 		*f_pos += retval;
 
 clean_up:
 	mutex_unlock(&(dev_data->file_mutex));
-	kfree(tmpbuf);
 	return retval;
 }
 
@@ -341,7 +368,6 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 		size_t count, loff_t *f_pos)
 {
 	ssize_t retval;
-	unsigned char *tmpbuf;
 	struct rmidev_data *dev_data = filp->private_data;
 
 	if (IS_ERR(dev_data)) {
@@ -355,26 +381,27 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
-	tmpbuf = kzalloc(count + 1, GFP_KERNEL);
-	if (!tmpbuf)
-		return -ENOMEM;
+	mutex_lock(&(dev_data->file_mutex));
 
-	if (copy_from_user(tmpbuf, buf, count)) {
-		kfree(tmpbuf);
-		return -EFAULT;
+	if (dev_data->tmpbuf_size < count && alloc_tmpbuf(filp, count) != 0) {
+		retval = -ENOMEM;
+		goto clean_up;
 	}
 
-	mutex_lock(&(dev_data->file_mutex));
+	if (copy_from_user(dev_data->tmpbuf, buf, count)) {
+		retval = -EFAULT;
+		goto clean_up;
+	}
 
 	retval = rmidev->fn_ptr->write(rmidev->rmi4_data,
 			*f_pos,
-			tmpbuf,
+			dev_data->tmpbuf,
 			count);
 	if (retval >= 0)
 		*f_pos += retval;
 
+clean_up:
 	mutex_unlock(&(dev_data->file_mutex));
-	kfree(tmpbuf);
 	return retval;
 }
 
