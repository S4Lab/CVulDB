MotorolaMobilityLLC__kernel-msm
commit cfb9e825735b5fae9105b9650324045257c991bf
Author:     Jordan Crouse <jcrouse@codeaurora.org>
AuthorDate: Tue May 31 11:24:22 2016 -0600
Commit:     Ashwin Kumar Pathmudi <jfxr63@motorola.com>
CommitDate: Fri Jan 27 03:33:21 2017 -0600

    msm: kgsl: Reserve a context ID slot but don't populate immediately
    
    When creating a context allocate an ID but don't populate the slot
    with the context pointer until we are done setup up the rest of the
    process. This avoids a race if somebody tries to free the same
    identifier before the create operation is complete.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2016-8479
    
    Change-Id: Ic0dedbadca5b4cc4ce567afad48a33078b549439
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Ashwin Pathmudi <jfxr63@motorola.com>
    Reviewed-on: https://gerrit.mot.com/944627
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Patrick Auchter <auchter@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>

diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index 003746dbc5d6..614be4015ef7 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -516,21 +516,18 @@ void kgsl_context_dump(struct kgsl_context *context)
 EXPORT_SYMBOL(kgsl_context_dump);
 
 /* Allocate a new context ID */
-int _kgsl_get_context_id(struct kgsl_device *device,
-		struct kgsl_context *context)
+static int _kgsl_get_context_id(struct kgsl_device *device)
 {
 	int id;
 
 	idr_preload(GFP_KERNEL);
 	write_lock(&device->context_lock);
-	id = idr_alloc(&device->context_idr, context, 1,
+	/* Allocate the slot but don't put a pointer in it yet */
+	id = idr_alloc(&device->context_idr, NULL, 1,
 		KGSL_MEMSTORE_MAX, GFP_NOWAIT);
 	write_unlock(&device->context_lock);
 	idr_preload_end();
 
-	if (id > 0)
-		context->id = id;
-
 	return id;
 }
 
@@ -554,7 +551,7 @@ int kgsl_context_init(struct kgsl_device_private *dev_priv,
 	char name[64];
 	int ret = 0, id;
 
-	id = _kgsl_get_context_id(device, context);
+	id = _kgsl_get_context_id(device);
 	if (id == -ENOSPC) {
 		/*
 		 * Before declaring that there are no contexts left try
@@ -565,7 +562,7 @@ int kgsl_context_init(struct kgsl_device_private *dev_priv,
 		mutex_unlock(&device->mutex);
 		flush_workqueue(device->events_wq);
 		mutex_lock(&device->mutex);
-		id = _kgsl_get_context_id(device, context);
+		id = _kgsl_get_context_id(device);
 	}
 
 	if (id < 0) {
@@ -577,6 +574,8 @@ int kgsl_context_init(struct kgsl_device_private *dev_priv,
 		return id;
 	}
 
+	context->id = id;
+
 	kref_init(&context->refcount);
 	/*
 	 * Get a refernce to the process private so its not destroyed, until
@@ -2580,6 +2579,12 @@ long kgsl_ioctl_drawctxt_create(struct kgsl_device_private *dev_priv,
 		goto done;
 	}
 	trace_kgsl_context_create(dev_priv->device, context, param->flags);
+
+	/* Commit the pointer to the context in context_idr */
+	write_lock(&device->context_lock);
+	idr_replace(&device->context_idr, context, context->id);
+	write_unlock(&device->context_lock);
+
 	param->drawctxt_id = context->id;
 done:
 	mutex_unlock(&device->mutex);
