MotorolaMobilityLLC__kernel-msm
commit 91588002c4e7d398bb7307bb58586dead749de41
Author:     ahmedsh <ahmedsh@codeaurora.org>
AuthorDate: Mon Jan 9 17:24:09 2017 -0500
Commit:     Fan Hang <hangfan1@lenovo.com>
CommitDate: Tue Oct 17 09:27:28 2017 +0800

    seemp: use local stack mem when encoding params
    
    Avoid race condition in driver when encoding param by
    reading contents from a local copy instead of msg buffer
    itself which can be mapped to user space.
    
    Mot-CRs-fixed:(CR)
    CVE-fixed:CVE-2017-0462
    CRs-fixed:1102288
    
    Change-Id: I405ca6c7fcb0afa112e0851907b5dca805ac5411
    Signed-off-by: Ahmed Sheikh <ahmedsh@codeaurora.org>
    Signed-off-by: Amarendra Reddy <amarenr@motorola.com>
    Reviewed-on: https://gerrit.mot.com/953659
    SLTApproved: Slta Waiver <sltawvr@motorola.com>
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key <jirakey@motorola.com>
    Reviewed-by: Igor Kovalenko <igork@motorola.com>
    Submit-Approved: Jira Key <jirakey@motorola.com>
    Reviewed-on: https://gerrit.mot.com/992760
    Reviewed-by: Qiang Nie <nieqiang2@mt.com>
    SLTApproved: Qiang Nie <nieqiang2@mt.com>
    Submit-Approved: Qiang Nie <nieqiang2@mt.com>

diff --git a/drivers/platform/msm/seemp_core/seemp_event_encoder.c b/drivers/platform/msm/seemp_core/seemp_event_encoder.c
index df56a84bc667..36901f5fbee7 100644
--- a/drivers/platform/msm/seemp_core/seemp_event_encoder.c
+++ b/drivers/platform/msm/seemp_core/seemp_event_encoder.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015, 2017, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -48,9 +48,15 @@ static void check_param_range(char *section_eq, bool param,
 
 void encode_seemp_params(struct seemp_logk_blk *blk)
 {
-	char *s = blk->payload.msg + 1;
+	struct seemp_logk_blk tmp;
+	char *s = 0;
+	char *msg_section_start = 0;
+	char *msg_section_eq = 0;
+	char *msg_s = 0;
 
-	blk->payload.msg[BLK_MAX_MSG_SZ - 1] = 0; /* zero-terminate */
+	memcpy(tmp.payload.msg, blk->payload.msg, BLK_MAX_MSG_SZ);
+	s = tmp.payload.msg + 1;
+	tmp.payload.msg[BLK_MAX_MSG_SZ - 1] = 0; /* zero-terminate */
 
 	while (true) {
 		char *section_start = s;
@@ -105,8 +111,13 @@ void encode_seemp_params(struct seemp_logk_blk *blk)
 			}
 		}
 
-		encode_seemp_section(section_start, section_eq, s, param,
-					numeric, id, numeric_value);
+		msg_section_start = blk->payload.msg + (section_start -
+				tmp.payload.msg);
+		msg_section_eq = blk->payload.msg + (section_eq -
+				tmp.payload.msg);
+		msg_s = blk->payload.msg + (s - tmp.payload.msg);
+		encode_seemp_section(msg_section_start, msg_section_eq,
+				msg_s, param, numeric, id, numeric_value);
 
 		if (*s == 0)
 			break;
