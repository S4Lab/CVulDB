MotorolaMobilityLLC__kernel-msm
commit 922596a952d1dc1cf8005905cb430cbfc3f9cc45
Author:     Hardik Arya <harya@codeaurora.org>
AuthorDate: Fri Jan 4 16:14:20 2019 +0530
Commit:     chenyt9 <chenyt9@lenovo.com>
CommitDate: Mon Dec 9 16:57:15 2019 +0800

    soc: qcom: Validate read and write index before calculating ptr
    
    Currently we are not validating read and write index of
    tx and rx fifo's before calculating ptr, this can lead to
    out-of-bound access. The patch adds proper check for the same.
    
    Mot-CRs-fixed: (CR)
    CVE-Fixed: CVE-2019-2283
    CRs-Fixed: 2355425
    
    Change-Id: I7b158e94ae743a90ac364783fe31914ca0fa582b
    Signed-off-by: Hardik Arya <harya@codeaurora.org>
    Signed-off-by: Jignesh Patel <jignesh@motorola.com>
    Reviewed-on: https://gerrit.mot.com/1324125
    SLTApproved: Slta Waiver
    SME-Granted: SME Approvals Granted
    Tested-by: Jira Key
    Reviewed-by: Ling Jin <lingjin@motorola.com>
    Submit-Approved: Jira Key

diff --git a/drivers/soc/qcom/glink_smem_native_xprt.c b/drivers/soc/qcom/glink_smem_native_xprt.c
index 8a62e4ea6200..a22869d87866 100644
--- a/drivers/soc/qcom/glink_smem_native_xprt.c
+++ b/drivers/soc/qcom/glink_smem_native_xprt.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014-2017, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -441,6 +441,8 @@ static int fifo_read(struct edge_info *einfo, void *_data, int len)
 	uint32_t fifo_size = einfo->rx_fifo_size;
 	uint32_t n;
 
+	if (read_index >= fifo_size || write_index >= fifo_size)
+		return 0;
 	while (len) {
 		ptr = einfo->rx_fifo + read_index;
 		if (read_index <= write_index)
@@ -484,6 +486,8 @@ static uint32_t fifo_write_body(struct edge_info *einfo, const void *_data,
 	uint32_t fifo_size = einfo->tx_fifo_size;
 	uint32_t n;
 
+	if (read_index >= fifo_size || *write_index >= fifo_size)
+		return 0;
 	while (len) {
 		ptr = einfo->tx_fifo + *write_index;
 		if (*write_index < read_index) {
