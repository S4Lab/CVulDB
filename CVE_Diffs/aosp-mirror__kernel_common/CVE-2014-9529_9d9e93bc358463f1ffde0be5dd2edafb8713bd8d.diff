aosp-mirror__kernel_common
commit 9d9e93bc358463f1ffde0be5dd2edafb8713bd8d
Author:     Sasha Levin <sasha.levin@oracle.com>
AuthorDate: Fri Jul 8 16:00:30 2016 -0700
Commit:     Mark Salyzyn <salyzyn@google.com>
CommitDate: Mon Jul 11 18:00:46 2016 +0000

    UPSTREAM: KEYS: close race between key lookup and freeing
    
    (cherry pick from commit a3a8784454692dd72e5d5d34dcdab17b4420e74c)
    
    When a key is being garbage collected, it's key->user would get put
    before the ->destroy() callback is called, where the key is removed from
    it's respective tracking structures.
    
    This leaves a key hanging in a semi-invalid state which leaves a window
    open for a different task to try an access key->user. An example is
    find_keyring_by_name() which would dereference key->user for a key that
    is in the process of being garbage collected (where key->user was freed
    but ->destroy() wasn't called yet - so it's still present in the linked
    list).
    
    This would cause either a panic, or corrupt memory.
    
    Fixes CVE-2014-9529.
    
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Change-Id: I23f34be2a0b97de5ee38a66729888d63f3d60c88
    Bug: 29510361

diff --git a/security/keys/gc.c b/security/keys/gc.c
index d3222b6d7d59..009d9370c8fd 100644
--- a/security/keys/gc.c
+++ b/security/keys/gc.c
@@ -157,12 +157,12 @@ static noinline void key_gc_unused_keys(struct list_head *keys)
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
 			atomic_dec(&key->user->nikeys);
 
-		key_user_put(key->user);
-
 		/* now throw away the key memory */
 		if (key->type->destroy)
 			key->type->destroy(key);
 
+		key_user_put(key->user);
+
 		kfree(key->description);
 
 #ifdef KEY_DEBUGGING
