postgres__postgres
commit 1341e017dffee00fb245081ec5a11d3b93d9aafb
Author:     Tom Lane <tgl@sss.pgh.pa.us>
AuthorDate: Mon Feb 5 10:58:27 2018 -0500
Commit:     Tom Lane <tgl@sss.pgh.pa.us>
CommitDate: Mon Feb 5 10:58:27 2018 -0500

    Ensure that all temp files made during pg_upgrade are non-world-readable.
    
    pg_upgrade has always attempted to ensure that the transient dump files
    it creates are inaccessible except to the owner.  However, refactoring
    in commit 76a7650c4 broke that for the file containing "pg_dumpall -g"
    output; since then, that file was protected according to the process's
    default umask.  Since that file may contain role passwords (hopefully
    encrypted, but passwords nonetheless), this is a particularly unfortunate
    oversight.  Prudent users of pg_upgrade on multiuser systems would
    probably run it under a umask tight enough that the issue is moot, but
    perhaps some users are depending only on pg_upgrade's umask changes to
    protect their data.
    
    To fix this in a future-proof way, let's just tighten the umask at
    process start.  There are no files pg_upgrade needs to write at a
    weaker security level; and if there were, transiently relaxing the
    umask around where they're created would be a safer approach.
    
    Report and patch by Tom Lane; the idea for the fix is due to Noah Misch.
    Back-patch to all supported branches.
    
    Security: CVE-2018-1053

diff --git a/src/bin/pg_upgrade/dump.c b/src/bin/pg_upgrade/dump.c
index 81fb725338..86892cebd4 100644
--- a/src/bin/pg_upgrade/dump.c
+++ b/src/bin/pg_upgrade/dump.c
@@ -19,7 +19,6 @@ void
 generate_old_dump(void)
 {
 	int			dbnum;
-	mode_t		old_umask;
 
 	prep_status("Creating dump of global objects");
 
@@ -34,13 +33,6 @@ generate_old_dump(void)
 
 	prep_status("Creating dump of database schemas\n");
 
-	/*
-	 * Set umask for this function, all functions it calls, and all
-	 * subprocesses/threads it creates.  We can't use fopen_priv() as Windows
-	 * uses threads and umask is process-global.
-	 */
-	old_umask = umask(S_IRWXG | S_IRWXO);
-
 	/* create per-db dump files */
 	for (dbnum = 0; dbnum < old_cluster.dbarr.ndbs; dbnum++)
 	{
@@ -75,8 +67,6 @@ generate_old_dump(void)
 	while (reap_child(true) == true)
 		;
 
-	umask(old_umask);
-
 	end_progress_output();
 	check_ok();
 }
diff --git a/src/bin/pg_upgrade/file.c b/src/bin/pg_upgrade/file.c
index 3461927992..6bb811be69 100644
--- a/src/bin/pg_upgrade/file.c
+++ b/src/bin/pg_upgrade/file.c
@@ -314,18 +314,3 @@ win32_pghardlink(const char *src, const char *dst)
 		return 0;
 }
 #endif
-
-
-/* fopen() file with no group/other permissions */
-FILE *
-fopen_priv(const char *path, const char *mode)
-{
-	mode_t		old_umask = umask(S_IRWXG | S_IRWXO);
-	FILE	   *fp;
-
-	fp = fopen(path, mode);
-
-	umask(old_umask);			/* we assume this can't change errno */
-
-	return fp;
-}
diff --git a/src/bin/pg_upgrade/pg_upgrade.c b/src/bin/pg_upgrade/pg_upgrade.c
index 710b8efb87..f9f73093f3 100644
--- a/src/bin/pg_upgrade/pg_upgrade.c
+++ b/src/bin/pg_upgrade/pg_upgrade.c
@@ -75,6 +75,9 @@ main(int argc, char **argv)
 	char	   *deletion_script_file_name = NULL;
 	bool		live_check = false;
 
+	/* Ensure that all files created by pg_upgrade are non-world-readable */
+	umask(S_IRWXG | S_IRWXO);
+
 	parseCommandLine(argc, argv);
 
 	get_restricted_token(os_info.progname);
diff --git a/src/bin/pg_upgrade/pg_upgrade.h b/src/bin/pg_upgrade/pg_upgrade.h
index 439552c5da..9fbdacc53e 100644
--- a/src/bin/pg_upgrade/pg_upgrade.h
+++ b/src/bin/pg_upgrade/pg_upgrade.h
@@ -374,7 +374,9 @@ void linkFile(const char *src, const char *dst,
 void rewriteVisibilityMap(const char *fromfile, const char *tofile,
 					 const char *schemaName, const char *relName);
 void		check_hard_link(void);
-FILE	   *fopen_priv(const char *path, const char *mode);
+
+/* fopen_priv() is no longer different from fopen() */
+#define fopen_priv(path, mode)	fopen(path, mode)
 
 /* function.c */
 
