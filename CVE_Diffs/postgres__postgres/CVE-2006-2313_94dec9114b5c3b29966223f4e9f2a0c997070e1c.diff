postgres__postgres
commit 94dec9114b5c3b29966223f4e9f2a0c997070e1c
Author:     Tom Lane <tgl@sss.pgh.pa.us>
AuthorDate: Sun May 21 20:20:05 2006 +0000
Commit:     Tom Lane <tgl@sss.pgh.pa.us>
CommitDate: Sun May 21 20:20:05 2006 +0000

    Modify libpq's string-escaping routines to be aware of encoding considerations
    and standard_conforming_strings.  The encoding changes are needed for proper
    escaping in multibyte encodings, as per the SQL-injection vulnerabilities
    noted in CVE-2006-2313 and CVE-2006-2314.  Concurrent fixes are being applied
    to the server to ensure that it rejects queries that may have been corrupted
    by attempted SQL injection, but this merely guarantees that unpatched clients
    will fail rather than allow injection.  An actual fix requires changing the
    client-side code.  While at it we have also fixed these routines to understand
    about standard_conforming_strings, so that the upcoming changeover to SQL-spec
    string syntax can be somewhat transparent to client code.
    
    Since the existing API of PQescapeString and PQescapeBytea provides no way to
    inform them which settings are in use, these functions are now deprecated in
    favor of new functions PQescapeStringConn and PQescapeByteaConn.  The new
    functions take the PGconn to which the string will be sent as an additional
    parameter, and look inside the connection structure to determine what to do.
    So as to provide some functionality for clients using the old functions,
    libpq stores the latest encoding and standard_conforming_strings values
    received from the backend in static variables, and the old functions consult
    these variables.  This will work reliably in clients using only one Postgres
    connection at a time, or even multiple connections if they all use the same
    encoding and string syntax settings; which should cover many practical
    scenarios.
    
    Clients that use homebrew escaping methods, such as PHP's addslashes()
    function or even hardwired regexp substitution, will require extra effort
    to fix :-(.  It is strongly recommended that such code be replaced by use of
    PQescapeStringConn/PQescapeByteaConn if at all feasible.

diff --git a/doc/src/sgml/libpq.sgml b/doc/src/sgml/libpq.sgml
index 1bd8b3bf89..eba8819d90 100644
--- a/doc/src/sgml/libpq.sgml
+++ b/doc/src/sgml/libpq.sgml
@@ -1,5 +1,5 @@
 <!--
-$PostgreSQL: pgsql/doc/src/sgml/libpq.sgml,v 1.178.4.2 2005/06/09 19:08:36 tgl Exp $
+$PostgreSQL: pgsql/doc/src/sgml/libpq.sgml,v 1.178.4.3 2006/05/21 20:20:04 tgl Exp $
 -->
 
  <chapter id="libpq">
@@ -2144,15 +2144,16 @@ It is not thread-safe.
 <sect2 id="libpq-exec-escape-string">
   <title>Escaping Strings for Inclusion in SQL Commands</title>
 
+   <indexterm zone="libpq-exec-escape-string"><primary>PQescapeStringConn</></>
    <indexterm zone="libpq-exec-escape-string"><primary>PQescapeString</></>
    <indexterm zone="libpq-exec-escape-string"><primary>escaping strings</></>
 
 <para>
-<function>PQescapeString</function> escapes a string for use within an SQL
+<function>PQescapeStringConn</function> escapes a string for use within an SQL
 command.  This is useful when inserting data values as literal constants
 in SQL commands.  Certain characters (such as quotes and backslashes) must
 be escaped to prevent them from being interpreted specially by the SQL parser.
-<function>PQescapeString</> performs this operation.
+<function>PQescapeStringConn</> performs this operation.
 </para>
 
 <tip>
@@ -2170,36 +2171,68 @@ value is passed as a separate parameter in <function>PQexecParams</> or
 its sibling routines.
 
 <synopsis>
-size_t PQescapeString (char *to, const char *from, size_t length);
+size_t PQescapeStringConn (PGconn *conn,
+                           char *to, const char *from, size_t length,
+                           int *error);
 </synopsis>
 </para>
 
 <para>
+<function>PQescapeStringConn</> writes an escaped
+version of the <parameter>from</> string to the <parameter>to</>
+buffer, escaping special characters so that they cannot cause any
+harm, and adding a terminating zero byte.  The single quotes that
+must surround <productname>PostgreSQL</> string literals are not
+included in the result string; they should be provided in the SQL
+command that the result is inserted into.
 The parameter <parameter>from</> points to the first character of the string
 that is to be escaped, and the <parameter>length</> parameter gives the
-number of characters in this string.  A terminating zero byte is not
+number of bytes in this string.  A terminating zero byte is not
 required, and should not be counted in <parameter>length</>.  (If
 a terminating zero byte is found before <parameter>length</> bytes are
-processed, <function>PQescapeString</> stops at the zero; the behavior
+processed, <function>PQescapeStringConn</> stops at the zero; the behavior
 is thus rather like <function>strncpy</>.)
 <parameter>to</> shall point to a
-buffer that is able to hold at least one more character than twice
+buffer that is able to hold at least one more byte than twice
 the value of <parameter>length</>, otherwise the behavior is
-undefined.  A call to <function>PQescapeString</> writes an escaped
-version of the <parameter>from</> string to the <parameter>to</>
-buffer, replacing special characters so that they cannot cause any
-harm, and adding a terminating zero byte.  The single quotes that
-must surround <productname>PostgreSQL</> string literals are not
-included in the result string; they should be provided in the SQL
-command that the result is inserted into.
+undefined.
+Behavior is likewise undefined if the <parameter>to</> and <parameter>from</>
+strings overlap.
+</para>
+<para>
+If the <parameter>error</> parameter is not NULL, then <literal>*error</>
+is set to zero on success, nonzero on error.  Presently the only possible
+error conditions involve invalid multibyte encoding in the source string.
+The output string is still generated on error, but it can be expected that
+the server will reject it as malformed.  On error, a suitable message is
+stored in the <parameter>conn</> object, whether or not <parameter>error</>
+is NULL.
 </para>
 <para>
-<function>PQescapeString</> returns the number of characters written
+<function>PQescapeStringConn</> returns the number of bytes written
 to <parameter>to</>, not including the terminating zero byte.
 </para>
+
 <para>
-Behavior is undefined if the <parameter>to</> and <parameter>from</>
-strings overlap.
+<synopsis>
+size_t PQescapeString (char *to, const char *from, size_t length);
+</synopsis>
+</para>
+
+<para>
+<function>PQescapeString</> is an older, deprecated version of
+<function>PQescapeStringConn</>; the difference is that it does not
+take <parameter>conn</> or <parameter>error</> parameters.  Because of this,
+it cannot adjust its behavior depending on the connection properties (such as
+character encoding) and therefore <emphasis>it may give the wrong results</>.
+Also, it has no way to report error conditions.
+</para>
+<para>
+<function>PQescapeString</> can be used safely in single-threaded client
+programs that work with only one <productname>PostgreSQL</> connection at
+a time (in this case it can find out what it needs to know <quote>behind the
+scenes</>).  In other contexts it is a security hazard and should be avoided
+in favor of <function>PQescapeStringConn</>.
 </para>
 </sect2>
 
@@ -2214,29 +2247,30 @@ strings overlap.
 
   <variablelist>
   <varlistentry>
-  <term><function>PQescapeBytea</function><indexterm><primary>PQescapeBytea</></></term>
+  <term><function>PQescapeByteaConn</function><indexterm><primary>PQescapeByteaConn</></></term>
   <listitem>
   <para>
    Escapes binary data for use within an SQL command with the type
-   <type>bytea</type>.  As with <function>PQescapeString</function>,
+   <type>bytea</type>.  As with <function>PQescapeStringConn</function>,
    this is only used when inserting data directly into an SQL command string.
 <synopsis>
-unsigned char *PQescapeBytea(const unsigned char *from,
-                             size_t from_length,
-                             size_t *to_length);
+unsigned char *PQescapeByteaConn(PGconn *conn,
+                                 const unsigned char *from,
+                                 size_t from_length,
+                                 size_t *to_length);
 </synopsis>
 </para>
 
 <para>
    Certain byte values <emphasis>must</emphasis> be escaped (but all
-   byte values <emphasis>may</emphasis> be escaped) when used as part
+   byte values <emphasis>can</emphasis> be escaped) when used as part
    of a <type>bytea</type> literal in an <acronym>SQL</acronym>
    statement. In general, to escape a byte, it is converted into the
    three digit octal number equal to the octet value, and preceded by
-   two backslashes. The single quote (<literal>'</>) and backslash
+   one or two backslashes. The single quote (<literal>'</>) and backslash
    (<literal>\</>) characters have special alternative escape
    sequences. See <xref linkend="datatype-binary"> for more
-   information. <function>PQescapeBytea</function> performs this
+   information. <function>PQescapeByteaConn</function> performs this
    operation, escaping only the minimally required bytes.
   </para>
 
@@ -2247,22 +2281,60 @@ unsigned char *PQescapeBytea(const unsigned char *from,
    bytes in this binary string.  (A terminating zero byte is
    neither necessary nor counted.)  The <parameter>to_length</parameter>
    parameter points to a variable that will hold the resultant
-   escaped string length. The result string length includes the terminating
+   escaped string length. This result string length includes the terminating
    zero byte of the result.
   </para>
 
   <para>
-   <function>PQescapeBytea</> returns an escaped version of the
+   <function>PQescapeByteaConn</> returns an escaped version of the
    <parameter>from</parameter> parameter binary string in memory
-   allocated with <function>malloc()</>.  This memory must be freed
-   using <function>PQfreemem</> when the result is no longer needed.
-   The return string has all special characters replaced so that they
-   can be properly processed by the
-   <productname>PostgreSQL</productname> string literal parser, and
-   the <type>bytea</type> input function. A terminating zero byte is
-   also added.  The single quotes that must surround
-   <productname>PostgreSQL</productname> string literals are not part
-   of the result string.
+   allocated with <function>malloc()</>.  This memory must be freed using
+   <function>PQfreemem()</> when the result is no longer needed.  The
+   return string has all special characters replaced so that they can
+   be properly processed by the <productname>PostgreSQL</productname>
+   string literal parser, and the <type>bytea</type> input function. A
+   terminating zero byte is also added.  The single quotes that must
+   surround <productname>PostgreSQL</productname> string literals are
+   not part of the result string.
+  </para>
+
+  <para>
+   On error, a NULL pointer is returned, and a suitable error message
+   is stored in the <parameter>conn</> object.  Currently, the only
+   possible error is insufficient memory for the result string.
+  </para>
+  </listitem>
+  </varlistentry>
+
+  <varlistentry>
+  <term><function>PQescapeBytea</function><indexterm><primary>PQescapeBytea</></></term>
+  <listitem>
+  <para>
+   <function>PQescapeBytea</> is an older, deprecated version of
+   <function>PQescapeByteaConn</>.
+<synopsis>
+unsigned char *PQescapeBytea(const unsigned char *from,
+                             size_t from_length,
+                             size_t *to_length);
+</synopsis>
+</para>
+
+<para>
+   The only difference from <function>PQescapeByteaConn</> is that
+   <function>PQescapeBytea</> does not
+   take a <structname>PGconn</> parameter.  Because of this, it cannot adjust
+   its behavior depending on the connection properties (in particular,
+   whether standard-conforming strings are enabled)
+   and therefore <emphasis>it may give the wrong results</>.  Also, it
+   has no way to return an error message on failure.
+  </para>
+
+  <para>
+   <function>PQescapeBytea</> can be used safely in single-threaded client
+   programs that work with only one <productname>PostgreSQL</> connection at
+   a time (in this case it can find out what it needs to know <quote>behind the
+   scenes</>).  In other contexts it is a security hazard and should be
+   avoided in favor of <function>PQescapeByteaConn</>.
   </para>
   </listitem>
   </varlistentry>
@@ -2271,7 +2343,7 @@ unsigned char *PQescapeBytea(const unsigned char *from,
   <term><function>PQunescapeBytea</function><indexterm><primary>PQunescapeBytea</></></term>
   <listitem>
   <para>
-   Converts an escaped string representation of binary data into binary
+   Converts a string representation of binary data into binary
    data &mdash; the reverse of <function>PQescapeBytea</function>.
    This is needed when retrieving <type>bytea</type> data in text format,
    but not when retrieving it in binary format.
@@ -2281,16 +2353,24 @@ unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
 </synopsis>
 </para>
 
-<para>
-   The <parameter>from</parameter> parameter points to an escaped string
-   such as might be returned by <function>PQgetvalue</function> when applied to a
-   <type>bytea</type> column. <function>PQunescapeBytea</function> converts
-   this string representation into its binary representation.
+  <para>
+   The <parameter>from</parameter> parameter points to a string
+   such as might be returned by <function>PQgetvalue</function> when applied
+   to a <type>bytea</type> column. <function>PQunescapeBytea</function>
+   converts this string representation into its binary representation.
    It returns a pointer to a buffer allocated with
    <function>malloc()</function>, or null on error, and puts the size of
    the buffer in <parameter>to_length</parameter>. The result must be
    freed using <function>PQfreemem</> when it is no longer needed.
   </para>
+
+  <para>
+   This conversion is not exactly the inverse of
+   <function>PQescapeBytea</function>, because the string is not expected
+   to be <quote>escaped</> when received from <function>PQgetvalue</function>.
+   In particular this means there is no need for string quoting considerations,
+   and so no need for a <structname>PGconn</> parameter.
+  </para>
   </listitem>
   </varlistentry>
 
@@ -2306,6 +2386,7 @@ void PQfreemem(void *ptr);
 
 <para>
    Frees memory allocated by <application>libpq</>, particularly
+   <function>PQescapeByteaConn</function>,
    <function>PQescapeBytea</function>,
    <function>PQunescapeBytea</function>,
    and <function>PQnotifies</function>.
diff --git a/src/interfaces/libpq/exports.txt b/src/interfaces/libpq/exports.txt
index 363764fffe..c5e8146bce 100644
--- a/src/interfaces/libpq/exports.txt
+++ b/src/interfaces/libpq/exports.txt
@@ -1,4 +1,4 @@
-# $PostgreSQL: pgsql/src/interfaces/libpq/exports.txt,v 1.3 2004/10/30 23:11:26 tgl Exp $
+# $PostgreSQL: pgsql/src/interfaces/libpq/exports.txt,v 1.3.4.1 2006/05/21 20:20:04 tgl Exp $
 # Functions to be exported by libpq DLLs
 PQconnectdb               1
 PQsetdbLogin              2
@@ -122,3 +122,5 @@ PQsendPrepare             119
 PQgetCancel               120
 PQfreeCancel              121
 PQcancel                  122
+PQescapeStringConn        126
+PQescapeByteaConn         127
diff --git a/src/interfaces/libpq/fe-connect.c b/src/interfaces/libpq/fe-connect.c
index 0fe08aa0d5..36b5ce3479 100644
--- a/src/interfaces/libpq/fe-connect.c
+++ b/src/interfaces/libpq/fe-connect.c
@@ -8,7 +8,7 @@
  *
  *
  * IDENTIFICATION
- *	  $PostgreSQL: pgsql/src/interfaces/libpq/fe-connect.c,v 1.301.4.4 2005/07/13 15:26:06 tgl Exp $
+ *	  $PostgreSQL: pgsql/src/interfaces/libpq/fe-connect.c,v 1.301.4.5 2006/05/21 20:20:04 tgl Exp $
  *
  *-------------------------------------------------------------------------
  */
@@ -1985,6 +1985,7 @@ makeEmptyPGconn(void)
 	conn->xactStatus = PQTRANS_IDLE;
 	conn->setenv_state = SETENV_STATE_IDLE;
 	conn->client_encoding = PG_SQL_ASCII;
+	conn->std_strings = false;	/* unless server says differently */
 	conn->verbosity = PQERRORS_DEFAULT;
 	conn->sock = -1;
 #ifdef USE_SSL
@@ -3077,8 +3078,14 @@ PQsetClientEncoding(PGconn *conn, const char *encoding)
 		status = -1;
 	else
 	{
-		/* change libpq internal encoding */
-		conn->client_encoding = pg_char_to_encoding(encoding);
+		/*
+		 * In protocol 2 we have to assume the setting will stick, and
+		 * adjust our state immediately.  In protocol 3 and up we can
+		 * rely on the backend to report the parameter value, and we'll
+		 * change state at that time.
+		 */
+		if (PG_PROTOCOL_MAJOR(conn->pversion) < 3)
+			pqSaveParameterStatus(conn, "client_encoding", encoding);
 		status = 0;				/* everything is ok */
 	}
 	PQclear(res);
diff --git a/src/interfaces/libpq/fe-exec.c b/src/interfaces/libpq/fe-exec.c
index f24d5f4439..55a3670fad 100644
--- a/src/interfaces/libpq/fe-exec.c
+++ b/src/interfaces/libpq/fe-exec.c
@@ -8,7 +8,7 @@
  *
  *
  * IDENTIFICATION
- *	  $PostgreSQL: pgsql/src/interfaces/libpq/fe-exec.c,v 1.166.4.1 2006/05/21 19:57:39 momjian Exp $
+ *	  $PostgreSQL: pgsql/src/interfaces/libpq/fe-exec.c,v 1.166.4.2 2006/05/21 20:20:04 tgl Exp $
  *
  *-------------------------------------------------------------------------
  */
@@ -41,6 +41,12 @@ char	   *const pgresStatus[] = {
 	"PGRES_FATAL_ERROR"
 };
 
+/*
+ * static state needed by PQescapeString and PQescapeBytea; initialize to
+ * values that result in backward-compatible behavior
+ */
+static int	static_client_encoding = PG_SQL_ASCII;
+static bool	static_std_strings = false;
 
 
 static bool PQsendQueryStart(PGconn *conn);
@@ -603,11 +609,22 @@ pqSaveParameterStatus(PGconn *conn, const char *name, const char *value)
 	}
 
 	/*
-	 * Special hacks: remember client_encoding as a numeric value, and
-	 * convert server version to a numeric form as well.
+	 * Special hacks: remember client_encoding and standard_conforming_strings,
+	 * and convert server version to a numeric form.  We keep the first two of
+	 * these in static variables as well, so that PQescapeString and
+	 * PQescapeBytea can behave somewhat sanely (at least in single-
+	 * connection-using programs).
 	 */
 	if (strcmp(name, "client_encoding") == 0)
+	{
 		conn->client_encoding = pg_char_to_encoding(value);
+		static_client_encoding = conn->client_encoding;
+	}
+	else if (strcmp(name, "standard_conforming_strings") == 0)
+	{
+		conn->std_strings = (strcmp(value, "on") == 0);
+		static_std_strings = conn->std_strings;
+	}
 	else if (strcmp(name, "server_version") == 0)
 	{
 		int			cnt;
@@ -2331,7 +2348,7 @@ PQfreeNotify(PGnotify *notify)
 /*
  * Escaping arbitrary strings to get valid SQL literal strings.
  *
- * Replaces "\\" with "\\\\" and "'" with "''".
+ * Replaces "'" with "''", and if not std_strings, replaces "\" with "\\".
  *
  * length is the length of the source string.  (Note: if a terminating NUL
  * is encountered sooner, PQescapeString stops short of "length"; the behavior
@@ -2343,33 +2360,74 @@ PQfreeNotify(PGnotify *notify)
  *
  * Returns the actual length of the output (not counting the terminating NUL).
  */
-size_t
-PQescapeString(char *to, const char *from, size_t length)
+static size_t
+PQescapeStringInternal(PGconn *conn,
+					   char *to, const char *from, size_t length,
+					   int *error,
+					   int encoding, bool std_strings)
 {
 	const char *source = from;
 	char	   *target = to;
 	size_t		remaining = length;
 
+	if (error)
+		*error = 0;
+
 	while (remaining > 0 && *source != '\0')
 	{
-		switch (*source)
+		char	c = *source;
+		int		len;
+		int		i;
+
+		/* Fast path for plain ASCII */
+		if (!IS_HIGHBIT_SET(c))
 		{
-			case '\\':
-				*target++ = '\\';
-				*target++ = '\\';
-				break;
+			/* Apply quoting if needed */
+			if (c == '\'' ||
+				(c == '\\' && !std_strings))
+				*target++ = c;
+			/* Copy the character */
+			*target++ = c;
+			source++;
+			remaining--;
+			continue;
+		}
 
-			case '\'':
-				*target++ = '\'';
-				*target++ = '\'';
-				break;
+		/* Slow path for possible multibyte characters */
+		len = pg_encoding_mblen(encoding, source);
 
-			default:
-				*target++ = *source;
+		/* Copy the character */
+		for (i = 0; i < len; i++)
+		{
+			if (remaining == 0 || *source == '\0')
 				break;
+			*target++ = *source++;
+			remaining--;
+		}
+
+		/*
+		 * If we hit premature end of string (ie, incomplete multibyte
+		 * character), try to pad out to the correct length with spaces.
+		 * We may not be able to pad completely, but we will always be able
+		 * to insert at least one pad space (since we'd not have quoted a
+		 * multibyte character).  This should be enough to make a string that
+		 * the server will error out on.
+		 */
+		if (i < len)
+		{
+			if (error)
+				*error = 1;
+			if (conn)
+				printfPQExpBuffer(&conn->errorMessage,
+						libpq_gettext("incomplete multibyte character\n"));
+			for (; i < len; i++)
+			{
+				if (((size_t) (target - to)) / 2 >= length)
+					break;
+				*target++ = ' ';
+			}
+			break;
 		}
-		source++;
-		remaining--;
 	}
 
 	/* Write the terminating NUL character. */
@@ -2378,72 +2436,109 @@ PQescapeString(char *to, const char *from, size_t length)
 	return target - to;
 }
 
+size_t
+PQescapeStringConn(PGconn *conn,
+				   char *to, const char *from, size_t length,
+				   int *error)
+{
+	if (!conn)
+	{
+		/* force empty-string result */
+		*to = '\0';
+		if (error)
+			*error = 1;
+		return 0;
+	}
+	return PQescapeStringInternal(conn, to, from, length, error,
+								  conn->client_encoding,
+								  conn->std_strings);
+}
+
+size_t
+PQescapeString(char *to, const char *from, size_t length)
+{
+	return PQescapeStringInternal(NULL, to, from, length, NULL,
+								  static_client_encoding,
+								  static_std_strings);
+}
+
 /*
  *		PQescapeBytea	- converts from binary string to the
  *		minimal encoding necessary to include the string in an SQL
  *		INSERT statement with a bytea type column as the target.
  *
  *		The following transformations are applied
- *		'\0' == ASCII  0 == \\000
- *		'\'' == ASCII 39 == \'
- *		'\\' == ASCII 92 == \\\\
- *		anything < 0x20, or > 0x7e ---> \\ooo
+ *		'\0' == ASCII  0 == \000
+ *		'\'' == ASCII 39 == ''
+ *		'\\' == ASCII 92 == \\
+ *		anything < 0x20, or > 0x7e ---> \ooo
  *										(where ooo is an octal expression)
+ *		If not std_strings, all backslashes sent to the output are doubled.
  */
-unsigned char *
-PQescapeBytea(const unsigned char *bintext, size_t binlen, size_t *bytealen)
+static unsigned char *
+PQescapeByteaInternal(PGconn *conn,
+					  const unsigned char *from, size_t from_length,
+					  size_t *to_length, bool std_strings)
 {
 	const unsigned char *vp;
 	unsigned char *rp;
 	unsigned char *result;
 	size_t		i;
 	size_t		len;
+	size_t		bslash_len = (std_strings ? 1 : 2);
 
 	/*
 	 * empty string has 1 char ('\0')
 	 */
 	len = 1;
 
-	vp = bintext;
-	for (i = binlen; i > 0; i--, vp++)
+	vp = from;
+	for (i = from_length; i > 0; i--, vp++)
 	{
 		if (*vp < 0x20 || *vp > 0x7e)
-			len += 5;			/* '5' is for '\\ooo' */
+			len += bslash_len + 3;
 		else if (*vp == '\'')
 			len += 2;
 		else if (*vp == '\\')
-			len += 4;
+			len += bslash_len + bslash_len;
 		else
 			len++;
 	}
 
+	*to_length = len;
 	rp = result = (unsigned char *) malloc(len);
 	if (rp == NULL)
+	{
+		if (conn)
+			printfPQExpBuffer(&conn->errorMessage,
+							  libpq_gettext("out of memory\n"));
 		return NULL;
+	}
 
-	vp = bintext;
-	*bytealen = len;
-
-	for (i = binlen; i > 0; i--, vp++)
+	vp = from;
+	for (i = from_length; i > 0; i--, vp++)
 	{
 		if (*vp < 0x20 || *vp > 0x7e)
 		{
-			(void) sprintf(rp, "\\\\%03o", *vp);
-			rp += 5;
+			if (!std_strings)
+				*rp++ = '\\';
+			(void) sprintf((char *) rp, "\\%03o", *vp);
+			rp += 4;
 		}
 		else if (*vp == '\'')
 		{
-			rp[0] = '\'';
-			rp[1] = '\'';
-			rp += 2;
+			*rp++ = '\'';
+			*rp++ = '\'';
 		}
 		else if (*vp == '\\')
 		{
-			rp[0] = '\\';
-			rp[1] = '\\';
-			rp[2] = '\\';
-			rp[3] = '\\';
-			rp += 4;
+			if (!std_strings)
+			{
+				*rp++ = '\\';
+				*rp++ = '\\';
+			}
+			*rp++ = '\\';
+			*rp++ = '\\';
 		}
 		else
 			*rp++ = *vp;
@@ -2453,6 +2548,25 @@ PQescapeBytea(const unsigned char *bintext, size_t binlen, size_t *bytealen)
 	return result;
 }
 
+unsigned char *
+PQescapeByteaConn(PGconn *conn,
+				  const unsigned char *from, size_t from_length,
+				  size_t *to_length)
+{
+	if (!conn)
+		return NULL;
+	return PQescapeByteaInternal(conn, from, from_length, to_length,
+								 conn->std_strings);
+}
+
+unsigned char *
+PQescapeBytea(const unsigned char *from, size_t from_length, size_t *to_length)
+{
+	return PQescapeByteaInternal(NULL, from, from_length, to_length,
+								 static_std_strings);
+}
+
+
 #define ISFIRSTOCTDIGIT(CH) ((CH) >= '0' && (CH) <= '3')
 #define ISOCTDIGIT(CH) ((CH) >= '0' && (CH) <= '7')
 #define OCTVAL(CH) ((CH) - '0')
@@ -2462,7 +2576,7 @@ PQescapeBytea(const unsigned char *bintext, size_t binlen, size_t *bytealen)
  *		of a bytea, strtext, into binary, filling a buffer. It returns a
  *		pointer to the buffer (or NULL on error), and the size of the
  *		buffer in retbuflen. The pointer may subsequently be used as an
- *		argument to the function free(3). It is the reverse of PQescapeBytea.
+ *		argument to the function PQfreemem.
  *
  *		The following transformations are made:
  *		\\	 == ASCII 92 == \
diff --git a/src/interfaces/libpq/libpq-fe.h b/src/interfaces/libpq/libpq-fe.h
index f7f379748b..a675335ec1 100644
--- a/src/interfaces/libpq/libpq-fe.h
+++ b/src/interfaces/libpq/libpq-fe.h
@@ -7,7 +7,7 @@
  * Portions Copyright (c) 1996-2005, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
- * $PostgreSQL: pgsql/src/interfaces/libpq/libpq-fe.h,v 1.116 2004/12/31 22:03:50 pgsql Exp $
+ * $PostgreSQL: pgsql/src/interfaces/libpq/libpq-fe.h,v 1.116.4.1 2006/05/21 20:20:05 tgl Exp $
  *
  *-------------------------------------------------------------------------
  */
@@ -436,11 +436,18 @@ extern PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
 
 
 /* Quoting strings before inclusion in queries. */
-extern size_t PQescapeString(char *to, const char *from, size_t length);
-extern unsigned char *PQescapeBytea(const unsigned char *bintext, size_t binlen,
-			  size_t *bytealen);
+extern size_t PQescapeStringConn(PGconn *conn,
+								 char *to, const char *from, size_t length,
+								 int *error);
+extern unsigned char *PQescapeByteaConn(PGconn *conn,
+				  const unsigned char *from, size_t from_length,
+				  size_t *to_length);
 extern unsigned char *PQunescapeBytea(const unsigned char *strtext,
 				size_t *retbuflen);
+/* These forms are deprecated! */
+extern size_t PQescapeString(char *to, const char *from, size_t length);
+extern unsigned char *PQescapeBytea(const unsigned char *from, size_t from_length,
+			  size_t *to_length);
 
 
 
diff --git a/src/interfaces/libpq/libpq-int.h b/src/interfaces/libpq/libpq-int.h
index 9862e01bc9..f63e0e054d 100644
--- a/src/interfaces/libpq/libpq-int.h
+++ b/src/interfaces/libpq/libpq-int.h
@@ -12,7 +12,7 @@
  * Portions Copyright (c) 1996-2005, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
- * $PostgreSQL: pgsql/src/interfaces/libpq/libpq-int.h,v 1.100 2005/01/06 00:59:47 tgl Exp $
+ * $PostgreSQL: pgsql/src/interfaces/libpq/libpq-int.h,v 1.100.4.1 2006/05/21 20:20:05 tgl Exp $
  *
  *-------------------------------------------------------------------------
  */
@@ -303,6 +303,7 @@ struct pg_conn
 	char		cryptSalt[2];	/* password salt received from backend */
 	pgParameterStatus *pstatus; /* ParameterStatus data */
 	int			client_encoding;	/* encoding id */
+	bool		std_strings;	/* standard_conforming_strings */
 	PGVerbosity verbosity;		/* error/notice message verbosity */
 	PGlobjfuncs *lobjfuncs;		/* private state for large-object access
 								 * fns */
