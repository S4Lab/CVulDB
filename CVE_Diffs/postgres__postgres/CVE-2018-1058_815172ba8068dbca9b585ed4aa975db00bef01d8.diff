postgres__postgres
commit 815172ba8068dbca9b585ed4aa975db00bef01d8
Author:     Tom Lane <tgl@sss.pgh.pa.us>
AuthorDate: Mon Feb 26 10:18:22 2018 -0500
Commit:     Tom Lane <tgl@sss.pgh.pa.us>
CommitDate: Mon Feb 26 10:18:22 2018 -0500

    Avoid using unsafe search_path settings during dump and restore.
    
    Historically, pg_dump has "set search_path = foo, pg_catalog" when
    dumping an object in schema "foo", and has also caused that setting
    to be used while restoring the object.  This is problematic because
    functions and operators in schema "foo" could capture references meant
    to refer to pg_catalog entries, both in the queries issued by pg_dump
    and those issued during the subsequent restore run.  That could
    result in dump/restore misbehavior, or in privilege escalation if a
    nefarious user installs trojan-horse functions or operators.
    
    This patch changes pg_dump so that it does not change the search_path
    dynamically.  The emitted restore script sets the search_path to what
    was used at dump time, and then leaves it alone thereafter.  Created
    objects are placed in the correct schema, regardless of the active
    search_path, by dint of schema-qualifying their names in the CREATE
    commands, as well as in subsequent ALTER and ALTER-like commands.
    
    Since this change requires a change in the behavior of pg_restore
    when processing an archive file made according to this new convention,
    bump the archive file version number; old versions of pg_restore will
    therefore refuse to process files made with new versions of pg_dump.
    
    Security: CVE-2018-1058

diff --git a/src/backend/utils/adt/ruleutils.c b/src/backend/utils/adt/ruleutils.c
index 416c333f3a..081e754f4c 100644
--- a/src/backend/utils/adt/ruleutils.c
+++ b/src/backend/utils/adt/ruleutils.c
@@ -82,15 +82,17 @@
 #define PRETTYINDENT_LIMIT		40		/* wrap limit */
 
 /* Pretty flags */
-#define PRETTYFLAG_PAREN		1
-#define PRETTYFLAG_INDENT		2
+#define PRETTYFLAG_PAREN		0x0001
+#define PRETTYFLAG_INDENT		0x0002
+#define PRETTYFLAG_SCHEMA		0x0004
 
 /* Default line length for pretty-print wrapping: 0 means wrap always */
 #define WRAP_COLUMN_DEFAULT		0
 
-/* macro to test if pretty action needed */
+/* macros to test if pretty action needed */
 #define PRETTY_PAREN(context)	((context)->prettyFlags & PRETTYFLAG_PAREN)
 #define PRETTY_INDENT(context)	((context)->prettyFlags & PRETTYFLAG_INDENT)
+#define PRETTY_SCHEMA(context)	((context)->prettyFlags & PRETTYFLAG_SCHEMA)
 
 
 /* ----------
@@ -489,7 +491,7 @@ pg_get_ruledef_ext(PG_FUNCTION_ARGS)
 	int			prettyFlags;
 	char	   *res;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 
 	res = pg_get_ruledef_worker(ruleoid, prettyFlags);
 
@@ -610,7 +612,7 @@ pg_get_viewdef_ext(PG_FUNCTION_ARGS)
 	int			prettyFlags;
 	char	   *res;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 
 	res = pg_get_viewdef_worker(viewoid, prettyFlags, WRAP_COLUMN_DEFAULT);
 
@@ -630,7 +632,7 @@ pg_get_viewdef_wrap(PG_FUNCTION_ARGS)
 	char	   *res;
 
 	/* calling this implies we want pretty printing */
-	prettyFlags = PRETTYFLAG_PAREN | PRETTYFLAG_INDENT;
+	prettyFlags = PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA;
 
 	res = pg_get_viewdef_worker(viewoid, prettyFlags, wrap);
 
@@ -676,7 +678,7 @@ pg_get_viewdef_name_ext(PG_FUNCTION_ARGS)
 	Oid			viewoid;
 	char	   *res;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 
 	/* Look up view name.  Can't lock it - we might not have privileges. */
 	viewrel = makeRangeVarFromNameList(textToQualifiedNameList(viewname));
@@ -910,8 +912,15 @@ pg_get_triggerdef_worker(Oid trigid, bool pretty)
 			appendStringInfoString(&buf, " TRUNCATE");
 		findx++;
 	}
+
+	/*
+	 * In non-pretty mode, always schema-qualify the target table name for
+	 * safety.  In pretty mode, schema-qualify only if not visible.
+	 */
 	appendStringInfo(&buf, " ON %s ",
-					 generate_relation_name(trigrec->tgrelid, NIL));
+					 pretty ?
+					 generate_relation_name(trigrec->tgrelid, NIL) :
+					 generate_qualified_relation_name(trigrec->tgrelid));
 
 	if (OidIsValid(trigrec->tgconstraint))
 	{
@@ -984,7 +993,7 @@ pg_get_triggerdef_worker(Oid trigid, bool pretty)
 		context.windowClause = NIL;
 		context.windowTList = NIL;
 		context.varprefix = true;
-		context.prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+		context.prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 		context.wrapColumn = WRAP_COLUMN_DEFAULT;
 		context.indentLevel = PRETTYINDENT_STD;
 		context.special_exprkind = EXPR_KIND_NONE;
@@ -1071,7 +1080,7 @@ pg_get_indexdef_ext(PG_FUNCTION_ARGS)
 	int			prettyFlags;
 	char	   *res;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 
 	res = pg_get_indexdef_worker(indexrelid, colno, NULL, colno != 0, false,
 								 prettyFlags, true);
@@ -1099,7 +1108,8 @@ pg_get_indexdef_columns(Oid indexrelid, bool pretty)
 {
 	int			prettyFlags;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
+
 	return pg_get_indexdef_worker(indexrelid, 0, NULL, true, false,
 								  prettyFlags, false);
 }
@@ -1229,7 +1239,9 @@ pg_get_indexdef_worker(Oid indexrelid, int colno,
 			appendStringInfo(&buf, "CREATE %sINDEX %s ON %s USING %s (",
 							 idxrec->indisunique ? "UNIQUE " : "",
 							 quote_identifier(NameStr(idxrelrec->relname)),
-							 generate_relation_name(indrelid, NIL),
+							 (prettyFlags & PRETTYFLAG_SCHEMA) ?
+							 generate_relation_name(indrelid, NIL) :
+							 generate_qualified_relation_name(indrelid),
 							 quote_identifier(NameStr(amrec->amname)));
 		else	/* currently, must be EXCLUDE constraint */
 			appendStringInfo(&buf, "EXCLUDE USING %s (",
@@ -1427,7 +1439,7 @@ pg_get_constraintdef_ext(PG_FUNCTION_ARGS)
 	int			prettyFlags;
 	char	   *res;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 
 	res = pg_get_constraintdef_worker(constraintId, false, prettyFlags, true);
 
@@ -1869,7 +1881,7 @@ pg_get_expr_ext(PG_FUNCTION_ARGS)
 	int			prettyFlags;
 	char	   *relname;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 
 	if (OidIsValid(relid))
 	{
@@ -4300,7 +4312,10 @@ make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,
 	}
 
 	/* The relation the rule is fired on */
-	appendStringInfo(buf, " TO %s", generate_relation_name(ev_class, NIL));
+	appendStringInfo(buf, " TO %s",
+					 (prettyFlags & PRETTYFLAG_SCHEMA) ?
+					 generate_relation_name(ev_class, NIL) :
+					 generate_qualified_relation_name(ev_class));
 
 	/* If the rule has an event qualification, add it */
 	if (ev_qual == NULL)
diff --git a/src/bin/pg_dump/dumputils.c b/src/bin/pg_dump/dumputils.c
index c171978060..abd0579d5d 100644
--- a/src/bin/pg_dump/dumputils.c
+++ b/src/bin/pg_dump/dumputils.c
@@ -34,6 +34,7 @@ static void AddAcl(PQExpBuffer aclbuf, const char *keyword,
  *
  *	name: the object name, in the form to use in the commands (already quoted)
  *	subname: the sub-object name, if any (already quoted); NULL if none
+ *	nspname: the namespace the object is in (NULL if none); not pre-quoted
  *	type: the object type (as seen in GRANT command: must be one of
  *		TABLE, SEQUENCE, FUNCTION, LANGUAGE, SCHEMA, DATABASE, TABLESPACE,
  *		FOREIGN DATA WRAPPER, SERVER, or LARGE OBJECT)
@@ -54,7 +55,7 @@ static void AddAcl(PQExpBuffer aclbuf, const char *keyword,
  * since this routine uses fmtId() internally.
  */
 bool
-buildACLCommands(const char *name, const char *subname,
+buildACLCommands(const char *name, const char *subname, const char *nspname,
 				 const char *type, const char *acls, const char *racls,
 				 const char *owner, const char *prefix, int remoteVersion,
 				 PQExpBuffer sql)
@@ -154,7 +155,10 @@ buildACLCommands(const char *name, const char *subname,
 		appendPQExpBuffer(firstsql, "%sREVOKE ALL", prefix);
 		if (subname)
 			appendPQExpBuffer(firstsql, "(%s)", subname);
-		appendPQExpBuffer(firstsql, " ON %s %s FROM PUBLIC;\n", type, name);
+		appendPQExpBuffer(firstsql, " ON %s ", type);
+		if (nspname && *nspname)
+			appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+		appendPQExpBuffer(firstsql, "%s FROM PUBLIC;\n", name);
 	}
 	else
 	{
@@ -172,8 +176,11 @@ buildACLCommands(const char *name, const char *subname,
 			{
 				if (privs->len > 0)
 				{
-					appendPQExpBuffer(firstsql, "%sREVOKE %s ON %s %s FROM ",
-									  prefix, privs->data, type, name);
+					appendPQExpBuffer(firstsql, "%sREVOKE %s ON %s ",
+									  prefix, privs->data, type);
+					if (nspname && *nspname)
+						appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+					appendPQExpBuffer(firstsql, "%s FROM ", name);
 					if (grantee->len == 0)
 						appendPQExpBufferStr(firstsql, "PUBLIC;\n");
 					else if (strncmp(grantee->data, "group ",
@@ -187,8 +194,11 @@ buildACLCommands(const char *name, const char *subname,
 				if (privswgo->len > 0)
 				{
 					appendPQExpBuffer(firstsql,
-							   "%sREVOKE GRANT OPTION FOR %s ON %s %s FROM ",
-									  prefix, privswgo->data, type, name);
+									  "%sREVOKE GRANT OPTION FOR %s ON %s ",
+									  prefix, privswgo->data, type);
+					if (nspname && *nspname)
+						appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+					appendPQExpBuffer(firstsql, "%s FROM ", name);
 					if (grantee->len == 0)
 						appendPQExpBufferStr(firstsql, "PUBLIC");
 					else if (strncmp(grantee->data, "group ",
@@ -255,18 +265,33 @@ buildACLCommands(const char *name, const char *subname,
 					appendPQExpBuffer(firstsql, "%sREVOKE ALL", prefix);
 					if (subname)
 						appendPQExpBuffer(firstsql, "(%s)", subname);
-					appendPQExpBuffer(firstsql, " ON %s %s FROM %s;\n",
-									  type, name, fmtId(grantee->data));
+					appendPQExpBuffer(firstsql, " ON %s ", type);
+					if (nspname && *nspname)
+						appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+					appendPQExpBuffer(firstsql, "%s FROM %s;\n",
+									  name, fmtId(grantee->data));
 					if (privs->len > 0)
+					{
 						appendPQExpBuffer(firstsql,
-										  "%sGRANT %s ON %s %s TO %s;\n",
-										  prefix, privs->data, type, name,
-										  fmtId(grantee->data));
+										  "%sGRANT %s ON %s ",
+										  prefix, privs->data, type);
+						if (nspname && *nspname)
+							appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+						appendPQExpBuffer(firstsql,
+										  "%s TO %s;\n",
+										  name, fmtId(grantee->data));
+					}
 					if (privswgo->len > 0)
+					{
 						appendPQExpBuffer(firstsql,
-							"%sGRANT %s ON %s %s TO %s WITH GRANT OPTION;\n",
-										  prefix, privswgo->data, type, name,
-										  fmtId(grantee->data));
+										  "%sGRANT %s ON %s ",
+										  prefix, privswgo->data, type);
+						if (nspname && *nspname)
+							appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+						appendPQExpBuffer(firstsql,
+										  "%s TO %s WITH GRANT OPTION;\n",
+										  name, fmtId(grantee->data));
+					}
 				}
 			}
 			else
@@ -288,8 +313,11 @@ buildACLCommands(const char *name, const char *subname,
 
 				if (privs->len > 0)
 				{
-					appendPQExpBuffer(secondsql, "%sGRANT %s ON %s %s TO ",
-									  prefix, privs->data, type, name);
+					appendPQExpBuffer(secondsql, "%sGRANT %s ON %s ",
+									  prefix, privs->data, type);
+					if (nspname && *nspname)
+						appendPQExpBuffer(secondsql, "%s.", fmtId(nspname));
+					appendPQExpBuffer(secondsql, "%s TO ", name);
 					if (grantee->len == 0)
 						appendPQExpBufferStr(secondsql, "PUBLIC;\n");
 					else if (strncmp(grantee->data, "group ",
@@ -301,8 +329,11 @@ buildACLCommands(const char *name, const char *subname,
 				}
 				if (privswgo->len > 0)
 				{
-					appendPQExpBuffer(secondsql, "%sGRANT %s ON %s %s TO ",
-									  prefix, privswgo->data, type, name);
+					appendPQExpBuffer(secondsql, "%sGRANT %s ON %s ",
+									  prefix, privswgo->data, type);
+					if (nspname && *nspname)
+						appendPQExpBuffer(secondsql, "%s.", fmtId(nspname));
+					appendPQExpBuffer(secondsql, "%s TO ", name);
 					if (grantee->len == 0)
 						appendPQExpBufferStr(secondsql, "PUBLIC");
 					else if (strncmp(grantee->data, "group ",
@@ -332,8 +363,11 @@ buildACLCommands(const char *name, const char *subname,
 		appendPQExpBuffer(firstsql, "%sREVOKE ALL", prefix);
 		if (subname)
 			appendPQExpBuffer(firstsql, "(%s)", subname);
-		appendPQExpBuffer(firstsql, " ON %s %s FROM %s;\n",
-						  type, name, fmtId(owner));
+		appendPQExpBuffer(firstsql, " ON %s ", type);
+		if (nspname && *nspname)
+			appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+		appendPQExpBuffer(firstsql, "%s FROM %s;\n",
+						  name, fmtId(owner));
 	}
 
 	destroyPQExpBuffer(grantee);
@@ -392,7 +426,8 @@ buildDefaultACLCommands(const char *type, const char *nspname,
 	if (strlen(initacls) != 0 || strlen(initracls) != 0)
 	{
 		appendPQExpBuffer(sql, "SELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\n");
-		if (!buildACLCommands("", NULL, type, initacls, initracls, owner,
+		if (!buildACLCommands("", NULL, NULL, type,
+							  initacls, initracls, owner,
 							  prefix->data, remoteVersion, sql))
 		{
 			destroyPQExpBuffer(prefix);
@@ -401,7 +436,8 @@ buildDefaultACLCommands(const char *type, const char *nspname,
 		appendPQExpBuffer(sql, "SELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\n");
 	}
 
-	if (!buildACLCommands("", NULL, type, acls, racls, owner,
+	if (!buildACLCommands("", NULL, NULL, type,
+						  acls, racls, owner,
 						  prefix->data, remoteVersion, sql))
 	{
 		destroyPQExpBuffer(prefix);
@@ -645,26 +681,32 @@ AddAcl(PQExpBuffer aclbuf, const char *keyword, const char *subname)
  * buildShSecLabelQuery
  *
  * Build a query to retrieve security labels for a shared object.
+ * The object is identified by its OID plus the name of the catalog
+ * it can be found in (e.g., "pg_database" for database names).
+ * The query is appended to "sql".  (We don't execute it here so as to
+ * keep this file free of assumptions about how to deal with SQL errors.)
  */
 void
-buildShSecLabelQuery(PGconn *conn, const char *catalog_name, uint32 objectId,
+buildShSecLabelQuery(PGconn *conn, const char *catalog_name, Oid objectId,
 					 PQExpBuffer sql)
 {
 	appendPQExpBuffer(sql,
 					  "SELECT provider, label FROM pg_catalog.pg_shseclabel "
-					  "WHERE classoid = '%s'::pg_catalog.regclass AND "
-					  "objoid = %u", catalog_name, objectId);
+					  "WHERE classoid = 'pg_catalog.%s'::pg_catalog.regclass "
+					  "AND objoid = '%u'", catalog_name, objectId);
 }
 
 /*
  * emitShSecLabels
  *
- * Format security label data retrieved by the query generated in
- * buildShSecLabelQuery.
+ * Construct SECURITY LABEL commands using the data retrieved by the query
+ * generated by buildShSecLabelQuery, and append them to "buffer".
+ * Here, the target object is identified by its type name (e.g. "DATABASE")
+ * and its name (not pre-quoted).
  */
 void
 emitShSecLabels(PGconn *conn, PGresult *res, PQExpBuffer buffer,
-				const char *target, const char *objname)
+				const char *objtype, const char *objname)
 {
 	int			i;
 
@@ -676,7 +718,7 @@ emitShSecLabels(PGconn *conn, PGresult *res, PQExpBuffer buffer,
 		/* must use fmtId result before calling it again */
 		appendPQExpBuffer(buffer,
 						  "SECURITY LABEL FOR %s ON %s",
-						  fmtId(provider), target);
+						  fmtId(provider), objtype);
 		appendPQExpBuffer(buffer,
 						  " %s IS ",
 						  fmtId(objname));
diff --git a/src/bin/pg_dump/dumputils.h b/src/bin/pg_dump/dumputils.h
index caa390b3d3..e2241cf40e 100644
--- a/src/bin/pg_dump/dumputils.h
+++ b/src/bin/pg_dump/dumputils.h
@@ -36,7 +36,7 @@
 #endif
 
 
-extern bool buildACLCommands(const char *name, const char *subname,
+extern bool buildACLCommands(const char *name, const char *subname, const char *nspname,
 				 const char *type, const char *acls, const char *racls,
 				 const char *owner, const char *prefix, int remoteVersion,
 				 PQExpBuffer sql);
@@ -47,9 +47,9 @@ extern bool buildDefaultACLCommands(const char *type, const char *nspname,
 						int remoteVersion,
 						PQExpBuffer sql);
 extern void buildShSecLabelQuery(PGconn *conn, const char *catalog_name,
-					 uint32 objectId, PQExpBuffer sql);
+					 Oid objectId, PQExpBuffer sql);
 extern void emitShSecLabels(PGconn *conn, PGresult *res,
-				PQExpBuffer buffer, const char *target, const char *objname);
+				PQExpBuffer buffer, const char *objtype, const char *objname);
 
 extern void buildACLQueries(PQExpBuffer acl_subquery, PQExpBuffer racl_subquery,
 				PQExpBuffer init_acl_subquery, PQExpBuffer init_racl_subquery,
diff --git a/src/bin/pg_dump/pg_backup.h b/src/bin/pg_dump/pg_backup.h
index 1641861f7a..50601dc3a7 100644
--- a/src/bin/pg_dump/pg_backup.h
+++ b/src/bin/pg_dump/pg_backup.h
@@ -186,6 +186,9 @@ typedef struct Archive
 	/* info needed for string escaping */
 	int			encoding;		/* libpq code for client_encoding */
 	bool		std_strings;	/* standard_conforming_strings */
+
+	/* other important stuff */
+	char	   *searchpath;		/* search_path to set during restore */
 	char	   *use_role;		/* Issue SET ROLE to this */
 
 	/* error handling */
diff --git a/src/bin/pg_dump/pg_backup_archiver.c b/src/bin/pg_dump/pg_backup_archiver.c
index 58d95c24df..527fc4419a 100644
--- a/src/bin/pg_dump/pg_backup_archiver.c
+++ b/src/bin/pg_dump/pg_backup_archiver.c
@@ -71,6 +71,7 @@ static void _selectOutputSchema(ArchiveHandle *AH, const char *schemaName);
 static void _selectTablespace(ArchiveHandle *AH, const char *tablespace);
 static void processEncodingEntry(ArchiveHandle *AH, TocEntry *te);
 static void processStdStringsEntry(ArchiveHandle *AH, TocEntry *te);
+static void processSearchPathEntry(ArchiveHandle *AH, TocEntry *te);
 static teReqs _tocEntryRequired(TocEntry *te, teSection curSection, RestoreOptions *ropt);
 static RestorePass _tocEntryRestorePass(TocEntry *te);
 static bool _tocEntryIsACL(TocEntry *te);
@@ -895,7 +896,9 @@ restore_toc_entry(ArchiveHandle *AH, TocEntry *te, bool is_parallel)
 						ahprintf(AH, "TRUNCATE TABLE %s%s;\n\n",
 								 (PQserverVersion(AH->connection) >= 80400 ?
 								  "ONLY " : ""),
-								 fmtId(te->tag));
+							  fmtQualifiedId(PQserverVersion(AH->connection),
+											 te->namespace,
+											 te->tag));
 					}
 
 					/*
@@ -982,10 +985,10 @@ _disableTriggersIfNecessary(ArchiveHandle *AH, TocEntry *te)
 	/*
 	 * Disable them.
 	 */
-	_selectOutputSchema(AH, te->namespace);
-
 	ahprintf(AH, "ALTER TABLE %s DISABLE TRIGGER ALL;\n\n",
-			 fmtId(te->tag));
+			 fmtQualifiedId(PQserverVersion(AH->connection),
+							te->namespace,
+							te->tag));
 }
 
 static void
@@ -1010,10 +1013,10 @@ _enableTriggersIfNecessary(ArchiveHandle *AH, TocEntry *te)
 	/*
 	 * Enable them.
 	 */
-	_selectOutputSchema(AH, te->namespace);
-
 	ahprintf(AH, "ALTER TABLE %s ENABLE TRIGGER ALL;\n\n",
-			 fmtId(te->tag));
+			 fmtQualifiedId(PQserverVersion(AH->connection),
+							te->namespace,
+							te->tag));
 }
 
 /*
@@ -2683,6 +2686,8 @@ ReadToc(ArchiveHandle *AH)
 			processEncodingEntry(AH, te);
 		else if (strcmp(te->desc, "STDSTRINGS") == 0)
 			processStdStringsEntry(AH, te);
+		else if (strcmp(te->desc, "SEARCHPATH") == 0)
+			processSearchPathEntry(AH, te);
 	}
 }
 
@@ -2730,6 +2735,16 @@ processStdStringsEntry(ArchiveHandle *AH, TocEntry *te)
 					  te->defn);
 }
 
+static void
+processSearchPathEntry(ArchiveHandle *AH, TocEntry *te)
+{
+	/*
+	 * te->defn should contain a command to set search_path.  We just copy it
+	 * verbatim for use later.
+	 */
+	AH->public.searchpath = pg_strdup(te->defn);
+}
+
 static void
 StrictNamesCheck(RestoreOptions *ropt)
 {
@@ -2778,9 +2793,10 @@ _tocEntryRequired(TocEntry *te, teSection curSection, RestoreOptions *ropt)
 {
 	teReqs		res = REQ_SCHEMA | REQ_DATA;
 
-	/* ENCODING and STDSTRINGS items are treated specially */
+	/* These items are treated specially */
 	if (strcmp(te->desc, "ENCODING") == 0 ||
-		strcmp(te->desc, "STDSTRINGS") == 0)
+		strcmp(te->desc, "STDSTRINGS") == 0 ||
+		strcmp(te->desc, "SEARCHPATH") == 0)
 		return REQ_SPECIAL;
 
 	/* If it's an ACL, maybe ignore it */
@@ -2993,6 +3009,10 @@ _doSetFixedOutputState(ArchiveHandle *AH)
 	if (ropt && ropt->use_role)
 		ahprintf(AH, "SET ROLE %s;\n", fmtId(ropt->use_role));
 
+	/* Select the dump-time search_path */
+	if (AH->public.searchpath)
+		ahprintf(AH, "%s", AH->public.searchpath);
+
 	/* Make sure function checking is disabled */
 	ahprintf(AH, "SET check_function_bodies = false;\n");
 
@@ -3197,6 +3217,15 @@ _selectOutputSchema(ArchiveHandle *AH, const char *schemaName)
 {
 	PQExpBuffer qry;
 
+	/*
+	 * If there was a SEARCHPATH TOC entry, we're supposed to just stay with
+	 * that search_path rather than switching to entry-specific paths.
+	 * Otherwise, it's an old archive that will not restore correctly unless
+	 * we set the search_path as it's expecting.
+	 */
+	if (AH->public.searchpath)
+		return;
+
 	if (!schemaName || *schemaName == '\0' ||
 		(AH->currSchema && strcmp(AH->currSchema, schemaName) == 0))
 		return;					/* no need to do anything */
@@ -3326,8 +3355,10 @@ _getObjectDescription(PQExpBuffer buf, TocEntry *te, ArchiveHandle *AH)
 		strcmp(type, "SERVER") == 0 ||
 		strcmp(type, "USER MAPPING") == 0)
 	{
-		/* We already know that search_path was set properly */
-		appendPQExpBuffer(buf, "%s %s", type, fmtId(te->tag));
+		appendPQExpBuffer(buf, "%s ", type);
+		if (te->namespace && *te->namespace)
+			appendPQExpBuffer(buf, "%s.", fmtId(te->namespace));
+		appendPQExpBufferStr(buf, fmtId(te->tag));
 		return;
 	}
 
diff --git a/src/bin/pg_dump/pg_backup_archiver.h b/src/bin/pg_dump/pg_backup_archiver.h
index 5eb1fc4949..b4e1d47969 100644
--- a/src/bin/pg_dump/pg_backup_archiver.h
+++ b/src/bin/pg_dump/pg_backup_archiver.h
@@ -64,7 +64,7 @@ typedef z_stream *z_streamp;
 
 /* Current archive version number (the format we can output) */
 #define K_VERS_MAJOR 1
-#define K_VERS_MINOR 12
+#define K_VERS_MINOR 13
 #define K_VERS_REV 0
 
 /* Data block types */
@@ -90,9 +90,11 @@ typedef z_stream *z_streamp;
 																 * indicator */
 #define K_VERS_1_12 (( (1 * 256 + 12) * 256 + 0) * 256 + 0)		/* add separate BLOB
 																 * entries */
+#define K_VERS_1_13 (( (1 * 256 + 13) * 256 + 0) * 256 + 0)		/* change search_path
+																 * behavior */
 
 /* Newest format we can read */
-#define K_VERS_MAX (( (1 * 256 + 12) * 256 + 255) * 256 + 0)
+#define K_VERS_MAX (( (1 * 256 + 13) * 256 + 255) * 256 + 0)
 
 
 /* Flags to indicate disposition of offsets stored in files */
diff --git a/src/bin/pg_dump/pg_dump.c b/src/bin/pg_dump/pg_dump.c
index 548f37f554..e6c09772ec 100644
--- a/src/bin/pg_dump/pg_dump.c
+++ b/src/bin/pg_dump/pg_dump.c
@@ -132,6 +132,15 @@ char		g_comment_end[10];
 
 static const CatalogId nilCatalogId = {0, 0};
 
+/*
+ * Macro for producing quoted, schema-qualified name of a dumpable object.
+ * Note implicit dependence on "fout"; we should get rid of that argument.
+ */
+#define fmtQualifiedDumpable(obj) \
+	fmtQualifiedId(fout->remoteVersion, \
+				   (obj)->dobj.namespace->dobj.name, \
+				   (obj)->dobj.name)
+
 static void help(const char *progname);
 static void setup_connection(Archive *AH,
 				 const char *dumpencoding, const char *dumpsnapshot,
@@ -149,13 +158,13 @@ static NamespaceInfo *findNamespace(Archive *fout, Oid nsoid, Oid objoid);
 static void dumpTableData(Archive *fout, TableDataInfo *tdinfo);
 static void refreshMatViewData(Archive *fout, TableDataInfo *tdinfo);
 static void guessConstraintInheritance(TableInfo *tblinfo, int numTables);
-static void dumpComment(Archive *fout, const char *target,
+static void dumpComment(Archive *fout, const char *type, const char *name,
 			const char *namespace, const char *owner,
 			CatalogId catalogId, int subid, DumpId dumpId);
 static int findComments(Archive *fout, Oid classoid, Oid objoid,
 			 CommentItem **items);
 static int	collectComments(Archive *fout, CommentItem **items);
-static void dumpSecLabel(Archive *fout, const char *target,
+static void dumpSecLabel(Archive *fout, const char *type, const char *name,
 			 const char *namespace, const char *owner,
 			 CatalogId catalogId, int subid, DumpId dumpId);
 static int findSecLabels(Archive *fout, Oid classoid, Oid objoid,
@@ -208,7 +217,7 @@ static void dumpDefaultACL(Archive *fout, DefaultACLInfo *daclinfo);
 
 static void dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
 		const char *type, const char *name, const char *subname,
-		const char *tag, const char *nspname, const char *owner,
+		const char *nspname, const char *owner,
 		const char *acls, const char *racls,
 		const char *initacls, const char *initracls);
 
@@ -237,11 +246,10 @@ static char *format_function_signature(Archive *fout,
 						  FuncInfo *finfo, bool honor_quotes);
 static char *convertRegProcReference(Archive *fout,
 						const char *proc);
-static char *convertOperatorReference(Archive *fout, const char *opr);
+static char *getFormattedOperatorName(Archive *fout, const char *oproid);
 static char *convertTSFunction(Archive *fout, Oid funcOid);
 static Oid	findLastBuiltinOid_V71(Archive *fout, const char *);
 static Oid	findLastBuiltinOid_V70(Archive *fout);
-static void selectSourceSchema(Archive *fout, const char *schemaName);
 static char *getFormattedTypeName(Archive *fout, Oid oid, OidOptions opts);
 static char *myFormatType(const char *typname, int32 typmod);
 static void getBlobs(Archive *fout);
@@ -251,6 +259,7 @@ static void dumpPolicy(Archive *fout, PolicyInfo *polinfo);
 static void dumpDatabase(Archive *AH);
 static void dumpEncoding(Archive *AH);
 static void dumpStdStrings(Archive *AH);
+static void dumpSearchPath(Archive *AH);
 static void binary_upgrade_set_type_oids_by_type_oid(Archive *fout,
 								PQExpBuffer upgrade_buffer, Oid pg_type_oid);
 static bool binary_upgrade_set_type_oids_by_rel_oid(Archive *fout,
@@ -260,7 +269,9 @@ static void binary_upgrade_set_pg_class_oids(Archive *fout,
 								 Oid pg_class_oid, bool is_index);
 static void binary_upgrade_extension_member(PQExpBuffer upgrade_buffer,
 								DumpableObject *dobj,
-								const char *objlabel);
+								const char *objtype,
+								const char *objname,
+								const char *objnamespace);
 static const char *getAttrName(int attrnum, TableInfo *tblInfo);
 static const char *fmtCopyColumnList(const TableInfo *ti, PQExpBuffer buffer);
 static bool nonemptyReloptions(const char *reloptions);
@@ -815,9 +826,10 @@ main(int argc, char **argv)
 	 * order.
 	 */
 
-	/* First the special ENCODING and STDSTRINGS entries. */
+	/* First the special ENCODING, STDSTRINGS, and SEARCHPATH entries. */
 	dumpEncoding(fout);
 	dumpStdStrings(fout);
+	dumpSearchPath(fout);
 
 	/* The database item is always next, unless we don't want it at all */
 	if (dopt.include_everything && !dopt.dataOnly)
@@ -1671,14 +1683,6 @@ dumpTableData_copy(Archive *fout, void *dcontext)
 		write_msg(NULL, "dumping contents of table \"%s.%s\"\n",
 				  tbinfo->dobj.namespace->dobj.name, classname);
 
-	/*
-	 * Make sure we are in proper schema.  We will qualify the table name
-	 * below anyway (in case its name conflicts with a pg_catalog table); but
-	 * this ensures reproducible results in case the table contains regproc,
-	 * regclass, etc columns.
-	 */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 	/*
 	 * If possible, specify the column list explicitly so that we have no
 	 * possibility of retrieving data in the wrong column order.  (The default
@@ -1693,9 +1697,7 @@ dumpTableData_copy(Archive *fout, void *dcontext)
 	if (oids && hasoids)
 	{
 		appendPQExpBuffer(q, "COPY %s %s WITH OIDS TO stdout;",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname),
+						  fmtQualifiedDumpable(tbinfo),
 						  column_list);
 	}
 	else if (tdinfo->filtercond)
@@ -1711,17 +1713,13 @@ dumpTableData_copy(Archive *fout, void *dcontext)
 		else
 			appendPQExpBufferStr(q, "* ");
 		appendPQExpBuffer(q, "FROM %s %s) TO stdout;",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname),
+						  fmtQualifiedDumpable(tbinfo),
 						  tdinfo->filtercond);
 	}
 	else
 	{
 		appendPQExpBuffer(q, "COPY %s %s TO stdout;",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname),
+						  fmtQualifiedDumpable(tbinfo),
 						  column_list);
 	}
 	res = ExecuteSqlQuery(fout, q->data, PGRES_COPY_OUT);
@@ -1831,7 +1829,6 @@ dumpTableData_insert(Archive *fout, void *dcontext)
 {
 	TableDataInfo *tdinfo = (TableDataInfo *) dcontext;
 	TableInfo  *tbinfo = tdinfo->tdtable;
-	const char *classname = tbinfo->dobj.name;
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer insertStmt = NULL;
@@ -1840,29 +1837,17 @@ dumpTableData_insert(Archive *fout, void *dcontext)
 	int			nfields;
 	int			field;
 
-	/*
-	 * Make sure we are in proper schema.  We will qualify the table name
-	 * below anyway (in case its name conflicts with a pg_catalog table); but
-	 * this ensures reproducible results in case the table contains regproc,
-	 * regclass, etc columns.
-	 */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 	if (fout->remoteVersion >= 70100)
 	{
 		appendPQExpBuffer(q, "DECLARE _pg_dump_cursor CURSOR FOR "
 						  "SELECT * FROM ONLY %s",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname));
+						  fmtQualifiedDumpable(tbinfo));
 	}
 	else
 	{
 		appendPQExpBuffer(q, "DECLARE _pg_dump_cursor CURSOR FOR "
 						  "SELECT * FROM %s",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname));
+						  fmtQualifiedDumpable(tbinfo));
 	}
 	if (tdinfo->filtercond)
 		appendPQExpBuffer(q, " %s", tdinfo->filtercond);
@@ -1887,7 +1872,7 @@ dumpTableData_insert(Archive *fout, void *dcontext)
 			{
 				insertStmt = createPQExpBuffer();
 				appendPQExpBuffer(insertStmt, "INSERT INTO %s ",
-								  fmtId(classname));
+								  fmtQualifiedDumpable(tbinfo));
 
 				/* corner case for zero-column table */
 				if (nfields == 0)
@@ -2029,7 +2014,7 @@ dumpTableData(Archive *fout, TableDataInfo *tdinfo)
 		dumpFn = dumpTableData_copy;
 		/* must use 2 steps here 'cause fmtId is nonreentrant */
 		appendPQExpBuffer(copyBuf, "COPY %s ",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(copyBuf, "%s %sFROM stdin;\n",
 						  fmtCopyColumnList(tbinfo, clistBuf),
 					  (tdinfo->oids && tbinfo->hasoids) ? "WITH OIDS " : "");
@@ -2080,7 +2065,7 @@ refreshMatViewData(Archive *fout, TableDataInfo *tdinfo)
 	q = createPQExpBuffer();
 
 	appendPQExpBuffer(q, "REFRESH MATERIALIZED VIEW %s;\n",
-					  fmtId(tbinfo->dobj.name));
+					  fmtQualifiedDumpable(tbinfo));
 
 	if (tdinfo->dobj.dump & DUMP_COMPONENT_DATA)
 		ArchiveEntry(fout,
@@ -2202,9 +2187,6 @@ buildMatViewRefreshDependencies(Archive *fout)
 	if (fout->remoteVersion < 90300)
 		return;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	query = createPQExpBuffer();
 
 	appendPQExpBufferStr(query, "WITH RECURSIVE w AS "
@@ -2448,15 +2430,14 @@ dumpDatabase(Archive *fout)
 			   *tablespace;
 	uint32		frozenxid,
 				minmxid;
+	char	   *qdatname;
 
 	datname = PQdb(conn);
+	qdatname = pg_strdup(fmtId(datname));
 
 	if (g_verbose)
 		write_msg(NULL, "saving database definition\n");
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/* Get the database owner and parameters from pg_database */
 	if (fout->remoteVersion >= 90300)
 	{
@@ -2564,7 +2545,7 @@ dumpDatabase(Archive *fout)
 	tablespace = PQgetvalue(res, 0, i_tablespace);
 
 	appendPQExpBuffer(creaQry, "CREATE DATABASE %s WITH TEMPLATE = template0",
-					  fmtId(datname));
+					  qdatname);
 	if (strlen(encoding) > 0)
 	{
 		appendPQExpBufferStr(creaQry, " ENCODING = ");
@@ -2595,11 +2576,10 @@ dumpDatabase(Archive *fout)
 						  frozenxid, minmxid);
 		appendStringLiteralAH(creaQry, datname, fout);
 		appendPQExpBufferStr(creaQry, ";\n");
-
 	}
 
 	appendPQExpBuffer(delQry, "DROP DATABASE %s;\n",
-					  fmtId(datname));
+					  qdatname);
 
 	dbDumpId = createDumpId();
 
@@ -2713,8 +2693,8 @@ dumpDatabase(Archive *fout)
 		destroyPQExpBuffer(loOutQry);
 	}
 
-	/* Compute correct tag for comments etc */
-	appendPQExpBuffer(labelq, "DATABASE %s", fmtId(datname));
+	/* Compute correct tag for archive entry */
+	appendPQExpBuffer(labelq, "DATABASE %s", qdatname);
 
 	/* Dump DB comment if any */
 	if (fout->remoteVersion >= 80200)
@@ -2734,7 +2714,7 @@ dumpDatabase(Archive *fout)
 			 * Generates warning when loaded into a differently-named
 			 * database.
 			 */
-			appendPQExpBuffer(dbQry, "COMMENT ON DATABASE %s IS ", fmtId(datname));
+			appendPQExpBuffer(dbQry, "COMMENT ON DATABASE %s IS ", qdatname);
 			appendStringLiteralAH(dbQry, comment, fout);
 			appendPQExpBufferStr(dbQry, ";\n");
 
@@ -2748,7 +2728,7 @@ dumpDatabase(Archive *fout)
 	}
 	else
 	{
-		dumpComment(fout, labelq->data, NULL, dba,
+		dumpComment(fout, "DATABASE", qdatname, NULL, dba,
 					dbCatId, 0, dbDumpId);
 	}
 
@@ -2777,6 +2757,7 @@ dumpDatabase(Archive *fout)
 
 	PQclear(res);
 
+	free(qdatname);
 	destroyPQExpBuffer(dbQry);
 	destroyPQExpBuffer(delQry);
 	destroyPQExpBuffer(creaQry);
@@ -2836,6 +2817,84 @@ dumpStdStrings(Archive *AH)
 	destroyPQExpBuffer(qry);
 }
 
+/*
+ * dumpSearchPath: record the active search_path in the archive
+ */
+static void
+dumpSearchPath(Archive *AH)
+{
+	PQExpBuffer qry = createPQExpBuffer();
+	PQExpBuffer path = createPQExpBuffer();
+	PGresult   *res;
+	char	  **schemanames = NULL;
+	int			nschemanames = 0;
+	int			i;
+
+	if (AH->remoteVersion >= 70300)
+	{
+		/*
+		 * We use the result of current_schemas(), not the search_path GUC,
+		 * because that might contain wildcards such as "$user", which won't
+		 * necessarily have the same value during restore.  Also, this way
+		 * avoids listing schemas that may appear in search_path but not
+		 * actually exist, which seems like a prudent exclusion.
+		 */
+		res = ExecuteSqlQueryForSingleRow(AH,
+								 "SELECT pg_catalog.current_schemas(false)");
+
+		if (!parsePGArray(PQgetvalue(res, 0, 0), &schemanames, &nschemanames))
+			exit_horribly(NULL, "could not parse result of current_schemas()\n");
+
+		/*
+		 * We use set_config(), not a simple "SET search_path" command,
+		 * because the latter has less-clean behavior if the search path is
+		 * empty.  While that's likely to get fixed at some point, it seems
+		 * like a good idea to be as backwards-compatible as possible in what
+		 * we put into archives.
+		 */
+		for (i = 0; i < nschemanames; i++)
+		{
+			if (i > 0)
+				appendPQExpBufferStr(path, ", ");
+			appendPQExpBufferStr(path, fmtId(schemanames[i]));
+		}
+
+		PQclear(res);
+	}
+	else
+	{
+		/*
+		 * For pre-schema servers, we must force the output search path to be
+		 * "public", because the source server's ruleutils functions will not
+		 * schema-qualify anything.  Thus, for example, references to user
+		 * tables in view definitions won't work otherwise.
+		 */
+		appendPQExpBufferStr(path, "public");
+	}
+
+	appendPQExpBufferStr(qry, "SELECT pg_catalog.set_config('search_path', ");
+	appendStringLiteralAH(qry, path->data, AH);
+	appendPQExpBufferStr(qry, ", false);\n");
+
+	if (g_verbose)
+		write_msg(NULL, "saving search_path = %s\n", path->data);
+
+	ArchiveEntry(AH, nilCatalogId, createDumpId(),
+				 "SEARCHPATH", NULL, NULL, "",
+				 false, "SEARCHPATH", SECTION_PRE_DATA,
+				 qry->data, "", NULL,
+				 NULL, 0,
+				 NULL, NULL);
+
+	/* Also save it in AH->searchpath, in case we're doing plain text dump */
+	AH->searchpath = pg_strdup(qry->data);
+
+	if (schemanames)
+		free(schemanames);
+	destroyPQExpBuffer(qry);
+	destroyPQExpBuffer(path);
+}
+
 
 /*
  * getBlobs:
@@ -2862,9 +2921,6 @@ getBlobs(Archive *fout)
 	if (g_verbose)
 		write_msg(NULL, "reading large objects\n");
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/* Fetch BLOB OIDs, and owner/ACL data if >= 9.0 */
 	if (fout->remoteVersion >= 90600)
 	{
@@ -3017,26 +3073,22 @@ dumpBlob(Archive *fout, BlobInfo *binfo)
 					 NULL, 0,
 					 NULL, NULL);
 
-	/* set up tag for comment and/or ACL */
-	resetPQExpBuffer(cquery);
-	appendPQExpBuffer(cquery, "LARGE OBJECT %s", binfo->dobj.name);
-
 	/* Dump comment if any */
 	if (binfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, cquery->data,
+		dumpComment(fout, "LARGE OBJECT", binfo->dobj.name,
 					NULL, binfo->rolname,
 					binfo->dobj.catId, 0, binfo->dobj.dumpId);
 
 	/* Dump security label if any */
 	if (binfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, cquery->data,
+		dumpSecLabel(fout, "LARGE OBJECT", binfo->dobj.name,
 					 NULL, binfo->rolname,
 					 binfo->dobj.catId, 0, binfo->dobj.dumpId);
 
 	/* Dump ACL if any */
 	if (binfo->blobacl && (binfo->dobj.dump & DUMP_COMPONENT_ACL))
 		dumpACL(fout, binfo->dobj.catId, binfo->dobj.dumpId, "LARGE OBJECT",
-				binfo->dobj.name, NULL, cquery->data,
+				binfo->dobj.name, NULL,
 				NULL, binfo->rolname, binfo->blobacl, binfo->rblobacl,
 				binfo->initblobacl, binfo->initrblobacl);
 
@@ -3063,9 +3115,6 @@ dumpBlobs(Archive *fout, void *arg)
 	if (g_verbose)
 		write_msg(NULL, "saving large objects\n");
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * Currently, we re-fetch all BLOB OIDs using a cursor.  Consider scanning
 	 * the already-in-memory dumpable objects instead...
@@ -3195,11 +3244,6 @@ getPolicies(Archive *fout, TableInfo tblinfo[], int numTables)
 					  tbinfo->dobj.namespace->dobj.name,
 					  tbinfo->dobj.name);
 
-		/*
-		 * select table schema to ensure regproc name is qualified if needed
-		 */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		resetPQExpBuffer(query);
 
 		/* Get the policies for the table. */
@@ -3295,7 +3339,7 @@ dumpPolicy(Archive *fout, PolicyInfo *polinfo)
 		query = createPQExpBuffer();
 
 		appendPQExpBuffer(query, "ALTER TABLE %s ENABLE ROW LEVEL SECURITY;",
-						  fmtId(polinfo->dobj.name));
+						  fmtQualifiedDumpable(polinfo));
 
 		if (polinfo->dobj.dump & DUMP_COMPONENT_POLICY)
 			ArchiveEntry(fout, polinfo->dobj.catId, polinfo->dobj.dumpId,
@@ -3333,7 +3377,9 @@ dumpPolicy(Archive *fout, PolicyInfo *polinfo)
 	delqry = createPQExpBuffer();
 
 	appendPQExpBuffer(query, "CREATE POLICY %s", fmtId(polinfo->polname));
-	appendPQExpBuffer(query, " ON %s FOR %s", fmtId(tbinfo->dobj.name), cmd);
+
+	appendPQExpBuffer(query, " ON %s FOR %s", fmtQualifiedDumpable(tbinfo),
+					  cmd);
 
 	if (polinfo->polroles != NULL)
 		appendPQExpBuffer(query, " TO %s", polinfo->polroles);
@@ -3347,7 +3393,7 @@ dumpPolicy(Archive *fout, PolicyInfo *polinfo)
 	appendPQExpBuffer(query, ";\n");
 
 	appendPQExpBuffer(delqry, "DROP POLICY %s", fmtId(polinfo->polname));
-	appendPQExpBuffer(delqry, " ON %s;\n", fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delqry, " ON %s;\n", fmtQualifiedDumpable(tbinfo));
 
 	tag = psprintf("%s %s", tbinfo->dobj.name, polinfo->dobj.name);
 
@@ -3517,11 +3563,16 @@ binary_upgrade_set_pg_class_oids(Archive *fout,
 /*
  * If the DumpableObject is a member of an extension, add a suitable
  * ALTER EXTENSION ADD command to the creation commands in upgrade_buffer.
+ *
+ * For somewhat historical reasons, objname should already be quoted,
+ * but not objnamespace (if any).
  */
 static void
 binary_upgrade_extension_member(PQExpBuffer upgrade_buffer,
 								DumpableObject *dobj,
-								const char *objlabel)
+								const char *objtype,
+								const char *objname,
+								const char *objnamespace)
 {
 	DumpableObject *extobj = NULL;
 	int			i;
@@ -3543,13 +3594,17 @@ binary_upgrade_extension_member(PQExpBuffer upgrade_buffer,
 		extobj = NULL;
 	}
 	if (extobj == NULL)
-		exit_horribly(NULL, "could not find parent extension for %s\n", objlabel);
+		exit_horribly(NULL, "could not find parent extension for %s %s\n",
+					  objtype, objname);
 
 	appendPQExpBufferStr(upgrade_buffer,
 	  "\n-- For binary upgrade, handle extension membership the hard way\n");
-	appendPQExpBuffer(upgrade_buffer, "ALTER EXTENSION %s ADD %s;\n",
+	appendPQExpBuffer(upgrade_buffer, "ALTER EXTENSION %s ADD %s ",
 					  fmtId(extobj->name),
-					  objlabel);
+					  objtype);
+	if (objnamespace && *objnamespace)
+		appendPQExpBuffer(upgrade_buffer, "%s.", fmtId(objnamespace));
+	appendPQExpBuffer(upgrade_buffer, "%s;\n", objname);
 }
 
 /*
@@ -3618,9 +3673,6 @@ getNamespaces(Archive *fout, int *numNamespaces)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * we fetch all namespaces including system ones, so that every object we
 	 * read in can be linked to a containing namespace.
@@ -3820,9 +3872,6 @@ getExtensions(Archive *fout, int *numExtensions)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBufferStr(query, "SELECT x.tableoid, x.oid, "
 						 "x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition "
 						 "FROM pg_extension x "
@@ -3922,9 +3971,6 @@ getTypes(Archive *fout, int *numTypes)
 	 * be revisited if the backend ever allows renaming of array types.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90600)
 	{
 		PQExpBuffer acl_subquery = createPQExpBuffer();
@@ -4235,9 +4281,6 @@ getOperators(Archive *fout, int *numOprs)
 	 * system-defined operators at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 70300)
 	{
 		appendPQExpBuffer(query, "SELECT tableoid, oid, oprname, "
@@ -4354,9 +4397,6 @@ getCollations(Archive *fout, int *numCollations)
 	 * system-defined collations at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, collname, "
 					  "collnamespace, "
 					  "(%s collowner) AS rolname "
@@ -4438,9 +4478,6 @@ getConversions(Archive *fout, int *numConversions)
 	 * system-defined conversions at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, conname, "
 					  "connamespace, "
 					  "(%s conowner) AS rolname "
@@ -4517,9 +4554,6 @@ getAccessMethods(Archive *fout, int *numAccessMethods)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/* Select all access methods from pg_am table */
 	appendPQExpBuffer(query, "SELECT tableoid, oid, amname, amtype, "
 					  "amhandler::pg_catalog.regproc AS amhandler "
@@ -4590,9 +4624,6 @@ getOpclasses(Archive *fout, int *numOpclasses)
 	 * system-defined opclasses at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 70300)
 	{
 		appendPQExpBuffer(query, "SELECT tableoid, oid, opcname, "
@@ -4700,9 +4731,6 @@ getOpfamilies(Archive *fout, int *numOpfamilies)
 	 * system-defined opfamilies at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, opfname, "
 					  "opfnamespace, "
 					  "(%s opfowner) AS rolname "
@@ -4784,9 +4812,6 @@ getAggregates(Archive *fout, int *numAggs)
 	int			i_initaggacl;
 	int			i_initraggacl;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * Find all interesting aggregates.  See comment in getFuncs() for the
 	 * rationale behind the filtering logic.
@@ -5015,9 +5040,6 @@ getFuncs(Archive *fout, int *numFuncs)
 	int			i_initproacl;
 	int			i_initrproacl;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * Find all interesting functions.  This is a bit complicated:
 	 *
@@ -5304,9 +5326,6 @@ getTables(Archive *fout, int *numTables)
 	int			i_relpages;
 	int			i_changed_acl;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * Find all the tables and table-like objects.
 	 *
@@ -6096,9 +6115,7 @@ getTables(Archive *fout, int *numTables)
 			resetPQExpBuffer(query);
 			appendPQExpBuffer(query,
 							  "LOCK TABLE %s IN ACCESS SHARE MODE",
-							  fmtQualifiedId(fout->remoteVersion,
-										tblinfo[i].dobj.namespace->dobj.name,
-											 tblinfo[i].dobj.name));
+							  fmtQualifiedDumpable(&tblinfo[i]));
 			ExecuteSqlStatement(fout, query->data);
 		}
 
@@ -6186,13 +6203,9 @@ getInherits(Archive *fout, int *numInherits)
 	int			i;
 	PQExpBuffer query = createPQExpBuffer();
 	InhInfo    *inhinfo;
-
 	int			i_inhrelid;
 	int			i_inhparent;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/* find all the inheritance information */
 
 	appendPQExpBufferStr(query, "SELECT inhrelid, inhparent FROM pg_inherits");
@@ -6277,9 +6290,6 @@ getIndexes(Archive *fout, TableInfo tblinfo[], int numTables)
 					  tbinfo->dobj.namespace->dobj.name,
 					  tbinfo->dobj.name);
 
-		/* Make sure we are in proper schema so indexdef is right */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		/*
 		 * The point of the messy-looking outer join is to find a constraint
 		 * that is related by an internal dependency link to the index. If we
@@ -6645,12 +6655,6 @@ getConstraints(Archive *fout, TableInfo tblinfo[], int numTables)
 					  tbinfo->dobj.namespace->dobj.name,
 					  tbinfo->dobj.name);
 
-		/*
-		 * select table schema to ensure constraint expr is qualified if
-		 * needed
-		 */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		resetPQExpBuffer(query);
 		appendPQExpBuffer(query,
 						  "SELECT tableoid, oid, conname, confrelid, "
@@ -6719,12 +6723,6 @@ getDomainConstraints(Archive *fout, TypeInfo *tyinfo)
 	if (fout->remoteVersion < 70300)
 		return;
 
-	/*
-	 * select appropriate schema to ensure names in constraint are properly
-	 * qualified
-	 */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	query = createPQExpBuffer();
 
 	if (fout->remoteVersion >= 90100)
@@ -6827,9 +6825,6 @@ getRules(Archive *fout, int *numRules)
 	int			i_is_instead;
 	int			i_ev_enabled;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 80300)
 	{
 		appendPQExpBufferStr(query, "SELECT "
@@ -6985,11 +6980,6 @@ getTriggers(Archive *fout, TableInfo tblinfo[], int numTables)
 					  tbinfo->dobj.namespace->dobj.name,
 					  tbinfo->dobj.name);
 
-		/*
-		 * select table schema to ensure regproc name is qualified if needed
-		 */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		resetPQExpBuffer(query);
 		if (fout->remoteVersion >= 90000)
 		{
@@ -7200,9 +7190,6 @@ getEventTriggers(Archive *fout, int *numEventTriggers)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query,
 					  "SELECT e.tableoid, e.oid, evtname, evtenabled, "
 					  "evtevent, (%s evtowner) AS evtowner, "
@@ -7290,9 +7277,6 @@ getProcLangs(Archive *fout, int *numProcLangs)
 	int			i_initrlanacl;
 	int			i_lanowner;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90600)
 	{
 		PQExpBuffer acl_subquery = createPQExpBuffer();
@@ -7518,9 +7502,6 @@ getCasts(Archive *fout, int *numCasts)
 	int			i_castcontext;
 	int			i_castmethod;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 80400)
 	{
 		appendPQExpBufferStr(query, "SELECT tableoid, oid, "
@@ -7670,9 +7651,6 @@ getTransforms(Archive *fout, int *numTransforms)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, "
 					  "trftype, trflang, trffromsql::oid, trftosql::oid "
 					  "FROM pg_transform "
@@ -7785,12 +7763,6 @@ getTableAttrs(Archive *fout, TableInfo *tblinfo, int numTables)
 		if (!tbinfo->interesting)
 			continue;
 
-		/*
-		 * Make sure we are in proper schema for this table; this allows
-		 * correct retrieval of formatted type names and default exprs
-		 */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		/* find all the user attributes and their types */
 
 		/*
@@ -8363,9 +8335,6 @@ getTSParsers(Archive *fout, int *numTSParsers)
 	 * system-defined objects at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBufferStr(query, "SELECT tableoid, oid, prsname, prsnamespace, "
 						 "prsstart::oid, prstoken::oid, "
 						 "prsend::oid, prsheadline::oid, prslextype::oid "
@@ -8451,9 +8420,6 @@ getTSDictionaries(Archive *fout, int *numTSDicts)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, dictname, "
 					  "dictnamespace, (%s dictowner) AS rolname, "
 					  "dicttemplate, dictinitoption "
@@ -8538,9 +8504,6 @@ getTSTemplates(Archive *fout, int *numTSTemplates)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBufferStr(query, "SELECT tableoid, oid, tmplname, "
 						 "tmplnamespace, tmplinit::oid, tmpllexize::oid "
 						 "FROM pg_ts_template");
@@ -8618,9 +8581,6 @@ getTSConfigurations(Archive *fout, int *numTSConfigs)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, cfgname, "
 					  "cfgnamespace, (%s cfgowner) AS rolname, cfgparser "
 					  "FROM pg_ts_config",
@@ -8705,9 +8665,6 @@ getForeignDataWrappers(Archive *fout, int *numForeignDataWrappers)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90600)
 	{
 		PQExpBuffer acl_subquery = createPQExpBuffer();
@@ -8875,9 +8832,6 @@ getForeignServers(Archive *fout, int *numForeignServers)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90600)
 	{
 		PQExpBuffer acl_subquery = createPQExpBuffer();
@@ -9024,9 +8978,6 @@ getDefaultACLs(Archive *fout, int *numDefaultACLs)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90600)
 	{
 		PQExpBuffer acl_subquery = createPQExpBuffer();
@@ -9128,13 +9079,18 @@ getDefaultACLs(Archive *fout, int *numDefaultACLs)
  * dumpComment --
  *
  * This routine is used to dump any comments associated with the
- * object handed to this routine. The routine takes a constant character
- * string for the target part of the comment-creation command, plus
+ * object handed to this routine. The routine takes the object type
+ * and object name (ready to print, except for schema decoration), plus
  * the namespace and owner of the object (for labeling the ArchiveEntry),
  * plus catalog ID and subid which are the lookup key for pg_description,
  * plus the dump ID for the object (for setting a dependency).
  * If a matching pg_description entry is found, it is dumped.
  *
+ * Note: in some cases, such as comments for triggers and rules, the "type"
+ * string really looks like, e.g., "TRIGGER name ON".  This is a bit of a hack
+ * but it doesn't seem worth complicating the API for all callers to make
+ * it cleaner.
+ *
  * Note: although this routine takes a dumpId for dependency purposes,
  * that purpose is just to mark the dependency in the emitted dump file
  * for possible future use by pg_restore.  We do NOT use it for determining
@@ -9143,7 +9099,7 @@ getDefaultACLs(Archive *fout, int *numDefaultACLs)
  * calling ArchiveEntry() for the specified object.
  */
 static void
-dumpComment(Archive *fout, const char *target,
+dumpComment(Archive *fout, const char *type, const char *name,
 			const char *namespace, const char *owner,
 			CatalogId catalogId, int subid, DumpId dumpId)
 {
@@ -9152,7 +9108,7 @@ dumpComment(Archive *fout, const char *target,
 	int			ncomments;
 
 	/* Comments are schema not data ... except blob comments are data */
-	if (strncmp(target, "LARGE OBJECT ", 13) != 0)
+	if (strcmp(type, "LARGE OBJECT") != 0)
 	{
 		if (dopt->dataOnly)
 			return;
@@ -9181,24 +9137,31 @@ dumpComment(Archive *fout, const char *target,
 	if (ncomments > 0)
 	{
 		PQExpBuffer query = createPQExpBuffer();
+		PQExpBuffer tag = createPQExpBuffer();
 
-		appendPQExpBuffer(query, "COMMENT ON %s IS ", target);
+		appendPQExpBuffer(query, "COMMENT ON %s ", type);
+		if (namespace && *namespace)
+			appendPQExpBuffer(query, "%s.", fmtId(namespace));
+		appendPQExpBuffer(query, "%s IS ", name);
 		appendStringLiteralAH(query, comments->descr, fout);
 		appendPQExpBufferStr(query, ";\n");
 
+		appendPQExpBuffer(tag, "%s %s", type, name);
+
 		/*
 		 * We mark comments as SECTION_NONE because they really belong in the
 		 * same section as their parent, whether that is pre-data or
 		 * post-data.
 		 */
 		ArchiveEntry(fout, nilCatalogId, createDumpId(),
-					 target, namespace, NULL, owner,
+					 tag->data, namespace, NULL, owner,
 					 false, "COMMENT", SECTION_NONE,
 					 query->data, "", NULL,
 					 &(dumpId), 1,
 					 NULL, NULL);
 
 		destroyPQExpBuffer(query);
+		destroyPQExpBuffer(tag);
 	}
 }
 
@@ -9216,7 +9179,7 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 	CommentItem *comments;
 	int			ncomments;
 	PQExpBuffer query;
-	PQExpBuffer target;
+	PQExpBuffer tag;
 
 	/* Comments are SCHEMA not data */
 	if (dopt->dataOnly)
@@ -9233,7 +9196,7 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 		return;
 
 	query = createPQExpBuffer();
-	target = createPQExpBuffer();
+	tag = createPQExpBuffer();
 
 	while (ncomments > 0)
 	{
@@ -9242,17 +9205,18 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 
 		if (objsubid == 0)
 		{
-			resetPQExpBuffer(target);
-			appendPQExpBuffer(target, "%s %s", reltypename,
+			resetPQExpBuffer(tag);
+			appendPQExpBuffer(tag, "%s %s", reltypename,
 							  fmtId(tbinfo->dobj.name));
 
 			resetPQExpBuffer(query);
-			appendPQExpBuffer(query, "COMMENT ON %s IS ", target->data);
+			appendPQExpBuffer(query, "COMMENT ON %s %s IS ", reltypename,
+							  fmtQualifiedDumpable(tbinfo));
 			appendStringLiteralAH(query, descr, fout);
 			appendPQExpBufferStr(query, ";\n");
 
 			ArchiveEntry(fout, nilCatalogId, createDumpId(),
-						 target->data,
+						 tag->data,
 						 tbinfo->dobj.namespace->dobj.name,
 						 NULL, tbinfo->rolname,
 						 false, "COMMENT", SECTION_NONE,
@@ -9262,18 +9226,21 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 		}
 		else if (objsubid > 0 && objsubid <= tbinfo->numatts)
 		{
-			resetPQExpBuffer(target);
-			appendPQExpBuffer(target, "COLUMN %s.",
+			resetPQExpBuffer(tag);
+			appendPQExpBuffer(tag, "COLUMN %s.",
 							  fmtId(tbinfo->dobj.name));
-			appendPQExpBufferStr(target, fmtId(tbinfo->attnames[objsubid - 1]));
+			appendPQExpBufferStr(tag, fmtId(tbinfo->attnames[objsubid - 1]));
 
 			resetPQExpBuffer(query);
-			appendPQExpBuffer(query, "COMMENT ON %s IS ", target->data);
+			appendPQExpBuffer(query, "COMMENT ON COLUMN %s.",
+							  fmtQualifiedDumpable(tbinfo));
+			appendPQExpBuffer(query, "%s IS ",
+							  fmtId(tbinfo->attnames[objsubid - 1]));
 			appendStringLiteralAH(query, descr, fout);
 			appendPQExpBufferStr(query, ";\n");
 
 			ArchiveEntry(fout, nilCatalogId, createDumpId(),
-						 target->data,
+						 tag->data,
 						 tbinfo->dobj.namespace->dobj.name,
 						 NULL, tbinfo->rolname,
 						 false, "COMMENT", SECTION_NONE,
@@ -9287,7 +9254,7 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 	}
 
 	destroyPQExpBuffer(query);
-	destroyPQExpBuffer(target);
+	destroyPQExpBuffer(tag);
 }
 
 /*
@@ -9402,11 +9369,6 @@ collectComments(Archive *fout, CommentItem **items)
 	int			i;
 	CommentItem *comments;
 
-	/*
-	 * Note we do NOT change source schema here; preserve the caller's
-	 * setting, instead.
-	 */
-
 	query = createPQExpBuffer();
 
 	if (fout->remoteVersion >= 70300)
@@ -9602,7 +9564,6 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	char	   *qnspname;
 
 	/* Skip if not to be dumped */
@@ -9615,7 +9576,6 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qnspname = pg_strdup(fmtId(nspinfo->dobj.name));
 
@@ -9623,10 +9583,9 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 
 	appendPQExpBuffer(q, "CREATE SCHEMA %s;\n", qnspname);
 
-	appendPQExpBuffer(labelq, "SCHEMA %s", qnspname);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &nspinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &nspinfo->dobj,
+										"SCHEMA", qnspname, NULL);
 
 	if (nspinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, nspinfo->dobj.catId, nspinfo->dobj.dumpId,
@@ -9640,18 +9599,18 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 
 	/* Dump Schema Comments and Security Labels */
 	if (nspinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "SCHEMA", qnspname,
 					NULL, nspinfo->rolname,
 					nspinfo->dobj.catId, 0, nspinfo->dobj.dumpId);
 
 	if (nspinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "SCHEMA", qnspname,
 					 NULL, nspinfo->rolname,
 					 nspinfo->dobj.catId, 0, nspinfo->dobj.dumpId);
 
 	if (nspinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, nspinfo->dobj.catId, nspinfo->dobj.dumpId, "SCHEMA",
-				qnspname, NULL, labelq->data, NULL,
+				qnspname, NULL, NULL,
 				nspinfo->rolname, nspinfo->nspacl, nspinfo->rnspacl,
 				nspinfo->initnspacl, nspinfo->initrnspacl);
 
@@ -9659,7 +9618,6 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 }
 
 /*
@@ -9672,7 +9630,6 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	char	   *qextname;
 
 	/* Skip if not to be dumped */
@@ -9681,7 +9638,6 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qextname = pg_strdup(fmtId(extinfo->dobj.name));
 
@@ -9761,8 +9717,6 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 		appendPQExpBufferStr(q, ");\n");
 	}
 
-	appendPQExpBuffer(labelq, "EXTENSION %s", qextname);
-
 	if (extinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, extinfo->dobj.catId, extinfo->dobj.dumpId,
 					 extinfo->dobj.name,
@@ -9775,12 +9729,12 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 
 	/* Dump Extension Comments and Security Labels */
 	if (extinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "EXTENSION", qextname,
 					NULL, "",
 					extinfo->dobj.catId, 0, extinfo->dobj.dumpId);
 
 	if (extinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "EXTENSION", qextname,
 					 NULL, "",
 					 extinfo->dobj.catId, 0, extinfo->dobj.dumpId);
 
@@ -9788,7 +9742,6 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 }
 
 /*
@@ -9832,18 +9785,15 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	int			num,
 				i;
 	Oid			enum_oid;
 	char	   *qtypname;
+	char	   *qualtypname;
 	char	   *label;
 
-	/* Set proper schema search path */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90100)
 		appendPQExpBuffer(query, "SELECT oid, enumlabel "
 						  "FROM pg_catalog.pg_enum "
@@ -9862,23 +9812,20 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 	num = PQntuples(res);
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog.
 	 * CASCADE shouldn't be required here as for normal types since the I/O
 	 * functions are generic and do not get dropped.
 	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s;\n", qualtypname);
 
 	if (dopt->binary_upgrade)
 		binary_upgrade_set_type_oids_by_type_oid(fout, q,
 												 tyinfo->dobj.catId.oid);
 
 	appendPQExpBuffer(q, "CREATE TYPE %s AS ENUM (",
-					  qtypname);
+					  qualtypname);
 
 	if (!dopt->binary_upgrade)
 	{
@@ -9908,19 +9855,16 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 			appendPQExpBuffer(q,
 							  "SELECT pg_catalog.binary_upgrade_set_next_pg_enum_oid('%u'::pg_catalog.oid);\n",
 							  enum_oid);
-			appendPQExpBuffer(q, "ALTER TYPE %s.",
-							  fmtId(tyinfo->dobj.namespace->dobj.name));
-			appendPQExpBuffer(q, "%s ADD VALUE ",
-							  qtypname);
+			appendPQExpBuffer(q, "ALTER TYPE %s ADD VALUE ", qualtypname);
 			appendStringLiteralAH(q, label, fout);
 			appendPQExpBufferStr(q, ";\n\n");
 		}
 	}
 
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
@@ -9935,18 +9879,18 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 
 	/* Dump Type Comments and Security Labels */
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TYPE", qtypname,
 					tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "TYPE", qtypname,
 					 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-				qtypname, NULL, labelq->data,
+				qtypname, NULL,
 				tyinfo->dobj.namespace->dobj.name,
 				tyinfo->rolname, tyinfo->typacl, tyinfo->rtypacl,
 				tyinfo->inittypacl, tyinfo->initrtypacl);
@@ -9954,8 +9898,9 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 	PQclear(res);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -9968,19 +9913,13 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	Oid			collationOid;
 	char	   *qtypname;
+	char	   *qualtypname;
 	char	   *procname;
 
-	/*
-	 * select appropriate schema to ensure names in CREATE are properly
-	 * qualified
-	 */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	appendPQExpBuffer(query,
 			"SELECT pg_catalog.format_type(rngsubtype, NULL) AS rngsubtype, "
 					  "opc.opcname AS opcname, "
@@ -9999,23 +9938,20 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 	res = ExecuteSqlQueryForSingleRow(fout, query->data);
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog.
 	 * CASCADE shouldn't be required here as for normal types since the I/O
 	 * functions are generic and do not get dropped.
 	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s;\n", qualtypname);
 
 	if (dopt->binary_upgrade)
 		binary_upgrade_set_type_oids_by_type_oid(fout,
 												 q, tyinfo->dobj.catId.oid);
 
 	appendPQExpBuffer(q, "CREATE TYPE %s AS RANGE (",
-					  qtypname);
+					  qualtypname);
 
 	appendPQExpBuffer(q, "\n    subtype = %s",
 					  PQgetvalue(res, 0, PQfnumber(res, "rngsubtype")));
@@ -10026,7 +9962,6 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 		char	   *opcname = PQgetvalue(res, 0, PQfnumber(res, "opcname"));
 		char	   *nspname = PQgetvalue(res, 0, PQfnumber(res, "opcnsp"));
 
-		/* always schema-qualify, don't try to be smart */
 		appendPQExpBuffer(q, ",\n    subtype_opclass = %s.",
 						  fmtId(nspname));
 		appendPQExpBufferStr(q, fmtId(opcname));
@@ -10038,12 +9973,8 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 		CollInfo   *coll = findCollationByOid(collationOid);
 
 		if (coll)
-		{
-			/* always schema-qualify, don't try to be smart */
-			appendPQExpBuffer(q, ",\n    collation = %s.",
-							  fmtId(coll->dobj.namespace->dobj.name));
-			appendPQExpBufferStr(q, fmtId(coll->dobj.name));
-		}
+			appendPQExpBuffer(q, ",\n    collation = %s",
+							  fmtQualifiedDumpable(coll));
 	}
 
 	procname = PQgetvalue(res, 0, PQfnumber(res, "rngcanonical"));
@@ -10056,10 +9987,10 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 
 	appendPQExpBufferStr(q, "\n);\n");
 
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
@@ -10074,18 +10005,18 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 
 	/* Dump Type Comments and Security Labels */
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TYPE", qtypname,
 					tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "TYPE", qtypname,
 					 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-				qtypname, NULL, labelq->data,
+				qtypname, NULL,
 				tyinfo->dobj.namespace->dobj.name,
 				tyinfo->rolname, tyinfo->typacl, tyinfo->rtypacl,
 				tyinfo->inittypacl, tyinfo->initrtypacl);
@@ -10093,8 +10024,9 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 	PQclear(res);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -10112,30 +10044,25 @@ dumpUndefinedType(Archive *fout, TypeInfo *tyinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	char	   *qtypname;
+	char	   *qualtypname;
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog.
-	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s;\n", qualtypname);
 
 	if (dopt->binary_upgrade)
 		binary_upgrade_set_type_oids_by_type_oid(fout,
 												 q, tyinfo->dobj.catId.oid);
 
 	appendPQExpBuffer(q, "CREATE TYPE %s;\n",
-					  qtypname);
-
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
+					  qualtypname);
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
@@ -10150,25 +10077,26 @@ dumpUndefinedType(Archive *fout, TypeInfo *tyinfo)
 
 	/* Dump Type Comments and Security Labels */
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TYPE", qtypname,
 					tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "TYPE", qtypname,
 					 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-				qtypname, NULL, labelq->data,
+				qtypname, NULL,
 				tyinfo->dobj.namespace->dobj.name,
 				tyinfo->rolname, tyinfo->typacl, tyinfo->rtypacl,
 				tyinfo->inittypacl, tyinfo->initrtypacl);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -10181,10 +10109,10 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	char	   *qtypname;
+	char	   *qualtypname;
 	char	   *typlen;
 	char	   *typinput;
 	char	   *typoutput;
@@ -10208,9 +10136,6 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 	char	   *typdefault;
 	bool		typdefault_is_literal = false;
 
-	/* Set proper schema search path so regproc references list correctly */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	/* Fetch type-specific details */
 	if (fout->remoteVersion >= 90100)
 	{
@@ -10418,17 +10343,14 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 		typdefault = NULL;
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog.
 	 * The reason we include CASCADE is that the circular dependency between
 	 * the type and its I/O functions makes it impossible to drop the type any
 	 * other way.
 	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s CASCADE;\n",
-					  qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s CASCADE;\n", qualtypname);
 
 	/* We might already have a shell type, but setting pg_type_oid is harmless */
 	if (dopt->binary_upgrade)
@@ -10438,7 +10360,7 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 	appendPQExpBuffer(q,
 					  "CREATE TYPE %s (\n"
 					  "    INTERNALLENGTH = %s",
-					  qtypname,
+					  qualtypname,
 					  (strcmp(typlen, "-1") == 0) ? "variable" : typlen);
 
 	if (fout->remoteVersion >= 70300)
@@ -10482,8 +10404,6 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 	{
 		char	   *elemType;
 
-		/* reselect schema in case changed by function dump */
-		selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
 		elemType = getFormattedTypeName(fout, tyinfo->typelem, zeroAsOpaque);
 		appendPQExpBuffer(q, ",\n    ELEMENT = %s", elemType);
 		free(elemType);
@@ -10527,10 +10447,10 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 
 	appendPQExpBufferStr(q, "\n);\n");
 
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
@@ -10545,18 +10465,18 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 
 	/* Dump Type Comments and Security Labels */
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TYPE", qtypname,
 					tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "TYPE", qtypname,
 					 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-				qtypname, NULL, labelq->data,
+				qtypname, NULL,
 				tyinfo->dobj.namespace->dobj.name,
 				tyinfo->rolname, tyinfo->typacl, tyinfo->rtypacl,
 				tyinfo->inittypacl, tyinfo->initrtypacl);
@@ -10564,8 +10484,9 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 	PQclear(res);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -10578,20 +10499,17 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	int			i;
 	char	   *qtypname;
+	char	   *qualtypname;
 	char	   *typnotnull;
 	char	   *typdefn;
 	char	   *typdefault;
 	Oid			typcollation;
 	bool		typdefault_is_literal = false;
 
-	/* Set proper schema search path so type references list correctly */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	/* Fetch domain specific details */
 	if (fout->remoteVersion >= 90100)
 	{
@@ -10639,10 +10557,11 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 												 tyinfo->dobj.catId.oid);
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	appendPQExpBuffer(q,
 					  "CREATE DOMAIN %s AS %s",
-					  qtypname,
+					  qualtypname,
 					  typdefn);
 
 	/* Print collation only if different from base type's collation */
@@ -10652,12 +10571,7 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 
 		coll = findCollationByOid(typcollation);
 		if (coll)
-		{
-			/* always schema-qualify, don't try to be smart */
-			appendPQExpBuffer(q, " COLLATE %s.",
-							  fmtId(coll->dobj.namespace->dobj.name));
-			appendPQExpBufferStr(q, fmtId(coll->dobj.name));
-		}
+			appendPQExpBuffer(q, " COLLATE %s", fmtQualifiedDumpable(coll));
 	}
 
 	if (typnotnull[0] == 't')
@@ -10688,18 +10602,12 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 
 	appendPQExpBufferStr(q, ";\n");
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP DOMAIN %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
-
-	appendPQExpBuffer(labelq, "DOMAIN %s", qtypname);
+	appendPQExpBuffer(delq, "DROP DOMAIN %s;\n", qualtypname);
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"DOMAIN", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
@@ -10714,18 +10622,18 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 
 	/* Dump Domain Comments and Security Labels */
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "DOMAIN", qtypname,
 					tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "DOMAIN", qtypname,
 					 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-				qtypname, NULL, labelq->data,
+				qtypname, NULL,
 				tyinfo->dobj.namespace->dobj.name,
 				tyinfo->rolname, tyinfo->typacl, tyinfo->rtypacl,
 				tyinfo->inittypacl, tyinfo->initrtypacl);
@@ -10734,26 +10642,25 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 	for (i = 0; i < tyinfo->nDomChecks; i++)
 	{
 		ConstraintInfo *domcheck = &(tyinfo->domChecks[i]);
-		PQExpBuffer labelq = createPQExpBuffer();
+		PQExpBuffer conprefix = createPQExpBuffer();
 
-		appendPQExpBuffer(labelq, "CONSTRAINT %s ",
+		appendPQExpBuffer(conprefix, "CONSTRAINT %s ON DOMAIN",
 						  fmtId(domcheck->dobj.name));
-		appendPQExpBuffer(labelq, "ON DOMAIN %s",
-						  qtypname);
 
 		if (tyinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-			dumpComment(fout, labelq->data,
+			dumpComment(fout, conprefix->data, qtypname,
 						tyinfo->dobj.namespace->dobj.name,
 						tyinfo->rolname,
 						domcheck->dobj.catId, 0, tyinfo->dobj.dumpId);
 
-		destroyPQExpBuffer(labelq);
+		destroyPQExpBuffer(conprefix);
 	}
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -10768,10 +10675,10 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer dropped = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	char	   *qtypname;
+	char	   *qualtypname;
 	int			ntups;
 	int			i_attname;
 	int			i_atttypdefn;
@@ -10782,9 +10689,6 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	int			i;
 	int			actual_atts;
 
-	/* Set proper schema search path so type references list correctly */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	/* Fetch type specific details */
 	if (fout->remoteVersion >= 90100)
 	{
@@ -10844,9 +10748,10 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	}
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	appendPQExpBuffer(q, "CREATE TYPE %s AS (",
-					  qtypname);
+					  qualtypname);
 
 	actual_atts = 0;
 	for (i = 0; i < ntups; i++)
@@ -10884,12 +10789,8 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 
 				coll = findCollationByOid(attcollation);
 				if (coll)
-				{
-					/* always schema-qualify, don't try to be smart */
-					appendPQExpBuffer(q, " COLLATE %s.",
-									  fmtId(coll->dobj.namespace->dobj.name));
-					appendPQExpBufferStr(q, fmtId(coll->dobj.name));
-				}
+					appendPQExpBuffer(q, " COLLATE %s",
+									  fmtQualifiedDumpable(coll));
 			}
 		}
 		else
@@ -10911,11 +10812,11 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 							  "WHERE attname = ", attlen, attalign);
 			appendStringLiteralAH(dropped, attname, fout);
 			appendPQExpBufferStr(dropped, "\n  AND attrelid = ");
-			appendStringLiteralAH(dropped, qtypname, fout);
+			appendStringLiteralAH(dropped, qualtypname, fout);
 			appendPQExpBufferStr(dropped, "::pg_catalog.regclass;\n");
 
 			appendPQExpBuffer(dropped, "ALTER TYPE %s ",
-							  qtypname);
+							  qualtypname);
 			appendPQExpBuffer(dropped, "DROP ATTRIBUTE %s;\n",
 							  fmtId(attname));
 		}
@@ -10923,18 +10824,12 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	appendPQExpBufferStr(q, "\n);\n");
 	appendPQExpBufferStr(q, dropped->data);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
-
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s;\n", qualtypname);
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
@@ -10950,18 +10845,18 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 
 	/* Dump Type Comments and Security Labels */
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TYPE", qtypname,
 					tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "TYPE", qtypname,
 					 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 					 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-				qtypname, NULL, labelq->data,
+				qtypname, NULL,
 				tyinfo->dobj.namespace->dobj.name,
 				tyinfo->rolname, tyinfo->typacl, tyinfo->rtypacl,
 				tyinfo->inittypacl, tyinfo->initrtypacl);
@@ -10970,8 +10865,9 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(dropped);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 
 	/* Dump any per-column comments */
 	if (tyinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
@@ -11063,7 +10959,9 @@ dumpCompositeTypeColComments(Archive *fout, TypeInfo *tyinfo)
 			appendPQExpBufferStr(target, fmtId(attname));
 
 			resetPQExpBuffer(query);
-			appendPQExpBuffer(query, "COMMENT ON %s IS ", target->data);
+			appendPQExpBuffer(query, "COMMENT ON COLUMN %s.",
+							  fmtQualifiedDumpable(tyinfo));
+			appendPQExpBuffer(query, "%s IS ", fmtId(attname));
 			appendStringLiteralAH(query, descr, fout);
 			appendPQExpBufferStr(query, ";\n");
 
@@ -11118,7 +11016,7 @@ dumpShellType(Archive *fout, ShellTypeInfo *stinfo)
 										   stinfo->baseType->dobj.catId.oid);
 
 	appendPQExpBuffer(q, "CREATE TYPE %s;\n",
-					  fmtId(stinfo->dobj.name));
+					  fmtQualifiedDumpable(stinfo));
 
 	if (stinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, stinfo->dobj.catId, stinfo->dobj.dumpId,
@@ -11145,10 +11043,8 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer defqry;
 	PQExpBuffer delqry;
-	PQExpBuffer labelq;
 	bool		useParams;
 	char	   *qlanname;
-	char	   *lanschema;
 	FuncInfo   *funcInfo;
 	FuncInfo   *inlineInfo = NULL;
 	FuncInfo   *validatorInfo = NULL;
@@ -11194,20 +11090,9 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 
 	defqry = createPQExpBuffer();
 	delqry = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qlanname = pg_strdup(fmtId(plang->dobj.name));
 
-	/*
-	 * If dumping a HANDLER clause, treat the language as being in the handler
-	 * function's schema; this avoids cluttering the HANDLER clause. Otherwise
-	 * it doesn't really have a schema.
-	 */
-	if (useParams)
-		lanschema = funcInfo->dobj.namespace->dobj.name;
-	else
-		lanschema = NULL;
-
 	appendPQExpBuffer(delqry, "DROP PROCEDURAL LANGUAGE %s;\n",
 					  qlanname);
 
@@ -11217,25 +11102,13 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 						  plang->lanpltrusted ? "TRUSTED " : "",
 						  qlanname);
 		appendPQExpBuffer(defqry, " HANDLER %s",
-						  fmtId(funcInfo->dobj.name));
+						  fmtQualifiedDumpable(funcInfo));
 		if (OidIsValid(plang->laninline))
-		{
-			appendPQExpBufferStr(defqry, " INLINE ");
-			/* Cope with possibility that inline is in different schema */
-			if (inlineInfo->dobj.namespace != funcInfo->dobj.namespace)
-				appendPQExpBuffer(defqry, "%s.",
-							   fmtId(inlineInfo->dobj.namespace->dobj.name));
-			appendPQExpBufferStr(defqry, fmtId(inlineInfo->dobj.name));
-		}
+			appendPQExpBuffer(defqry, " INLINE %s",
+							  fmtQualifiedDumpable(inlineInfo));
 		if (OidIsValid(plang->lanvalidator))
-		{
-			appendPQExpBufferStr(defqry, " VALIDATOR ");
-			/* Cope with possibility that validator is in different schema */
-			if (validatorInfo->dobj.namespace != funcInfo->dobj.namespace)
-				appendPQExpBuffer(defqry, "%s.",
-							fmtId(validatorInfo->dobj.namespace->dobj.name));
-			appendPQExpBufferStr(defqry, fmtId(validatorInfo->dobj.name));
-		}
+			appendPQExpBuffer(defqry, " VALIDATOR %s",
+							  fmtQualifiedDumpable(validatorInfo));
 	}
 	else
 	{
@@ -11253,15 +11126,14 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 	}
 	appendPQExpBufferStr(defqry, ";\n");
 
-	appendPQExpBuffer(labelq, "LANGUAGE %s", qlanname);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(defqry, &plang->dobj, labelq->data);
+		binary_upgrade_extension_member(defqry, &plang->dobj,
+										"LANGUAGE", qlanname, NULL);
 
 	if (plang->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, plang->dobj.catId, plang->dobj.dumpId,
 					 plang->dobj.name,
-					 lanschema, NULL, plang->lanowner,
+					 NULL, NULL, plang->lanowner,
 					 false, "PROCEDURAL LANGUAGE", SECTION_PRE_DATA,
 					 defqry->data, delqry->data, NULL,
 					 NULL, 0,
@@ -11269,19 +11141,18 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 
 	/* Dump Proc Lang Comments and Security Labels */
 	if (plang->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
-					lanschema, plang->lanowner,
+		dumpComment(fout, "LANGUAGE", qlanname,
+					NULL, plang->lanowner,
 					plang->dobj.catId, 0, plang->dobj.dumpId);
 
 	if (plang->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
-					 lanschema, plang->lanowner,
+		dumpSecLabel(fout, "LANGUAGE", qlanname,
+					 NULL, plang->lanowner,
 					 plang->dobj.catId, 0, plang->dobj.dumpId);
 
 	if (plang->lanpltrusted && plang->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, plang->dobj.catId, plang->dobj.dumpId, "LANGUAGE",
-				qlanname, NULL, labelq->data,
-				lanschema,
+				qlanname, NULL, NULL,
 				plang->lanowner, plang->lanacl, plang->rlanacl,
 				plang->initlanacl, plang->initrlanacl);
 
@@ -11289,7 +11160,6 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 
 	destroyPQExpBuffer(defqry);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
 }
 
 /*
@@ -11433,7 +11303,6 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delqry;
-	PQExpBuffer labelq;
 	PQExpBuffer asPart;
 	PGresult   *res;
 	char	   *funcsig;		/* identity signature */
@@ -11475,12 +11344,8 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delqry = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	asPart = createPQExpBuffer();
 
-	/* Set proper schema search path so type references list correctly */
-	selectSourceSchema(fout, finfo->dobj.namespace->dobj.name);
-
 	/* Fetch function-specific details */
 	if (fout->remoteVersion >= 90600)
 	{
@@ -11691,6 +11556,15 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 
 	lanname = PQgetvalue(res, 0, PQfnumber(res, "lanname"));
 
+	/*
+	 * Before 7.3, the "C" language name was actually upper case in the
+	 * pg_language catalog.  If we don't down-case it, we'll get a lookup
+	 * failure at restore.
+	 */
+	if (fout->remoteVersion < 70300 &&
+		strcmp(lanname, "C") == 0)
+		lanname = "c";
+
 	/*
 	 * See backend/commands/functioncmds.c for details of how the 'AS' clause
 	 * is used.  In 8.4 and up, an unused probin is NULL (here ""); previous
@@ -11801,15 +11675,15 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 
 	funcsig_tag = format_function_signature(fout, finfo, false);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delqry, "DROP FUNCTION %s.%s;\n",
 					  fmtId(finfo->dobj.namespace->dobj.name),
 					  funcsig);
 
-	appendPQExpBuffer(q, "CREATE FUNCTION %s ", funcfullsig ? funcfullsig :
+	appendPQExpBuffer(q, "CREATE FUNCTION %s.%s ",
+					  fmtId(finfo->dobj.namespace->dobj.name),
+					  funcfullsig ? funcfullsig :
 					  funcsig);
+
 	if (funcresult)
 		appendPQExpBuffer(q, "RETURNS %s", funcresult);
 	else
@@ -11923,10 +11797,10 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 
 	appendPQExpBuffer(q, "\n    %s;\n", asPart->data);
 
-	appendPQExpBuffer(labelq, "FUNCTION %s", funcsig);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &finfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &finfo->dobj,
+										"FUNCTION", funcsig,
+										finfo->dobj.namespace->dobj.name);
 
 	if (finfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, finfo->dobj.catId, finfo->dobj.dumpId,
@@ -11941,18 +11815,18 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 
 	/* Dump Function Comments and Security Labels */
 	if (finfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "FUNCTION", funcsig,
 					finfo->dobj.namespace->dobj.name, finfo->rolname,
 					finfo->dobj.catId, 0, finfo->dobj.dumpId);
 
 	if (finfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "FUNCTION", funcsig,
 					 finfo->dobj.namespace->dobj.name, finfo->rolname,
 					 finfo->dobj.catId, 0, finfo->dobj.dumpId);
 
 	if (finfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, finfo->dobj.catId, finfo->dobj.dumpId, "FUNCTION",
-				funcsig, NULL, labelq->data,
+				funcsig, NULL,
 				finfo->dobj.namespace->dobj.name,
 				finfo->rolname, finfo->proacl, finfo->rproacl,
 				finfo->initproacl, finfo->initrproacl);
@@ -11962,7 +11836,6 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(asPart);
 	free(funcsig);
 	if (funcfullsig)
@@ -11989,6 +11862,7 @@ dumpCast(Archive *fout, CastInfo *cast)
 	PQExpBuffer defqry;
 	PQExpBuffer delqry;
 	PQExpBuffer labelq;
+	PQExpBuffer castargs;
 	FuncInfo   *funcInfo = NULL;
 	char	   *sourceType;
 	char	   *targetType;
@@ -12006,15 +11880,10 @@ dumpCast(Archive *fout, CastInfo *cast)
 						  cast->castfunc);
 	}
 
-	/*
-	 * Make sure we are in proper schema (needed for getFormattedTypeName).
-	 * Casts don't have a schema of their own, so use pg_catalog.
-	 */
-	selectSourceSchema(fout, "pg_catalog");
-
 	defqry = createPQExpBuffer();
 	delqry = createPQExpBuffer();
 	labelq = createPQExpBuffer();
+	castargs = createPQExpBuffer();
 
 	sourceType = getFormattedTypeName(fout, cast->castsource, zeroAsNone);
 	targetType = getFormattedTypeName(fout, cast->casttarget, zeroAsNone);
@@ -12038,9 +11907,8 @@ dumpCast(Archive *fout, CastInfo *cast)
 				char	   *fsig = format_function_signature(fout, funcInfo, true);
 
 				/*
-				 * Always qualify the function name, in case it is not in
-				 * pg_catalog schema (format_function_signature won't qualify
-				 * it).
+				 * Always qualify the function name (format_function_signature
+				 * won't qualify it).
 				 */
 				appendPQExpBuffer(defqry, "WITH FUNCTION %s.%s",
 						   fmtId(funcInfo->dobj.namespace->dobj.name), fsig);
@@ -12062,13 +11930,17 @@ dumpCast(Archive *fout, CastInfo *cast)
 	appendPQExpBuffer(labelq, "CAST (%s AS %s)",
 					  sourceType, targetType);
 
+	appendPQExpBuffer(castargs, "(%s AS %s)",
+					  sourceType, targetType);
+
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(defqry, &cast->dobj, labelq->data);
+		binary_upgrade_extension_member(defqry, &cast->dobj,
+										"CAST", castargs->data, NULL);
 
 	if (cast->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, cast->dobj.catId, cast->dobj.dumpId,
 					 labelq->data,
-					 "pg_catalog", NULL, "",
+					 NULL, NULL, "",
 					 false, "CAST", SECTION_PRE_DATA,
 					 defqry->data, delqry->data, NULL,
 					 NULL, 0,
@@ -12076,8 +11948,8 @@ dumpCast(Archive *fout, CastInfo *cast)
 
 	/* Dump Cast Comments */
 	if (cast->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
-					"pg_catalog", "",
+		dumpComment(fout, "CAST", castargs->data,
+					NULL, "",
 					cast->dobj.catId, 0, cast->dobj.dumpId);
 
 	free(sourceType);
@@ -12086,6 +11958,7 @@ dumpCast(Archive *fout, CastInfo *cast)
 	destroyPQExpBuffer(defqry);
 	destroyPQExpBuffer(delqry);
 	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(castargs);
 }
 
 /*
@@ -12098,6 +11971,7 @@ dumpTransform(Archive *fout, TransformInfo *transform)
 	PQExpBuffer defqry;
 	PQExpBuffer delqry;
 	PQExpBuffer labelq;
+	PQExpBuffer transformargs;
 	FuncInfo   *fromsqlFuncInfo = NULL;
 	FuncInfo   *tosqlFuncInfo = NULL;
 	char	   *lanname;
@@ -12123,12 +11997,10 @@ dumpTransform(Archive *fout, TransformInfo *transform)
 						  transform->trftosql);
 	}
 
-	/* Make sure we are in proper schema (needed for getFormattedTypeName) */
-	selectSourceSchema(fout, "pg_catalog");
-
 	defqry = createPQExpBuffer();
 	delqry = createPQExpBuffer();
 	labelq = createPQExpBuffer();
+	transformargs = createPQExpBuffer();
 
 	lanname = get_language_name(fout, transform->trflang);
 	transformType = getFormattedTypeName(fout, transform->trftype, zeroAsNone);
@@ -12149,8 +12021,8 @@ dumpTransform(Archive *fout, TransformInfo *transform)
 			char	   *fsig = format_function_signature(fout, fromsqlFuncInfo, true);
 
 			/*
-			 * Always qualify the function name, in case it is not in
-			 * pg_catalog schema (format_function_signature won't qualify it).
+			 * Always qualify the function name (format_function_signature
+			 * won't qualify it).
 			 */
 			appendPQExpBuffer(defqry, "FROM SQL WITH FUNCTION %s.%s",
 					fmtId(fromsqlFuncInfo->dobj.namespace->dobj.name), fsig);
@@ -12170,8 +12042,8 @@ dumpTransform(Archive *fout, TransformInfo *transform)
 			char	   *fsig = format_function_signature(fout, tosqlFuncInfo, true);
 
 			/*
-			 * Always qualify the function name, in case it is not in
-			 * pg_catalog schema (format_function_signature won't qualify it).
+			 * Always qualify the function name (format_function_signature
+			 * won't qualify it).
 			 */
 			appendPQExpBuffer(defqry, "TO SQL WITH FUNCTION %s.%s",
 					  fmtId(tosqlFuncInfo->dobj.namespace->dobj.name), fsig);
@@ -12186,13 +12058,17 @@ dumpTransform(Archive *fout, TransformInfo *transform)
 	appendPQExpBuffer(labelq, "TRANSFORM FOR %s LANGUAGE %s",
 					  transformType, lanname);
 
+	appendPQExpBuffer(transformargs, "FOR %s LANGUAGE %s",
+					  transformType, lanname);
+
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(defqry, &transform->dobj, labelq->data);
+		binary_upgrade_extension_member(defqry, &transform->dobj,
+									 "TRANSFORM", transformargs->data, NULL);
 
 	if (transform->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, transform->dobj.catId, transform->dobj.dumpId,
 					 labelq->data,
-					 "pg_catalog", NULL, "",
+					 NULL, NULL, "",
 					 false, "TRANSFORM", SECTION_PRE_DATA,
 					 defqry->data, delqry->data, NULL,
 					 transform->dobj.dependencies, transform->dobj.nDeps,
@@ -12200,8 +12076,8 @@ dumpTransform(Archive *fout, TransformInfo *transform)
 
 	/* Dump Transform Comments */
 	if (transform->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
-					"pg_catalog", "",
+		dumpComment(fout, "TRANSFORM", transformargs->data,
+					NULL, "",
 					transform->dobj.catId, 0, transform->dobj.dumpId);
 
 	free(lanname);
@@ -12209,6 +12085,7 @@ dumpTransform(Archive *fout, TransformInfo *transform)
 	destroyPQExpBuffer(defqry);
 	destroyPQExpBuffer(delqry);
 	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(transformargs);
 }
 
 
@@ -12223,7 +12100,6 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer oprid;
 	PQExpBuffer details;
 	const char *name;
@@ -12265,21 +12141,17 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	oprid = createPQExpBuffer();
 	details = createPQExpBuffer();
 
-	/* Make sure we are in proper schema so regoperator works correctly */
-	selectSourceSchema(fout, oprinfo->dobj.namespace->dobj.name);
-
 	if (fout->remoteVersion >= 80300)
 	{
 		appendPQExpBuffer(query, "SELECT oprkind, "
 						  "oprcode::pg_catalog.regprocedure, "
 						  "oprleft::pg_catalog.regtype, "
 						  "oprright::pg_catalog.regtype, "
-						  "oprcom::pg_catalog.regoperator, "
-						  "oprnegate::pg_catalog.regoperator, "
+						  "oprcom, "
+						  "oprnegate, "
 						  "oprrest::pg_catalog.regprocedure, "
 						  "oprjoin::pg_catalog.regprocedure, "
 						  "oprcanmerge, oprcanhash "
@@ -12293,8 +12165,8 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 						  "oprcode::pg_catalog.regprocedure, "
 						  "oprleft::pg_catalog.regtype, "
 						  "oprright::pg_catalog.regtype, "
-						  "oprcom::pg_catalog.regoperator, "
-						  "oprnegate::pg_catalog.regoperator, "
+						  "oprcom, "
+						  "oprnegate, "
 						  "oprrest::pg_catalog.regprocedure, "
 						  "oprjoin::pg_catalog.regprocedure, "
 						  "(oprlsortop != 0) AS oprcanmerge, "
@@ -12396,14 +12268,14 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	else
 		appendPQExpBufferStr(oprid, ", NONE)");
 
-	oprref = convertOperatorReference(fout, oprcom);
+	oprref = getFormattedOperatorName(fout, oprcom);
 	if (oprref)
 	{
 		appendPQExpBuffer(details, ",\n    COMMUTATOR = %s", oprref);
 		free(oprref);
 	}
 
-	oprref = convertOperatorReference(fout, oprnegate);
+	oprref = getFormattedOperatorName(fout, oprnegate);
 	if (oprref)
 	{
 		appendPQExpBuffer(details, ",\n    NEGATOR = %s", oprref);
@@ -12430,20 +12302,18 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 		free(oprregproc);
 	}
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delq, "DROP OPERATOR %s.%s;\n",
 					  fmtId(oprinfo->dobj.namespace->dobj.name),
 					  oprid->data);
 
-	appendPQExpBuffer(q, "CREATE OPERATOR %s (\n%s\n);\n",
+	appendPQExpBuffer(q, "CREATE OPERATOR %s.%s (\n%s\n);\n",
+					  fmtId(oprinfo->dobj.namespace->dobj.name),
 					  oprinfo->dobj.name, details->data);
 
-	appendPQExpBuffer(labelq, "OPERATOR %s", oprid->data);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &oprinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &oprinfo->dobj,
+										"OPERATOR", oprid->data,
+										oprinfo->dobj.namespace->dobj.name);
 
 	if (oprinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, oprinfo->dobj.catId, oprinfo->dobj.dumpId,
@@ -12458,7 +12328,7 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 
 	/* Dump Operator Comments */
 	if (oprinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "OPERATOR", oprid->data,
 					oprinfo->dobj.namespace->dobj.name, oprinfo->rolname,
 					oprinfo->dobj.catId, 0, oprinfo->dobj.dumpId);
 
@@ -12467,7 +12337,6 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(oprid);
 	destroyPQExpBuffer(details);
 }
@@ -12515,65 +12384,39 @@ convertRegProcReference(Archive *fout, const char *proc)
 }
 
 /*
- * Convert an operator cross-reference obtained from pg_operator
+ * getFormattedOperatorName - retrieve the operator name for the
+ * given operator OID (presented in string form).
  *
- * Returns an allocated string of what to print, or NULL to print nothing.
+ * Returns an allocated string, or NULL if the given OID is InvalidOid.
  * Caller is responsible for free'ing result string.
  *
- * In 7.3 and up the input is a REGOPERATOR display; we have to strip the
- * argument-types part, and add OPERATOR() decoration if the name is
- * schema-qualified.  In older versions, the input is just a numeric OID,
- * which we search our operator list for.
+ * What we produce has the format "OPERATOR(schema.oprname)".  This is only
+ * useful in commands where the operator's argument types can be inferred from
+ * context.  We always schema-qualify the name, though.  The predecessor to
+ * this code tried to skip the schema qualification if possible, but that led
+ * to wrong results in corner cases, such as if an operator and its negator
+ * are in different schemas.
  */
 static char *
-convertOperatorReference(Archive *fout, const char *opr)
+getFormattedOperatorName(Archive *fout, const char *oproid)
 {
 	OprInfo    *oprInfo;
 
 	/* In all cases "0" means a null reference */
-	if (strcmp(opr, "0") == 0)
+	if (strcmp(oproid, "0") == 0)
 		return NULL;
 
-	if (fout->remoteVersion >= 70300)
-	{
-		char	   *name;
-		char	   *oname;
-		char	   *ptr;
-		bool		inquote;
-		bool		sawdot;
-
-		name = pg_strdup(opr);
-		/* find non-double-quoted left paren, and check for non-quoted dot */
-		inquote = false;
-		sawdot = false;
-		for (ptr = name; *ptr; ptr++)
-		{
-			if (*ptr == '"')
-				inquote = !inquote;
-			else if (*ptr == '.' && !inquote)
-				sawdot = true;
-			else if (*ptr == '(' && !inquote)
-			{
-				*ptr = '\0';
-				break;
-			}
-		}
-		/* If not schema-qualified, don't need to add OPERATOR() */
-		if (!sawdot)
-			return name;
-		oname = psprintf("OPERATOR(%s)", name);
-		free(name);
-		return oname;
-	}
-
-	oprInfo = findOprByOid(atooid(opr));
+	oprInfo = findOprByOid(atooid(oproid));
 	if (oprInfo == NULL)
 	{
 		write_msg(NULL, "WARNING: could not find operator with OID %s\n",
-				  opr);
+				  oproid);
 		return NULL;
 	}
-	return pg_strdup(oprInfo->dobj.name);
+
+	return psprintf("OPERATOR(%s.%s)",
+					fmtId(oprInfo->dobj.namespace->dobj.name),
+					oprInfo->dobj.name);
 }
 
 /*
@@ -12612,7 +12455,6 @@ dumpAccessMethod(Archive *fout, AccessMethodInfo *aminfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	char	   *qamname;
 
 	/* Skip if not to be dumped */
@@ -12621,7 +12463,6 @@ dumpAccessMethod(Archive *fout, AccessMethodInfo *aminfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qamname = pg_strdup(fmtId(aminfo->dobj.name));
 
@@ -12635,10 +12476,9 @@ dumpAccessMethod(Archive *fout, AccessMethodInfo *aminfo)
 		default:
 			write_msg(NULL, "WARNING: invalid type \"%c\" of access method \"%s\"\n",
 					  aminfo->amtype, qamname);
-			pg_free(qamname);
 			destroyPQExpBuffer(q);
 			destroyPQExpBuffer(delq);
-			destroyPQExpBuffer(labelq);
+			free(qamname);
 			return;
 	}
 
@@ -12647,11 +12487,9 @@ dumpAccessMethod(Archive *fout, AccessMethodInfo *aminfo)
 	appendPQExpBuffer(delq, "DROP ACCESS METHOD %s;\n",
 					  qamname);
 
-	appendPQExpBuffer(labelq, "ACCESS METHOD %s",
-					  qamname);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &aminfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &aminfo->dobj,
+										"ACCESS METHOD", qamname, NULL);
 
 	if (aminfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, aminfo->dobj.catId, aminfo->dobj.dumpId,
@@ -12666,15 +12504,13 @@ dumpAccessMethod(Archive *fout, AccessMethodInfo *aminfo)
 
 	/* Dump Access Method Comments */
 	if (aminfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "ACCESS METHOD", qamname,
 					NULL, "",
 					aminfo->dobj.catId, 0, aminfo->dobj.dumpId);
 
-	pg_free(qamname);
-
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qamname);
 }
 
 /*
@@ -12688,7 +12524,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	PQExpBuffer nameusing;
 	PGresult   *res;
 	int			ntups;
 	int			i_opcintype;
@@ -12741,10 +12577,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
-
-	/* Make sure we are in proper schema so regoperator works correctly */
-	selectSourceSchema(fout, opcinfo->dobj.namespace->dobj.name);
+	nameusing = createPQExpBuffer();
 
 	/* Get additional fields from the pg_opclass row */
 	if (fout->remoteVersion >= 80300)
@@ -12795,19 +12628,14 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	/* amname will still be needed after we PQclear res */
 	amname = pg_strdup(PQgetvalue(res, 0, i_amname));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delq, "DROP OPERATOR CLASS %s",
-					  fmtId(opcinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s",
-					  fmtId(opcinfo->dobj.name));
+					  fmtQualifiedDumpable(opcinfo));
 	appendPQExpBuffer(delq, " USING %s;\n",
 					  fmtId(amname));
 
 	/* Build the fixed portion of the CREATE command */
 	appendPQExpBuffer(q, "CREATE OPERATOR CLASS %s\n    ",
-					  fmtId(opcinfo->dobj.name));
+					  fmtQualifiedDumpable(opcinfo));
 	if (strcmp(opcdefault, "t") == 0)
 		appendPQExpBufferStr(q, "DEFAULT ");
 	appendPQExpBuffer(q, "FOR TYPE %s USING %s",
@@ -12816,8 +12644,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	if (strlen(opcfamilyname) > 0)
 	{
 		appendPQExpBufferStr(q, " FAMILY ");
-		if (strcmp(opcfamilynsp, opcinfo->dobj.namespace->dobj.name) != 0)
-			appendPQExpBuffer(q, "%s.", fmtId(opcfamilynsp));
+		appendPQExpBuffer(q, "%s.", fmtId(opcfamilynsp));
 		appendPQExpBufferStr(q, fmtId(opcfamilyname));
 	}
 	appendPQExpBufferStr(q, " AS\n    ");
@@ -12935,8 +12762,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 		if (strlen(sortfamily) > 0)
 		{
 			appendPQExpBufferStr(q, " FOR ORDER BY ");
-			if (strcmp(sortfamilynsp, opcinfo->dobj.namespace->dobj.name) != 0)
-				appendPQExpBuffer(q, "%s.", fmtId(sortfamilynsp));
+			appendPQExpBuffer(q, "%s.", fmtId(sortfamilynsp));
 			appendPQExpBufferStr(q, fmtId(sortfamily));
 		}
 
@@ -13030,13 +12856,14 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 
 	appendPQExpBufferStr(q, ";\n");
 
-	appendPQExpBuffer(labelq, "OPERATOR CLASS %s",
-					  fmtId(opcinfo->dobj.name));
-	appendPQExpBuffer(labelq, " USING %s",
+	appendPQExpBufferStr(nameusing, fmtId(opcinfo->dobj.name));
+	appendPQExpBuffer(nameusing, " USING %s",
 					  fmtId(amname));
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &opcinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &opcinfo->dobj,
+										"OPERATOR CLASS", nameusing->data,
+										opcinfo->dobj.namespace->dobj.name);
 
 	if (opcinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, opcinfo->dobj.catId, opcinfo->dobj.dumpId,
@@ -13051,7 +12878,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 
 	/* Dump Operator Class Comments */
 	if (opcinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "OPERATOR CLASS", nameusing->data,
 					opcinfo->dobj.namespace->dobj.name, opcinfo->rolname,
 					opcinfo->dobj.catId, 0, opcinfo->dobj.dumpId);
 
@@ -13061,7 +12888,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(nameusing);
 }
 
 /*
@@ -13078,7 +12905,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	PQExpBuffer nameusing;
 	PGresult   *res;
 	PGresult   *res_ops;
 	PGresult   *res_procs;
@@ -13113,10 +12940,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
-
-	/* Make sure we are in proper schema so regoperator works correctly */
-	selectSourceSchema(fout, opfinfo->dobj.namespace->dobj.name);
+	nameusing = createPQExpBuffer();
 
 	/*
 	 * Fetch only those opfamily members that are tied directly to the
@@ -13208,19 +13032,14 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	/* amname will still be needed after we PQclear res */
 	amname = pg_strdup(PQgetvalue(res, 0, i_amname));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delq, "DROP OPERATOR FAMILY %s",
-					  fmtId(opfinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s",
-					  fmtId(opfinfo->dobj.name));
+					  fmtQualifiedDumpable(opfinfo));
 	appendPQExpBuffer(delq, " USING %s;\n",
 					  fmtId(amname));
 
 	/* Build the fixed portion of the CREATE command */
 	appendPQExpBuffer(q, "CREATE OPERATOR FAMILY %s",
-					  fmtId(opfinfo->dobj.name));
+					  fmtQualifiedDumpable(opfinfo));
 	appendPQExpBuffer(q, " USING %s;\n",
 					  fmtId(amname));
 
@@ -13230,7 +13049,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	if (PQntuples(res_ops) > 0 || PQntuples(res_procs) > 0)
 	{
 		appendPQExpBuffer(q, "ALTER OPERATOR FAMILY %s",
-						  fmtId(opfinfo->dobj.name));
+						  fmtQualifiedDumpable(opfinfo));
 		appendPQExpBuffer(q, " USING %s ADD\n    ",
 						  fmtId(amname));
 
@@ -13264,8 +13083,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 			if (strlen(sortfamily) > 0)
 			{
 				appendPQExpBufferStr(q, " FOR ORDER BY ");
-				if (strcmp(sortfamilynsp, opfinfo->dobj.namespace->dobj.name) != 0)
-					appendPQExpBuffer(q, "%s.", fmtId(sortfamilynsp));
+				appendPQExpBuffer(q, "%s.", fmtId(sortfamilynsp));
 				appendPQExpBufferStr(q, fmtId(sortfamily));
 			}
 
@@ -13305,13 +13123,14 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 		appendPQExpBufferStr(q, ";\n");
 	}
 
-	appendPQExpBuffer(labelq, "OPERATOR FAMILY %s",
-					  fmtId(opfinfo->dobj.name));
-	appendPQExpBuffer(labelq, " USING %s",
+	appendPQExpBufferStr(nameusing, fmtId(opfinfo->dobj.name));
+	appendPQExpBuffer(nameusing, " USING %s",
 					  fmtId(amname));
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &opfinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &opfinfo->dobj,
+										"OPERATOR FAMILY", nameusing->data,
+										opfinfo->dobj.namespace->dobj.name);
 
 	if (opfinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, opfinfo->dobj.catId, opfinfo->dobj.dumpId,
@@ -13326,7 +13145,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 
 	/* Dump Operator Family Comments */
 	if (opfinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "OPERATOR FAMILY", nameusing->data,
 					opfinfo->dobj.namespace->dobj.name, opfinfo->rolname,
 					opfinfo->dobj.catId, 0, opfinfo->dobj.dumpId);
 
@@ -13336,7 +13155,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(nameusing);
 }
 
 /*
@@ -13350,7 +13169,7 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qcollname;
 	PGresult   *res;
 	int			i_collcollate;
 	int			i_collctype;
@@ -13364,10 +13183,8 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, collinfo->dobj.namespace->dobj.name);
+	qcollname = pg_strdup(fmtId(collinfo->dobj.name));
 
 	/* Get collation-specific details */
 	appendPQExpBuffer(query, "SELECT "
@@ -13385,25 +13202,20 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	collcollate = PQgetvalue(res, 0, i_collcollate);
 	collctype = PQgetvalue(res, 0, i_collctype);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP COLLATION %s",
-					  fmtId(collinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(collinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP COLLATION %s;\n",
+					  fmtQualifiedDumpable(collinfo));
 
 	appendPQExpBuffer(q, "CREATE COLLATION %s (lc_collate = ",
-					  fmtId(collinfo->dobj.name));
+					  fmtQualifiedDumpable(collinfo));
 	appendStringLiteralAH(q, collcollate, fout);
 	appendPQExpBufferStr(q, ", lc_ctype = ");
 	appendStringLiteralAH(q, collctype, fout);
 	appendPQExpBufferStr(q, ");\n");
 
-	appendPQExpBuffer(labelq, "COLLATION %s", fmtId(collinfo->dobj.name));
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &collinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &collinfo->dobj,
+										"COLLATION", qcollname,
+										collinfo->dobj.namespace->dobj.name);
 
 	if (collinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, collinfo->dobj.catId, collinfo->dobj.dumpId,
@@ -13418,7 +13230,7 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 
 	/* Dump Collation Comments */
 	if (collinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "COLLATION", qcollname,
 					collinfo->dobj.namespace->dobj.name, collinfo->rolname,
 					collinfo->dobj.catId, 0, collinfo->dobj.dumpId);
 
@@ -13427,7 +13239,7 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qcollname);
 }
 
 /*
@@ -13441,7 +13253,7 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qconvname;
 	PGresult   *res;
 	int			i_conforencoding;
 	int			i_contoencoding;
@@ -13459,10 +13271,8 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, convinfo->dobj.namespace->dobj.name);
+	qconvname = pg_strdup(fmtId(convinfo->dobj.name));
 
 	/* Get conversion-specific details */
 	appendPQExpBuffer(query, "SELECT "
@@ -13485,27 +13295,22 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 	conproc = PQgetvalue(res, 0, i_conproc);
 	condefault = (PQgetvalue(res, 0, i_condefault)[0] == 't');
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP CONVERSION %s",
-					  fmtId(convinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(convinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP CONVERSION %s;\n",
+					  fmtQualifiedDumpable(convinfo));
 
 	appendPQExpBuffer(q, "CREATE %sCONVERSION %s FOR ",
 					  (condefault) ? "DEFAULT " : "",
-					  fmtId(convinfo->dobj.name));
+					  fmtQualifiedDumpable(convinfo));
 	appendStringLiteralAH(q, conforencoding, fout);
 	appendPQExpBufferStr(q, " TO ");
 	appendStringLiteralAH(q, contoencoding, fout);
 	/* regproc is automatically quoted in 7.3 and above */
 	appendPQExpBuffer(q, " FROM %s;\n", conproc);
 
-	appendPQExpBuffer(labelq, "CONVERSION %s", fmtId(convinfo->dobj.name));
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &convinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &convinfo->dobj,
+										"CONVERSION", qconvname,
+										convinfo->dobj.namespace->dobj.name);
 
 	if (convinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, convinfo->dobj.catId, convinfo->dobj.dumpId,
@@ -13520,7 +13325,7 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 
 	/* Dump Conversion Comments */
 	if (convinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "CONVERSION", qconvname,
 					convinfo->dobj.namespace->dobj.name, convinfo->rolname,
 					convinfo->dobj.catId, 0, convinfo->dobj.dumpId);
 
@@ -13529,7 +13334,7 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qconvname);
 }
 
 /*
@@ -13583,7 +13388,6 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer details;
 	char	   *aggsig;			/* identity signature */
 	char	   *aggfullsig = NULL;		/* full signature */
@@ -13638,12 +13442,8 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	details = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, agginfo->aggfn.dobj.namespace->dobj.name);
-
 	/* Get aggregate-specific details */
 	if (fout->remoteVersion >= 90600)
 	{
@@ -13652,7 +13452,7 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 					"aggcombinefn, aggserialfn, aggdeserialfn, aggmtransfn, "
 		   "aggminvtransfn, aggmfinalfn, aggmtranstype::pg_catalog.regtype, "
 						  "aggfinalextra, aggmfinalextra, "
-						  "aggsortop::pg_catalog.regoperator, "
+						  "aggsortop, "
 						  "(aggkind = 'h') AS hypothetical, "
 						  "aggtransspace, agginitval, "
 						  "aggmtransspace, aggminitval, "
@@ -13673,7 +13473,7 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 						"'-' AS aggdeserialfn, aggmtransfn, aggminvtransfn, "
 						  "aggmfinalfn, aggmtranstype::pg_catalog.regtype, "
 						  "aggfinalextra, aggmfinalextra, "
-						  "aggsortop::pg_catalog.regoperator, "
+						  "aggsortop, "
 						  "(aggkind = 'h') AS hypothetical, "
 						  "aggtransspace, agginitval, "
 						  "aggmtransspace, aggminitval, "
@@ -13694,7 +13494,7 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 						  "'-' AS aggminvtransfn, '-' AS aggmfinalfn, "
 						  "0 AS aggmtranstype, false AS aggfinalextra, "
 						  "false AS aggmfinalextra, "
-						  "aggsortop::pg_catalog.regoperator, "
+						  "aggsortop, "
 						  "false AS hypothetical, "
 						  "0 AS aggtransspace, agginitval, "
 						  "0 AS aggmtransspace, NULL AS aggminitval, "
@@ -13715,7 +13515,7 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 						  "'-' AS aggminvtransfn, '-' AS aggmfinalfn, "
 						  "0 AS aggmtranstype, false AS aggfinalextra, "
 						  "false AS aggmfinalextra, "
-						  "aggsortop::pg_catalog.regoperator, "
+						  "aggsortop, "
 						  "false AS hypothetical, "
 						  "0 AS aggtransspace, agginitval, "
 						  "0 AS aggmtransspace, NULL AS aggminitval, "
@@ -13937,7 +13737,7 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 			appendPQExpBufferStr(details, ",\n    MFINALFUNC_EXTRA");
 	}
 
-	aggsortconvop = convertOperatorReference(fout, aggsortop);
+	aggsortconvop = getFormattedOperatorName(fout, aggsortop);
 	if (aggsortconvop)
 	{
 		appendPQExpBuffer(details, ",\n    SORTOP = %s",
@@ -13959,20 +13759,18 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 						  agginfo->aggfn.dobj.name);
 	}
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delq, "DROP AGGREGATE %s.%s;\n",
 					  fmtId(agginfo->aggfn.dobj.namespace->dobj.name),
 					  aggsig);
 
-	appendPQExpBuffer(q, "CREATE AGGREGATE %s (\n%s\n);\n",
+	appendPQExpBuffer(q, "CREATE AGGREGATE %s.%s (\n%s\n);\n",
+					  fmtId(agginfo->aggfn.dobj.namespace->dobj.name),
 					  aggfullsig ? aggfullsig : aggsig, details->data);
 
-	appendPQExpBuffer(labelq, "AGGREGATE %s", aggsig);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &agginfo->aggfn.dobj, labelq->data);
+		binary_upgrade_extension_member(q, &agginfo->aggfn.dobj,
+										"AGGREGATE", aggsig,
+								   agginfo->aggfn.dobj.namespace->dobj.name);
 
 	if (agginfo->aggfn.dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, agginfo->aggfn.dobj.catId,
@@ -13988,13 +13786,13 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 
 	/* Dump Aggregate Comments */
 	if (agginfo->aggfn.dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "AGGREGATE", aggsig,
 					agginfo->aggfn.dobj.namespace->dobj.name,
 					agginfo->aggfn.rolname,
 					agginfo->aggfn.dobj.catId, 0, agginfo->aggfn.dobj.dumpId);
 
 	if (agginfo->aggfn.dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "AGGREGATE", aggsig,
 					 agginfo->aggfn.dobj.namespace->dobj.name,
 					 agginfo->aggfn.rolname,
 				   agginfo->aggfn.dobj.catId, 0, agginfo->aggfn.dobj.dumpId);
@@ -14010,8 +13808,7 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 
 	if (agginfo->aggfn.dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, agginfo->aggfn.dobj.catId, agginfo->aggfn.dobj.dumpId,
-				"FUNCTION",
-				aggsig, NULL, labelq->data,
+				"FUNCTION", aggsig, NULL,
 				agginfo->aggfn.dobj.namespace->dobj.name,
 				agginfo->aggfn.rolname, agginfo->aggfn.proacl,
 				agginfo->aggfn.rproacl,
@@ -14027,7 +13824,6 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(details);
 }
 
@@ -14041,7 +13837,7 @@ dumpTSParser(Archive *fout, TSParserInfo *prsinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qprsname;
 
 	/* Skip if not to be dumped */
 	if (!prsinfo->dobj.dump || dopt->dataOnly)
@@ -14049,13 +13845,11 @@ dumpTSParser(Archive *fout, TSParserInfo *prsinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, prsinfo->dobj.namespace->dobj.name);
+	qprsname = pg_strdup(fmtId(prsinfo->dobj.name));
 
 	appendPQExpBuffer(q, "CREATE TEXT SEARCH PARSER %s (\n",
-					  fmtId(prsinfo->dobj.name));
+					  fmtQualifiedDumpable(prsinfo));
 
 	appendPQExpBuffer(q, "    START = %s,\n",
 					  convertTSFunction(fout, prsinfo->prsstart));
@@ -14069,19 +13863,13 @@ dumpTSParser(Archive *fout, TSParserInfo *prsinfo)
 	appendPQExpBuffer(q, "    LEXTYPES = %s );\n",
 					  convertTSFunction(fout, prsinfo->prslextype));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TEXT SEARCH PARSER %s",
-					  fmtId(prsinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(prsinfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "TEXT SEARCH PARSER %s",
-					  fmtId(prsinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP TEXT SEARCH PARSER %s;\n",
+					  fmtQualifiedDumpable(prsinfo));
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &prsinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &prsinfo->dobj,
+										"TEXT SEARCH PARSER", qprsname,
+										prsinfo->dobj.namespace->dobj.name);
 
 	if (prsinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, prsinfo->dobj.catId, prsinfo->dobj.dumpId,
@@ -14096,13 +13884,13 @@ dumpTSParser(Archive *fout, TSParserInfo *prsinfo)
 
 	/* Dump Parser Comments */
 	if (prsinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TEXT SEARCH PARSER", qprsname,
 					prsinfo->dobj.namespace->dobj.name, "",
 					prsinfo->dobj.catId, 0, prsinfo->dobj.dumpId);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qprsname);
 }
 
 /*
@@ -14115,8 +13903,8 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer query;
+	char	   *qdictname;
 	PGresult   *res;
 	char	   *nspname;
 	char	   *tmplname;
@@ -14127,11 +13915,11 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	query = createPQExpBuffer();
 
+	qdictname = pg_strdup(fmtId(dictinfo->dobj.name));
+
 	/* Fetch name and namespace of the dictionary's template */
-	selectSourceSchema(fout, "pg_catalog");
 	appendPQExpBuffer(query, "SELECT nspname, tmplname "
 					  "FROM pg_ts_template p, pg_namespace n "
 					  "WHERE p.oid = '%u' AND n.oid = tmplnamespace",
@@ -14140,15 +13928,11 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 	nspname = PQgetvalue(res, 0, 0);
 	tmplname = PQgetvalue(res, 0, 1);
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, dictinfo->dobj.namespace->dobj.name);
-
 	appendPQExpBuffer(q, "CREATE TEXT SEARCH DICTIONARY %s (\n",
-					  fmtId(dictinfo->dobj.name));
+					  fmtQualifiedDumpable(dictinfo));
 
 	appendPQExpBufferStr(q, "    TEMPLATE = ");
-	if (strcmp(nspname, dictinfo->dobj.namespace->dobj.name) != 0)
-		appendPQExpBuffer(q, "%s.", fmtId(nspname));
+	appendPQExpBuffer(q, "%s.", fmtId(nspname));
 	appendPQExpBufferStr(q, fmtId(tmplname));
 
 	PQclear(res);
@@ -14159,19 +13943,13 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 
 	appendPQExpBufferStr(q, " );\n");
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TEXT SEARCH DICTIONARY %s",
-					  fmtId(dictinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(dictinfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "TEXT SEARCH DICTIONARY %s",
-					  fmtId(dictinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP TEXT SEARCH DICTIONARY %s;\n",
+					  fmtQualifiedDumpable(dictinfo));
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &dictinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &dictinfo->dobj,
+										"TEXT SEARCH DICTIONARY", qdictname,
+										dictinfo->dobj.namespace->dobj.name);
 
 	if (dictinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, dictinfo->dobj.catId, dictinfo->dobj.dumpId,
@@ -14186,14 +13964,14 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 
 	/* Dump Dictionary Comments */
 	if (dictinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TEXT SEARCH DICTIONARY", qdictname,
 					dictinfo->dobj.namespace->dobj.name, dictinfo->rolname,
 					dictinfo->dobj.catId, 0, dictinfo->dobj.dumpId);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qdictname);
 }
 
 /*
@@ -14206,7 +13984,7 @@ dumpTSTemplate(Archive *fout, TSTemplateInfo *tmplinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qtmplname;
 
 	/* Skip if not to be dumped */
 	if (!tmplinfo->dobj.dump || dopt->dataOnly)
@@ -14214,13 +13992,11 @@ dumpTSTemplate(Archive *fout, TSTemplateInfo *tmplinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, tmplinfo->dobj.namespace->dobj.name);
+	qtmplname = pg_strdup(fmtId(tmplinfo->dobj.name));
 
 	appendPQExpBuffer(q, "CREATE TEXT SEARCH TEMPLATE %s (\n",
-					  fmtId(tmplinfo->dobj.name));
+					  fmtQualifiedDumpable(tmplinfo));
 
 	if (tmplinfo->tmplinit != InvalidOid)
 		appendPQExpBuffer(q, "    INIT = %s,\n",
@@ -14228,19 +14004,13 @@ dumpTSTemplate(Archive *fout, TSTemplateInfo *tmplinfo)
 	appendPQExpBuffer(q, "    LEXIZE = %s );\n",
 					  convertTSFunction(fout, tmplinfo->tmpllexize));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TEXT SEARCH TEMPLATE %s",
-					  fmtId(tmplinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(tmplinfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "TEXT SEARCH TEMPLATE %s",
-					  fmtId(tmplinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP TEXT SEARCH TEMPLATE %s;\n",
+					  fmtQualifiedDumpable(tmplinfo));
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &tmplinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tmplinfo->dobj,
+										"TEXT SEARCH TEMPLATE", qtmplname,
+										tmplinfo->dobj.namespace->dobj.name);
 
 	if (tmplinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tmplinfo->dobj.catId, tmplinfo->dobj.dumpId,
@@ -14255,13 +14025,13 @@ dumpTSTemplate(Archive *fout, TSTemplateInfo *tmplinfo)
 
 	/* Dump Template Comments */
 	if (tmplinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TEXT SEARCH TEMPLATE", qtmplname,
 					tmplinfo->dobj.namespace->dobj.name, "",
 					tmplinfo->dobj.catId, 0, tmplinfo->dobj.dumpId);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qtmplname);
 }
 
 /*
@@ -14274,8 +14044,8 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer query;
+	char	   *qcfgname;
 	PGresult   *res;
 	char	   *nspname;
 	char	   *prsname;
@@ -14290,11 +14060,11 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	query = createPQExpBuffer();
 
+	qcfgname = pg_strdup(fmtId(cfginfo->dobj.name));
+
 	/* Fetch name and namespace of the config's parser */
-	selectSourceSchema(fout, "pg_catalog");
 	appendPQExpBuffer(query, "SELECT nspname, prsname "
 					  "FROM pg_ts_parser p, pg_namespace n "
 					  "WHERE p.oid = '%u' AND n.oid = prsnamespace",
@@ -14303,15 +14073,10 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 	nspname = PQgetvalue(res, 0, 0);
 	prsname = PQgetvalue(res, 0, 1);
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, cfginfo->dobj.namespace->dobj.name);
-
 	appendPQExpBuffer(q, "CREATE TEXT SEARCH CONFIGURATION %s (\n",
-					  fmtId(cfginfo->dobj.name));
+					  fmtQualifiedDumpable(cfginfo));
 
-	appendPQExpBufferStr(q, "    PARSER = ");
-	if (strcmp(nspname, cfginfo->dobj.namespace->dobj.name) != 0)
-		appendPQExpBuffer(q, "%s.", fmtId(nspname));
+	appendPQExpBuffer(q, "    PARSER = %s.", fmtId(nspname));
 	appendPQExpBuffer(q, "%s );\n", fmtId(prsname));
 
 	PQclear(res);
@@ -14345,7 +14110,7 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 			if (i > 0)
 				appendPQExpBufferStr(q, ";\n");
 			appendPQExpBuffer(q, "\nALTER TEXT SEARCH CONFIGURATION %s\n",
-							  fmtId(cfginfo->dobj.name));
+							  fmtQualifiedDumpable(cfginfo));
 			/* tokenname needs quoting, dictname does NOT */
 			appendPQExpBuffer(q, "    ADD MAPPING FOR %s WITH %s",
 							  fmtId(tokenname), dictname);
@@ -14359,19 +14124,13 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 
 	PQclear(res);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TEXT SEARCH CONFIGURATION %s",
-					  fmtId(cfginfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(cfginfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "TEXT SEARCH CONFIGURATION %s",
-					  fmtId(cfginfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP TEXT SEARCH CONFIGURATION %s;\n",
+					  fmtQualifiedDumpable(cfginfo));
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &cfginfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &cfginfo->dobj,
+										"TEXT SEARCH CONFIGURATION", qcfgname,
+										cfginfo->dobj.namespace->dobj.name);
 
 	if (cfginfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, cfginfo->dobj.catId, cfginfo->dobj.dumpId,
@@ -14386,14 +14145,14 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 
 	/* Dump Configuration Comments */
 	if (cfginfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "TEXT SEARCH CONFIGURATION", qcfgname,
 					cfginfo->dobj.namespace->dobj.name, cfginfo->rolname,
 					cfginfo->dobj.catId, 0, cfginfo->dobj.dumpId);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qcfgname);
 }
 
 /*
@@ -14406,7 +14165,6 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	char	   *qfdwname;
 
 	/* Skip if not to be dumped */
@@ -14415,7 +14173,6 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qfdwname = pg_strdup(fmtId(fdwinfo->dobj.name));
 
@@ -14436,11 +14193,10 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 	appendPQExpBuffer(delq, "DROP FOREIGN DATA WRAPPER %s;\n",
 					  qfdwname);
 
-	appendPQExpBuffer(labelq, "FOREIGN DATA WRAPPER %s",
-					  qfdwname);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &fdwinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &fdwinfo->dobj,
+										"FOREIGN DATA WRAPPER", qfdwname,
+										NULL);
 
 	if (fdwinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, fdwinfo->dobj.catId, fdwinfo->dobj.dumpId,
@@ -14456,15 +14212,14 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 	/* Handle the ACL */
 	if (fdwinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, fdwinfo->dobj.catId, fdwinfo->dobj.dumpId,
-				"FOREIGN DATA WRAPPER",
-				qfdwname, NULL, labelq->data,
+				"FOREIGN DATA WRAPPER", qfdwname, NULL,
 				NULL, fdwinfo->rolname,
 				fdwinfo->fdwacl, fdwinfo->rfdwacl,
 				fdwinfo->initfdwacl, fdwinfo->initrfdwacl);
 
 	/* Dump Foreign Data Wrapper Comments */
 	if (fdwinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "FOREIGN DATA WRAPPER", qfdwname,
 					NULL, fdwinfo->rolname,
 					fdwinfo->dobj.catId, 0, fdwinfo->dobj.dumpId);
 
@@ -14472,7 +14227,6 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 }
 
 /*
@@ -14485,7 +14239,6 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer query;
 	PGresult   *res;
 	char	   *qsrvname;
@@ -14497,13 +14250,11 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	query = createPQExpBuffer();
 
 	qsrvname = pg_strdup(fmtId(srvinfo->dobj.name));
 
 	/* look up the foreign-data wrapper */
-	selectSourceSchema(fout, "pg_catalog");
 	appendPQExpBuffer(query, "SELECT fdwname "
 					  "FROM pg_foreign_data_wrapper w "
 					  "WHERE w.oid = '%u'",
@@ -14534,10 +14285,9 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 	appendPQExpBuffer(delq, "DROP SERVER %s;\n",
 					  qsrvname);
 
-	appendPQExpBuffer(labelq, "SERVER %s", qsrvname);
-
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &srvinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &srvinfo->dobj,
+										"SERVER", qsrvname, NULL);
 
 	if (srvinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, srvinfo->dobj.catId, srvinfo->dobj.dumpId,
@@ -14553,8 +14303,7 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 	/* Handle the ACL */
 	if (srvinfo->dobj.dump & DUMP_COMPONENT_ACL)
 		dumpACL(fout, srvinfo->dobj.catId, srvinfo->dobj.dumpId,
-				"FOREIGN SERVER",
-				qsrvname, NULL, labelq->data,
+				"FOREIGN SERVER", qsrvname, NULL,
 				NULL, srvinfo->rolname,
 				srvinfo->srvacl, srvinfo->rsrvacl,
 				srvinfo->initsrvacl, srvinfo->initrsrvacl);
@@ -14568,7 +14317,7 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 
 	/* Dump Foreign Server Comments */
 	if (srvinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "SERVER", qsrvname,
 					NULL, srvinfo->rolname,
 					srvinfo->dobj.catId, 0, srvinfo->dobj.dumpId);
 
@@ -14576,7 +14325,6 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
 }
 
@@ -14616,8 +14364,6 @@ dumpUserMappings(Archive *fout,
 	 * OPTIONS clause.  A possible alternative is to skip such mappings
 	 * altogether, but it's not clear that that's an improvement.
 	 */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query,
 					  "SELECT usename, "
 					  "array_to_string(ARRAY("
@@ -14762,20 +14508,19 @@ dumpDefaultACL(Archive *fout, DefaultACLInfo *daclinfo)
  *		FOREIGN DATA WRAPPER, SERVER, or LARGE OBJECT.
  * 'name' is the formatted name of the object.  Must be quoted etc. already.
  * 'subname' is the formatted name of the sub-object, if any.  Must be quoted.
- * 'tag' is the tag for the archive entry (should be the same tag as would be
- *		used for comments etc; for example "TABLE foo").
+ *		(Currently we assume that subname is only provided for table columns.)
  * 'nspname' is the namespace the object is in (NULL if none).
  * 'owner' is the owner, NULL if there is no owner (for languages).
  * 'acls' contains the ACL string of the object from the appropriate system
- * 		catalog field; it will be passed to buildACLCommands for building the
- * 		appropriate GRANT commands.
+ *		catalog field; it will be passed to buildACLCommands for building the
+ *		appropriate GRANT commands.
  * 'racls' contains the ACL string of any initial-but-now-revoked ACLs of the
- * 		object; it will be passed to buildACLCommands for building the
- * 		appropriate REVOKE commands.
+ *		object; it will be passed to buildACLCommands for building the
+ *		appropriate REVOKE commands.
  * 'initacls' In binary-upgrade mode, ACL string of the object's initial
- * 		privileges, to be recorded into pg_init_privs
+ *		privileges, to be recorded into pg_init_privs
  * 'initracls' In binary-upgrade mode, ACL string of the object's
- * 		revoked-from-default privileges, to be recorded into pg_init_privs
+ *		revoked-from-default privileges, to be recorded into pg_init_privs
  *
  * NB: initacls/initracls are needed because extensions can set privileges on
  * an object during the extension's script file and we record those into
@@ -14785,7 +14530,7 @@ dumpDefaultACL(Archive *fout, DefaultACLInfo *daclinfo)
 static void
 dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
 		const char *type, const char *name, const char *subname,
-		const char *tag, const char *nspname, const char *owner,
+		const char *nspname, const char *owner,
 		const char *acls, const char *racls,
 		const char *initacls, const char *initracls)
 {
@@ -14813,7 +14558,8 @@ dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
 	if (strlen(initacls) != 0 || strlen(initracls) != 0)
 	{
 		appendPQExpBuffer(sql, "SELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\n");
-		if (!buildACLCommands(name, subname, type, initacls, initracls, owner,
+		if (!buildACLCommands(name, subname, nspname, type,
+							  initacls, initracls, owner,
 							  "", fout->remoteVersion, sql))
 			exit_horribly(NULL,
 						  "could not parse initial GRANT ACL list (%s) or initial REVOKE ACL list (%s) for object \"%s\" (%s)\n",
@@ -14821,21 +14567,32 @@ dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
 		appendPQExpBuffer(sql, "SELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\n");
 	}
 
-	if (!buildACLCommands(name, subname, type, acls, racls, owner,
+	if (!buildACLCommands(name, subname, nspname, type,
+						  acls, racls, owner,
 						  "", fout->remoteVersion, sql))
 		exit_horribly(NULL,
 					  "could not parse GRANT ACL list (%s) or REVOKE ACL list (%s) for object \"%s\" (%s)\n",
 					  acls, racls, name, type);
 
 	if (sql->len > 0)
+	{
+		PQExpBuffer tag = createPQExpBuffer();
+
+		if (subname)
+			appendPQExpBuffer(tag, "COLUMN %s.%s", name, subname);
+		else
+			appendPQExpBuffer(tag, "%s %s", type, name);
+
 		ArchiveEntry(fout, nilCatalogId, createDumpId(),
-					 tag, nspname,
+					 tag->data, nspname,
 					 NULL,
 					 owner ? owner : "",
 					 false, "ACL", SECTION_NONE,
 					 sql->data, "", NULL,
 					 &(objDumpId), 1,
 					 NULL, NULL);
+		destroyPQExpBuffer(tag);
+	}
 
 	destroyPQExpBuffer(sql);
 }
@@ -14844,8 +14601,8 @@ dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
  * dumpSecLabel
  *
  * This routine is used to dump any security labels associated with the
- * object handed to this routine. The routine takes a constant character
- * string for the target part of the security-label command, plus
+ * object handed to this routine. The routine takes the object type
+ * and object name (ready to print, except for schema decoration), plus
  * the namespace and owner of the object (for labeling the ArchiveEntry),
  * plus catalog ID and subid which are the lookup key for pg_seclabel,
  * plus the dump ID for the object (for setting a dependency).
@@ -14859,7 +14616,7 @@ dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
  * calling ArchiveEntry() for the specified object.
  */
 static void
-dumpSecLabel(Archive *fout, const char *target,
+dumpSecLabel(Archive *fout, const char *type, const char *name,
 			 const char *namespace, const char *owner,
 			 CatalogId catalogId, int subid, DumpId dumpId)
 {
@@ -14874,7 +14631,7 @@ dumpSecLabel(Archive *fout, const char *target,
 		return;
 
 	/* Security labels are schema not data ... except blob labels are data */
-	if (strncmp(target, "LARGE OBJECT ", 13) != 0)
+	if (strcmp(type, "LARGE OBJECT") != 0)
 	{
 		if (dopt->dataOnly)
 			return;
@@ -14900,21 +14657,29 @@ dumpSecLabel(Archive *fout, const char *target,
 			continue;
 
 		appendPQExpBuffer(query,
-						  "SECURITY LABEL FOR %s ON %s IS ",
-						  fmtId(labels[i].provider), target);
+						  "SECURITY LABEL FOR %s ON %s ",
+						  fmtId(labels[i].provider), type);
+		if (namespace && *namespace)
+			appendPQExpBuffer(query, "%s.", fmtId(namespace));
+		appendPQExpBuffer(query, "%s IS ", name);
 		appendStringLiteralAH(query, labels[i].label, fout);
 		appendPQExpBufferStr(query, ";\n");
 	}
 
 	if (query->len > 0)
 	{
+		PQExpBuffer tag = createPQExpBuffer();
+
+		appendPQExpBuffer(tag, "%s %s", type, name);
 		ArchiveEntry(fout, nilCatalogId, createDumpId(),
-					 target, namespace, NULL, owner,
+					 tag->data, namespace, NULL, owner,
 					 false, "SECURITY LABEL", SECTION_NONE,
 					 query->data, "", NULL,
 					 &(dumpId), 1,
 					 NULL, NULL);
+		destroyPQExpBuffer(tag);
 	}
+
 	destroyPQExpBuffer(query);
 }
 
@@ -14966,13 +14731,14 @@ dumpTableSecLabel(Archive *fout, TableInfo *tbinfo, const char *reltypename)
 		if (objsubid == 0)
 		{
 			appendPQExpBuffer(target, "%s %s", reltypename,
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
 		}
 		else
 		{
 			colname = getAttrName(objsubid, tbinfo);
-			/* first fmtId result must be consumed before calling it again */
-			appendPQExpBuffer(target, "COLUMN %s", fmtId(tbinfo->dobj.name));
+			/* first fmtXXX result must be consumed before calling again */
+			appendPQExpBuffer(target, "COLUMN %s",
+							  fmtQualifiedDumpable(tbinfo));
 			appendPQExpBuffer(target, ".%s", fmtId(colname));
 		}
 		appendPQExpBuffer(query, "SECURITY LABEL FOR %s ON %s IS ",
@@ -15170,14 +14936,12 @@ dumpTable(Archive *fout, TableInfo *tbinfo)
 	{
 		const char *objtype =
 		(tbinfo->relkind == RELKIND_SEQUENCE) ? "SEQUENCE" : "TABLE";
-		char	   *acltag = psprintf("%s %s", objtype, namecopy);
 
 		dumpACL(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId,
-				objtype, namecopy, NULL, acltag,
+				objtype, namecopy, NULL,
 				tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 				tbinfo->relacl, tbinfo->rrelacl,
 				tbinfo->initrelacl, tbinfo->initrrelacl);
-		free(acltag);
 	}
 
 	/*
@@ -15259,17 +15023,14 @@ dumpTable(Archive *fout, TableInfo *tbinfo)
 			char	   *initattacl = PQgetvalue(res, i, 3);
 			char	   *initrattacl = PQgetvalue(res, i, 4);
 			char	   *attnamecopy;
-			char	   *acltag;
 
 			attnamecopy = pg_strdup(fmtId(attname));
-			acltag = psprintf("COLUMN %s.%s", namecopy, attnamecopy);
 			/* Column's GRANT type is always TABLE */
-			dumpACL(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId, "TABLE",
-					namecopy, attnamecopy, acltag,
+			dumpACL(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId,
+					"TABLE", namecopy, attnamecopy,
 					tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 					attacl, rattacl, initattacl, initrattacl);
 			free(attnamecopy);
-			free(acltag);
 		}
 		PQclear(res);
 		destroyPQExpBuffer(query);
@@ -15347,7 +15108,8 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
+	char	   *qrelname;
+	char	   *qualrelname;
 	int			numParents;
 	TableInfo **parents;
 	int			actual_atts;	/* number of attrs in this CREATE statement */
@@ -15358,8 +15120,8 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 	int			j,
 				k;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
+	qrelname = pg_strdup(fmtId(tbinfo->dobj.name));
+	qualrelname = pg_strdup(fmtQualifiedDumpable(tbinfo));
 
 	if (dopt->binary_upgrade)
 		binary_upgrade_set_type_oids_by_rel_oid(fout, q,
@@ -15372,20 +15134,14 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 		reltypename = "VIEW";
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "DROP VIEW %s.",
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s;\n",
-						  fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(delq, "DROP VIEW %s;\n", qualrelname);
 
 		if (dopt->binary_upgrade)
 			binary_upgrade_set_pg_class_oids(fout, q,
 											 tbinfo->dobj.catId.oid, false);
 
-		appendPQExpBuffer(q, "CREATE VIEW %s", fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(q, "CREATE VIEW %s", qualrelname);
+
 		if (nonemptyReloptions(tbinfo->reloptions))
 		{
 			appendPQExpBufferStr(q, " WITH (");
@@ -15399,9 +15155,6 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 		if (tbinfo->checkoption != NULL)
 			appendPQExpBuffer(q, "\n  WITH %s CHECK OPTION", tbinfo->checkoption);
 		appendPQExpBufferStr(q, ";\n");
-
-		appendPQExpBuffer(labelq, "VIEW %s",
-						  fmtId(tbinfo->dobj.name));
 	}
 	else
 	{
@@ -15453,17 +15206,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 		numParents = tbinfo->numParents;
 		parents = tbinfo->parents;
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "DROP %s %s.", reltypename,
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s;\n",
-						  fmtId(tbinfo->dobj.name));
-
-		appendPQExpBuffer(labelq, "%s %s", reltypename,
-						  fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(delq, "DROP %s %s;\n", reltypename, qualrelname);
 
 		if (dopt->binary_upgrade)
 			binary_upgrade_set_pg_class_oids(fout, q,
@@ -15473,7 +15216,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 						  tbinfo->relpersistence == RELPERSISTENCE_UNLOGGED ?
 						  "UNLOGGED " : "",
 						  reltypename,
-						  fmtId(tbinfo->dobj.name));
+						  qualrelname);
 
 		/*
 		 * Attach to type, if reloftype; except in case of a binary upgrade,
@@ -15564,12 +15307,8 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 						coll = findCollationByOid(tbinfo->attcollation[j]);
 						if (coll)
-						{
-							/* always schema-qualify, don't try to be smart */
-							appendPQExpBuffer(q, " COLLATE %s.",
-									 fmtId(coll->dobj.namespace->dobj.name));
-							appendPQExpBufferStr(q, fmtId(coll->dobj.name));
-						}
+							appendPQExpBuffer(q, " COLLATE %s",
+											  fmtQualifiedDumpable(coll));
 					}
 
 					if (has_default)
@@ -15623,10 +15362,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 					if (k > 0)
 						appendPQExpBufferStr(q, ", ");
-					if (parentRel->dobj.namespace != tbinfo->dobj.namespace)
-						appendPQExpBuffer(q, "%s.",
-								fmtId(parentRel->dobj.namespace->dobj.name));
-					appendPQExpBufferStr(q, fmtId(parentRel->dobj.name));
+					appendPQExpBufferStr(q, fmtQualifiedDumpable(parentRel));
 				}
 				appendPQExpBufferChar(q, ')');
 			}
@@ -15713,15 +15449,15 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 									  tbinfo->attalign[j]);
 					appendStringLiteralAH(q, tbinfo->attnames[j], fout);
 					appendPQExpBufferStr(q, "\n  AND attrelid = ");
-					appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+					appendStringLiteralAH(q, qualrelname, fout);
 					appendPQExpBufferStr(q, "::pg_catalog.regclass;\n");
 
 					if (tbinfo->relkind == RELKIND_RELATION)
 						appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-										  fmtId(tbinfo->dobj.name));
+										  qualrelname);
 					else
 						appendPQExpBuffer(q, "ALTER FOREIGN TABLE ONLY %s ",
-										  fmtId(tbinfo->dobj.name));
+										  qualrelname);
 					appendPQExpBuffer(q, "DROP COLUMN %s;\n",
 									  fmtId(tbinfo->attnames[j]));
 				}
@@ -15733,7 +15469,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 										 "WHERE attname = ");
 					appendStringLiteralAH(q, tbinfo->attnames[j], fout);
 					appendPQExpBufferStr(q, "\n  AND attrelid = ");
-					appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+					appendStringLiteralAH(q, qualrelname, fout);
 					appendPQExpBufferStr(q, "::pg_catalog.regclass;\n");
 				}
 			}
@@ -15747,7 +15483,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 				appendPQExpBufferStr(q, "\n-- For binary upgrade, set up inherited constraint.\n");
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, " ADD CONSTRAINT %s ",
 								  fmtId(constr->dobj.name));
 				appendPQExpBuffer(q, "%s;\n", constr->condef);
@@ -15756,7 +15492,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 									 "WHERE contype = 'c' AND conname = ");
 				appendStringLiteralAH(q, constr->dobj.name, fout);
 				appendPQExpBufferStr(q, "\n  AND conrelid = ");
-				appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+				appendStringLiteralAH(q, qualrelname, fout);
 				appendPQExpBufferStr(q, "::pg_catalog.regclass;\n");
 			}
 
@@ -15768,12 +15504,9 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 					TableInfo  *parentRel = parents[k];
 
 					appendPQExpBuffer(q, "ALTER TABLE ONLY %s INHERIT ",
-									  fmtId(tbinfo->dobj.name));
-					if (parentRel->dobj.namespace != tbinfo->dobj.namespace)
-						appendPQExpBuffer(q, "%s.",
-								fmtId(parentRel->dobj.namespace->dobj.name));
+									  qualrelname);
 					appendPQExpBuffer(q, "%s;\n",
-									  fmtId(parentRel->dobj.name));
+									  fmtQualifiedDumpable(parentRel));
 				}
 			}
 
@@ -15781,7 +15514,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 			{
 				appendPQExpBufferStr(q, "\n-- For binary upgrade, set up typed tables this way.\n");
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s OF %s;\n",
-								  fmtId(tbinfo->dobj.name),
+								  qualrelname,
 								  tbinfo->reloftype);
 			}
 		}
@@ -15802,7 +15535,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 							  "SET relfrozenxid = '%u', relminmxid = '%u'\n"
 							  "WHERE oid = ",
 							  tbinfo->frozenxid, tbinfo->minmxid);
-			appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+			appendStringLiteralAH(q, qualrelname, fout);
 			appendPQExpBufferStr(q, "::pg_catalog.regclass;\n");
 
 			if (tbinfo->toast_oid)
@@ -15834,7 +15567,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 			appendPQExpBufferStr(q, "UPDATE pg_catalog.pg_class\n"
 								 "SET relispopulated = 't'\n"
 								 "WHERE oid = ");
-			appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+			appendStringLiteralAH(q, qualrelname, fout);
 			appendPQExpBufferStr(q, "::pg_catalog.regclass;\n");
 		}
 
@@ -15857,7 +15590,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 				tbinfo->notnull[j] && !tbinfo->inhNotNull[j])
 			{
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, "ALTER COLUMN %s SET NOT NULL;\n",
 								  fmtId(tbinfo->attnames[j]));
 			}
@@ -15870,7 +15603,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 			if (tbinfo->attstattarget[j] >= 0)
 			{
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, "ALTER COLUMN %s ",
 								  fmtId(tbinfo->attnames[j]));
 				appendPQExpBuffer(q, "SET STATISTICS %d;\n",
@@ -15907,7 +15640,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 				if (storage != NULL)
 				{
 					appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-									  fmtId(tbinfo->dobj.name));
+									  qualrelname);
 					appendPQExpBuffer(q, "ALTER COLUMN %s ",
 									  fmtId(tbinfo->attnames[j]));
 					appendPQExpBuffer(q, "SET STORAGE %s;\n",
@@ -15921,7 +15654,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 			if (tbinfo->attoptions[j] && tbinfo->attoptions[j][0] != '\0')
 			{
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, "ALTER COLUMN %s ",
 								  fmtId(tbinfo->attnames[j]));
 				appendPQExpBuffer(q, "SET (%s);\n",
@@ -15936,7 +15669,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 				tbinfo->attfdwoptions[j][0] != '\0')
 			{
 				appendPQExpBuffer(q, "ALTER FOREIGN TABLE %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, "ALTER COLUMN %s ",
 								  fmtId(tbinfo->attnames[j]));
 				appendPQExpBuffer(q, "OPTIONS (\n    %s\n);\n",
@@ -15959,25 +15692,27 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 		else if (tbinfo->relreplident == REPLICA_IDENTITY_NOTHING)
 		{
 			appendPQExpBuffer(q, "\nALTER TABLE ONLY %s REPLICA IDENTITY NOTHING;\n",
-							  fmtId(tbinfo->dobj.name));
+							  qualrelname);
 		}
 		else if (tbinfo->relreplident == REPLICA_IDENTITY_FULL)
 		{
 			appendPQExpBuffer(q, "\nALTER TABLE ONLY %s REPLICA IDENTITY FULL;\n",
-							  fmtId(tbinfo->dobj.name));
+							  qualrelname);
 		}
 	}
 
 	if (tbinfo->relkind == RELKIND_FOREIGN_TABLE && tbinfo->hasoids)
 		appendPQExpBuffer(q, "\nALTER TABLE ONLY %s SET WITH OIDS;\n",
-						  fmtId(tbinfo->dobj.name));
+						  qualrelname);
 
 	if (tbinfo->forcerowsec)
 		appendPQExpBuffer(q, "\nALTER TABLE ONLY %s FORCE ROW LEVEL SECURITY;\n",
-						  fmtId(tbinfo->dobj.name));
+						  qualrelname);
 
 	if (dopt->binary_upgrade)
-		binary_upgrade_extension_member(q, &tbinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tbinfo->dobj,
+										reltypename, qrelname,
+										tbinfo->dobj.namespace->dobj.name);
 
 	if (tbinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId,
@@ -16016,7 +15751,8 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qrelname);
+	free(qualrelname);
 }
 
 /*
@@ -16030,6 +15766,7 @@ dumpAttrDef(Archive *fout, AttrDefInfo *adinfo)
 	int			adnum = adinfo->adnum;
 	PQExpBuffer q;
 	PQExpBuffer delq;
+	char	   *qualrelname;
 	char	   *tag;
 
 	/* Skip if table definition not to be dumped */
@@ -16043,19 +15780,16 @@ dumpAttrDef(Archive *fout, AttrDefInfo *adinfo)
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
 
+	qualrelname = pg_strdup(fmtQualifiedDumpable(tbinfo));
+
 	appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-					  fmtId(tbinfo->dobj.name));
+					  qualrelname);
 	appendPQExpBuffer(q, "ALTER COLUMN %s SET DEFAULT %s;\n",
 					  fmtId(tbinfo->attnames[adnum - 1]),
 					  adinfo->adef_expr);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "ALTER TABLE %s.",
-					  fmtId(tbinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s ",
-					  fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delq, "ALTER TABLE %s ",
+					  qualrelname);
 	appendPQExpBuffer(delq, "ALTER COLUMN %s DROP DEFAULT;\n",
 					  fmtId(tbinfo->attnames[adnum - 1]));
 
@@ -16075,6 +15809,7 @@ dumpAttrDef(Archive *fout, AttrDefInfo *adinfo)
 	free(tag);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
+	free(qualrelname);
 }
 
 /*
@@ -16123,17 +15858,15 @@ dumpIndex(Archive *fout, IndxInfo *indxinfo)
 	bool		is_constraint = (indxinfo->indexconstraint != 0);
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qindxname;
 
 	if (dopt->dataOnly)
 		return;
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	appendPQExpBuffer(labelq, "INDEX %s",
-					  fmtId(indxinfo->dobj.name));
+	qindxname = pg_strdup(fmtId(indxinfo->dobj.name));
 
 	/*
 	 * If there's an associated constraint, don't dump the index per se, but
@@ -16155,28 +15888,24 @@ dumpIndex(Archive *fout, IndxInfo *indxinfo)
 		if (indxinfo->indisclustered)
 		{
 			appendPQExpBuffer(q, "\nALTER TABLE %s CLUSTER",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
+			/* index name is not qualified in this syntax */
 			appendPQExpBuffer(q, " ON %s;\n",
-							  fmtId(indxinfo->dobj.name));
+							  qindxname);
 		}
 
 		/* If the index defines identity, we need to record that. */
 		if (indxinfo->indisreplident)
 		{
 			appendPQExpBuffer(q, "\nALTER TABLE ONLY %s REPLICA IDENTITY USING",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
+			/* index name is not qualified in this syntax */
 			appendPQExpBuffer(q, " INDEX %s;\n",
-							  fmtId(indxinfo->dobj.name));
+							  qindxname);
 		}
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "DROP INDEX %s.",
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s;\n",
-						  fmtId(indxinfo->dobj.name));
+		appendPQExpBuffer(delq, "DROP INDEX %s;\n",
+						  fmtQualifiedDumpable(indxinfo));
 
 		if (indxinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 			ArchiveEntry(fout, indxinfo->dobj.catId, indxinfo->dobj.dumpId,
@@ -16192,7 +15921,7 @@ dumpIndex(Archive *fout, IndxInfo *indxinfo)
 
 	/* Dump Index Comments */
 	if (indxinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "INDEX", qindxname,
 					tbinfo->dobj.namespace->dobj.name,
 					tbinfo->rolname,
 					indxinfo->dobj.catId, 0,
@@ -16201,7 +15930,7 @@ dumpIndex(Archive *fout, IndxInfo *indxinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qindxname);
 }
 
 /*
@@ -16243,7 +15972,7 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 											 indxinfo->dobj.catId.oid, true);
 
 		appendPQExpBuffer(q, "ALTER TABLE ONLY %s\n",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(q, "    ADD CONSTRAINT %s ",
 						  fmtId(coninfo->dobj.name));
 
@@ -16293,19 +16022,14 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 		if (indxinfo->indisclustered)
 		{
 			appendPQExpBuffer(q, "\nALTER TABLE %s CLUSTER",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
+			/* index name is not qualified in this syntax */
 			appendPQExpBuffer(q, " ON %s;\n",
 							  fmtId(indxinfo->dobj.name));
 		}
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "ALTER TABLE ONLY %s.",
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s ",
-						  fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(delq, "ALTER TABLE ONLY %s ",
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(delq, "DROP CONSTRAINT %s;\n",
 						  fmtId(coninfo->dobj.name));
 
@@ -16329,19 +16053,13 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 		 * current table data is not processed
 		 */
 		appendPQExpBuffer(q, "ALTER TABLE ONLY %s\n",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(q, "    ADD CONSTRAINT %s %s;\n",
 						  fmtId(coninfo->dobj.name),
 						  coninfo->condef);
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "ALTER TABLE ONLY %s.",
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s ",
-						  fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(delq, "ALTER TABLE ONLY %s ",
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(delq, "DROP CONSTRAINT %s;\n",
 						  fmtId(coninfo->dobj.name));
 
@@ -16367,19 +16085,13 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 		{
 			/* not ONLY since we want it to propagate to children */
 			appendPQExpBuffer(q, "ALTER TABLE %s\n",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
 			appendPQExpBuffer(q, "    ADD CONSTRAINT %s %s;\n",
 							  fmtId(coninfo->dobj.name),
 							  coninfo->condef);
 
-			/*
-			 * DROP must be fully qualified in case same name appears in
-			 * pg_catalog
-			 */
-			appendPQExpBuffer(delq, "ALTER TABLE %s.",
-							  fmtId(tbinfo->dobj.namespace->dobj.name));
-			appendPQExpBuffer(delq, "%s ",
-							  fmtId(tbinfo->dobj.name));
+			appendPQExpBuffer(delq, "ALTER TABLE %s ",
+							  fmtQualifiedDumpable(tbinfo));
 			appendPQExpBuffer(delq, "DROP CONSTRAINT %s;\n",
 							  fmtId(coninfo->dobj.name));
 
@@ -16406,19 +16118,13 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 		if (coninfo->separate)
 		{
 			appendPQExpBuffer(q, "ALTER DOMAIN %s\n",
-							  fmtId(tyinfo->dobj.name));
+							  fmtQualifiedDumpable(tyinfo));
 			appendPQExpBuffer(q, "    ADD CONSTRAINT %s %s;\n",
 							  fmtId(coninfo->dobj.name),
 							  coninfo->condef);
 
-			/*
-			 * DROP must be fully qualified in case same name appears in
-			 * pg_catalog
-			 */
-			appendPQExpBuffer(delq, "ALTER DOMAIN %s.",
-							  fmtId(tyinfo->dobj.namespace->dobj.name));
-			appendPQExpBuffer(delq, "%s ",
-							  fmtId(tyinfo->dobj.name));
+			appendPQExpBuffer(delq, "ALTER DOMAIN %s ",
+							  fmtQualifiedDumpable(tyinfo));
 			appendPQExpBuffer(delq, "DROP CONSTRAINT %s;\n",
 							  fmtId(coninfo->dobj.name));
 
@@ -16463,21 +16169,23 @@ static void
 dumpTableConstraintComment(Archive *fout, ConstraintInfo *coninfo)
 {
 	TableInfo  *tbinfo = coninfo->contable;
-	PQExpBuffer labelq = createPQExpBuffer();
+	PQExpBuffer conprefix = createPQExpBuffer();
+	char	   *qtabname;
 
-	appendPQExpBuffer(labelq, "CONSTRAINT %s ",
+	qtabname = pg_strdup(fmtId(tbinfo->dobj.name));
+
+	appendPQExpBuffer(conprefix, "CONSTRAINT %s ON",
 					  fmtId(coninfo->dobj.name));
-	appendPQExpBuffer(labelq, "ON %s",
-					  fmtId(tbinfo->dobj.name));
 
 	if (coninfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, conprefix->data, qtabname,
 					tbinfo->dobj.namespace->dobj.name,
 					tbinfo->rolname,
 					coninfo->dobj.catId, 0,
 			 coninfo->separate ? coninfo->dobj.dumpId : tbinfo->dobj.dumpId);
 
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(conprefix);
+	free(qtabname);
 }
 
 /*
@@ -16545,10 +16253,9 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 	bool		cycled;
 	PQExpBuffer query = createPQExpBuffer();
 	PQExpBuffer delqry = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
+	char	   *qseqname;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
+	qseqname = pg_strdup(fmtId(tbinfo->dobj.name));
 
 	snprintf(bufm, sizeof(bufm), INT64_FORMAT, SEQ_MINVALUE);
 	snprintf(bufx, sizeof(bufx), INT64_FORMAT, SEQ_MAXVALUE);
@@ -16568,7 +16275,7 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 						  "END AS min_value, "
 						  "cache_value, is_cycled FROM %s",
 						  bufx, bufm,
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 	}
 	else
 	{
@@ -16585,7 +16292,7 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 						  "END AS min_value, "
 						  "cache_value, is_cycled FROM %s",
 						  bufx, bufm,
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 	}
 
 	res = ExecuteSqlQuery(fout, query->data, PGRES_TUPLES_OK);
@@ -16618,13 +16325,8 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 	cache = PQgetvalue(res, 0, 5);
 	cycled = (strcmp(PQgetvalue(res, 0, 6), "t") == 0);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delqry, "DROP SEQUENCE %s.",
-					  fmtId(tbinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delqry, "%s;\n",
-					  fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delqry, "DROP SEQUENCE %s;\n",
+					  fmtQualifiedDumpable(tbinfo));
 
 	resetPQExpBuffer(query);
 
@@ -16638,7 +16340,7 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 
 	appendPQExpBuffer(query,
 					  "CREATE SEQUENCE %s\n",
-					  fmtId(tbinfo->dobj.name));
+					  fmtQualifiedDumpable(tbinfo));
 
 	if (fout->remoteVersion >= 80400)
 		appendPQExpBuffer(query, "    START WITH %s\n", startv);
@@ -16661,13 +16363,12 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 
 	appendPQExpBufferStr(query, ";\n");
 
-	appendPQExpBuffer(labelq, "SEQUENCE %s", fmtId(tbinfo->dobj.name));
-
 	/* binary_upgrade:	no need to clear TOAST table oid */
 
 	if (dopt->binary_upgrade)
 		binary_upgrade_extension_member(query, &tbinfo->dobj,
-										labelq->data);
+										"SEQUENCE", qseqname,
+										tbinfo->dobj.namespace->dobj.name);
 
 	if (tbinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId,
@@ -16704,9 +16405,9 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 		{
 			resetPQExpBuffer(query);
 			appendPQExpBuffer(query, "ALTER SEQUENCE %s",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
 			appendPQExpBuffer(query, " OWNED BY %s",
-							  fmtId(owning_tab->dobj.name));
+							  fmtQualifiedDumpable(owning_tab));
 			appendPQExpBuffer(query, ".%s;\n",
 						fmtId(owning_tab->attnames[tbinfo->owning_col - 1]));
 
@@ -16725,12 +16426,12 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 
 	/* Dump Sequence Comments and Security Labels */
 	if (tbinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "SEQUENCE", qseqname,
 					tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 					tbinfo->dobj.catId, 0, tbinfo->dobj.dumpId);
 
 	if (tbinfo->dobj.dump & DUMP_COMPONENT_SECLABEL)
-		dumpSecLabel(fout, labelq->data,
+		dumpSecLabel(fout, "SEQUENCE", qseqname,
 					 tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 					 tbinfo->dobj.catId, 0, tbinfo->dobj.dumpId);
 
@@ -16738,7 +16439,7 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
+	free(qseqname);
 }
 
 /*
@@ -16754,12 +16455,9 @@ dumpSequenceData(Archive *fout, TableDataInfo *tdinfo)
 	bool		called;
 	PQExpBuffer query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 	appendPQExpBuffer(query,
 					  "SELECT last_value, is_called FROM %s",
-					  fmtId(tbinfo->dobj.name));
+					  fmtQualifiedDumpable(tbinfo));
 
 	res = ExecuteSqlQuery(fout, query->data, PGRES_TUPLES_OK);
 
@@ -16777,7 +16475,7 @@ dumpSequenceData(Archive *fout, TableDataInfo *tdinfo)
 
 	resetPQExpBuffer(query);
 	appendPQExpBufferStr(query, "SELECT pg_catalog.setval(");
-	appendStringLiteralAH(query, fmtId(tbinfo->dobj.name), fout);
+	appendStringLiteralAH(query, fmtQualifiedDumpable(tbinfo), fout);
 	appendPQExpBuffer(query, ", %s, %s);\n",
 					  last, (called ? "true" : "false"));
 
@@ -16808,7 +16506,8 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 	TableInfo  *tbinfo = tginfo->tgtable;
 	PQExpBuffer query;
 	PQExpBuffer delqry;
-	PQExpBuffer labelq;
+	PQExpBuffer trigprefix;
+	char	   *qtabname;
 	char	   *tgargs;
 	size_t		lentgargs;
 	const char *p;
@@ -16824,17 +16523,14 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 
 	query = createPQExpBuffer();
 	delqry = createPQExpBuffer();
-	labelq = createPQExpBuffer();
+	trigprefix = createPQExpBuffer();
+
+	qtabname = pg_strdup(fmtId(tbinfo->dobj.name));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delqry, "DROP TRIGGER %s ",
 					  fmtId(tginfo->dobj.name));
-	appendPQExpBuffer(delqry, "ON %s.",
-					  fmtId(tbinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delqry, "%s;\n",
-					  fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delqry, "ON %s;\n",
+					  fmtQualifiedDumpable(tbinfo));
 
 	if (tginfo->tgdef)
 	{
@@ -16898,7 +16594,7 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 			findx++;
 		}
 		appendPQExpBuffer(query, " ON %s\n",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 
 		if (tginfo->tgisconstraint)
 		{
@@ -16964,7 +16660,7 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 	if (tginfo->tgenabled != 't' && tginfo->tgenabled != 'O')
 	{
 		appendPQExpBuffer(query, "\nALTER TABLE %s ",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		switch (tginfo->tgenabled)
 		{
 			case 'D':
@@ -16985,10 +16681,8 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 						  fmtId(tginfo->dobj.name));
 	}
 
-	appendPQExpBuffer(labelq, "TRIGGER %s ",
+	appendPQExpBuffer(trigprefix, "TRIGGER %s ON",
 					  fmtId(tginfo->dobj.name));
-	appendPQExpBuffer(labelq, "ON %s",
-					  fmtId(tbinfo->dobj.name));
 
 	tag = psprintf("%s %s", tbinfo->dobj.name, tginfo->dobj.name);
 
@@ -17004,14 +16698,15 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 					 NULL, NULL);
 
 	if (tginfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, trigprefix->data, qtabname,
 					tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 					tginfo->dobj.catId, 0, tginfo->dobj.dumpId);
 
 	free(tag);
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(trigprefix);
+	free(qtabname);
 }
 
 /*
@@ -17024,7 +16719,7 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 	DumpOptions *dopt = fout->dopt;
 	PQExpBuffer query;
 	PQExpBuffer delqry;
-	PQExpBuffer labelq;
+	char	   *qevtname;
 
 	/* Skip if not to be dumped */
 	if (!evtinfo->dobj.dump || dopt->dataOnly)
@@ -17032,10 +16727,11 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 
 	query = createPQExpBuffer();
 	delqry = createPQExpBuffer();
-	labelq = createPQExpBuffer();
+
+	qevtname = pg_strdup(fmtId(evtinfo->dobj.name));
 
 	appendPQExpBufferStr(query, "CREATE EVENT TRIGGER ");
-	appendPQExpBufferStr(query, fmtId(evtinfo->dobj.name));
+	appendPQExpBufferStr(query, qevtname);
 	appendPQExpBufferStr(query, " ON ");
 	appendPQExpBufferStr(query, fmtId(evtinfo->evtevent));
 
@@ -17053,7 +16749,7 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 	if (evtinfo->evtenabled != 'O')
 	{
 		appendPQExpBuffer(query, "\nALTER EVENT TRIGGER %s ",
-						  fmtId(evtinfo->dobj.name));
+						  qevtname);
 		switch (evtinfo->evtenabled)
 		{
 			case 'D':
@@ -17073,10 +16769,7 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 	}
 
 	appendPQExpBuffer(delqry, "DROP EVENT TRIGGER %s;\n",
-					  fmtId(evtinfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "EVENT TRIGGER %s",
-					  fmtId(evtinfo->dobj.name));
+					  qevtname);
 
 	if (evtinfo->dobj.dump & DUMP_COMPONENT_DEFINITION)
 		ArchiveEntry(fout, evtinfo->dobj.catId, evtinfo->dobj.dumpId,
@@ -17088,13 +16781,13 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 					 NULL, NULL);
 
 	if (evtinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, "EVENT TRIGGER", qevtname,
 					NULL, evtinfo->evtowner,
 					evtinfo->dobj.catId, 0, evtinfo->dobj.dumpId);
 
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
+	free(qevtname);
 }
 
 /*
@@ -17109,7 +16802,8 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	PQExpBuffer query;
 	PQExpBuffer cmd;
 	PQExpBuffer delcmd;
-	PQExpBuffer labelq;
+	PQExpBuffer ruleprefix;
+	char	   *qtabname;
 	PGresult   *res;
 	char	   *tag;
 
@@ -17124,15 +16818,12 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	if (!rinfo->separate)
 		return;
 
-	/*
-	 * Make sure we are in proper schema.
-	 */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 	query = createPQExpBuffer();
 	cmd = createPQExpBuffer();
 	delcmd = createPQExpBuffer();
-	labelq = createPQExpBuffer();
+	ruleprefix = createPQExpBuffer();
+
+	qtabname = pg_strdup(fmtId(tbinfo->dobj.name));
 
 	if (fout->remoteVersion >= 70300)
 	{
@@ -17165,7 +16856,7 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	 */
 	if (rinfo->ev_enabled != 'O')
 	{
-		appendPQExpBuffer(cmd, "ALTER TABLE %s ", fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(cmd, "ALTER TABLE %s ", fmtQualifiedDumpable(tbinfo));
 		switch (rinfo->ev_enabled)
 		{
 			case 'A':
@@ -17189,25 +16880,18 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	if (nonemptyReloptions(rinfo->reloptions))
 	{
 		appendPQExpBuffer(cmd, "ALTER VIEW %s SET (",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		appendReloptionsArrayAH(cmd, rinfo->reloptions, "", fout);
 		appendPQExpBufferStr(cmd, ");\n");
 	}
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delcmd, "DROP RULE %s ",
 					  fmtId(rinfo->dobj.name));
-	appendPQExpBuffer(delcmd, "ON %s.",
-					  fmtId(tbinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delcmd, "%s;\n",
-					  fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delcmd, "ON %s;\n",
+					  fmtQualifiedDumpable(tbinfo));
 
-	appendPQExpBuffer(labelq, "RULE %s",
+	appendPQExpBuffer(ruleprefix, "RULE %s ON",
 					  fmtId(rinfo->dobj.name));
-	appendPQExpBuffer(labelq, " ON %s",
-					  fmtId(tbinfo->dobj.name));
 
 	tag = psprintf("%s %s", tbinfo->dobj.name, rinfo->dobj.name);
 
@@ -17224,7 +16908,7 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 
 	/* Dump rule comments */
 	if (rinfo->dobj.dump & DUMP_COMPONENT_COMMENT)
-		dumpComment(fout, labelq->data,
+		dumpComment(fout, ruleprefix->data, qtabname,
 					tbinfo->dobj.namespace->dobj.name,
 					tbinfo->rolname,
 					rinfo->dobj.catId, 0, rinfo->dobj.dumpId);
@@ -17235,7 +16919,8 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(cmd);
 	destroyPQExpBuffer(delcmd);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(ruleprefix);
+	free(qtabname);
 }
 
 /*
@@ -17267,9 +16952,6 @@ getExtensionMembership(Archive *fout, ExtensionInfo extinfo[],
 	if (numExtensions == 0)
 		return;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	query = createPQExpBuffer();
 
 	/* refclassid constraint is redundant but may speed the search */
@@ -17469,9 +17151,6 @@ processExtensionTables(Archive *fout, ExtensionInfo extinfo[],
 	 * recreated after the data has been loaded.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	query = createPQExpBuffer();
 
 	printfPQExpBuffer(query,
@@ -17543,9 +17222,6 @@ getDependencies(Archive *fout)
 	if (g_verbose)
 		write_msg(NULL, "reading dependency data\n");
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	query = createPQExpBuffer();
 
 	/*
@@ -17868,50 +17544,14 @@ findDumpableDependencies(ArchiveHandle *AH, DumpableObject *dobj,
 }
 
 
-/*
- * selectSourceSchema - make the specified schema the active search path
- * in the source database.
- *
- * NB: pg_catalog is explicitly searched after the specified schema;
- * so user names are only qualified if they are cross-schema references,
- * and system names are only qualified if they conflict with a user name
- * in the current schema.
- *
- * Whenever the selected schema is not pg_catalog, be careful to qualify
- * references to system catalogs and types in our emitted commands!
- *
- * This function is called only from selectSourceSchemaOnAH and
- * selectSourceSchema.
- */
-static void
-selectSourceSchema(Archive *fout, const char *schemaName)
-{
-	PQExpBuffer query;
-
-	/* This is checked by the callers already */
-	Assert(schemaName != NULL && *schemaName != '\0');
-
-	/* Not relevant if fetching from pre-7.3 DB */
-	if (fout->remoteVersion < 70300)
-		return;
-
-	query = createPQExpBuffer();
-	appendPQExpBuffer(query, "SET search_path = %s",
-					  fmtId(schemaName));
-	if (strcmp(schemaName, "pg_catalog") != 0)
-		appendPQExpBufferStr(query, ", pg_catalog");
-
-	ExecuteSqlStatement(fout, query->data);
-
-	destroyPQExpBuffer(query);
-}
-
 /*
  * getFormattedTypeName - retrieve a nicely-formatted type name for the
- * given type name.
+ * given type OID.
+ *
+ * This does not guarantee to schema-qualify the output, so it should not
+ * be used to create the target object name for CREATE or ALTER commands.
  *
- * NB: in 7.3 and up the result may depend on the currently-selected
- * schema; this is why we don't try to cache the names.
+ * TODO: there might be some value in caching the results.
  */
 static char *
 getFormattedTypeName(Archive *fout, Oid oid, OidOptions opts)
diff --git a/src/bin/pg_dump/pg_dumpall.c b/src/bin/pg_dump/pg_dumpall.c
index 003a6704c6..9436b87ec7 100644
--- a/src/bin/pg_dump/pg_dumpall.c
+++ b/src/bin/pg_dump/pg_dumpall.c
@@ -52,9 +52,10 @@ static void dumpDatabases(PGconn *conn);
 static void dumpTimestamp(const char *msg);
 
 static int	runPgDump(const char *dbname);
-static void buildShSecLabels(PGconn *conn, const char *catalog_name,
-				 uint32 objectId, PQExpBuffer buffer,
-				 const char *target, const char *objname);
+static void buildShSecLabels(PGconn *conn,
+				 const char *catalog_name, Oid objectId,
+				 const char *objtype, const char *objname,
+				 PQExpBuffer buffer);
 static PGconn *connectDatabase(const char *dbname, const char *connstr, const char *pghost, const char *pgport,
 		   const char *pguser, trivalue prompt_password, bool fail_on_error);
 static char *constructConnStr(const char **keywords, const char **values);
@@ -877,7 +878,8 @@ dumpRoles(PGconn *conn)
 
 		if (!no_security_labels && server_version >= 90200)
 			buildShSecLabels(conn, "pg_authid", auth_oid,
-							 buf, "ROLE", rolename);
+							 "ROLE", rolename,
+							 buf);
 
 		fprintf(OPF, "%s", buf->data);
 	}
@@ -1138,7 +1140,7 @@ dumpTablespaces(PGconn *conn)
 	for (i = 0; i < PQntuples(res); i++)
 	{
 		PQExpBuffer buf = createPQExpBuffer();
-		uint32		spcoid = atooid(PQgetvalue(res, i, 0));
+		Oid			spcoid = atooid(PQgetvalue(res, i, 0));
 		char	   *spcname = PQgetvalue(res, i, 1);
 		char	   *spcowner = PQgetvalue(res, i, 2);
 		char	   *spclocation = PQgetvalue(res, i, 3);
@@ -1163,11 +1165,12 @@ dumpTablespaces(PGconn *conn)
 							  fspcname, spcoptions);
 
 		if (!skip_acls &&
-			!buildACLCommands(fspcname, NULL, "TABLESPACE", spcacl, rspcacl,
+			!buildACLCommands(fspcname, NULL, NULL, "TABLESPACE",
+							  spcacl, rspcacl,
 							  spcowner, "", server_version, buf))
 		{
 			fprintf(stderr, _("%s: could not parse ACL list (%s) for tablespace \"%s\"\n"),
-					progname, spcacl, fspcname);
+					progname, spcacl, spcname);
 			PQfinish(conn);
 			exit_nicely(1);
 		}
@@ -1181,7 +1184,8 @@ dumpTablespaces(PGconn *conn)
 
 		if (!no_security_labels && server_version >= 90200)
 			buildShSecLabels(conn, "pg_tablespace", spcoid,
-							 buf, "TABLESPACE", fspcname);
+							 "TABLESPACE", spcname,
+							 buf);
 
 		fprintf(OPF, "%s", buf->data);
 
@@ -1530,7 +1534,7 @@ dumpCreateDB(PGconn *conn)
 		}
 
 		if (!skip_acls &&
-			!buildACLCommands(fdbname, NULL, "DATABASE",
+			!buildACLCommands(fdbname, NULL, NULL, "DATABASE",
 							  dbacl, rdbacl, dbowner,
 							  "", server_version, buf))
 		{
@@ -1848,19 +1852,23 @@ runPgDump(const char *dbname)
  *
  * Build SECURITY LABEL command(s) for a shared object
  *
- * The caller has to provide object type and identifier to select security
- * labels from pg_seclabels system view.
+ * The caller has to provide object type and identity in two separate formats:
+ * catalog_name (e.g., "pg_database") and object OID, as well as
+ * type name (e.g., "DATABASE") and object name (not pre-quoted).
+ *
+ * The command(s) are appended to "buffer".
  */
 static void
-buildShSecLabels(PGconn *conn, const char *catalog_name, uint32 objectId,
-				 PQExpBuffer buffer, const char *target, const char *objname)
+buildShSecLabels(PGconn *conn, const char *catalog_name, Oid objectId,
+				 const char *objtype, const char *objname,
+				 PQExpBuffer buffer)
 {
 	PQExpBuffer sql = createPQExpBuffer();
 	PGresult   *res;
 
 	buildShSecLabelQuery(conn, catalog_name, objectId, sql);
 	res = executeQuery(conn, sql->data);
-	emitShSecLabels(conn, res, buffer, target, objname);
+	emitShSecLabels(conn, res, buffer, objtype, objname);
 
 	PQclear(res);
 	destroyPQExpBuffer(sql);
diff --git a/src/bin/pg_dump/t/002_pg_dump.pl b/src/bin/pg_dump/t/002_pg_dump.pl
index d5bfbc797c..e35230c40a 100644
--- a/src/bin/pg_dump/t/002_pg_dump.pl
+++ b/src/bin/pg_dump/t/002_pg_dump.pl
@@ -363,7 +363,7 @@ my %tests = (
 			test_schema_plus_blobs => 1, }, },
 	'ALTER SEQUENCE test_table_col1_seq' => {
 		regexp => qr/^
-			\QALTER SEQUENCE test_table_col1_seq OWNED BY test_table.col1;\E
+			\QALTER SEQUENCE dump_test.test_table_col1_seq OWNED BY dump_test.test_table.col1;\E
 			/xm,
 		like => {
 			binary_upgrade          => 1,
@@ -388,7 +388,7 @@ my %tests = (
 			section_post_data        => 1, }, },
 	'ALTER SEQUENCE test_third_table_col1_seq' => {
 		regexp => qr/^
-			\QALTER SEQUENCE test_third_table_col1_seq OWNED BY test_third_table.col1;\E
+			\QALTER SEQUENCE dump_test_second_schema.test_third_table_col1_seq OWNED BY dump_test_second_schema.test_third_table.col1;\E
 			/xm,
 		like => {
 			binary_upgrade           => 1,
@@ -413,7 +413,7 @@ my %tests = (
 			test_schema_plus_blobs   => 1, }, },
 	'ALTER TABLE ONLY test_table ADD CONSTRAINT ... PRIMARY KEY' => {
 		regexp => qr/^
-			\QALTER TABLE ONLY test_table\E \n^\s+
+			\QALTER TABLE ONLY dump_test.test_table\E \n^\s+
 			\QADD CONSTRAINT test_table_pkey PRIMARY KEY (col1);\E
 			/xm,
 		like => {
@@ -436,7 +436,7 @@ my %tests = (
 			section_pre_data         => 1,
 			section_data             => 1, }, },
 	'ALTER TABLE test_table OWNER TO' => {
-		regexp => qr/^ALTER TABLE test_table OWNER TO .*;/m,
+		regexp => qr/^ALTER TABLE dump_test.test_table OWNER TO .*;/m,
 		like   => {
 			binary_upgrade          => 1,
 			clean                   => 1,
@@ -458,7 +458,7 @@ my %tests = (
 		create_order => 23,
 		create_sql   => 'ALTER TABLE dump_test.test_table
 					   ENABLE ROW LEVEL SECURITY;',
-		regexp => qr/^ALTER TABLE test_table ENABLE ROW LEVEL SECURITY;/m,
+		regexp => qr/^ALTER TABLE dump_test.test_table ENABLE ROW LEVEL SECURITY;/m,
 		like   => {
 			binary_upgrade          => 1,
 			clean                   => 1,
@@ -478,7 +478,7 @@ my %tests = (
 			exclude_dump_test_schema => 1,
 			exclude_test_table       => 1, }, },
 	'ALTER TABLE test_second_table OWNER TO' => {
-		regexp => qr/^ALTER TABLE test_second_table OWNER TO .*;/m,
+		regexp => qr/^ALTER TABLE dump_test.test_second_table OWNER TO .*;/m,
 		like   => {
 			binary_upgrade          => 1,
 			clean                   => 1,
@@ -497,7 +497,7 @@ my %tests = (
 			exclude_dump_test_schema => 1,
 			only_dump_test_table     => 1, }, },
 	'ALTER TABLE test_third_table OWNER TO' => {
-		regexp => qr/^ALTER TABLE test_third_table OWNER TO .*;/m,
+		regexp => qr/^ALTER TABLE dump_test_second_schema.test_third_table OWNER TO .*;/m,
 		like   => {
 			binary_upgrade           => 1,
 			clean                    => 1,
@@ -623,7 +623,7 @@ my %tests = (
 		create_order => 36,
 		create_sql   => 'COMMENT ON TABLE dump_test.test_table
 					   IS \'comment on table\';',
-		regexp => qr/^COMMENT ON TABLE test_table IS 'comment on table';/m,
+		regexp => qr/^COMMENT ON TABLE dump_test.test_table IS 'comment on table';/m,
 		like   => {
 			binary_upgrade          => 1,
 			clean                   => 1,
@@ -646,7 +646,7 @@ my %tests = (
 		create_sql   => 'COMMENT ON COLUMN dump_test.test_table.col1
 					   IS \'comment on column\';',
 		regexp => qr/^
-			\QCOMMENT ON COLUMN test_table.col1 IS 'comment on column';\E
+			\QCOMMENT ON COLUMN dump_test.test_table.col1 IS 'comment on column';\E
 			/xm,
 		like => {
 			binary_upgrade          => 1,
@@ -670,7 +670,7 @@ my %tests = (
 		create_sql   => 'COMMENT ON COLUMN dump_test.composite.f1
 					   IS \'comment on column of type\';',
 		regexp => qr/^
-			\QCOMMENT ON COLUMN composite.f1 IS 'comment on column of type';\E
+			\QCOMMENT ON COLUMN dump_test.composite.f1 IS 'comment on column of type';\E
 			/xm,
 		like => {
 			binary_upgrade          => 1,
@@ -706,7 +706,7 @@ my %tests = (
 		create_sql   => 'INSERT INTO dump_test.test_table (col1) '
 		  . 'SELECT generate_series FROM generate_series(1,9);',
 		regexp => qr/^
-			\QCOPY test_table (col1) FROM stdin;\E
+			\QCOPY dump_test.test_table (col1) FROM stdin;\E
 			\n(?:\d\n){9}\\\.\n
 			/xm,
 		like => {
@@ -731,7 +731,7 @@ my %tests = (
 		create_sql => 'INSERT INTO dump_test.fk_reference_test_table (col1) '
 		  . 'SELECT generate_series FROM generate_series(1,5);',
 		regexp => qr/^
-			\QCOPY fk_reference_test_table (col1) FROM stdin;\E
+			\QCOPY dump_test.fk_reference_test_table (col1) FROM stdin;\E
 			\n(?:\d\n){5}\\\.\n
 			/xm,
 		like => {
@@ -753,9 +753,9 @@ my %tests = (
 			only_dump_test_table     => 1, }, },
 	'COPY fk_reference_test_table second' => {
 		regexp => qr/^
-			\QCOPY test_table (col1) FROM stdin;\E
+			\QCOPY dump_test.test_table (col1) FROM stdin;\E
 			\n(?:\d\n){9}\\\.\n.*
-			\QCOPY fk_reference_test_table (col1) FROM stdin;\E
+			\QCOPY dump_test.fk_reference_test_table (col1) FROM stdin;\E
 			\n(?:\d\n){5}\\\.\n
 			/xms,
 		like   => { data_only => 1, },
@@ -769,7 +769,7 @@ my %tests = (
 		  . 'SELECT generate_series, generate_series::text '
 		  . 'FROM generate_series(1,9);',
 		regexp => qr/^
-			\QCOPY test_second_table (col1, col2) FROM stdin;\E
+			\QCOPY dump_test.test_second_table (col1, col2) FROM stdin;\E
 			\n(?:\d\t\d\n){9}\\\.\n
 			/xm,
 		like => {
@@ -795,7 +795,7 @@ my %tests = (
 		  'INSERT INTO dump_test_second_schema.test_third_table (col1) '
 		  . 'SELECT generate_series FROM generate_series(1,9);',
 		regexp => qr/^
-			\QCOPY test_third_table (col1) FROM stdin;\E
+			\QCOPY dump_test_second_schema.test_third_table (col1) FROM stdin;\E
 			\n(?:\d\n){9}\\\.\n
 			/xm,
 		like => {
@@ -817,7 +817,7 @@ my %tests = (
 			test_schema_plus_blobs => 1, }, },
 	'INSERT INTO test_table' => {
 		regexp => qr/^
-			(?:INSERT\ INTO\ test_table\ \(col1\)\ VALUES\ \(\d\);\n){9}
+			(?:INSERT\ INTO\ dump_test.test_table\ \(col1\)\ VALUES\ \(\d\);\n){9}
 			/xm,
 		like   => { column_inserts => 1, },
 		unlike => {
@@ -838,7 +838,7 @@ my %tests = (
 			test_schema_plus_blobs   => 1, }, },
 	'INSERT INTO test_second_table' => {
 		regexp => qr/^
-			(?:INSERT\ INTO\ test_second_table\ \(col1,\ col2\)
+			(?:INSERT\ INTO\ dump_test.test_second_table\ \(col1,\ col2\)
 			   \ VALUES\ \(\d,\ '\d'\);\n){9}/xm,
 		like   => { column_inserts => 1, },
 		unlike => {
@@ -859,7 +859,7 @@ my %tests = (
 			test_schema_plus_blobs   => 1, }, },
 	'INSERT INTO test_third_table' => {
 		regexp => qr/^
-			(?:INSERT\ INTO\ test_third_table\ \(col1\)
+			(?:INSERT\ INTO\ dump_test_second_schema.test_third_table\ \(col1\)
 			   \ VALUES\ \(\d\);\n){9}/xm,
 		like   => { column_inserts => 1, },
 		unlike => {
@@ -1024,7 +1024,7 @@ my %tests = (
 						  initcond1 = \'{0,0}\'
 					   );',
 		regexp => qr/^
-			\QCREATE AGGREGATE newavg(integer) (\E
+			\QCREATE AGGREGATE dump_test.newavg(integer) (\E
 			\n\s+\QSFUNC = int4_avg_accum,\E
 			\n\s+\QSTYPE = bigint[],\E
 			\n\s+\QINITCOND = '{0,0}',\E
@@ -1057,7 +1057,7 @@ my %tests = (
 					   CHECK(VALUE ~ \'^\d{5}$\' OR
 							 VALUE ~ \'^\d{5}-\d{4}$\');',
 		regexp => qr/^
-			\QCREATE DOMAIN us_postal_code AS text\E
+			\QCREATE DOMAIN dump_test.us_postal_code AS text\E
 			\n\s+
 			\QCONSTRAINT us_postal_code_check CHECK \E
 			\Q(((VALUE ~ '^\d{5}\E
@@ -1091,7 +1091,7 @@ my %tests = (
 					   RETURNS LANGUAGE_HANDLER AS \'$libdir/plpgsql\',
 					   \'plpgsql_call_handler\' LANGUAGE C;',
 		regexp => qr/^
-			\QCREATE FUNCTION pltestlang_call_handler() \E
+			\QCREATE FUNCTION dump_test.pltestlang_call_handler() \E
 			\QRETURNS language_handler\E
 			\n\s+\QLANGUAGE c\E
 			\n\s+AS\ \'\$
@@ -1124,7 +1124,7 @@ my %tests = (
 					   RETURNS trigger LANGUAGE plpgsql
 					   AS $$ BEGIN RETURN NULL; END;$$;',
 		regexp => qr/^
-			\QCREATE FUNCTION trigger_func() RETURNS trigger\E
+			\QCREATE FUNCTION dump_test.trigger_func() RETURNS trigger\E
 			\n\s+\QLANGUAGE plpgsql\E
 			\n\s+AS\ \$\$
 			\Q BEGIN RETURN NULL; END;\E
@@ -1156,7 +1156,7 @@ my %tests = (
 					   RETURNS event_trigger LANGUAGE plpgsql
 					   AS $$ BEGIN RETURN; END;$$;',
 		regexp => qr/^
-			\QCREATE FUNCTION event_trigger_func() RETURNS event_trigger\E
+			\QCREATE FUNCTION dump_test.event_trigger_func() RETURNS event_trigger\E
 			\n\s+\QLANGUAGE plpgsql\E
 			\n\s+AS\ \$\$
 			\Q BEGIN RETURN; END;\E
@@ -1220,9 +1220,9 @@ my %tests = (
 					   FOR EACH ROW WHEN (NEW.col1 > 10)
 					   EXECUTE PROCEDURE dump_test.trigger_func();',
 		regexp => qr/^
-			\QCREATE TRIGGER test_trigger BEFORE INSERT ON test_table \E
+			\QCREATE TRIGGER test_trigger BEFORE INSERT ON dump_test.test_table \E
 			\QFOR EACH ROW WHEN ((new.col1 > 10)) \E
-			\QEXECUTE PROCEDURE trigger_func();\E
+			\QEXECUTE PROCEDURE dump_test.trigger_func();\E
 			/xm,
 		like => {
 			binary_upgrade          => 1,
@@ -1250,7 +1250,7 @@ my %tests = (
 		create_sql   => 'CREATE TYPE dump_test.planets
 					   AS ENUM ( \'venus\', \'earth\', \'mars\' );',
 		regexp => qr/^
-			\QCREATE TYPE planets AS ENUM (\E
+			\QCREATE TYPE dump_test.planets AS ENUM (\E
 			\n\s+'venus',
 			\n\s+'earth',
 			\n\s+'mars'
@@ -1277,7 +1277,7 @@ my %tests = (
 			section_post_data        => 1, }, },
 	'CREATE TYPE dump_test.planets AS ENUM pg_upgrade' => {
 		regexp => qr/^
-			\QCREATE TYPE planets AS ENUM (\E
+			\QCREATE TYPE dump_test.planets AS ENUM (\E
 			\n\);.*^
 			\QALTER TYPE dump_test.planets ADD VALUE 'venus';\E
 			\n.*^
@@ -1310,7 +1310,7 @@ my %tests = (
 		create_sql   => 'CREATE TYPE dump_test.textrange
 					   AS RANGE (subtype=text, collation="C");',
 		regexp => qr/^
-			\QCREATE TYPE textrange AS RANGE (\E
+			\QCREATE TYPE dump_test.textrange AS RANGE (\E
 			\n\s+\Qsubtype = text,\E
 			\n\s+\Qcollation = pg_catalog."C"\E
 			\n\);/xm,
@@ -1337,7 +1337,7 @@ my %tests = (
 	'CREATE TYPE dump_test.int42' => {
 		create_order => 39,
 		create_sql   => 'CREATE TYPE dump_test.int42;',
-		regexp       => qr/^CREATE TYPE int42;/m,
+		regexp       => qr/^CREATE TYPE dump_test.int42;/m,
 		like         => {
 			clean                   => 1,
 			clean_if_exists         => 1,
@@ -1364,7 +1364,7 @@ my %tests = (
 					   RETURNS dump_test.int42 AS \'int4in\'
 					   LANGUAGE internal STRICT IMMUTABLE;',
 		regexp => qr/^
-			\QCREATE FUNCTION int42_in(cstring) RETURNS int42\E
+			\QCREATE FUNCTION dump_test.int42_in(cstring) RETURNS dump_test.int42\E
 			\n\s+\QLANGUAGE internal IMMUTABLE STRICT\E
 			\n\s+AS\ \$\$int4in\$\$;
 			/xm,
@@ -1395,7 +1395,7 @@ my %tests = (
 					   RETURNS cstring AS \'int4out\'
 					   LANGUAGE internal STRICT IMMUTABLE;',
 		regexp => qr/^
-			\QCREATE FUNCTION int42_out(int42) RETURNS cstring\E
+			\QCREATE FUNCTION dump_test.int42_out(dump_test.int42) RETURNS cstring\E
 			\n\s+\QLANGUAGE internal IMMUTABLE STRICT\E
 			\n\s+AS\ \$\$int4out\$\$;
 			/xm,
@@ -1430,10 +1430,10 @@ my %tests = (
 						   default = 42,
 						   passedbyvalue);',
 		regexp => qr/^
-			\QCREATE TYPE int42 (\E
+			\QCREATE TYPE dump_test.int42 (\E
 			\n\s+\QINTERNALLENGTH = 4,\E
-			\n\s+\QINPUT = int42_in,\E
-			\n\s+\QOUTPUT = int42_out,\E
+			\n\s+\QINPUT = dump_test.int42_in,\E
+			\n\s+\QOUTPUT = dump_test.int42_out,\E
 			\n\s+\QDEFAULT = '42',\E
 			\n\s+\QALIGNMENT = int4,\E
 			\n\s+\QSTORAGE = plain,\E
@@ -1466,9 +1466,9 @@ my %tests = (
 						   f2 dump_test.int42
 					   );',
 		regexp => qr/^
-			\QCREATE TYPE composite AS (\E
+			\QCREATE TYPE dump_test.composite AS (\E
 			\n\s+\Qf1 integer,\E
-			\n\s+\Qf2 int42\E
+			\n\s+\Qf2 dump_test.int42\E
 			\n\);
 			/xm,
 		like => {
@@ -1572,7 +1572,7 @@ my %tests = (
 					   HANDLER dump_test.pltestlang_call_handler;',
 		regexp => qr/^
 			\QCREATE PROCEDURAL LANGUAGE pltestlang \E
-			\QHANDLER pltestlang_call_handler;\E
+			\QHANDLER dump_test.pltestlang_call_handler;\E
 			/xm,
 		like => {
 			binary_upgrade          => 1,
@@ -1600,9 +1600,9 @@ my %tests = (
 		create_sql   => 'CREATE MATERIALIZED VIEW dump_test.matview (col1) AS
 					   SELECT * FROM dump_test.test_table;',
 		regexp => qr/^
-			\QCREATE MATERIALIZED VIEW matview AS\E
+			\QCREATE MATERIALIZED VIEW dump_test.matview AS\E
 			\n\s+\QSELECT test_table.col1\E
-			\n\s+\QFROM test_table\E
+			\n\s+\QFROM dump_test.test_table\E
 			\n\s+\QWITH NO DATA;\E
 			/xm,
 		like => {
@@ -1632,9 +1632,9 @@ my %tests = (
 						   dump_test.matview_second (col1) AS
 						   SELECT * FROM dump_test.matview;',
 		regexp => qr/^
-			\QCREATE MATERIALIZED VIEW matview_second AS\E
+			\QCREATE MATERIALIZED VIEW dump_test.matview_second AS\E
 			\n\s+\QSELECT matview.col1\E
-			\n\s+\QFROM matview\E
+			\n\s+\QFROM dump_test.matview\E
 			\n\s+\QWITH NO DATA;\E
 			/xm,
 		like => {
@@ -1664,7 +1664,7 @@ my %tests = (
 						   USING (true)
 						   WITH CHECK (true);',
 		regexp => qr/^
-			\QCREATE POLICY p1 ON test_table FOR ALL TO PUBLIC \E
+			\QCREATE POLICY p1 ON dump_test.test_table FOR ALL TO PUBLIC \E
 			\QUSING (true) WITH CHECK (true);\E
 			/xm,
 		like => {
@@ -1693,7 +1693,7 @@ my %tests = (
 		create_sql   => 'CREATE POLICY p2 ON dump_test.test_table
 						   FOR SELECT TO regress_dump_test_role USING (true);',
 		regexp => qr/^
-			\QCREATE POLICY p2 ON test_table FOR SELECT TO regress_dump_test_role \E
+			\QCREATE POLICY p2 ON dump_test.test_table FOR SELECT TO regress_dump_test_role \E
 			\QUSING (true);\E
 			/xm,
 		like => {
@@ -1722,7 +1722,7 @@ my %tests = (
 		create_sql   => 'CREATE POLICY p3 ON dump_test.test_table
 						   FOR INSERT TO regress_dump_test_role WITH CHECK (true);',
 		regexp => qr/^
-			\QCREATE POLICY p3 ON test_table FOR INSERT \E
+			\QCREATE POLICY p3 ON dump_test.test_table FOR INSERT \E
 			\QTO regress_dump_test_role WITH CHECK (true);\E
 			/xm,
 		like => {
@@ -1751,7 +1751,7 @@ my %tests = (
 		create_sql   => 'CREATE POLICY p4 ON dump_test.test_table FOR UPDATE
 						   TO regress_dump_test_role USING (true) WITH CHECK (true);',
 		regexp => qr/^
-			\QCREATE POLICY p4 ON test_table FOR UPDATE TO regress_dump_test_role \E
+			\QCREATE POLICY p4 ON dump_test.test_table FOR UPDATE TO regress_dump_test_role \E
 			\QUSING (true) WITH CHECK (true);\E
 			/xm,
 		like => {
@@ -1780,7 +1780,7 @@ my %tests = (
 		create_sql   => 'CREATE POLICY p5 ON dump_test.test_table
 						   FOR DELETE TO regress_dump_test_role USING (true);',
 		regexp => qr/^
-			\QCREATE POLICY p5 ON test_table FOR DELETE \E
+			\QCREATE POLICY p5 ON dump_test.test_table FOR DELETE \E
 			\QTO regress_dump_test_role USING (true);\E
 			/xm,
 		like => {
@@ -1861,7 +1861,7 @@ my %tests = (
 						   CHECK (col1 <= 1000)
 					   );',
 		regexp => qr/^
-			\QCREATE TABLE test_table (\E
+			\QCREATE TABLE dump_test.test_table (\E
 			\n\s+\Qcol1 integer NOT NULL,\E
 			\n\s+\QCONSTRAINT test_table_col1_check CHECK \E
 			\Q((col1 <= 1000))\E
@@ -1893,7 +1893,7 @@ my %tests = (
 						   col1 int primary key references dump_test.test_table
 					   );',
 		regexp => qr/^
-			\QCREATE TABLE fk_reference_test_table (\E
+			\QCREATE TABLE dump_test.fk_reference_test_table (\E
 			\n\s+\Qcol1 integer NOT NULL\E
 			\n\);
 			/xm,
@@ -1925,7 +1925,7 @@ my %tests = (
 						   col2 text
 					   );',
 		regexp => qr/^
-			\QCREATE TABLE test_second_table (\E
+			\QCREATE TABLE dump_test.test_second_table (\E
 			\n\s+\Qcol1 integer,\E
 			\n\s+\Qcol2 text\E
 			\n\);
@@ -1957,7 +1957,7 @@ my %tests = (
 						   col1 serial
 					   );',
 		regexp => qr/^
-			\QCREATE TABLE test_third_table (\E
+			\QCREATE TABLE dump_test_second_schema.test_third_table (\E
 			\n\s+\Qcol1 integer NOT NULL\E
 			\n\);
 			/xm,
@@ -1984,7 +1984,7 @@ my %tests = (
 			test_schema_plus_blobs   => 1, }, },
 	'CREATE SEQUENCE test_table_col1_seq' => {
 		regexp => qr/^
-			\QCREATE SEQUENCE test_table_col1_seq\E
+			\QCREATE SEQUENCE dump_test.test_table_col1_seq\E
 			\n\s+\QSTART WITH 1\E
 			\n\s+\QINCREMENT BY 1\E
 			\n\s+\QNO MINVALUE\E
@@ -2014,7 +2014,7 @@ my %tests = (
 			section_post_data        => 1, }, },
 	'CREATE SEQUENCE test_third_table_col1_seq' => {
 		regexp => qr/^
-			\QCREATE SEQUENCE test_third_table_col1_seq\E
+			\QCREATE SEQUENCE dump_test_second_schema.test_third_table_col1_seq\E
 			\n\s+\QSTART WITH 1\E
 			\n\s+\QINCREMENT BY 1\E
 			\n\s+\QNO MINVALUE\E
@@ -2048,7 +2048,7 @@ my %tests = (
 					   ON dump_test_second_schema.test_third_table (col1);',
 		regexp => qr/^
 			\QCREATE UNIQUE INDEX test_third_table_idx \E
-			\QON test_third_table USING btree (col1);\E
+			\QON dump_test_second_schema.test_third_table USING btree (col1);\E
 			/xm,
 		like => {
 			binary_upgrade           => 1,
@@ -2239,7 +2239,7 @@ my %tests = (
 		create_sql   => 'GRANT SELECT ON TABLE dump_test.test_table
 						   TO regress_dump_test_role;',
 		regexp =>
-		  qr/^GRANT SELECT ON TABLE test_table TO regress_dump_test_role;/m,
+		  qr/^GRANT SELECT ON TABLE dump_test.test_table TO regress_dump_test_role;/m,
 		like => {
 			binary_upgrade          => 1,
 			clean                   => 1,
@@ -2264,7 +2264,7 @@ my %tests = (
 						   TABLE dump_test_second_schema.test_third_table
 						   TO regress_dump_test_role;',
 		regexp =>
-qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
+qr/^GRANT SELECT ON TABLE dump_test_second_schema.test_third_table TO regress_dump_test_role;/m,
 		like => {
 			binary_upgrade           => 1,
 			clean                    => 1,
@@ -2289,7 +2289,7 @@ qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
 						   dump_test_second_schema.test_third_table_col1_seq
 						   TO regress_dump_test_role;',
 		regexp => qr/^
-			\QGRANT ALL ON SEQUENCE test_third_table_col1_seq TO regress_dump_test_role;\E
+			\QGRANT ALL ON SEQUENCE dump_test_second_schema.test_third_table_col1_seq TO regress_dump_test_role;\E
 			/xm,
 		like => {
 			binary_upgrade           => 1,
@@ -2315,7 +2315,7 @@ qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
 		  'GRANT INSERT (col1) ON TABLE dump_test.test_second_table
 						   TO regress_dump_test_role;',
 		regexp => qr/^
-			\QGRANT INSERT(col1) ON TABLE test_second_table TO regress_dump_test_role;\E
+			\QGRANT INSERT(col1) ON TABLE dump_test.test_second_table TO regress_dump_test_role;\E
 			/xm,
 		like => {
 			binary_upgrade          => 1,
@@ -2340,7 +2340,7 @@ qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
 		create_sql   => 'GRANT EXECUTE ON FUNCTION pg_sleep(float8)
 						   TO regress_dump_test_role;',
 		regexp => qr/^
-			\QGRANT ALL ON FUNCTION pg_sleep(double precision) TO regress_dump_test_role;\E
+			\QGRANT ALL ON FUNCTION pg_catalog.pg_sleep(double precision) TO regress_dump_test_role;\E
 			/xm,
 		like => {
 			binary_upgrade           => 1,
@@ -2395,37 +2395,37 @@ qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
 						   proacl
 						) ON TABLE pg_proc TO public;',
 		regexp => qr/
-		\QGRANT SELECT(tableoid) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(oid) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proname) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(pronamespace) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proowner) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(prolang) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(procost) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(prorows) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(provariadic) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(protransform) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proisagg) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proiswindow) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(prosecdef) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proleakproof) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proisstrict) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proretset) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(provolatile) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proparallel) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(pronargs) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(pronargdefaults) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(prorettype) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proargtypes) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proallargtypes) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proargmodes) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proargnames) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proargdefaults) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(protrftypes) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(prosrc) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(probin) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proconfig) ON TABLE pg_proc TO PUBLIC;\E\n.*
-		\QGRANT SELECT(proacl) ON TABLE pg_proc TO PUBLIC;\E/xms,
+		\QGRANT SELECT(tableoid) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(oid) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proname) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(pronamespace) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proowner) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(prolang) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(procost) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(prorows) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(provariadic) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(protransform) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proisagg) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proiswindow) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(prosecdef) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proleakproof) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proisstrict) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proretset) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(provolatile) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proparallel) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(pronargs) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(pronargdefaults) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(prorettype) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proargtypes) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proallargtypes) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proargmodes) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proargnames) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proargdefaults) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(protrftypes) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(prosrc) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(probin) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proconfig) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E\n.*
+		\QGRANT SELECT(proacl) ON TABLE pg_catalog.pg_proc TO PUBLIC;\E/xms,
 		like => {
 			binary_upgrade           => 1,
 			clean                    => 1,
@@ -2474,7 +2474,7 @@ qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
 			no_privs       => 1,
 			section_data   => 1, }, },
 	'REFRESH MATERIALIZED VIEW matview' => {
-		regexp => qr/^REFRESH MATERIALIZED VIEW matview;/m,
+		regexp => qr/^REFRESH MATERIALIZED VIEW dump_test.matview;/m,
 		like   => {
 			clean                   => 1,
 			clean_if_exists         => 1,
@@ -2497,9 +2497,9 @@ qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
 			section_pre_data         => 1, }, },
 	'REFRESH MATERIALIZED VIEW matview_second' => {
 		regexp => qr/^
-			\QREFRESH MATERIALIZED VIEW matview;\E
+			\QREFRESH MATERIALIZED VIEW dump_test.matview;\E
 			\n.*
-			\QREFRESH MATERIALIZED VIEW matview_second;\E
+			\QREFRESH MATERIALIZED VIEW dump_test.matview_second;\E
 			/xms,
 		like => {
 			clean                   => 1,
@@ -2549,7 +2549,7 @@ qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
 		create_sql   => 'REVOKE EXECUTE ON FUNCTION pg_sleep(float8)
 						   FROM public;',
 		regexp => qr/^
-			\QREVOKE ALL ON FUNCTION pg_sleep(double precision) FROM PUBLIC;\E
+			\QREVOKE ALL ON FUNCTION pg_catalog.pg_sleep(double precision) FROM PUBLIC;\E
 			/xm,
 		like => {
 			binary_upgrade           => 1,
@@ -2571,7 +2571,7 @@ qr/^GRANT SELECT ON TABLE test_third_table TO regress_dump_test_role;/m,
 	'REVOKE SELECT ON TABLE pg_proc FROM public' => {
 		create_order => 45,
 		create_sql   => 'REVOKE SELECT ON TABLE pg_proc FROM public;',
-		regexp       => qr/^REVOKE SELECT ON TABLE pg_proc FROM PUBLIC;/m,
+		regexp       => qr/^REVOKE SELECT ON TABLE pg_catalog.pg_proc FROM PUBLIC;/m,
 		like         => {
 			binary_upgrade           => 1,
 			clean                    => 1,
diff --git a/src/test/modules/test_pg_dump/t/001_base.pl b/src/test/modules/test_pg_dump/t/001_base.pl
index 200455cd26..85fe851d2f 100644
--- a/src/test/modules/test_pg_dump/t/001_base.pl
+++ b/src/test/modules/test_pg_dump/t/001_base.pl
@@ -184,7 +184,7 @@ my %tests = (
 		create_sql =>
 'ALTER EXTENSION test_pg_dump ADD TABLE regress_pg_dump_table_added;',
 		regexp => qr/^
-			\QCREATE TABLE regress_pg_dump_table_added (\E
+			\QCREATE TABLE public.regress_pg_dump_table_added (\E
 			\n\s+\Qcol1 integer NOT NULL,\E
 			\n\s+\Qcol2 integer\E
 			\n\);\n/xm,
@@ -240,7 +240,7 @@ my %tests = (
 
 	'CREATE SEQUENCE regress_pg_dump_table_col1_seq' => {
 		regexp => qr/^
-                    \QCREATE SEQUENCE regress_pg_dump_table_col1_seq\E
+                    \QCREATE SEQUENCE public.regress_pg_dump_table_col1_seq\E
                     \n\s+\QSTART WITH 1\E
                     \n\s+\QINCREMENT BY 1\E
                     \n\s+\QNO MINVALUE\E
@@ -265,7 +265,7 @@ my %tests = (
 		create_sql =>
 'CREATE TABLE regress_pg_dump_table_added (col1 int not null, col2 int);',
 		regexp => qr/^
-			\QCREATE TABLE regress_pg_dump_table_added (\E
+			\QCREATE TABLE public.regress_pg_dump_table_added (\E
 			\n\s+\Qcol1 integer NOT NULL,\E
 			\n\s+\Qcol2 integer\E
 			\n\);\n/xm,
@@ -284,7 +284,7 @@ my %tests = (
 
 	'CREATE SEQUENCE regress_pg_dump_seq' => {
 		regexp => qr/^
-                    \QCREATE SEQUENCE regress_pg_dump_seq\E
+                    \QCREATE SEQUENCE public.regress_pg_dump_seq\E
                     \n\s+\QSTART WITH 1\E
                     \n\s+\QINCREMENT BY 1\E
                     \n\s+\QNO MINVALUE\E
@@ -308,7 +308,7 @@ my %tests = (
 		create_order => 6,
 		create_sql   => qq{SELECT nextval('regress_seq_dumpable');},
 		regexp       => qr/^
-			\QSELECT pg_catalog.setval('regress_seq_dumpable', 1, true);\E
+			\QSELECT pg_catalog.setval('public.regress_seq_dumpable', 1, true);\E
 			\n/xm,
 		like => {
 			clean           => 1,
@@ -326,7 +326,7 @@ my %tests = (
 
 	'CREATE TABLE regress_pg_dump_table' => {
 		regexp => qr/^
-			\QCREATE TABLE regress_pg_dump_table (\E
+			\QCREATE TABLE public.regress_pg_dump_table (\E
 			\n\s+\Qcol1 integer NOT NULL,\E
 			\n\s+\Qcol2 integer\E
 			\n\);\n/xm,
@@ -384,7 +384,7 @@ my %tests = (
 		create_sql =>
 'GRANT SELECT ON regress_pg_dump_table_added TO regress_dump_test_role;',
 		regexp => qr/^
-			\QGRANT SELECT ON TABLE regress_pg_dump_table_added TO regress_dump_test_role;\E
+			\QGRANT SELECT ON TABLE public.regress_pg_dump_table_added TO regress_dump_test_role;\E
 			\n/xm,
 		like   => { binary_upgrade => 1, },
 		unlike => {
@@ -404,7 +404,7 @@ my %tests = (
 		create_sql =>
 'REVOKE SELECT ON regress_pg_dump_table_added FROM regress_dump_test_role;',
 		regexp => qr/^
-			\QREVOKE SELECT ON TABLE regress_pg_dump_table_added FROM regress_dump_test_role;\E
+			\QREVOKE SELECT ON TABLE public.regress_pg_dump_table_added FROM regress_dump_test_role;\E
 			\n/xm,
 		like => {
 			binary_upgrade   => 1,
@@ -423,7 +423,7 @@ my %tests = (
 	'GRANT SELECT ON TABLE regress_pg_dump_table' => {
 		regexp => qr/^
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\E\n
-			\QGRANT SELECT ON TABLE regress_pg_dump_table TO regress_dump_test_role;\E\n
+			\QGRANT SELECT ON TABLE public.regress_pg_dump_table TO regress_dump_test_role;\E\n
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\E
 			\n/xms,
 		like   => { binary_upgrade => 1, },
@@ -442,7 +442,7 @@ my %tests = (
 	'GRANT SELECT(col1) ON regress_pg_dump_table' => {
 		regexp => qr/^
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\E\n
-			\QGRANT SELECT(col1) ON TABLE regress_pg_dump_table TO PUBLIC;\E\n
+			\QGRANT SELECT(col1) ON TABLE public.regress_pg_dump_table TO PUBLIC;\E\n
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\E
 			\n/xms,
 		like   => { binary_upgrade => 1, },
@@ -464,7 +464,7 @@ my %tests = (
 		create_sql   => 'GRANT SELECT(col2) ON regress_pg_dump_table
 						   TO regress_dump_test_role;',
 		regexp => qr/^
-			\QGRANT SELECT(col2) ON TABLE regress_pg_dump_table TO regress_dump_test_role;\E
+			\QGRANT SELECT(col2) ON TABLE public.regress_pg_dump_table TO regress_dump_test_role;\E
 			\n/xm,
 		like => {
 			binary_upgrade   => 1,
@@ -486,7 +486,7 @@ my %tests = (
 		create_sql => 'GRANT USAGE ON SEQUENCE regress_pg_dump_table_col1_seq
 		                   TO regress_dump_test_role;',
 		regexp => qr/^
-			\QGRANT USAGE ON SEQUENCE regress_pg_dump_table_col1_seq TO regress_dump_test_role;\E
+			\QGRANT USAGE ON SEQUENCE public.regress_pg_dump_table_col1_seq TO regress_dump_test_role;\E
 			\n/xm,
 		like => {
 			binary_upgrade   => 1,
@@ -504,7 +504,7 @@ my %tests = (
 
 	'GRANT USAGE ON regress_pg_dump_seq TO regress_dump_test_role' => {
 		regexp => qr/^
-			\QGRANT USAGE ON SEQUENCE regress_pg_dump_seq TO regress_dump_test_role;\E
+			\QGRANT USAGE ON SEQUENCE public.regress_pg_dump_seq TO regress_dump_test_role;\E
 			\n/xm,
 		like   => { binary_upgrade => 1, },
 		unlike => {
@@ -524,7 +524,7 @@ my %tests = (
 		create_sql   => 'REVOKE SELECT(col1) ON regress_pg_dump_table
 						   FROM PUBLIC;',
 		regexp => qr/^
-			\QREVOKE SELECT(col1) ON TABLE regress_pg_dump_table FROM PUBLIC;\E
+			\QREVOKE SELECT(col1) ON TABLE public.regress_pg_dump_table FROM PUBLIC;\E
 			\n/xm,
 		like => {
 			binary_upgrade   => 1,
@@ -543,7 +543,7 @@ my %tests = (
  # Objects included in extension part of a schema created by this extension */
 	'CREATE TABLE regress_pg_dump_schema.test_table' => {
 		regexp => qr/^
-			\QCREATE TABLE test_table (\E
+			\QCREATE TABLE regress_pg_dump_schema.test_table (\E
 			\n\s+\Qcol1 integer,\E
 			\n\s+\Qcol2 integer\E
 			\n\);\n/xm,
@@ -563,7 +563,7 @@ my %tests = (
 	'GRANT SELECT ON regress_pg_dump_schema.test_table' => {
 		regexp => qr/^
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\E\n
-			\QGRANT SELECT ON TABLE test_table TO regress_dump_test_role;\E\n
+			\QGRANT SELECT ON TABLE regress_pg_dump_schema.test_table TO regress_dump_test_role;\E\n
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\E
 			\n/xms,
 		like   => { binary_upgrade => 1, },
@@ -581,7 +581,7 @@ my %tests = (
 
 	'CREATE SEQUENCE regress_pg_dump_schema.test_seq' => {
 		regexp => qr/^
-                    \QCREATE SEQUENCE test_seq\E
+                    \QCREATE SEQUENCE regress_pg_dump_schema.test_seq\E
                     \n\s+\QSTART WITH 1\E
                     \n\s+\QINCREMENT BY 1\E
                     \n\s+\QNO MINVALUE\E
@@ -604,7 +604,7 @@ my %tests = (
 	'GRANT USAGE ON regress_pg_dump_schema.test_seq' => {
 		regexp => qr/^
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\E\n
-			\QGRANT USAGE ON SEQUENCE test_seq TO regress_dump_test_role;\E\n
+			\QGRANT USAGE ON SEQUENCE regress_pg_dump_schema.test_seq TO regress_dump_test_role;\E\n
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\E
 			\n/xms,
 		like   => { binary_upgrade => 1, },
@@ -622,7 +622,7 @@ my %tests = (
 
 	'CREATE TYPE regress_pg_dump_schema.test_type' => {
 		regexp => qr/^
-                    \QCREATE TYPE test_type AS (\E
+                    \QCREATE TYPE regress_pg_dump_schema.test_type AS (\E
                     \n\s+\Qcol1 integer\E
                     \n\);\n/xm,
 		like   => { binary_upgrade => 1, },
@@ -641,7 +641,7 @@ my %tests = (
 	'GRANT USAGE ON regress_pg_dump_schema.test_type' => {
 		regexp => qr/^
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\E\n
-			\QGRANT ALL ON TYPE test_type TO regress_dump_test_role;\E\n
+			\QGRANT ALL ON TYPE regress_pg_dump_schema.test_type TO regress_dump_test_role;\E\n
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\E
 			\n/xms,
 		like   => { binary_upgrade => 1, },
@@ -659,7 +659,7 @@ my %tests = (
 
 	'CREATE FUNCTION regress_pg_dump_schema.test_func' => {
 		regexp => qr/^
-            \QCREATE FUNCTION test_func() RETURNS integer\E
+            \QCREATE FUNCTION regress_pg_dump_schema.test_func() RETURNS integer\E
             \n\s+\QLANGUAGE sql\E
             \n/xm,
 		like   => { binary_upgrade => 1, },
@@ -678,7 +678,7 @@ my %tests = (
 	'GRANT ALL ON regress_pg_dump_schema.test_func' => {
 		regexp => qr/^
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\E\n
-			\QGRANT ALL ON FUNCTION test_func() TO regress_dump_test_role;\E\n
+			\QGRANT ALL ON FUNCTION regress_pg_dump_schema.test_func() TO regress_dump_test_role;\E\n
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\E
 			\n/xms,
 		like   => { binary_upgrade => 1, },
@@ -696,7 +696,7 @@ my %tests = (
 
 	'CREATE AGGREGATE regress_pg_dump_schema.test_agg' => {
 		regexp => qr/^
-            \QCREATE AGGREGATE test_agg(smallint) (\E
+            \QCREATE AGGREGATE regress_pg_dump_schema.test_agg(smallint) (\E
             \n\s+\QSFUNC = int2_sum,\E
             \n\s+\QSTYPE = bigint\E
             \n\);\n/xm,
@@ -716,7 +716,7 @@ my %tests = (
 	'GRANT ALL ON regress_pg_dump_schema.test_agg' => {
 		regexp => qr/^
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\E\n
-			\QGRANT ALL ON FUNCTION test_agg(smallint) TO regress_dump_test_role;\E\n
+			\QGRANT ALL ON FUNCTION regress_pg_dump_schema.test_agg(smallint) TO regress_dump_test_role;\E\n
 			\QSELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\E
 			\n/xms,
 		like   => { binary_upgrade => 1, },
@@ -738,7 +738,7 @@ my %tests = (
 		create_sql   => 'CREATE TABLE regress_pg_dump_schema.external_tab
 						   (col1 int);',
 		regexp => qr/^
-			\QCREATE TABLE external_tab (\E
+			\QCREATE TABLE regress_pg_dump_schema.external_tab (\E
 			\n\s+\Qcol1 integer\E
 			\n\);\n/xm,
 		like => {
diff --git a/src/test/regress/expected/collate.linux.utf8.out b/src/test/regress/expected/collate.linux.utf8.out
index 495e4ad448..1e435ce44a 100644
--- a/src/test/regress/expected/collate.linux.utf8.out
+++ b/src/test/regress/expected/collate.linux.utf8.out
@@ -943,12 +943,12 @@ ERROR:  collations are not supported by type integer
 LINE 1: ...ATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "C...
                                                              ^
 SELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
-      relname       |                                           pg_get_indexdef                                           
---------------------+-----------------------------------------------------------------------------------------------------
- collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_test1 USING btree (b)
- collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_test1 USING btree (b COLLATE "C")
- collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_test1 USING btree (b COLLATE "C")
- collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
+      relname       |                                              pg_get_indexdef                                               
+--------------------+------------------------------------------------------------------------------------------------------------
+ collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON public.collate_test1 USING btree (b)
+ collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON public.collate_test1 USING btree (b COLLATE "C")
+ collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON public.collate_test1 USING btree (b COLLATE "C")
+ collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON public.collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
 (4 rows)
 
 -- schema manipulation commands
diff --git a/src/test/regress/expected/collate.out b/src/test/regress/expected/collate.out
index f076a4dbae..5a94edcade 100644
--- a/src/test/regress/expected/collate.out
+++ b/src/test/regress/expected/collate.out
@@ -572,12 +572,12 @@ ERROR:  collations are not supported by type integer
 LINE 1: ...ATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "P...
                                                              ^
 SELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
-      relname       |                                           pg_get_indexdef                                           
---------------------+-----------------------------------------------------------------------------------------------------
- collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_test1 USING btree (b)
- collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_test1 USING btree (b COLLATE "POSIX")
- collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_test1 USING btree (b COLLATE "POSIX")
- collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
+      relname       |                                                  pg_get_indexdef                                                  
+--------------------+-------------------------------------------------------------------------------------------------------------------
+ collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_tests.collate_test1 USING btree (b)
+ collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_tests.collate_test1 USING btree (b COLLATE "POSIX")
+ collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_tests.collate_test1 USING btree (b COLLATE "POSIX")
+ collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_tests.collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
 (4 rows)
 
 -- foreign keys
diff --git a/src/test/regress/expected/rules.out b/src/test/regress/expected/rules.out
index e827e4b912..4be33aac84 100644
--- a/src/test/regress/expected/rules.out
+++ b/src/test/regress/expected/rules.out
@@ -2265,103 +2265,103 @@ toyemp| SELECT emp.name,
 SELECT tablename, rulename, definition FROM pg_rules
 	ORDER BY tablename, rulename;
 pg_settings|pg_settings_n|CREATE RULE pg_settings_n AS
-    ON UPDATE TO pg_settings DO INSTEAD NOTHING;
+    ON UPDATE TO pg_catalog.pg_settings DO INSTEAD NOTHING;
 pg_settings|pg_settings_u|CREATE RULE pg_settings_u AS
-    ON UPDATE TO pg_settings
+    ON UPDATE TO pg_catalog.pg_settings
    WHERE (new.name = old.name) DO  SELECT set_config(old.name, new.setting, false) AS set_config;
 rtest_emp|rtest_emp_del|CREATE RULE rtest_emp_del AS
-    ON DELETE TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
+    ON DELETE TO public.rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
   VALUES (old.ename, "current_user"(), 'fired'::bpchar, '$0.00'::money, old.salary);
 rtest_emp|rtest_emp_ins|CREATE RULE rtest_emp_ins AS
-    ON INSERT TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
+    ON INSERT TO public.rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
   VALUES (new.ename, "current_user"(), 'hired'::bpchar, new.salary, '$0.00'::money);
 rtest_emp|rtest_emp_upd|CREATE RULE rtest_emp_upd AS
-    ON UPDATE TO rtest_emp
+    ON UPDATE TO public.rtest_emp
    WHERE (new.salary <> old.salary) DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)
   VALUES (new.ename, "current_user"(), 'honored'::bpchar, new.salary, old.salary);
 rtest_nothn1|rtest_nothn_r1|CREATE RULE rtest_nothn_r1 AS
-    ON INSERT TO rtest_nothn1
+    ON INSERT TO public.rtest_nothn1
    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD NOTHING;
 rtest_nothn1|rtest_nothn_r2|CREATE RULE rtest_nothn_r2 AS
-    ON INSERT TO rtest_nothn1
+    ON INSERT TO public.rtest_nothn1
    WHERE ((new.a >= 30) AND (new.a < 40)) DO INSTEAD NOTHING;
 rtest_nothn2|rtest_nothn_r3|CREATE RULE rtest_nothn_r3 AS
-    ON INSERT TO rtest_nothn2
+    ON INSERT TO public.rtest_nothn2
    WHERE (new.a >= 100) DO INSTEAD  INSERT INTO rtest_nothn3 (a, b)
   VALUES (new.a, new.b);
 rtest_nothn2|rtest_nothn_r4|CREATE RULE rtest_nothn_r4 AS
-    ON INSERT TO rtest_nothn2 DO INSTEAD NOTHING;
+    ON INSERT TO public.rtest_nothn2 DO INSTEAD NOTHING;
 rtest_order1|rtest_order_r1|CREATE RULE rtest_order_r1 AS
-    ON INSERT TO rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
+    ON INSERT TO public.rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 1 - this should run 1st'::text);
 rtest_order1|rtest_order_r2|CREATE RULE rtest_order_r2 AS
-    ON INSERT TO rtest_order1 DO  INSERT INTO rtest_order2 (a, b, c)
+    ON INSERT TO public.rtest_order1 DO  INSERT INTO rtest_order2 (a, b, c)
   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 2 - this should run 2nd'::text);
 rtest_order1|rtest_order_r3|CREATE RULE rtest_order_r3 AS
-    ON INSERT TO rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
+    ON INSERT TO public.rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 3 - this should run 3rd'::text);
 rtest_order1|rtest_order_r4|CREATE RULE rtest_order_r4 AS
-    ON INSERT TO rtest_order1
+    ON INSERT TO public.rtest_order1
    WHERE (new.a < 100) DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)
   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 4 - this should run 4th'::text);
 rtest_person|rtest_pers_del|CREATE RULE rtest_pers_del AS
-    ON DELETE TO rtest_person DO  DELETE FROM rtest_admin
+    ON DELETE TO public.rtest_person DO  DELETE FROM rtest_admin
   WHERE (rtest_admin.pname = old.pname);
 rtest_person|rtest_pers_upd|CREATE RULE rtest_pers_upd AS
-    ON UPDATE TO rtest_person DO  UPDATE rtest_admin SET pname = new.pname
+    ON UPDATE TO public.rtest_person DO  UPDATE rtest_admin SET pname = new.pname
   WHERE (rtest_admin.pname = old.pname);
 rtest_system|rtest_sys_del|CREATE RULE rtest_sys_del AS
-    ON DELETE TO rtest_system DO ( DELETE FROM rtest_interface
+    ON DELETE TO public.rtest_system DO ( DELETE FROM rtest_interface
   WHERE (rtest_interface.sysname = old.sysname);
  DELETE FROM rtest_admin
   WHERE (rtest_admin.sysname = old.sysname);
 );
 rtest_system|rtest_sys_upd|CREATE RULE rtest_sys_upd AS
-    ON UPDATE TO rtest_system DO ( UPDATE rtest_interface SET sysname = new.sysname
+    ON UPDATE TO public.rtest_system DO ( UPDATE rtest_interface SET sysname = new.sysname
   WHERE (rtest_interface.sysname = old.sysname);
  UPDATE rtest_admin SET sysname = new.sysname
   WHERE (rtest_admin.sysname = old.sysname);
 );
 rtest_t4|rtest_t4_ins1|CREATE RULE rtest_t4_ins1 AS
-    ON INSERT TO rtest_t4
+    ON INSERT TO public.rtest_t4
    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD  INSERT INTO rtest_t5 (a, b)
   VALUES (new.a, new.b);
 rtest_t4|rtest_t4_ins2|CREATE RULE rtest_t4_ins2 AS
-    ON INSERT TO rtest_t4
+    ON INSERT TO public.rtest_t4
    WHERE ((new.a >= 20) AND (new.a < 30)) DO  INSERT INTO rtest_t6 (a, b)
   VALUES (new.a, new.b);
 rtest_t5|rtest_t5_ins|CREATE RULE rtest_t5_ins AS
-    ON INSERT TO rtest_t5
+    ON INSERT TO public.rtest_t5
    WHERE (new.a > 15) DO  INSERT INTO rtest_t7 (a, b)
   VALUES (new.a, new.b);
 rtest_t6|rtest_t6_ins|CREATE RULE rtest_t6_ins AS
-    ON INSERT TO rtest_t6
+    ON INSERT TO public.rtest_t6
    WHERE (new.a > 25) DO INSTEAD  INSERT INTO rtest_t8 (a, b)
   VALUES (new.a, new.b);
 rtest_v1|rtest_v1_del|CREATE RULE rtest_v1_del AS
-    ON DELETE TO rtest_v1 DO INSTEAD  DELETE FROM rtest_t1
+    ON DELETE TO public.rtest_v1 DO INSTEAD  DELETE FROM rtest_t1
   WHERE (rtest_t1.a = old.a);
 rtest_v1|rtest_v1_ins|CREATE RULE rtest_v1_ins AS
-    ON INSERT TO rtest_v1 DO INSTEAD  INSERT INTO rtest_t1 (a, b)
+    ON INSERT TO public.rtest_v1 DO INSTEAD  INSERT INTO rtest_t1 (a, b)
   VALUES (new.a, new.b);
 rtest_v1|rtest_v1_upd|CREATE RULE rtest_v1_upd AS
-    ON UPDATE TO rtest_v1 DO INSTEAD  UPDATE rtest_t1 SET a = new.a, b = new.b
+    ON UPDATE TO public.rtest_v1 DO INSTEAD  UPDATE rtest_t1 SET a = new.a, b = new.b
   WHERE (rtest_t1.a = old.a);
 shoelace|shoelace_del|CREATE RULE shoelace_del AS
-    ON DELETE TO shoelace DO INSTEAD  DELETE FROM shoelace_data
+    ON DELETE TO public.shoelace DO INSTEAD  DELETE FROM shoelace_data
   WHERE (shoelace_data.sl_name = old.sl_name);
 shoelace|shoelace_ins|CREATE RULE shoelace_ins AS
-    ON INSERT TO shoelace DO INSTEAD  INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit)
+    ON INSERT TO public.shoelace DO INSTEAD  INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit)
   VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);
 shoelace|shoelace_upd|CREATE RULE shoelace_upd AS
-    ON UPDATE TO shoelace DO INSTEAD  UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit
+    ON UPDATE TO public.shoelace DO INSTEAD  UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit
   WHERE (shoelace_data.sl_name = old.sl_name);
 shoelace_data|log_shoelace|CREATE RULE log_shoelace AS
-    ON UPDATE TO shoelace_data
+    ON UPDATE TO public.shoelace_data
    WHERE (new.sl_avail <> old.sl_avail) DO  INSERT INTO shoelace_log (sl_name, sl_avail, log_who, log_when)
   VALUES (new.sl_name, new.sl_avail, 'Al Bundy'::name, 'Thu Jan 01 00:00:00 1970'::timestamp without time zone);
 shoelace_ok|shoelace_ok_ins|CREATE RULE shoelace_ok_ins AS
-    ON INSERT TO shoelace_ok DO INSTEAD  UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant)
+    ON INSERT TO public.shoelace_ok DO INSTEAD  UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant)
   WHERE (shoelace.sl_name = new.ok_name);
 -- restore normal output mode
 \a\t
@@ -2873,7 +2873,7 @@ SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
                                          definition                                          
 ---------------------------------------------------------------------------------------------
  CREATE RULE hat_nosert AS                                                                  +
-     ON INSERT TO hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)               +
+     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)        +
    VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name COLLATE "C" bpchar_pattern_ops)+
    WHERE (hat_color = 'green'::bpchar) DO NOTHING                                           +
    RETURNING hat_data.hat_name,                                                             +
@@ -2898,7 +2898,7 @@ SELECT tablename, rulename, definition FROM pg_rules
  tablename |  rulename  |                                         definition                                          
 -----------+------------+---------------------------------------------------------------------------------------------
  hats      | hat_nosert | CREATE RULE hat_nosert AS                                                                  +
-           |            |     ON INSERT TO hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)               +
+           |            |     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)        +
            |            |   VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name COLLATE "C" bpchar_pattern_ops)+
            |            |   WHERE (hat_color = 'green'::bpchar) DO NOTHING                                           +
            |            |   RETURNING hat_data.hat_name,                                                             +
@@ -2916,12 +2916,12 @@ CREATE RULE hat_nosert_all AS ON INSERT TO hats
         DO NOTHING
         RETURNING *;
 SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
-                                  definition                                  
-------------------------------------------------------------------------------
- CREATE RULE hat_nosert_all AS                                               +
-     ON INSERT TO hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)+
-   VALUES (new.hat_name, new.hat_color) ON CONFLICT DO NOTHING               +
-   RETURNING hat_data.hat_name,                                              +
+                                     definition                                      
+-------------------------------------------------------------------------------------
+ CREATE RULE hat_nosert_all AS                                                      +
+     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)+
+   VALUES (new.hat_name, new.hat_color) ON CONFLICT DO NOTHING                      +
+   RETURNING hat_data.hat_name,                                                     +
      hat_data.hat_color;
 (1 row)
 
@@ -2948,7 +2948,7 @@ SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
                                                                definition                                                                
 -----------------------------------------------------------------------------------------------------------------------------------------
  CREATE RULE hat_upsert AS                                                                                                              +
-     ON INSERT TO hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)                                                           +
+     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)                                                    +
    VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name) DO UPDATE SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color+
    WHERE ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))                                                   +
    RETURNING hat_data.hat_name,                                                                                                         +
@@ -2996,7 +2996,7 @@ SELECT tablename, rulename, definition FROM pg_rules
  tablename |  rulename  |                                                               definition                                                                
 -----------+------------+-----------------------------------------------------------------------------------------------------------------------------------------
  hats      | hat_upsert | CREATE RULE hat_upsert AS                                                                                                              +
-           |            |     ON INSERT TO hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)                                                           +
+           |            |     ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)                                                    +
            |            |   VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name) DO UPDATE SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color+
            |            |   WHERE ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))                                                   +
            |            |   RETURNING hat_data.hat_name,                                                                                                         +
diff --git a/src/test/regress/expected/triggers.out b/src/test/regress/expected/triggers.out
index a7bf5dc159..f343058102 100644
--- a/src/test/regress/expected/triggers.out
+++ b/src/test/regress/expected/triggers.out
@@ -391,9 +391,9 @@ SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'
 (1 row)
 
 SELECT pg_get_triggerdef(oid, false) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
-                                                              pg_get_triggerdef                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------
- CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN ((old.a <> new.a)) EXECUTE PROCEDURE trigger_func('modified_a')
+                                                                  pg_get_triggerdef                                                                  
+-----------------------------------------------------------------------------------------------------------------------------------------------------
+ CREATE TRIGGER modified_a BEFORE UPDATE OF a ON public.main_table FOR EACH ROW WHEN ((old.a <> new.a)) EXECUTE PROCEDURE trigger_func('modified_a')
 (1 row)
 
 SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_any';
@@ -421,9 +421,9 @@ FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
 CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_table
 FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
 SELECT pg_get_triggerdef(oid) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'after_upd_a_b_row_trig';
-                                                             pg_get_triggerdef                                                             
--------------------------------------------------------------------------------------------------------------------------------------------
- CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row')
+                                                                pg_get_triggerdef                                                                 
+--------------------------------------------------------------------------------------------------------------------------------------------------
+ CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON public.main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row')
 (1 row)
 
 UPDATE main_table SET a = 50;
