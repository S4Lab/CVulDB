postgres__postgres
commit f6fc72cb697295c1807d14ee5c52d2086d1864af
Author:     Heikki Linnakangas <heikki.linnakangas@iki.fi>
AuthorDate: Mon Aug 7 17:03:42 2017 +0300
Commit:     Heikki Linnakangas <heikki.linnakangas@iki.fi>
CommitDate: Mon Aug 7 17:03:49 2017 +0300

    Don't allow logging in with empty password.
    
    Some authentication methods allowed it, others did not. In the client-side,
    libpq does not even try to authenticate with an empty password, which makes
    using empty passwords hazardous: an administrator might think that an
    account with an empty password cannot be used to log in, because psql
    doesn't allow it, and not realize that a different client would in fact
    allow it. To clear that confusion and to be be consistent, disallow empty
    passwords in all authentication methods.
    
    All the authentication methods that used plaintext authentication over the
    wire, except for BSD authentication, already checked that the password
    received from the user was not empty. To avoid forgetting it in the future
    again, move the check to the recv_password_packet function. That only
    forbids using an empty password with plaintext authentication, however.
    MD5 and SCRAM need a different fix:
    
    * In stable branches, check that the MD5 hash stored for the user does not
    not correspond to an empty string. This adds some overhead to MD5
    authentication, because the server needs to compute an extra MD5 hash, but
    it is not noticeable in practice.
    
    * In HEAD, modify CREATE and ALTER ROLE to clear the password if an empty
    string, or a password hash that corresponds to an empty string, is
    specified. The user-visible behavior is the same as in the stable branches,
    the user cannot log in, but it seems better to stop the empty password from
    entering the system in the first place. Secondly, it is fairly expensive to
    check that a SCRAM hash doesn't correspond to an empty string, because
    computing a SCRAM hash is much more expensive than an MD5 hash by design,
    so better avoid doing that on every authentication.
    
    We could clear the password on CREATE/ALTER ROLE also in stable branches,
    but we would still need to check at authentication time, because even if we
    prevent empty passwords from being stored in pg_authid, there might be
    existing ones there already.
    
    Reported by Jeroen van der Ham, Ben de Graaff and Jelte Fennema.
    
    Security: CVE-2017-7546

diff --git a/src/backend/libpq/auth.c b/src/backend/libpq/auth.c
index f585ae0aed..ba64bcf913 100644
--- a/src/backend/libpq/auth.c
+++ b/src/backend/libpq/auth.c
@@ -697,6 +697,20 @@ recv_password_packet(Port *port)
 				(errcode(ERRCODE_PROTOCOL_VIOLATION),
 				 errmsg("invalid password packet size")));
 
+	/*
+	 * Don't allow an empty password. Libpq treats an empty password the same
+	 * as no password at all, and won't even try to authenticate. But other
+	 * clients might, so allowing it would be confusing.
+	 *
+	 * Note that this only catches an empty password sent by the client in
+	 * plaintext. There's another check in md5_crypt_verify to prevent an
+	 * empty password from being used with MD5 authentication.
+	 */
+	if (buf.data[0] == '\0')
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_PASSWORD),
+				 errmsg("empty password returned by client")));
+
 	/* Do not echo password to logs, for security. */
 	elog(DEBUG5, "received password packet");
 
@@ -1820,12 +1834,6 @@ pam_passwd_conv_proc(int num_msg, const struct pam_message ** msg,
 						 */
 						goto fail;
 					}
-					if (strlen(passwd) == 0)
-					{
-						ereport(LOG,
-							  (errmsg("empty password returned by client")));
-						goto fail;
-					}
 				}
 				if ((reply[i].resp = strdup(passwd)) == NULL)
 					goto fail;
@@ -2146,16 +2154,11 @@ CheckLDAPAuth(Port *port)
 	if (passwd == NULL)
 		return STATUS_EOF;		/* client wouldn't send password */
 
-	if (strlen(passwd) == 0)
-	{
-		ereport(LOG,
-				(errmsg("empty password returned by client")));
-		return STATUS_ERROR;
-	}
-
 	if (InitializeLDAPConnection(port, &ldap) == STATUS_ERROR)
+	{
 		/* Error message already sent */
 		return STATUS_ERROR;
+	}
 
 	if (port->hba->ldapbasedn)
 	{
@@ -2509,13 +2512,6 @@ CheckRADIUSAuth(Port *port)
 	if (passwd == NULL)
 		return STATUS_EOF;		/* client wouldn't send password */
 
-	if (strlen(passwd) == 0)
-	{
-		ereport(LOG,
-				(errmsg("empty password returned by client")));
-		return STATUS_ERROR;
-	}
-
 	if (strlen(passwd) > RADIUS_MAX_PASSWORD_LENGTH)
 	{
 		ereport(LOG,
diff --git a/src/backend/libpq/crypt.c b/src/backend/libpq/crypt.c
index d79f5a2496..9cd7f787cc 100644
--- a/src/backend/libpq/crypt.c
+++ b/src/backend/libpq/crypt.c
@@ -74,12 +74,37 @@ md5_crypt_verify(const Port *port, const char *role, char *client_pass,
 
 	ReleaseSysCache(roleTup);
 
+	/*
+	 * Don't allow an empty password. Libpq treats an empty password the same
+	 * as no password at all, and won't even try to authenticate. But other
+	 * clients might, so allowing it would be confusing.
+	 *
+	 * For a plaintext password, we can simply check that it's not an empty
+	 * string. For an encrypted password, check that it does not match the MD5
+	 * hash of an empty string.
+	 */
 	if (*shadow_pass == '\0')
 	{
 		*logdetail = psprintf(_("User \"%s\" has an empty password."),
 							  role);
 		return STATUS_ERROR;	/* empty password */
 	}
+	if (isMD5(shadow_pass))
+	{
+		char		crypt_empty[MD5_PASSWD_LEN + 1];
+
+		if (!pg_md5_encrypt("",
+							port->user_name,
+							strlen(port->user_name),
+							crypt_empty))
+			return STATUS_ERROR;
+		if (strcmp(shadow_pass, crypt_empty) == 0)
+		{
+			*logdetail = psprintf(_("User \"%s\" has an empty password."),
+								  role);
+			return STATUS_ERROR;	/* empty password */
+		}
+	}
 
 	/*
 	 * Compare with the encrypted or plain password depending on the
