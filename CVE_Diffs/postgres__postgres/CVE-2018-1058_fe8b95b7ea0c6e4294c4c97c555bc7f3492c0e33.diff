postgres__postgres
commit fe8b95b7ea0c6e4294c4c97c555bc7f3492c0e33
Author:     Tom Lane <tgl@sss.pgh.pa.us>
AuthorDate: Mon Feb 26 10:18:22 2018 -0500
Commit:     Tom Lane <tgl@sss.pgh.pa.us>
CommitDate: Mon Feb 26 10:18:22 2018 -0500

    Avoid using unsafe search_path settings during dump and restore.
    
    Historically, pg_dump has "set search_path = foo, pg_catalog" when
    dumping an object in schema "foo", and has also caused that setting
    to be used while restoring the object.  This is problematic because
    functions and operators in schema "foo" could capture references meant
    to refer to pg_catalog entries, both in the queries issued by pg_dump
    and those issued during the subsequent restore run.  That could
    result in dump/restore misbehavior, or in privilege escalation if a
    nefarious user installs trojan-horse functions or operators.
    
    This patch changes pg_dump so that it does not change the search_path
    dynamically.  The emitted restore script sets the search_path to what
    was used at dump time, and then leaves it alone thereafter.  Created
    objects are placed in the correct schema, regardless of the active
    search_path, by dint of schema-qualifying their names in the CREATE
    commands, as well as in subsequent ALTER and ALTER-like commands.
    
    Since this change requires a change in the behavior of pg_restore
    when processing an archive file made according to this new convention,
    bump the archive file version number; old versions of pg_restore will
    therefore refuse to process files made with new versions of pg_dump.
    
    Security: CVE-2018-1058

diff --git a/src/backend/utils/adt/ruleutils.c b/src/backend/utils/adt/ruleutils.c
index 9d1a9e8c8a..728b649e29 100644
--- a/src/backend/utils/adt/ruleutils.c
+++ b/src/backend/utils/adt/ruleutils.c
@@ -75,15 +75,17 @@
 #define PRETTYINDENT_LIMIT		40		/* wrap limit */
 
 /* Pretty flags */
-#define PRETTYFLAG_PAREN		1
-#define PRETTYFLAG_INDENT		2
+#define PRETTYFLAG_PAREN		0x0001
+#define PRETTYFLAG_INDENT		0x0002
+#define PRETTYFLAG_SCHEMA		0x0004
 
 /* Default line length for pretty-print wrapping: 0 means wrap always */
 #define WRAP_COLUMN_DEFAULT		0
 
-/* macro to test if pretty action needed */
+/* macros to test if pretty action needed */
 #define PRETTY_PAREN(context)	((context)->prettyFlags & PRETTYFLAG_PAREN)
 #define PRETTY_INDENT(context)	((context)->prettyFlags & PRETTYFLAG_INDENT)
+#define PRETTY_SCHEMA(context)	((context)->prettyFlags & PRETTYFLAG_SCHEMA)
 
 
 /* ----------
@@ -456,7 +458,8 @@ pg_get_ruledef_ext(PG_FUNCTION_ARGS)
 	bool		pretty = PG_GETARG_BOOL(1);
 	int			prettyFlags;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
+
 	PG_RETURN_TEXT_P(string_to_text(pg_get_ruledef_worker(ruleoid, prettyFlags)));
 }
 
@@ -555,7 +558,8 @@ pg_get_viewdef_ext(PG_FUNCTION_ARGS)
 	bool		pretty = PG_GETARG_BOOL(1);
 	int			prettyFlags;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
+
 	PG_RETURN_TEXT_P(string_to_text(pg_get_viewdef_worker(viewoid, prettyFlags, WRAP_COLUMN_DEFAULT)));
 }
 
@@ -568,7 +572,8 @@ pg_get_viewdef_wrap(PG_FUNCTION_ARGS)
 	int			prettyFlags;
 
 	/* calling this implies we want pretty printing */
-	prettyFlags = PRETTYFLAG_PAREN | PRETTYFLAG_INDENT;
+	prettyFlags = PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA;
+
 	PG_RETURN_TEXT_P(string_to_text(pg_get_viewdef_worker(viewoid, prettyFlags, wrap)));
 }
 
@@ -601,7 +606,7 @@ pg_get_viewdef_name_ext(PG_FUNCTION_ARGS)
 	RangeVar   *viewrel;
 	Oid			viewoid;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 
 	/* Look up view name.  Can't lock it - we might not have privileges. */
 	viewrel = makeRangeVarFromNameList(textToQualifiedNameList(viewname));
@@ -805,8 +810,15 @@ pg_get_triggerdef_worker(Oid trigid, bool pretty)
 			appendStringInfo(&buf, " TRUNCATE");
 		findx++;
 	}
+
+	/*
+	 * In non-pretty mode, always schema-qualify the target table name for
+	 * safety.  In pretty mode, schema-qualify only if not visible.
+	 */
 	appendStringInfo(&buf, " ON %s ",
-					 generate_relation_name(trigrec->tgrelid, NIL));
+					 pretty ?
+					 generate_relation_name(trigrec->tgrelid, NIL) :
+					 generate_qualified_relation_name(trigrec->tgrelid));
 
 	if (OidIsValid(trigrec->tgconstraint))
 	{
@@ -879,7 +891,7 @@ pg_get_triggerdef_worker(Oid trigid, bool pretty)
 		context.windowClause = NIL;
 		context.windowTList = NIL;
 		context.varprefix = true;
-		context.prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+		context.prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 		context.wrapColumn = WRAP_COLUMN_DEFAULT;
 		context.indentLevel = PRETTYINDENT_STD;
 
@@ -959,7 +971,8 @@ pg_get_indexdef_ext(PG_FUNCTION_ARGS)
 	bool		pretty = PG_GETARG_BOOL(2);
 	int			prettyFlags;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
+
 	PG_RETURN_TEXT_P(string_to_text(pg_get_indexdef_worker(indexrelid, colno,
 														   NULL,
 														   colno != 0,
@@ -984,7 +997,8 @@ pg_get_indexdef_columns(Oid indexrelid, bool pretty)
 {
 	int			prettyFlags;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
+
 	return pg_get_indexdef_worker(indexrelid, 0, NULL, true, false, prettyFlags);
 }
 
@@ -1105,7 +1119,9 @@ pg_get_indexdef_worker(Oid indexrelid, int colno,
 			appendStringInfo(&buf, "CREATE %sINDEX %s ON %s USING %s (",
 							 idxrec->indisunique ? "UNIQUE " : "",
 							 quote_identifier(NameStr(idxrelrec->relname)),
-							 generate_relation_name(indrelid, NIL),
+							 (prettyFlags & PRETTYFLAG_SCHEMA) ?
+							 generate_relation_name(indrelid, NIL) :
+							 generate_qualified_relation_name(indrelid),
 							 quote_identifier(NameStr(amrec->amname)));
 		else	/* currently, must be EXCLUDE constraint */
 			appendStringInfo(&buf, "EXCLUDE USING %s (",
@@ -1297,7 +1313,8 @@ pg_get_constraintdef_ext(PG_FUNCTION_ARGS)
 	bool		pretty = PG_GETARG_BOOL(1);
 	int			prettyFlags;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
+
 	PG_RETURN_TEXT_P(string_to_text(pg_get_constraintdef_worker(constraintId,
 																false,
 															  prettyFlags)));
@@ -1698,7 +1715,7 @@ pg_get_expr_ext(PG_FUNCTION_ARGS)
 	int			prettyFlags;
 	char	   *relname;
 
-	prettyFlags = pretty ? PRETTYFLAG_PAREN | PRETTYFLAG_INDENT : PRETTYFLAG_INDENT;
+	prettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;
 
 	if (OidIsValid(relid))
 	{
@@ -3970,7 +3987,11 @@ make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,
 	}
 
 	/* The relation the rule is fired on */
-	appendStringInfo(buf, " TO %s", generate_relation_name(ev_class, NIL));
+	appendStringInfo(buf, " TO %s",
+					 (prettyFlags & PRETTYFLAG_SCHEMA) ?
+					 generate_relation_name(ev_class, NIL) :
+					 generate_qualified_relation_name(ev_class));
+
 	if (ev_attr > 0)
 		appendStringInfo(buf, ".%s",
 						 quote_identifier(get_relid_attribute_name(ev_class,
diff --git a/src/bin/pg_dump/dumputils.c b/src/bin/pg_dump/dumputils.c
index ffc342f6e8..648aae414c 100644
--- a/src/bin/pg_dump/dumputils.c
+++ b/src/bin/pg_dump/dumputils.c
@@ -718,6 +718,7 @@ parsePGArray(const char *atext, char ***itemarray, int *nitems)
  *
  *	name: the object name, in the form to use in the commands (already quoted)
  *	subname: the sub-object name, if any (already quoted); NULL if none
+ *	nspname: the namespace the object is in (NULL if none); not pre-quoted
  *	type: the object type (as seen in GRANT command: must be one of
  *		TABLE, SEQUENCE, FUNCTION, LANGUAGE, SCHEMA, DATABASE, TABLESPACE,
  *		FOREIGN DATA WRAPPER, SERVER, or LARGE OBJECT)
@@ -737,7 +738,7 @@ parsePGArray(const char *atext, char ***itemarray, int *nitems)
  * since this routine uses fmtId() internally.
  */
 bool
-buildACLCommands(const char *name, const char *subname,
+buildACLCommands(const char *name, const char *subname, const char *nspname,
 				 const char *type, const char *acls, const char *owner,
 				 const char *prefix, int remoteVersion,
 				 PQExpBuffer sql)
@@ -791,7 +792,10 @@ buildACLCommands(const char *name, const char *subname,
 	appendPQExpBuffer(firstsql, "%sREVOKE ALL", prefix);
 	if (subname)
 		appendPQExpBuffer(firstsql, "(%s)", subname);
-	appendPQExpBuffer(firstsql, " ON %s %s FROM PUBLIC;\n", type, name);
+	appendPQExpBuffer(firstsql, " ON %s ", type);
+	if (nspname && *nspname)
+		appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+	appendPQExpBuffer(firstsql, "%s FROM PUBLIC;\n", name);
 
 	/*
 	 * We still need some hacking though to cover the case where new default
@@ -839,18 +843,33 @@ buildACLCommands(const char *name, const char *subname,
 					appendPQExpBuffer(firstsql, "%sREVOKE ALL", prefix);
 					if (subname)
 						appendPQExpBuffer(firstsql, "(%s)", subname);
-					appendPQExpBuffer(firstsql, " ON %s %s FROM %s;\n",
-									  type, name, fmtId(grantee->data));
+					appendPQExpBuffer(firstsql, " ON %s ", type);
+					if (nspname && *nspname)
+						appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+					appendPQExpBuffer(firstsql, "%s FROM %s;\n",
+									  name, fmtId(grantee->data));
 					if (privs->len > 0)
+					{
+						appendPQExpBuffer(firstsql,
+										  "%sGRANT %s ON %s ",
+										  prefix, privs->data, type);
+						if (nspname && *nspname)
+							appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
 						appendPQExpBuffer(firstsql,
-										  "%sGRANT %s ON %s %s TO %s;\n",
-										  prefix, privs->data, type, name,
-										  fmtId(grantee->data));
+										  "%s TO %s;\n",
+										  name, fmtId(grantee->data));
+					}
 					if (privswgo->len > 0)
+					{
+						appendPQExpBuffer(firstsql,
+										  "%sGRANT %s ON %s ",
+										  prefix, privswgo->data, type);
+						if (nspname && *nspname)
+							appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
 						appendPQExpBuffer(firstsql,
-							"%sGRANT %s ON %s %s TO %s WITH GRANT OPTION;\n",
-										  prefix, privswgo->data, type, name,
-										  fmtId(grantee->data));
+										  "%s TO %s WITH GRANT OPTION;\n",
+										  name, fmtId(grantee->data));
+					}
 				}
 			}
 			else
@@ -865,8 +884,11 @@ buildACLCommands(const char *name, const char *subname,
 
 				if (privs->len > 0)
 				{
-					appendPQExpBuffer(secondsql, "%sGRANT %s ON %s %s TO ",
-									  prefix, privs->data, type, name);
+					appendPQExpBuffer(secondsql, "%sGRANT %s ON %s ",
+									  prefix, privs->data, type);
+					if (nspname && *nspname)
+						appendPQExpBuffer(secondsql, "%s.", fmtId(nspname));
+					appendPQExpBuffer(secondsql, "%s TO ", name);
 					if (grantee->len == 0)
 						appendPQExpBuffer(secondsql, "PUBLIC;\n");
 					else if (strncmp(grantee->data, "group ",
@@ -878,8 +900,11 @@ buildACLCommands(const char *name, const char *subname,
 				}
 				if (privswgo->len > 0)
 				{
-					appendPQExpBuffer(secondsql, "%sGRANT %s ON %s %s TO ",
-									  prefix, privswgo->data, type, name);
+					appendPQExpBuffer(secondsql, "%sGRANT %s ON %s ",
+									  prefix, privswgo->data, type);
+					if (nspname && *nspname)
+						appendPQExpBuffer(secondsql, "%s.", fmtId(nspname));
+					appendPQExpBuffer(secondsql, "%s TO ", name);
 					if (grantee->len == 0)
 						appendPQExpBuffer(secondsql, "PUBLIC");
 					else if (strncmp(grantee->data, "group ",
@@ -906,8 +931,11 @@ buildACLCommands(const char *name, const char *subname,
 		appendPQExpBuffer(firstsql, "%sREVOKE ALL", prefix);
 		if (subname)
 			appendPQExpBuffer(firstsql, "(%s)", subname);
-		appendPQExpBuffer(firstsql, " ON %s %s FROM %s;\n",
-						  type, name, fmtId(owner));
+		appendPQExpBuffer(firstsql, " ON %s ", type);
+		if (nspname && *nspname)
+			appendPQExpBuffer(firstsql, "%s.", fmtId(nspname));
+		appendPQExpBuffer(firstsql, "%s FROM %s;\n",
+						  name, fmtId(owner));
 	}
 
 	destroyPQExpBuffer(grantee);
@@ -958,7 +986,7 @@ buildDefaultACLCommands(const char *type, const char *nspname,
 	if (nspname)
 		appendPQExpBuffer(prefix, "IN SCHEMA %s ", fmtId(nspname));
 
-	result = buildACLCommands("", NULL,
+	result = buildACLCommands("", NULL, NULL,
 							  type, acls, owner,
 							  prefix->data, remoteVersion,
 							  sql);
@@ -1412,26 +1440,32 @@ processSQLNamePattern(PGconn *conn, PQExpBuffer buf, const char *pattern,
  * buildShSecLabelQuery
  *
  * Build a query to retrieve security labels for a shared object.
+ * The object is identified by its OID plus the name of the catalog
+ * it can be found in (e.g., "pg_database" for database names).
+ * The query is appended to "sql".  (We don't execute it here so as to
+ * keep this file free of assumptions about how to deal with SQL errors.)
  */
 void
-buildShSecLabelQuery(PGconn *conn, const char *catalog_name, uint32 objectId,
+buildShSecLabelQuery(PGconn *conn, const char *catalog_name, Oid objectId,
 					 PQExpBuffer sql)
 {
 	appendPQExpBuffer(sql,
 					  "SELECT provider, label FROM pg_catalog.pg_shseclabel "
-					  "WHERE classoid = '%s'::pg_catalog.regclass AND "
-					  "objoid = %u", catalog_name, objectId);
+					  "WHERE classoid = 'pg_catalog.%s'::pg_catalog.regclass "
+					  "AND objoid = '%u'", catalog_name, objectId);
 }
 
 /*
  * emitShSecLabels
  *
- * Format security label data retrieved by the query generated in
- * buildShSecLabelQuery.
+ * Construct SECURITY LABEL commands using the data retrieved by the query
+ * generated by buildShSecLabelQuery, and append them to "buffer".
+ * Here, the target object is identified by its type name (e.g. "DATABASE")
+ * and its name (not pre-quoted).
  */
 void
 emitShSecLabels(PGconn *conn, PGresult *res, PQExpBuffer buffer,
-				const char *target, const char *objname)
+				const char *objtype, const char *objname)
 {
 	int			i;
 
@@ -1443,7 +1477,7 @@ emitShSecLabels(PGconn *conn, PGresult *res, PQExpBuffer buffer,
 		/* must use fmtId result before calling it again */
 		appendPQExpBuffer(buffer,
 						  "SECURITY LABEL FOR %s ON %s",
-						  fmtId(provider), target);
+						  fmtId(provider), objtype);
 		appendPQExpBuffer(buffer,
 						  " %s IS ",
 						  fmtId(objname));
diff --git a/src/bin/pg_dump/dumputils.h b/src/bin/pg_dump/dumputils.h
index ed66651e4f..7b370660fe 100644
--- a/src/bin/pg_dump/dumputils.h
+++ b/src/bin/pg_dump/dumputils.h
@@ -53,7 +53,7 @@ extern void appendShellString(PQExpBuffer buf, const char *str);
 extern void appendConnStrVal(PQExpBuffer buf, const char *str);
 extern void appendPsqlMetaConnect(PQExpBuffer buf, const char *dbname);
 extern bool parsePGArray(const char *atext, char ***itemarray, int *nitems);
-extern bool buildACLCommands(const char *name, const char *subname,
+extern bool buildACLCommands(const char *name, const char *subname, const char *nspname,
 				 const char *type, const char *acls, const char *owner,
 				 const char *prefix, int remoteVersion,
 				 PQExpBuffer sql);
@@ -67,9 +67,9 @@ extern bool processSQLNamePattern(PGconn *conn, PQExpBuffer buf,
 					  const char *schemavar, const char *namevar,
 					  const char *altnamevar, const char *visibilityrule);
 extern void buildShSecLabelQuery(PGconn *conn, const char *catalog_name,
-					 uint32 objectId, PQExpBuffer sql);
+					 Oid objectId, PQExpBuffer sql);
 extern void emitShSecLabels(PGconn *conn, PGresult *res,
-				PQExpBuffer buffer, const char *target, const char *objname);
+				PQExpBuffer buffer, const char *objtype, const char *objname);
 extern void set_dump_section(const char *arg, int *dumpSections);
 
 extern void simple_string_list_append(SimpleStringList *list, const char *val);
diff --git a/src/bin/pg_dump/pg_backup.h b/src/bin/pg_dump/pg_backup.h
index 5c974b762f..fefef3fd7a 100644
--- a/src/bin/pg_dump/pg_backup.h
+++ b/src/bin/pg_dump/pg_backup.h
@@ -89,6 +89,9 @@ struct Archive
 	/* info needed for string escaping */
 	int			encoding;		/* libpq code for client_encoding */
 	bool		std_strings;	/* standard_conforming_strings */
+
+	/* other important stuff */
+	char	   *searchpath;		/* search_path to set during restore */
 	char	   *use_role;		/* Issue SET ROLE to this */
 
 	/* error handling */
diff --git a/src/bin/pg_dump/pg_backup_archiver.c b/src/bin/pg_dump/pg_backup_archiver.c
index 50ec4776d9..8c9455041e 100644
--- a/src/bin/pg_dump/pg_backup_archiver.c
+++ b/src/bin/pg_dump/pg_backup_archiver.c
@@ -67,6 +67,7 @@ static void _selectOutputSchema(ArchiveHandle *AH, const char *schemaName);
 static void _selectTablespace(ArchiveHandle *AH, const char *tablespace);
 static void processEncodingEntry(ArchiveHandle *AH, TocEntry *te);
 static void processStdStringsEntry(ArchiveHandle *AH, TocEntry *te);
+static void processSearchPathEntry(ArchiveHandle *AH, TocEntry *te);
 static teReqs _tocEntryRequired(TocEntry *te, teSection curSection, RestoreOptions *ropt);
 static RestorePass _tocEntryRestorePass(TocEntry *te);
 static bool _tocEntryIsACL(TocEntry *te);
@@ -706,7 +707,9 @@ restore_toc_entry(ArchiveHandle *AH, TocEntry *te,
 						ahprintf(AH, "TRUNCATE TABLE %s%s;\n\n",
 								 (PQserverVersion(AH->connection) >= 80400 ?
 								  "ONLY " : ""),
-								 fmtId(te->tag));
+							  fmtQualifiedId(PQserverVersion(AH->connection),
+											 te->namespace,
+											 te->tag));
 					}
 
 					/*
@@ -791,10 +794,10 @@ _disableTriggersIfNecessary(ArchiveHandle *AH, TocEntry *te, RestoreOptions *rop
 	/*
 	 * Disable them.
 	 */
-	_selectOutputSchema(AH, te->namespace);
-
 	ahprintf(AH, "ALTER TABLE %s DISABLE TRIGGER ALL;\n\n",
-			 fmtId(te->tag));
+			 fmtQualifiedId(PQserverVersion(AH->connection),
+							te->namespace,
+							te->tag));
 }
 
 static void
@@ -817,10 +820,10 @@ _enableTriggersIfNecessary(ArchiveHandle *AH, TocEntry *te, RestoreOptions *ropt
 	/*
 	 * Enable them.
 	 */
-	_selectOutputSchema(AH, te->namespace);
-
 	ahprintf(AH, "ALTER TABLE %s ENABLE TRIGGER ALL;\n\n",
-			 fmtId(te->tag));
+			 fmtQualifiedId(PQserverVersion(AH->connection),
+							te->namespace,
+							te->tag));
 }
 
 /*
@@ -2450,6 +2453,8 @@ ReadToc(ArchiveHandle *AH)
 			processEncodingEntry(AH, te);
 		else if (strcmp(te->desc, "STDSTRINGS") == 0)
 			processStdStringsEntry(AH, te);
+		else if (strcmp(te->desc, "SEARCHPATH") == 0)
+			processSearchPathEntry(AH, te);
 	}
 }
 
@@ -2497,14 +2502,25 @@ processStdStringsEntry(ArchiveHandle *AH, TocEntry *te)
 					  te->defn);
 }
 
+static void
+processSearchPathEntry(ArchiveHandle *AH, TocEntry *te)
+{
+	/*
+	 * te->defn should contain a command to set search_path.  We just copy it
+	 * verbatim for use later.
+	 */
+	AH->public.searchpath = pg_strdup(te->defn);
+}
+
 static teReqs
 _tocEntryRequired(TocEntry *te, teSection curSection, RestoreOptions *ropt)
 {
 	teReqs		res = REQ_SCHEMA | REQ_DATA;
 
-	/* ENCODING and STDSTRINGS items are treated specially */
+	/* These items are treated specially */
 	if (strcmp(te->desc, "ENCODING") == 0 ||
-		strcmp(te->desc, "STDSTRINGS") == 0)
+		strcmp(te->desc, "STDSTRINGS") == 0 ||
+		strcmp(te->desc, "SEARCHPATH") == 0)
 		return REQ_SPECIAL;
 
 	/* If it's an ACL, maybe ignore it */
@@ -2708,6 +2724,10 @@ _doSetFixedOutputState(ArchiveHandle *AH)
 	if (AH->ropt && AH->ropt->use_role)
 		ahprintf(AH, "SET ROLE %s;\n", fmtId(AH->ropt->use_role));
 
+	/* Select the dump-time search_path */
+	if (AH->public.searchpath)
+		ahprintf(AH, "%s", AH->public.searchpath);
+
 	/* Make sure function checking is disabled */
 	ahprintf(AH, "SET check_function_bodies = false;\n");
 
@@ -2904,6 +2924,15 @@ _selectOutputSchema(ArchiveHandle *AH, const char *schemaName)
 {
 	PQExpBuffer qry;
 
+	/*
+	 * If there was a SEARCHPATH TOC entry, we're supposed to just stay with
+	 * that search_path rather than switching to entry-specific paths.
+	 * Otherwise, it's an old archive that will not restore correctly unless
+	 * we set the search_path as it's expecting.
+	 */
+	if (AH->public.searchpath)
+		return;
+
 	if (!schemaName || *schemaName == '\0' ||
 		(AH->currSchema && strcmp(AH->currSchema, schemaName) == 0))
 		return;					/* no need to do anything */
diff --git a/src/bin/pg_dump/pg_backup_archiver.h b/src/bin/pg_dump/pg_backup_archiver.h
index dc2404c232..b953ed333f 100644
--- a/src/bin/pg_dump/pg_backup_archiver.h
+++ b/src/bin/pg_dump/pg_backup_archiver.h
@@ -64,7 +64,7 @@ typedef z_stream *z_streamp;
 
 /* Current archive version number (the format we can output) */
 #define K_VERS_MAJOR 1
-#define K_VERS_MINOR 12
+#define K_VERS_MINOR 13
 #define K_VERS_REV 0
 
 /* Data block types */
@@ -90,9 +90,11 @@ typedef z_stream *z_streamp;
 																 * indicator */
 #define K_VERS_1_12 (( (1 * 256 + 12) * 256 + 0) * 256 + 0)		/* add separate BLOB
 																 * entries */
+#define K_VERS_1_13 (( (1 * 256 + 13) * 256 + 0) * 256 + 0)		/* change search_path
+																 * behavior */
 
 /* Newest format we can read */
-#define K_VERS_MAX (( (1 * 256 + 12) * 256 + 255) * 256 + 0)
+#define K_VERS_MAX (( (1 * 256 + 13) * 256 + 255) * 256 + 0)
 
 
 /* Flags to indicate disposition of offsets stored in files */
diff --git a/src/bin/pg_dump/pg_dump.c b/src/bin/pg_dump/pg_dump.c
index 443d9ef8b6..c870b7dfc5 100644
--- a/src/bin/pg_dump/pg_dump.c
+++ b/src/bin/pg_dump/pg_dump.c
@@ -145,6 +145,15 @@ static int	no_unlogged_table_data = 0;
 static int	serializable_deferrable = 0;
 
 
+/*
+ * Macro for producing quoted, schema-qualified name of a dumpable object.
+ * Note implicit dependence on "fout"; we should get rid of that argument.
+ */
+#define fmtQualifiedDumpable(obj) \
+	fmtQualifiedId(fout->remoteVersion, \
+				   (obj)->dobj.namespace->dobj.name, \
+				   (obj)->dobj.name)
+
 static void help(const char *progname);
 static void setup_connection(Archive *AH, const char *dumpencoding,
 				 char *use_role);
@@ -159,13 +168,13 @@ static NamespaceInfo *findNamespace(Archive *fout, Oid nsoid, Oid objoid);
 static void dumpTableData(Archive *fout, TableDataInfo *tdinfo);
 static void refreshMatViewData(Archive *fout, TableDataInfo *tdinfo);
 static void guessConstraintInheritance(TableInfo *tblinfo, int numTables);
-static void dumpComment(Archive *fout, const char *target,
+static void dumpComment(Archive *fout, const char *type, const char *name,
 			const char *namespace, const char *owner,
 			CatalogId catalogId, int subid, DumpId dumpId);
 static int findComments(Archive *fout, Oid classoid, Oid objoid,
 			 CommentItem **items);
 static int	collectComments(Archive *fout, CommentItem **items);
-static void dumpSecLabel(Archive *fout, const char *target,
+static void dumpSecLabel(Archive *fout, const char *type, const char *name,
 			 const char *namespace, const char *owner,
 			 CatalogId catalogId, int subid, DumpId dumpId);
 static int findSecLabels(Archive *fout, Oid classoid, Oid objoid,
@@ -216,7 +225,7 @@ static void dumpDefaultACL(Archive *fout, DefaultACLInfo *daclinfo);
 
 static void dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
 		const char *type, const char *name, const char *subname,
-		const char *tag, const char *nspname, const char *owner,
+		const char *nspname, const char *owner,
 		const char *acls);
 
 static void getDependencies(Archive *fout);
@@ -243,11 +252,10 @@ static char *format_function_signature(Archive *fout,
 						  FuncInfo *finfo, bool honor_quotes);
 static const char *convertRegProcReference(Archive *fout,
 						const char *proc);
-static const char *convertOperatorReference(Archive *fout, const char *opr);
+static char *getFormattedOperatorName(Archive *fout, const char *oproid);
 static const char *convertTSFunction(Archive *fout, Oid funcOid);
 static Oid	findLastBuiltinOid_V71(Archive *fout, const char *);
 static Oid	findLastBuiltinOid_V70(Archive *fout);
-static void selectSourceSchema(Archive *fout, const char *schemaName);
 static char *getFormattedTypeName(Archive *fout, Oid oid, OidOptions opts);
 static char *myFormatType(const char *typname, int32 typmod);
 static void getBlobs(Archive *fout);
@@ -256,6 +264,7 @@ static int	dumpBlobs(Archive *fout, void *arg);
 static void dumpDatabase(Archive *AH);
 static void dumpEncoding(Archive *AH);
 static void dumpStdStrings(Archive *AH);
+static void dumpSearchPath(Archive *AH);
 static void binary_upgrade_set_type_oids_by_type_oid(Archive *fout,
 								PQExpBuffer upgrade_buffer, Oid pg_type_oid);
 static bool binary_upgrade_set_type_oids_by_rel_oid(Archive *fout,
@@ -265,7 +274,9 @@ static void binary_upgrade_set_pg_class_oids(Archive *fout,
 								 Oid pg_class_oid, bool is_index);
 static void binary_upgrade_extension_member(PQExpBuffer upgrade_buffer,
 								DumpableObject *dobj,
-								const char *objlabel);
+								const char *objtype,
+								const char *objname,
+								const char *objnamespace);
 static const char *getAttrName(int attrnum, TableInfo *tblInfo);
 static const char *fmtCopyColumnList(const TableInfo *ti, PQExpBuffer buffer);
 static bool nonemptyReloptions(const char *reloptions);
@@ -824,9 +835,10 @@ main(int argc, char **argv)
 	 * order.
 	 */
 
-	/* First the special ENCODING and STDSTRINGS entries. */
+	/* First the special ENCODING, STDSTRINGS, and SEARCHPATH entries. */
 	dumpEncoding(fout);
 	dumpStdStrings(fout);
+	dumpSearchPath(fout);
 
 	/* The database item is always next, unless we don't want it at all */
 	if (include_everything && !dataOnly)
@@ -1535,14 +1547,6 @@ dumpTableData_copy(Archive *fout, void *dcontext)
 	if (g_verbose)
 		write_msg(NULL, "dumping contents of table %s\n", classname);
 
-	/*
-	 * Make sure we are in proper schema.  We will qualify the table name
-	 * below anyway (in case its name conflicts with a pg_catalog table); but
-	 * this ensures reproducible results in case the table contains regproc,
-	 * regclass, etc columns.
-	 */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 	/*
 	 * If possible, specify the column list explicitly so that we have no
 	 * possibility of retrieving data in the wrong column order.  (The default
@@ -1557,9 +1561,7 @@ dumpTableData_copy(Archive *fout, void *dcontext)
 	if (oids && hasoids)
 	{
 		appendPQExpBuffer(q, "COPY %s %s WITH OIDS TO stdout;",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname),
+						  fmtQualifiedDumpable(tbinfo),
 						  column_list);
 	}
 	else if (tdinfo->filtercond)
@@ -1575,17 +1577,13 @@ dumpTableData_copy(Archive *fout, void *dcontext)
 		else
 			appendPQExpBufferStr(q, "* ");
 		appendPQExpBuffer(q, "FROM %s %s) TO stdout;",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname),
+						  fmtQualifiedDumpable(tbinfo),
 						  tdinfo->filtercond);
 	}
 	else
 	{
 		appendPQExpBuffer(q, "COPY %s %s TO stdout;",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname),
+						  fmtQualifiedDumpable(tbinfo),
 						  column_list);
 	}
 	res = ExecuteSqlQuery(fout, q->data, PGRES_COPY_OUT);
@@ -1695,36 +1693,23 @@ dumpTableData_insert(Archive *fout, void *dcontext)
 {
 	TableDataInfo *tdinfo = (TableDataInfo *) dcontext;
 	TableInfo  *tbinfo = tdinfo->tdtable;
-	const char *classname = tbinfo->dobj.name;
 	PQExpBuffer q = createPQExpBuffer();
 	PGresult   *res;
 	int			tuple;
 	int			nfields;
 	int			field;
 
-	/*
-	 * Make sure we are in proper schema.  We will qualify the table name
-	 * below anyway (in case its name conflicts with a pg_catalog table); but
-	 * this ensures reproducible results in case the table contains regproc,
-	 * regclass, etc columns.
-	 */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 	if (fout->remoteVersion >= 70100)
 	{
 		appendPQExpBuffer(q, "DECLARE _pg_dump_cursor CURSOR FOR "
 						  "SELECT * FROM ONLY %s",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname));
+						  fmtQualifiedDumpable(tbinfo));
 	}
 	else
 	{
 		appendPQExpBuffer(q, "DECLARE _pg_dump_cursor CURSOR FOR "
 						  "SELECT * FROM %s",
-						  fmtQualifiedId(fout->remoteVersion,
-										 tbinfo->dobj.namespace->dobj.name,
-										 classname));
+						  fmtQualifiedDumpable(tbinfo));
 	}
 	if (tdinfo->filtercond)
 		appendPQExpBuffer(q, " %s", tdinfo->filtercond);
@@ -1738,7 +1723,7 @@ dumpTableData_insert(Archive *fout, void *dcontext)
 		nfields = PQnfields(res);
 		for (tuple = 0; tuple < PQntuples(res); tuple++)
 		{
-			archprintf(fout, "INSERT INTO %s ", fmtId(classname));
+			archprintf(fout, "INSERT INTO %s ", fmtQualifiedDumpable(tbinfo));
 			if (nfields == 0)
 			{
 				/* corner case for zero-column table */
@@ -1864,7 +1849,7 @@ dumpTableData(Archive *fout, TableDataInfo *tdinfo)
 		dumpFn = dumpTableData_copy;
 		/* must use 2 steps here 'cause fmtId is nonreentrant */
 		appendPQExpBuffer(copyBuf, "COPY %s ",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(copyBuf, "%s %sFROM stdin;\n",
 						  fmtCopyColumnList(tbinfo, clistBuf),
 					  (tdinfo->oids && tbinfo->hasoids) ? "WITH OIDS " : "");
@@ -1914,7 +1899,7 @@ refreshMatViewData(Archive *fout, TableDataInfo *tdinfo)
 	q = createPQExpBuffer();
 
 	appendPQExpBuffer(q, "REFRESH MATERIALIZED VIEW %s;\n",
-					  fmtId(tbinfo->dobj.name));
+					  fmtQualifiedDumpable(tbinfo));
 
 	ArchiveEntry(fout,
 				 tdinfo->dobj.catId,	/* catalog ID */
@@ -2035,9 +2020,6 @@ buildMatViewRefreshDependencies(Archive *fout)
 	if (fout->remoteVersion < 90300)
 		return;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	query = createPQExpBuffer();
 
 	appendPQExpBuffer(query, "with recursive w as "
@@ -2278,16 +2260,16 @@ dumpDatabase(Archive *fout)
 			   *collate,
 			   *ctype,
 			   *tablespace;
-	uint32		frozenxid, minmxid;
+	uint32		frozenxid,
+				minmxid;
+	char	   *qdatname;
 
 	datname = PQdb(conn);
+	qdatname = pg_strdup(fmtId(datname));
 
 	if (g_verbose)
 		write_msg(NULL, "saving database definition\n");
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/* Get the database owner and parameters from pg_database */
 	if (fout->remoteVersion >= 90300)
 	{
@@ -2395,7 +2377,7 @@ dumpDatabase(Archive *fout)
 	tablespace = PQgetvalue(res, 0, i_tablespace);
 
 	appendPQExpBuffer(creaQry, "CREATE DATABASE %s WITH TEMPLATE = template0",
-					  fmtId(datname));
+					  qdatname);
 	if (strlen(encoding) > 0)
 	{
 		appendPQExpBuffer(creaQry, " ENCODING = ");
@@ -2425,11 +2407,10 @@ dumpDatabase(Archive *fout)
 						  frozenxid, minmxid);
 		appendStringLiteralAH(creaQry, datname, fout);
 		appendPQExpBuffer(creaQry, ";\n");
-
 	}
 
 	appendPQExpBuffer(delQry, "DROP DATABASE %s;\n",
-					  fmtId(datname));
+					  qdatname);
 
 	dbDumpId = createDumpId();
 
@@ -2542,8 +2523,8 @@ dumpDatabase(Archive *fout)
 		destroyPQExpBuffer(loOutQry);
 	}
 
-	/* Compute correct tag for comments etc */
-	appendPQExpBuffer(labelq, "DATABASE %s", fmtId(datname));
+	/* Compute correct tag for archive entry */
+	appendPQExpBuffer(labelq, "DATABASE %s", qdatname);
 
 	/* Dump DB comment if any */
 	if (fout->remoteVersion >= 80200)
@@ -2563,7 +2544,7 @@ dumpDatabase(Archive *fout)
 			 * Generates warning when loaded into a differently-named
 			 * database.
 			 */
-			appendPQExpBuffer(dbQry, "COMMENT ON DATABASE %s IS ", fmtId(datname));
+			appendPQExpBuffer(dbQry, "COMMENT ON DATABASE %s IS ", qdatname);
 			appendStringLiteralAH(dbQry, comment, fout);
 			appendPQExpBuffer(dbQry, ";\n");
 
@@ -2577,7 +2558,7 @@ dumpDatabase(Archive *fout)
 	}
 	else
 	{
-		dumpComment(fout, labelq->data, NULL, dba,
+		dumpComment(fout, "DATABASE", qdatname, NULL, dba,
 					dbCatId, 0, dbDumpId);
 	}
 
@@ -2606,6 +2587,7 @@ dumpDatabase(Archive *fout)
 
 	PQclear(res);
 
+	free(qdatname);
 	destroyPQExpBuffer(dbQry);
 	destroyPQExpBuffer(delQry);
 	destroyPQExpBuffer(creaQry);
@@ -2666,6 +2648,84 @@ dumpStdStrings(Archive *AH)
 	destroyPQExpBuffer(qry);
 }
 
+/*
+ * dumpSearchPath: record the active search_path in the archive
+ */
+static void
+dumpSearchPath(Archive *AH)
+{
+	PQExpBuffer qry = createPQExpBuffer();
+	PQExpBuffer path = createPQExpBuffer();
+	PGresult   *res;
+	char	  **schemanames = NULL;
+	int			nschemanames = 0;
+	int			i;
+
+	if (AH->remoteVersion >= 70300)
+	{
+		/*
+		 * We use the result of current_schemas(), not the search_path GUC,
+		 * because that might contain wildcards such as "$user", which won't
+		 * necessarily have the same value during restore.  Also, this way
+		 * avoids listing schemas that may appear in search_path but not
+		 * actually exist, which seems like a prudent exclusion.
+		 */
+		res = ExecuteSqlQueryForSingleRow(AH,
+								 "SELECT pg_catalog.current_schemas(false)");
+
+		if (!parsePGArray(PQgetvalue(res, 0, 0), &schemanames, &nschemanames))
+			exit_horribly(NULL, "could not parse result of current_schemas()\n");
+
+		/*
+		 * We use set_config(), not a simple "SET search_path" command,
+		 * because the latter has less-clean behavior if the search path is
+		 * empty.  While that's likely to get fixed at some point, it seems
+		 * like a good idea to be as backwards-compatible as possible in what
+		 * we put into archives.
+		 */
+		for (i = 0; i < nschemanames; i++)
+		{
+			if (i > 0)
+				appendPQExpBuffer(path, ", ");
+			appendPQExpBuffer(path, "%s", fmtId(schemanames[i]));
+		}
+
+		PQclear(res);
+	}
+	else
+	{
+		/*
+		 * For pre-schema servers, we must force the output search path to be
+		 * "public", because the source server's ruleutils functions will not
+		 * schema-qualify anything.  Thus, for example, references to user
+		 * tables in view definitions won't work otherwise.
+		 */
+		appendPQExpBuffer(path, "public");
+	}
+
+	appendPQExpBuffer(qry, "SELECT pg_catalog.set_config('search_path', ");
+	appendStringLiteralAH(qry, path->data, AH);
+	appendPQExpBuffer(qry, ", false);\n");
+
+	if (g_verbose)
+		write_msg(NULL, "saving search_path = %s\n", path->data);
+
+	ArchiveEntry(AH, nilCatalogId, createDumpId(),
+				 "SEARCHPATH", NULL, NULL, "",
+				 false, "SEARCHPATH", SECTION_PRE_DATA,
+				 qry->data, "", NULL,
+				 NULL, 0,
+				 NULL, NULL);
+
+	/* Also save it in AH->searchpath, in case we're doing plain text dump */
+	AH->searchpath = pg_strdup(qry->data);
+
+	if (schemanames)
+		free(schemanames);
+	destroyPQExpBuffer(qry);
+	destroyPQExpBuffer(path);
+}
+
 
 /*
  * getBlobs:
@@ -2685,9 +2745,6 @@ getBlobs(Archive *fout)
 	if (g_verbose)
 		write_msg(NULL, "reading large objects\n");
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/* Fetch BLOB OIDs, and owner/ACL data if >= 9.0 */
 	if (fout->remoteVersion >= 90000)
 		appendPQExpBuffer(blobQry,
@@ -2774,17 +2831,13 @@ dumpBlob(Archive *fout, BlobInfo *binfo)
 				 NULL, 0,
 				 NULL, NULL);
 
-	/* set up tag for comment and/or ACL */
-	resetPQExpBuffer(cquery);
-	appendPQExpBuffer(cquery, "LARGE OBJECT %s", binfo->dobj.name);
-
 	/* Dump comment if any */
-	dumpComment(fout, cquery->data,
+	dumpComment(fout, "LARGE OBJECT", binfo->dobj.name,
 				NULL, binfo->rolname,
 				binfo->dobj.catId, 0, binfo->dobj.dumpId);
 
 	/* Dump security label if any */
-	dumpSecLabel(fout, cquery->data,
+	dumpSecLabel(fout, "LARGE OBJECT", binfo->dobj.name,
 				 NULL, binfo->rolname,
 				 binfo->dobj.catId, 0, binfo->dobj.dumpId);
 
@@ -2797,7 +2850,7 @@ dumpBlob(Archive *fout, BlobInfo *binfo)
 	 */
 	if (binfo->blobacl && !binary_upgrade)
 		dumpACL(fout, binfo->dobj.catId, binfo->dobj.dumpId, "LARGE OBJECT",
-				binfo->dobj.name, NULL, cquery->data,
+				binfo->dobj.name, NULL,
 				NULL, binfo->rolname, binfo->blobacl);
 
 	destroyPQExpBuffer(cquery);
@@ -2830,9 +2883,6 @@ dumpBlobs(Archive *fout, void *arg)
 	if (g_verbose)
 		write_msg(NULL, "saving large objects\n");
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * Currently, we re-fetch all BLOB OIDs using a cursor.  Consider scanning
 	 * the already-in-memory dumpable objects instead...
@@ -3042,11 +3092,16 @@ binary_upgrade_set_pg_class_oids(Archive *fout,
 /*
  * If the DumpableObject is a member of an extension, add a suitable
  * ALTER EXTENSION ADD command to the creation commands in upgrade_buffer.
+ *
+ * For somewhat historical reasons, objname should already be quoted,
+ * but not objnamespace (if any).
  */
 static void
 binary_upgrade_extension_member(PQExpBuffer upgrade_buffer,
 								DumpableObject *dobj,
-								const char *objlabel)
+								const char *objtype,
+								const char *objname,
+								const char *objnamespace)
 {
 	DumpableObject *extobj = NULL;
 	int			i;
@@ -3068,13 +3123,17 @@ binary_upgrade_extension_member(PQExpBuffer upgrade_buffer,
 		extobj = NULL;
 	}
 	if (extobj == NULL)
-		exit_horribly(NULL, "could not find parent extension for %s\n", objlabel);
+		exit_horribly(NULL, "could not find parent extension for %s %s\n",
+					  objtype, objname);
 
 	appendPQExpBuffer(upgrade_buffer,
 	  "\n-- For binary upgrade, handle extension membership the hard way\n");
-	appendPQExpBuffer(upgrade_buffer, "ALTER EXTENSION %s ADD %s;\n",
+	appendPQExpBuffer(upgrade_buffer, "ALTER EXTENSION %s ADD %s ",
 					  fmtId(extobj->name),
-					  objlabel);
+					  objtype);
+	if (objnamespace && *objnamespace)
+		appendPQExpBuffer(upgrade_buffer, "%s.", fmtId(objnamespace));
+	appendPQExpBuffer(upgrade_buffer, "%s;\n", objname);
 }
 
 /*
@@ -3133,9 +3192,6 @@ getNamespaces(Archive *fout, int *numNamespaces)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * we fetch all namespaces including system ones, so that every object we
 	 * read in can be linked to a containing namespace.
@@ -3254,9 +3310,6 @@ getExtensions(Archive *fout, int *numExtensions)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT x.tableoid, x.oid, "
 					  "x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition "
 					  "FROM pg_extension x "
@@ -3352,9 +3405,6 @@ getTypes(Archive *fout, int *numTypes)
 	 * be revisited if the backend ever allows renaming of array types.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90200)
 	{
 		appendPQExpBuffer(query, "SELECT tableoid, oid, typname, "
@@ -3605,9 +3655,6 @@ getOperators(Archive *fout, int *numOprs)
 	 * system-defined operators at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 70300)
 	{
 		appendPQExpBuffer(query, "SELECT tableoid, oid, oprname, "
@@ -3721,9 +3768,6 @@ getCollations(Archive *fout, int *numCollations)
 	 * system-defined collations at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, collname, "
 					  "collnamespace, "
 					  "(%s collowner) AS rolname "
@@ -3800,9 +3844,6 @@ getConversions(Archive *fout, int *numConversions)
 	 * system-defined conversions at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, conname, "
 					  "connamespace, "
 					  "(%s conowner) AS rolname "
@@ -3872,9 +3913,6 @@ getOpclasses(Archive *fout, int *numOpclasses)
 	 * system-defined opclasses at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 70300)
 	{
 		appendPQExpBuffer(query, "SELECT tableoid, oid, opcname, "
@@ -3979,9 +4017,6 @@ getOpfamilies(Archive *fout, int *numOpfamilies)
 	 * system-defined opfamilies at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, opfname, "
 					  "opfnamespace, "
 					  "(%s opfowner) AS rolname "
@@ -4056,9 +4091,6 @@ getAggregates(Archive *fout, int *numAggs)
 	int			i_rolname;
 	int			i_aggacl;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * Find all user-defined aggregates.  See comment in getFuncs() for the
 	 * rationale behind the filtering logic.
@@ -4215,9 +4247,6 @@ getFuncs(Archive *fout, int *numFuncs)
 	int			i_prorettype;
 	int			i_proacl;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * Find all interesting functions.  This is a bit complicated:
 	 *
@@ -4404,9 +4433,6 @@ getTables(Archive *fout, int *numTables)
 	int			i_reloftype;
 	int			i_relpages;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/*
 	 * Find all the tables and table-like objects.
 	 *
@@ -4910,9 +4936,7 @@ getTables(Archive *fout, int *numTables)
 			resetPQExpBuffer(query);
 			appendPQExpBuffer(query,
 							  "LOCK TABLE %s IN ACCESS SHARE MODE",
-							  fmtQualifiedId(fout->remoteVersion,
-										tblinfo[i].dobj.namespace->dobj.name,
-											 tblinfo[i].dobj.name));
+							  fmtQualifiedDumpable(&tblinfo[i]));
 			ExecuteSqlStatement(fout, query->data);
 		}
 
@@ -4983,13 +5007,9 @@ getInherits(Archive *fout, int *numInherits)
 	int			i;
 	PQExpBuffer query = createPQExpBuffer();
 	InhInfo    *inhinfo;
-
 	int			i_inhrelid;
 	int			i_inhparent;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	/* find all the inheritance information */
 
 	appendPQExpBuffer(query, "SELECT inhrelid, inhparent FROM pg_inherits");
@@ -5072,9 +5092,6 @@ getIndexes(Archive *fout, TableInfo tblinfo[], int numTables)
 			write_msg(NULL, "reading indexes for table \"%s\"\n",
 					  tbinfo->dobj.name);
 
-		/* Make sure we are in proper schema so indexdef is right */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		/*
 		 * The point of the messy-looking outer join is to find a constraint
 		 * that is related by an internal dependency link to the index. If we
@@ -5405,12 +5422,6 @@ getConstraints(Archive *fout, TableInfo tblinfo[], int numTables)
 			write_msg(NULL, "reading foreign key constraints for table \"%s\"\n",
 					  tbinfo->dobj.name);
 
-		/*
-		 * select table schema to ensure constraint expr is qualified if
-		 * needed
-		 */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		resetPQExpBuffer(query);
 		appendPQExpBuffer(query,
 						  "SELECT tableoid, oid, conname, confrelid, "
@@ -5479,12 +5490,6 @@ getDomainConstraints(Archive *fout, TypeInfo *tyinfo)
 	if (fout->remoteVersion < 70300)
 		return;
 
-	/*
-	 * select appropriate schema to ensure names in constraint are properly
-	 * qualified
-	 */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	query = createPQExpBuffer();
 
 	if (fout->remoteVersion >= 90100)
@@ -5587,9 +5592,6 @@ getRules(Archive *fout, int *numRules)
 	int			i_is_instead;
 	int			i_ev_enabled;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 80300)
 	{
 		appendPQExpBuffer(query, "SELECT "
@@ -5743,11 +5745,6 @@ getTriggers(Archive *fout, TableInfo tblinfo[], int numTables)
 			write_msg(NULL, "reading triggers for table \"%s\"\n",
 					  tbinfo->dobj.name);
 
-		/*
-		 * select table schema to ensure regproc name is qualified if needed
-		 */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		resetPQExpBuffer(query);
 		if (fout->remoteVersion >= 90000)
 		{
@@ -5958,9 +5955,6 @@ getEventTriggers(Archive *fout, int *numEventTriggers)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query,
 					  "SELECT e.tableoid, e.oid, evtname, evtenabled, "
 					  "evtevent, (%s evtowner) AS evtowner, "
@@ -6041,9 +6035,6 @@ getProcLangs(Archive *fout, int *numProcLangs)
 	int			i_lanacl;
 	int			i_lanowner;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90000)
 	{
 		/* pg_language has a laninline column */
@@ -6206,9 +6197,6 @@ getCasts(Archive *fout, int *numCasts)
 	int			i_castcontext;
 	int			i_castmethod;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 80400)
 	{
 		appendPQExpBuffer(query, "SELECT tableoid, oid, "
@@ -6359,12 +6347,6 @@ getTableAttrs(Archive *fout, TableInfo *tblinfo, int numTables)
 		if (!tbinfo->interesting)
 			continue;
 
-		/*
-		 * Make sure we are in proper schema for this table; this allows
-		 * correct retrieval of formatted type names and default exprs
-		 */
-		selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 		/* find all the user attributes and their types */
 
 		/*
@@ -6934,9 +6916,6 @@ getTSParsers(Archive *fout, int *numTSParsers)
 	 * system-defined objects at dump-out time.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, prsname, prsnamespace, "
 					  "prsstart::oid, prstoken::oid, "
 					  "prsend::oid, prsheadline::oid, prslextype::oid "
@@ -7019,9 +6998,6 @@ getTSDictionaries(Archive *fout, int *numTSDicts)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, dictname, "
 					  "dictnamespace, (%s dictowner) AS rolname, "
 					  "dicttemplate, dictinitoption "
@@ -7103,9 +7079,6 @@ getTSTemplates(Archive *fout, int *numTSTemplates)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, tmplname, "
 					  "tmplnamespace, tmplinit::oid, tmpllexize::oid "
 					  "FROM pg_ts_template");
@@ -7180,9 +7153,6 @@ getTSConfigurations(Archive *fout, int *numTSConfigs)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, cfgname, "
 					  "cfgnamespace, (%s cfgowner) AS rolname, cfgparser "
 					  "FROM pg_ts_config",
@@ -7258,9 +7228,6 @@ getForeignDataWrappers(Archive *fout, int *numForeignDataWrappers)
 		return NULL;
 	}
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90100)
 	{
 		appendPQExpBuffer(query, "SELECT tableoid, oid, fdwname, "
@@ -7365,9 +7332,6 @@ getForeignServers(Archive *fout, int *numForeignServers)
 		return NULL;
 	}
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT tableoid, oid, srvname, "
 					  "(%s srvowner) AS rolname, "
 					  "srvfdw, srvtype, srvversion, srvacl,"
@@ -7453,9 +7417,6 @@ getDefaultACLs(Archive *fout, int *numDefaultACLs)
 
 	query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query, "SELECT oid, tableoid, "
 					  "(%s defaclrole) AS defaclrole, "
 					  "defaclnamespace, "
@@ -7514,13 +7475,18 @@ getDefaultACLs(Archive *fout, int *numDefaultACLs)
  * dumpComment --
  *
  * This routine is used to dump any comments associated with the
- * object handed to this routine. The routine takes a constant character
- * string for the target part of the comment-creation command, plus
+ * object handed to this routine. The routine takes the object type
+ * and object name (ready to print, except for schema decoration), plus
  * the namespace and owner of the object (for labeling the ArchiveEntry),
  * plus catalog ID and subid which are the lookup key for pg_description,
  * plus the dump ID for the object (for setting a dependency).
  * If a matching pg_description entry is found, it is dumped.
  *
+ * Note: in some cases, such as comments for triggers and rules, the "type"
+ * string really looks like, e.g., "TRIGGER name ON".  This is a bit of a hack
+ * but it doesn't seem worth complicating the API for all callers to make
+ * it cleaner.
+ *
  * Note: although this routine takes a dumpId for dependency purposes,
  * that purpose is just to mark the dependency in the emitted dump file
  * for possible future use by pg_restore.  We do NOT use it for determining
@@ -7529,7 +7495,7 @@ getDefaultACLs(Archive *fout, int *numDefaultACLs)
  * calling ArchiveEntry() for the specified object.
  */
 static void
-dumpComment(Archive *fout, const char *target,
+dumpComment(Archive *fout, const char *type, const char *name,
 			const char *namespace, const char *owner,
 			CatalogId catalogId, int subid, DumpId dumpId)
 {
@@ -7537,7 +7503,7 @@ dumpComment(Archive *fout, const char *target,
 	int			ncomments;
 
 	/* Comments are schema not data ... except blob comments are data */
-	if (strncmp(target, "LARGE OBJECT ", 13) != 0)
+	if (strcmp(type, "LARGE OBJECT") != 0)
 	{
 		if (dataOnly)
 			return;
@@ -7566,24 +7532,31 @@ dumpComment(Archive *fout, const char *target,
 	if (ncomments > 0)
 	{
 		PQExpBuffer query = createPQExpBuffer();
+		PQExpBuffer tag = createPQExpBuffer();
 
-		appendPQExpBuffer(query, "COMMENT ON %s IS ", target);
+		appendPQExpBuffer(query, "COMMENT ON %s ", type);
+		if (namespace && *namespace)
+			appendPQExpBuffer(query, "%s.", fmtId(namespace));
+		appendPQExpBuffer(query, "%s IS ", name);
 		appendStringLiteralAH(query, comments->descr, fout);
 		appendPQExpBuffer(query, ";\n");
 
+		appendPQExpBuffer(tag, "%s %s", type, name);
+
 		/*
 		 * We mark comments as SECTION_NONE because they really belong in the
 		 * same section as their parent, whether that is pre-data or
 		 * post-data.
 		 */
 		ArchiveEntry(fout, nilCatalogId, createDumpId(),
-					 target, namespace, NULL, owner,
+					 tag->data, namespace, NULL, owner,
 					 false, "COMMENT", SECTION_NONE,
 					 query->data, "", NULL,
 					 &(dumpId), 1,
 					 NULL, NULL);
 
 		destroyPQExpBuffer(query);
+		destroyPQExpBuffer(tag);
 	}
 }
 
@@ -7600,7 +7573,7 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 	CommentItem *comments;
 	int			ncomments;
 	PQExpBuffer query;
-	PQExpBuffer target;
+	PQExpBuffer tag;
 
 	/* Comments are SCHEMA not data */
 	if (dataOnly)
@@ -7617,7 +7590,7 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 		return;
 
 	query = createPQExpBuffer();
-	target = createPQExpBuffer();
+	tag = createPQExpBuffer();
 
 	while (ncomments > 0)
 	{
@@ -7626,17 +7599,18 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 
 		if (objsubid == 0)
 		{
-			resetPQExpBuffer(target);
-			appendPQExpBuffer(target, "%s %s", reltypename,
+			resetPQExpBuffer(tag);
+			appendPQExpBuffer(tag, "%s %s", reltypename,
 							  fmtId(tbinfo->dobj.name));
 
 			resetPQExpBuffer(query);
-			appendPQExpBuffer(query, "COMMENT ON %s IS ", target->data);
+			appendPQExpBuffer(query, "COMMENT ON %s %s IS ", reltypename,
+							  fmtQualifiedDumpable(tbinfo));
 			appendStringLiteralAH(query, descr, fout);
 			appendPQExpBuffer(query, ";\n");
 
 			ArchiveEntry(fout, nilCatalogId, createDumpId(),
-						 target->data,
+						 tag->data,
 						 tbinfo->dobj.namespace->dobj.name,
 						 NULL, tbinfo->rolname,
 						 false, "COMMENT", SECTION_NONE,
@@ -7646,19 +7620,21 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 		}
 		else if (objsubid > 0 && objsubid <= tbinfo->numatts)
 		{
-			resetPQExpBuffer(target);
-			appendPQExpBuffer(target, "COLUMN %s.",
+			resetPQExpBuffer(tag);
+			appendPQExpBuffer(tag, "COLUMN %s.",
 							  fmtId(tbinfo->dobj.name));
-			appendPQExpBuffer(target, "%s",
-							  fmtId(tbinfo->attnames[objsubid - 1]));
+			appendPQExpBuffer(tag, "%s", fmtId(tbinfo->attnames[objsubid - 1]));
 
 			resetPQExpBuffer(query);
-			appendPQExpBuffer(query, "COMMENT ON %s IS ", target->data);
+			appendPQExpBuffer(query, "COMMENT ON COLUMN %s.",
+							  fmtQualifiedDumpable(tbinfo));
+			appendPQExpBuffer(query, "%s IS ",
+							  fmtId(tbinfo->attnames[objsubid - 1]));
 			appendStringLiteralAH(query, descr, fout);
 			appendPQExpBuffer(query, ";\n");
 
 			ArchiveEntry(fout, nilCatalogId, createDumpId(),
-						 target->data,
+						 tag->data,
 						 tbinfo->dobj.namespace->dobj.name,
 						 NULL, tbinfo->rolname,
 						 false, "COMMENT", SECTION_NONE,
@@ -7672,7 +7648,7 @@ dumpTableComment(Archive *fout, TableInfo *tbinfo,
 	}
 
 	destroyPQExpBuffer(query);
-	destroyPQExpBuffer(target);
+	destroyPQExpBuffer(tag);
 }
 
 /*
@@ -7787,11 +7763,6 @@ collectComments(Archive *fout, CommentItem **items)
 	int			i;
 	CommentItem *comments;
 
-	/*
-	 * Note we do NOT change source schema here; preserve the caller's
-	 * setting, instead.
-	 */
-
 	query = createPQExpBuffer();
 
 	if (fout->remoteVersion >= 70300)
@@ -7976,7 +7947,6 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 {
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	char	   *qnspname;
 
 	/* Skip if not to be dumped */
@@ -7989,7 +7959,6 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qnspname = pg_strdup(fmtId(nspinfo->dobj.name));
 
@@ -7997,10 +7966,9 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 
 	appendPQExpBuffer(q, "CREATE SCHEMA %s;\n", qnspname);
 
-	appendPQExpBuffer(labelq, "SCHEMA %s", qnspname);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &nspinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &nspinfo->dobj,
+										"SCHEMA", qnspname, NULL);
 
 	ArchiveEntry(fout, nspinfo->dobj.catId, nspinfo->dobj.dumpId,
 				 nspinfo->dobj.name,
@@ -8012,22 +7980,21 @@ dumpNamespace(Archive *fout, NamespaceInfo *nspinfo)
 				 NULL, NULL);
 
 	/* Dump Schema Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "SCHEMA", qnspname,
 				NULL, nspinfo->rolname,
 				nspinfo->dobj.catId, 0, nspinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "SCHEMA", qnspname,
 				 NULL, nspinfo->rolname,
 				 nspinfo->dobj.catId, 0, nspinfo->dobj.dumpId);
 
 	dumpACL(fout, nspinfo->dobj.catId, nspinfo->dobj.dumpId, "SCHEMA",
-			qnspname, NULL, labelq->data, NULL,
+			qnspname, NULL, NULL,
 			nspinfo->rolname, nspinfo->nspacl);
 
 	free(qnspname);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 }
 
 /*
@@ -8039,7 +8006,6 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 {
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	char	   *qextname;
 
 	/* Skip if not to be dumped */
@@ -8048,7 +8014,6 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qextname = pg_strdup(fmtId(extinfo->dobj.name));
 
@@ -8128,8 +8093,6 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 		appendPQExpBuffer(q, ");\n");
 	}
 
-	appendPQExpBuffer(labelq, "EXTENSION %s", qextname);
-
 	ArchiveEntry(fout, extinfo->dobj.catId, extinfo->dobj.dumpId,
 				 extinfo->dobj.name,
 				 NULL, NULL,
@@ -8140,10 +8103,10 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 				 NULL, NULL);
 
 	/* Dump Extension Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "EXTENSION", qextname,
 				NULL, "",
 				extinfo->dobj.catId, 0, extinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "EXTENSION", qextname,
 				 NULL, "",
 				 extinfo->dobj.catId, 0, extinfo->dobj.dumpId);
 
@@ -8151,7 +8114,6 @@ dumpExtension(Archive *fout, ExtensionInfo *extinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 }
 
 /*
@@ -8192,18 +8154,15 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 {
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	int			num,
 				i;
 	Oid			enum_oid;
 	char	   *qtypname;
+	char	   *qualtypname;
 	char	   *label;
 
-	/* Set proper schema search path */
-	selectSourceSchema(fout, "pg_catalog");
-
 	if (fout->remoteVersion >= 90100)
 		appendPQExpBuffer(query, "SELECT oid, enumlabel "
 						  "FROM pg_catalog.pg_enum "
@@ -8222,23 +8181,20 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 	num = PQntuples(res);
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog.
 	 * CASCADE shouldn't be required here as for normal types since the I/O
 	 * functions are generic and do not get dropped.
 	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s;\n", qualtypname);
 
 	if (binary_upgrade)
 		binary_upgrade_set_type_oids_by_type_oid(fout, q,
 												 tyinfo->dobj.catId.oid);
 
 	appendPQExpBuffer(q, "CREATE TYPE %s AS ENUM (",
-					  qtypname);
+					  qualtypname);
 
 	if (!binary_upgrade)
 	{
@@ -8268,19 +8224,16 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 			appendPQExpBuffer(q,
 							  "SELECT binary_upgrade.set_next_pg_enum_oid('%u'::pg_catalog.oid);\n",
 							  enum_oid);
-			appendPQExpBuffer(q, "ALTER TYPE %s.",
-							  fmtId(tyinfo->dobj.namespace->dobj.name));
-			appendPQExpBuffer(q, "%s ADD VALUE ",
-							  qtypname);
+			appendPQExpBuffer(q, "ALTER TYPE %s ADD VALUE ", qualtypname);
 			appendStringLiteralAH(q, label, fout);
 			appendPQExpBuffer(q, ";\n\n");
 		}
 	}
 
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
 				 tyinfo->dobj.name,
@@ -8293,23 +8246,24 @@ dumpEnumType(Archive *fout, TypeInfo *tyinfo)
 				 NULL, NULL);
 
 	/* Dump Type Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TYPE", qtypname,
 				tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "TYPE", qtypname,
 				 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-			qtypname, NULL, labelq->data,
+			qtypname, NULL,
 			tyinfo->dobj.namespace->dobj.name,
 			tyinfo->rolname, tyinfo->typacl);
 
 	PQclear(res);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -8321,19 +8275,13 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 {
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	Oid			collationOid;
 	char	   *qtypname;
+	char	   *qualtypname;
 	char	   *procname;
 
-	/*
-	 * select appropriate schema to ensure names in CREATE are properly
-	 * qualified
-	 */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	appendPQExpBuffer(query,
 			"SELECT pg_catalog.format_type(rngsubtype, NULL) AS rngsubtype, "
 					  "opc.opcname AS opcname, "
@@ -8352,23 +8300,20 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 	res = ExecuteSqlQueryForSingleRow(fout, query->data);
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog.
 	 * CASCADE shouldn't be required here as for normal types since the I/O
 	 * functions are generic and do not get dropped.
 	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s;\n", qualtypname);
 
 	if (binary_upgrade)
 		binary_upgrade_set_type_oids_by_type_oid(fout,
 												 q, tyinfo->dobj.catId.oid);
 
 	appendPQExpBuffer(q, "CREATE TYPE %s AS RANGE (",
-					  qtypname);
+					  qualtypname);
 
 	appendPQExpBuffer(q, "\n    subtype = %s",
 					  PQgetvalue(res, 0, PQfnumber(res, "rngsubtype")));
@@ -8379,7 +8324,6 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 		char	   *opcname = PQgetvalue(res, 0, PQfnumber(res, "opcname"));
 		char	   *nspname = PQgetvalue(res, 0, PQfnumber(res, "opcnsp"));
 
-		/* always schema-qualify, don't try to be smart */
 		appendPQExpBuffer(q, ",\n    subtype_opclass = %s.",
 						  fmtId(nspname));
 		appendPQExpBuffer(q, "%s", fmtId(opcname));
@@ -8391,13 +8335,8 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 		CollInfo   *coll = findCollationByOid(collationOid);
 
 		if (coll)
-		{
-			/* always schema-qualify, don't try to be smart */
-			appendPQExpBuffer(q, ",\n    collation = %s.",
-							  fmtId(coll->dobj.namespace->dobj.name));
-			appendPQExpBuffer(q, "%s",
-							  fmtId(coll->dobj.name));
-		}
+			appendPQExpBuffer(q, ",\n    collation = %s",
+							  fmtQualifiedDumpable(coll));
 	}
 
 	procname = PQgetvalue(res, 0, PQfnumber(res, "rngcanonical"));
@@ -8410,10 +8349,10 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 
 	appendPQExpBuffer(q, "\n);\n");
 
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
 				 tyinfo->dobj.name,
@@ -8426,23 +8365,24 @@ dumpRangeType(Archive *fout, TypeInfo *tyinfo)
 				 NULL, NULL);
 
 	/* Dump Type Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TYPE", qtypname,
 				tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "TYPE", qtypname,
 				 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-			qtypname, NULL, labelq->data,
+			qtypname, NULL,
 			tyinfo->dobj.namespace->dobj.name,
 			tyinfo->rolname, tyinfo->typacl);
 
 	PQclear(res);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -8459,30 +8399,25 @@ dumpUndefinedType(Archive *fout, TypeInfo *tyinfo)
 {
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	char	   *qtypname;
+	char	   *qualtypname;
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog.
-	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s;\n", qualtypname);
 
 	if (binary_upgrade)
 		binary_upgrade_set_type_oids_by_type_oid(fout,
 												 q, tyinfo->dobj.catId.oid);
 
 	appendPQExpBuffer(q, "CREATE TYPE %s;\n",
-					  qtypname);
-
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
+					  qualtypname);
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
 				 tyinfo->dobj.name,
@@ -8495,21 +8430,22 @@ dumpUndefinedType(Archive *fout, TypeInfo *tyinfo)
 				 NULL, NULL);
 
 	/* Dump Type Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TYPE", qtypname,
 				tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "TYPE", qtypname,
 				 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-			qtypname, NULL, labelq->data,
+			qtypname, NULL,
 			tyinfo->dobj.namespace->dobj.name,
 			tyinfo->rolname, tyinfo->typacl);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -8521,10 +8457,10 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 {
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	char	   *qtypname;
+	char	   *qualtypname;
 	char	   *typlen;
 	char	   *typinput;
 	char	   *typoutput;
@@ -8548,9 +8484,6 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 	char	   *typdefault;
 	bool		typdefault_is_literal = false;
 
-	/* Set proper schema search path so regproc references list correctly */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	/* Fetch type-specific details */
 	if (fout->remoteVersion >= 90100)
 	{
@@ -8758,17 +8691,14 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 		typdefault = NULL;
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog.
 	 * The reason we include CASCADE is that the circular dependency between
 	 * the type and its I/O functions makes it impossible to drop the type any
 	 * other way.
 	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s CASCADE;\n",
-					  qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s CASCADE;\n", qualtypname);
 
 	/* We might already have a shell type, but setting pg_type_oid is harmless */
 	if (binary_upgrade)
@@ -8778,7 +8708,7 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 	appendPQExpBuffer(q,
 					  "CREATE TYPE %s (\n"
 					  "    INTERNALLENGTH = %s",
-					  qtypname,
+					  qualtypname,
 					  (strcmp(typlen, "-1") == 0) ? "variable" : typlen);
 
 	if (fout->remoteVersion >= 70300)
@@ -8822,8 +8752,6 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 	{
 		char	   *elemType;
 
-		/* reselect schema in case changed by function dump */
-		selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
 		elemType = getFormattedTypeName(fout, tyinfo->typelem, zeroAsOpaque);
 		appendPQExpBuffer(q, ",\n    ELEMENT = %s", elemType);
 		free(elemType);
@@ -8867,10 +8795,10 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 
 	appendPQExpBuffer(q, "\n);\n");
 
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
 				 tyinfo->dobj.name,
@@ -8883,23 +8811,24 @@ dumpBaseType(Archive *fout, TypeInfo *tyinfo)
 				 NULL, NULL);
 
 	/* Dump Type Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TYPE", qtypname,
 				tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "TYPE", qtypname,
 				 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-			qtypname, NULL, labelq->data,
+			qtypname, NULL,
 			tyinfo->dobj.namespace->dobj.name,
 			tyinfo->rolname, tyinfo->typacl);
 
 	PQclear(res);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -8911,20 +8840,17 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 {
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	int			i;
 	char	   *qtypname;
+	char	   *qualtypname;
 	char	   *typnotnull;
 	char	   *typdefn;
 	char	   *typdefault;
 	Oid			typcollation;
 	bool		typdefault_is_literal = false;
 
-	/* Set proper schema search path so type references list correctly */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	/* Fetch domain specific details */
 	if (fout->remoteVersion >= 90100)
 	{
@@ -8972,10 +8898,11 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 												 tyinfo->dobj.catId.oid);
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	appendPQExpBuffer(q,
 					  "CREATE DOMAIN %s AS %s",
-					  qtypname,
+					  qualtypname,
 					  typdefn);
 
 	/* Print collation only if different from base type's collation */
@@ -8985,13 +8912,7 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 
 		coll = findCollationByOid(typcollation);
 		if (coll)
-		{
-			/* always schema-qualify, don't try to be smart */
-			appendPQExpBuffer(q, " COLLATE %s.",
-							  fmtId(coll->dobj.namespace->dobj.name));
-			appendPQExpBuffer(q, "%s",
-							  fmtId(coll->dobj.name));
-		}
+			appendPQExpBuffer(q, " COLLATE %s", fmtQualifiedDumpable(coll));
 	}
 
 	if (typnotnull[0] == 't')
@@ -9022,18 +8943,12 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 
 	appendPQExpBuffer(q, ";\n");
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP DOMAIN %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
-
-	appendPQExpBuffer(labelq, "DOMAIN %s", qtypname);
+	appendPQExpBuffer(delq, "DROP DOMAIN %s;\n", qualtypname);
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"DOMAIN", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
 				 tyinfo->dobj.name,
@@ -9046,22 +8961,23 @@ dumpDomain(Archive *fout, TypeInfo *tyinfo)
 				 NULL, NULL);
 
 	/* Dump Domain Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "DOMAIN", qtypname,
 				tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "DOMAIN", qtypname,
 				 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-			qtypname, NULL, labelq->data,
+			qtypname, NULL,
 			tyinfo->dobj.namespace->dobj.name,
 			tyinfo->rolname, tyinfo->typacl);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 }
 
 /*
@@ -9075,10 +8991,10 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer dropped = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
 	PQExpBuffer query = createPQExpBuffer();
 	PGresult   *res;
 	char	   *qtypname;
+	char	   *qualtypname;
 	int			ntups;
 	int			i_attname;
 	int			i_atttypdefn;
@@ -9089,9 +9005,6 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	int			i;
 	int			actual_atts;
 
-	/* Set proper schema search path so type references list correctly */
-	selectSourceSchema(fout, tyinfo->dobj.namespace->dobj.name);
-
 	/* Fetch type specific details */
 	if (fout->remoteVersion >= 90100)
 	{
@@ -9151,9 +9064,10 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	}
 
 	qtypname = pg_strdup(fmtId(tyinfo->dobj.name));
+	qualtypname = pg_strdup(fmtQualifiedDumpable(tyinfo));
 
 	appendPQExpBuffer(q, "CREATE TYPE %s AS (",
-					  qtypname);
+					  qualtypname);
 
 	actual_atts = 0;
 	for (i = 0; i < ntups; i++)
@@ -9191,13 +9105,8 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 
 				coll = findCollationByOid(attcollation);
 				if (coll)
-				{
-					/* always schema-qualify, don't try to be smart */
-					appendPQExpBuffer(q, " COLLATE %s.",
-									  fmtId(coll->dobj.namespace->dobj.name));
-					appendPQExpBuffer(q, "%s",
-									  fmtId(coll->dobj.name));
-				}
+					appendPQExpBuffer(q, " COLLATE %s",
+									  fmtQualifiedDumpable(coll));
 			}
 		}
 		else
@@ -9219,11 +9128,11 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 							  "WHERE attname = ", attlen, attalign);
 			appendStringLiteralAH(dropped, attname, fout);
 			appendPQExpBuffer(dropped, "\n  AND attrelid = ");
-			appendStringLiteralAH(dropped, qtypname, fout);
+			appendStringLiteralAH(dropped, qualtypname, fout);
 			appendPQExpBuffer(dropped, "::pg_catalog.regclass;\n");
 
 			appendPQExpBuffer(dropped, "ALTER TYPE %s ",
-							  qtypname);
+							  qualtypname);
 			appendPQExpBuffer(dropped, "DROP ATTRIBUTE %s;\n",
 							  fmtId(attname));
 		}
@@ -9231,18 +9140,12 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	appendPQExpBuffer(q, "\n);\n");
 	appendPQExpBufferStr(q, dropped->data);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TYPE %s.",
-					  fmtId(tyinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s;\n",
-					  qtypname);
-
-	appendPQExpBuffer(labelq, "TYPE %s", qtypname);
+	appendPQExpBuffer(delq, "DROP TYPE %s;\n", qualtypname);
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &tyinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tyinfo->dobj,
+										"TYPE", qtypname,
+										tyinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId,
 				 tyinfo->dobj.name,
@@ -9256,15 +9159,15 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 
 
 	/* Dump Type Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TYPE", qtypname,
 				tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "TYPE", qtypname,
 				 tyinfo->dobj.namespace->dobj.name, tyinfo->rolname,
 				 tyinfo->dobj.catId, 0, tyinfo->dobj.dumpId);
 
 	dumpACL(fout, tyinfo->dobj.catId, tyinfo->dobj.dumpId, "TYPE",
-			qtypname, NULL, labelq->data,
+			qtypname, NULL,
 			tyinfo->dobj.namespace->dobj.name,
 			tyinfo->rolname, tyinfo->typacl);
 
@@ -9272,8 +9175,9 @@ dumpCompositeType(Archive *fout, TypeInfo *tyinfo)
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(dropped);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qtypname);
+	free(qualtypname);
 
 	/* Dump any per-column comments */
 	dumpCompositeTypeColComments(fout, tyinfo);
@@ -9365,7 +9269,9 @@ dumpCompositeTypeColComments(Archive *fout, TypeInfo *tyinfo)
 							  fmtId(attname));
 
 			resetPQExpBuffer(query);
-			appendPQExpBuffer(query, "COMMENT ON %s IS ", target->data);
+			appendPQExpBuffer(query, "COMMENT ON COLUMN %s.",
+							  fmtQualifiedDumpable(tyinfo));
+			appendPQExpBuffer(query, "%s IS ", fmtId(attname));
 			appendStringLiteralAH(query, descr, fout);
 			appendPQExpBuffer(query, ";\n");
 
@@ -9419,7 +9325,7 @@ dumpShellType(Archive *fout, ShellTypeInfo *stinfo)
 										   stinfo->baseType->dobj.catId.oid);
 
 	appendPQExpBuffer(q, "CREATE TYPE %s;\n",
-					  fmtId(stinfo->dobj.name));
+					  fmtQualifiedDumpable(stinfo));
 
 	ArchiveEntry(fout, stinfo->dobj.catId, stinfo->dobj.dumpId,
 				 stinfo->dobj.name,
@@ -9444,10 +9350,8 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 {
 	PQExpBuffer defqry;
 	PQExpBuffer delqry;
-	PQExpBuffer labelq;
 	bool		useParams;
 	char	   *qlanname;
-	char	   *lanschema;
 	FuncInfo   *funcInfo;
 	FuncInfo   *inlineInfo = NULL;
 	FuncInfo   *validatorInfo = NULL;
@@ -9493,20 +9397,9 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 
 	defqry = createPQExpBuffer();
 	delqry = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qlanname = pg_strdup(fmtId(plang->dobj.name));
 
-	/*
-	 * If dumping a HANDLER clause, treat the language as being in the handler
-	 * function's schema; this avoids cluttering the HANDLER clause. Otherwise
-	 * it doesn't really have a schema.
-	 */
-	if (useParams)
-		lanschema = funcInfo->dobj.namespace->dobj.name;
-	else
-		lanschema = NULL;
-
 	appendPQExpBuffer(delqry, "DROP PROCEDURAL LANGUAGE %s;\n",
 					  qlanname);
 
@@ -9516,27 +9409,13 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 						  plang->lanpltrusted ? "TRUSTED " : "",
 						  qlanname);
 		appendPQExpBuffer(defqry, " HANDLER %s",
-						  fmtId(funcInfo->dobj.name));
+						  fmtQualifiedDumpable(funcInfo));
 		if (OidIsValid(plang->laninline))
-		{
-			appendPQExpBuffer(defqry, " INLINE ");
-			/* Cope with possibility that inline is in different schema */
-			if (inlineInfo->dobj.namespace != funcInfo->dobj.namespace)
-				appendPQExpBuffer(defqry, "%s.",
-							   fmtId(inlineInfo->dobj.namespace->dobj.name));
-			appendPQExpBuffer(defqry, "%s",
-							  fmtId(inlineInfo->dobj.name));
-		}
+			appendPQExpBuffer(defqry, " INLINE %s",
+							  fmtQualifiedDumpable(inlineInfo));
 		if (OidIsValid(plang->lanvalidator))
-		{
-			appendPQExpBuffer(defqry, " VALIDATOR ");
-			/* Cope with possibility that validator is in different schema */
-			if (validatorInfo->dobj.namespace != funcInfo->dobj.namespace)
-				appendPQExpBuffer(defqry, "%s.",
-							fmtId(validatorInfo->dobj.namespace->dobj.name));
-			appendPQExpBuffer(defqry, "%s",
-							  fmtId(validatorInfo->dobj.name));
-		}
+			appendPQExpBuffer(defqry, " VALIDATOR %s",
+							  fmtQualifiedDumpable(validatorInfo));
 	}
 	else
 	{
@@ -9554,38 +9433,35 @@ dumpProcLang(Archive *fout, ProcLangInfo *plang)
 	}
 	appendPQExpBuffer(defqry, ";\n");
 
-	appendPQExpBuffer(labelq, "LANGUAGE %s", qlanname);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(defqry, &plang->dobj, labelq->data);
+		binary_upgrade_extension_member(defqry, &plang->dobj,
+										"LANGUAGE", qlanname, NULL);
 
 	ArchiveEntry(fout, plang->dobj.catId, plang->dobj.dumpId,
 				 plang->dobj.name,
-				 lanschema, NULL, plang->lanowner,
+				 NULL, NULL, plang->lanowner,
 				 false, "PROCEDURAL LANGUAGE", SECTION_PRE_DATA,
 				 defqry->data, delqry->data, NULL,
 				 NULL, 0,
 				 NULL, NULL);
 
 	/* Dump Proc Lang Comments and Security Labels */
-	dumpComment(fout, labelq->data,
-				lanschema, plang->lanowner,
+	dumpComment(fout, "LANGUAGE", qlanname,
+				NULL, plang->lanowner,
 				plang->dobj.catId, 0, plang->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
-				 lanschema, plang->lanowner,
+	dumpSecLabel(fout, "LANGUAGE", qlanname,
+				 NULL, plang->lanowner,
 				 plang->dobj.catId, 0, plang->dobj.dumpId);
 
 	if (plang->lanpltrusted)
 		dumpACL(fout, plang->dobj.catId, plang->dobj.dumpId, "LANGUAGE",
-				qlanname, NULL, labelq->data,
-				lanschema,
+				qlanname, NULL, NULL,
 				plang->lanowner, plang->lanacl);
 
 	free(qlanname);
 
 	destroyPQExpBuffer(defqry);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
 }
 
 /*
@@ -9723,7 +9599,6 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delqry;
-	PQExpBuffer labelq;
 	PQExpBuffer asPart;
 	PGresult   *res;
 	char	   *funcsig;		/* identity signature */
@@ -9763,12 +9638,8 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delqry = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	asPart = createPQExpBuffer();
 
-	/* Set proper schema search path so type references list correctly */
-	selectSourceSchema(fout, finfo->dobj.namespace->dobj.name);
-
 	/* Fetch function-specific details */
 	if (fout->remoteVersion >= 90200)
 	{
@@ -9932,6 +9803,15 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 	prorows = PQgetvalue(res, 0, PQfnumber(res, "prorows"));
 	lanname = PQgetvalue(res, 0, PQfnumber(res, "lanname"));
 
+	/*
+	 * Before 7.3, the "C" language name was actually upper case in the
+	 * pg_language catalog.  If we don't down-case it, we'll get a lookup
+	 * failure at restore.
+	 */
+	if (fout->remoteVersion < 70300 &&
+		strcmp(lanname, "C") == 0)
+		lanname = "c";
+
 	/*
 	 * See backend/commands/functioncmds.c for details of how the 'AS' clause
 	 * is used.  In 8.4 and up, an unused probin is NULL (here ""); previous
@@ -10045,14 +9925,14 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 
 	funcsig_tag = format_function_signature(fout, finfo, false);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delqry, "DROP FUNCTION %s.%s;\n",
 					  fmtId(finfo->dobj.namespace->dobj.name),
 					  funcsig);
 
-	appendPQExpBuffer(q, "CREATE FUNCTION %s ", funcfullsig);
+	appendPQExpBuffer(q, "CREATE FUNCTION %s.%s ",
+					  fmtId(finfo->dobj.namespace->dobj.name),
+					  funcfullsig);
+
 	if (funcresult)
 		appendPQExpBuffer(q, "RETURNS %s", funcresult);
 	else
@@ -10139,10 +10019,10 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 
 	appendPQExpBuffer(q, "\n    %s;\n", asPart->data);
 
-	appendPQExpBuffer(labelq, "FUNCTION %s", funcsig);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &finfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &finfo->dobj,
+										"FUNCTION", funcsig,
+										finfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, finfo->dobj.catId, finfo->dobj.dumpId,
 				 funcsig_tag,
@@ -10155,15 +10035,15 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 				 NULL, NULL);
 
 	/* Dump Function Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "FUNCTION", funcsig,
 				finfo->dobj.namespace->dobj.name, finfo->rolname,
 				finfo->dobj.catId, 0, finfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "FUNCTION", funcsig,
 				 finfo->dobj.namespace->dobj.name, finfo->rolname,
 				 finfo->dobj.catId, 0, finfo->dobj.dumpId);
 
 	dumpACL(fout, finfo->dobj.catId, finfo->dobj.dumpId, "FUNCTION",
-			funcsig, NULL, labelq->data,
+			funcsig, NULL,
 			finfo->dobj.namespace->dobj.name,
 			finfo->rolname, finfo->proacl);
 
@@ -10172,7 +10052,6 @@ dumpFunc(Archive *fout, FuncInfo *finfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(asPart);
 	free(funcsig);
 	free(funcsig_tag);
@@ -10196,7 +10075,10 @@ dumpCast(Archive *fout, CastInfo *cast)
 	PQExpBuffer defqry;
 	PQExpBuffer delqry;
 	PQExpBuffer labelq;
+	PQExpBuffer castargs;
 	FuncInfo   *funcInfo = NULL;
+	char	   *sourceType;
+	char	   *targetType;
 
 	/* Skip if not to be dumped */
 	if (!cast->dobj.dump || dataOnly)
@@ -10211,23 +10093,18 @@ dumpCast(Archive *fout, CastInfo *cast)
 						  cast->castfunc);
 	}
 
-	/*
-	 * Make sure we are in proper schema (needed for getFormattedTypeName).
-	 * Casts don't have a schema of their own, so use pg_catalog.
-	 */
-	selectSourceSchema(fout, "pg_catalog");
-
 	defqry = createPQExpBuffer();
 	delqry = createPQExpBuffer();
 	labelq = createPQExpBuffer();
+	castargs = createPQExpBuffer();
 
+	sourceType = getFormattedTypeName(fout, cast->castsource, zeroAsNone);
+	targetType = getFormattedTypeName(fout, cast->casttarget, zeroAsNone);
 	appendPQExpBuffer(delqry, "DROP CAST (%s AS %s);\n",
-					getFormattedTypeName(fout, cast->castsource, zeroAsNone),
-				   getFormattedTypeName(fout, cast->casttarget, zeroAsNone));
+					  sourceType, targetType);
 
 	appendPQExpBuffer(defqry, "CREATE CAST (%s AS %s) ",
-					getFormattedTypeName(fout, cast->castsource, zeroAsNone),
-				   getFormattedTypeName(fout, cast->casttarget, zeroAsNone));
+					  sourceType, targetType);
 
 	switch (cast->castmethod)
 	{
@@ -10243,9 +10120,8 @@ dumpCast(Archive *fout, CastInfo *cast)
 				char	   *fsig = format_function_signature(fout, funcInfo, true);
 
 				/*
-				 * Always qualify the function name, in case it is not in
-				 * pg_catalog schema (format_function_signature won't qualify
-				 * it).
+				 * Always qualify the function name (format_function_signature
+				 * won't qualify it).
 				 */
 				appendPQExpBuffer(defqry, "WITH FUNCTION %s.%s",
 						   fmtId(funcInfo->dobj.namespace->dobj.name), fsig);
@@ -10265,28 +10141,35 @@ dumpCast(Archive *fout, CastInfo *cast)
 	appendPQExpBuffer(defqry, ";\n");
 
 	appendPQExpBuffer(labelq, "CAST (%s AS %s)",
-					getFormattedTypeName(fout, cast->castsource, zeroAsNone),
-				   getFormattedTypeName(fout, cast->casttarget, zeroAsNone));
+					  sourceType, targetType);
+
+	appendPQExpBuffer(castargs, "(%s AS %s)",
+					  sourceType, targetType);
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(defqry, &cast->dobj, labelq->data);
+		binary_upgrade_extension_member(defqry, &cast->dobj,
+										"CAST", castargs->data, NULL);
 
 	ArchiveEntry(fout, cast->dobj.catId, cast->dobj.dumpId,
 				 labelq->data,
-				 "pg_catalog", NULL, "",
+				 NULL, NULL, "",
 				 false, "CAST", SECTION_PRE_DATA,
 				 defqry->data, delqry->data, NULL,
 				 NULL, 0,
 				 NULL, NULL);
 
 	/* Dump Cast Comments */
-	dumpComment(fout, labelq->data,
-				"pg_catalog", "",
+	dumpComment(fout, "CAST", castargs->data,
+				NULL, "",
 				cast->dobj.catId, 0, cast->dobj.dumpId);
 
+	free(sourceType);
+	free(targetType);
+
 	destroyPQExpBuffer(defqry);
 	destroyPQExpBuffer(delqry);
 	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(castargs);
 }
 
 /*
@@ -10299,7 +10182,6 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer oprid;
 	PQExpBuffer details;
 	const char *name;
@@ -10339,21 +10221,17 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	oprid = createPQExpBuffer();
 	details = createPQExpBuffer();
 
-	/* Make sure we are in proper schema so regoperator works correctly */
-	selectSourceSchema(fout, oprinfo->dobj.namespace->dobj.name);
-
 	if (fout->remoteVersion >= 80300)
 	{
 		appendPQExpBuffer(query, "SELECT oprkind, "
 						  "oprcode::pg_catalog.regprocedure, "
 						  "oprleft::pg_catalog.regtype, "
 						  "oprright::pg_catalog.regtype, "
-						  "oprcom::pg_catalog.regoperator, "
-						  "oprnegate::pg_catalog.regoperator, "
+						  "oprcom, "
+						  "oprnegate, "
 						  "oprrest::pg_catalog.regprocedure, "
 						  "oprjoin::pg_catalog.regprocedure, "
 						  "oprcanmerge, oprcanhash "
@@ -10367,8 +10245,8 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 						  "oprcode::pg_catalog.regprocedure, "
 						  "oprleft::pg_catalog.regtype, "
 						  "oprright::pg_catalog.regtype, "
-						  "oprcom::pg_catalog.regoperator, "
-						  "oprnegate::pg_catalog.regoperator, "
+						  "oprcom, "
+						  "oprnegate, "
 						  "oprrest::pg_catalog.regprocedure, "
 						  "oprjoin::pg_catalog.regprocedure, "
 						  "(oprlsortop != 0) AS oprcanmerge, "
@@ -10466,11 +10344,11 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	else
 		appendPQExpBuffer(oprid, ", NONE)");
 
-	name = convertOperatorReference(fout, oprcom);
+	name = getFormattedOperatorName(fout, oprcom);
 	if (name)
 		appendPQExpBuffer(details, ",\n    COMMUTATOR = %s", name);
 
-	name = convertOperatorReference(fout, oprnegate);
+	name = getFormattedOperatorName(fout, oprnegate);
 	if (name)
 		appendPQExpBuffer(details, ",\n    NEGATOR = %s", name);
 
@@ -10488,20 +10366,18 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	if (name)
 		appendPQExpBuffer(details, ",\n    JOIN = %s", name);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delq, "DROP OPERATOR %s.%s;\n",
 					  fmtId(oprinfo->dobj.namespace->dobj.name),
 					  oprid->data);
 
-	appendPQExpBuffer(q, "CREATE OPERATOR %s (\n%s\n);\n",
+	appendPQExpBuffer(q, "CREATE OPERATOR %s.%s (\n%s\n);\n",
+					  fmtId(oprinfo->dobj.namespace->dobj.name),
 					  oprinfo->dobj.name, details->data);
 
-	appendPQExpBuffer(labelq, "OPERATOR %s", oprid->data);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &oprinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &oprinfo->dobj,
+										"OPERATOR", oprid->data,
+										oprinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, oprinfo->dobj.catId, oprinfo->dobj.dumpId,
 				 oprinfo->dobj.name,
@@ -10514,7 +10390,7 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 				 NULL, NULL);
 
 	/* Dump Operator Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "OPERATOR", oprid->data,
 				oprinfo->dobj.namespace->dobj.name, oprinfo->rolname,
 				oprinfo->dobj.catId, 0, oprinfo->dobj.dumpId);
 
@@ -10523,7 +10399,6 @@ dumpOpr(Archive *fout, OprInfo *oprinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(oprid);
 	destroyPQExpBuffer(details);
 }
@@ -10570,65 +10445,42 @@ convertRegProcReference(Archive *fout, const char *proc)
 }
 
 /*
- * Convert an operator cross-reference obtained from pg_operator
+ * getFormattedOperatorName - retrieve the operator name for the
+ * given operator OID (presented in string form).
  *
- * Returns what to print, or NULL to print nothing
+ * Returns an allocated string, or NULL if the given OID is InvalidOid.
+ * Caller is responsible for free'ing result string.
  *
- * In 7.3 and up the input is a REGOPERATOR display; we have to strip the
- * argument-types part, and add OPERATOR() decoration if the name is
- * schema-qualified.  In older versions, the input is just a numeric OID,
- * which we search our operator list for.
+ * What we produce has the format "OPERATOR(schema.oprname)".  This is only
+ * useful in commands where the operator's argument types can be inferred from
+ * context.  We always schema-qualify the name, though.  The predecessor to
+ * this code tried to skip the schema qualification if possible, but that led
+ * to wrong results in corner cases, such as if an operator and its negator
+ * are in different schemas.
  */
-static const char *
-convertOperatorReference(Archive *fout, const char *opr)
+static char *
+getFormattedOperatorName(Archive *fout, const char *oproid)
 {
 	OprInfo    *oprInfo;
+	const char *oprschema;
+	char	   *result;
 
 	/* In all cases "0" means a null reference */
-	if (strcmp(opr, "0") == 0)
+	if (strcmp(oproid, "0") == 0)
 		return NULL;
 
-	if (fout->remoteVersion >= 70300)
-	{
-		char	   *name;
-		char	   *oname;
-		char	   *ptr;
-		bool		inquote;
-		bool		sawdot;
-
-		name = pg_strdup(opr);
-		/* find non-double-quoted left paren, and check for non-quoted dot */
-		inquote = false;
-		sawdot = false;
-		for (ptr = name; *ptr; ptr++)
-		{
-			if (*ptr == '"')
-				inquote = !inquote;
-			else if (*ptr == '.' && !inquote)
-				sawdot = true;
-			else if (*ptr == '(' && !inquote)
-			{
-				*ptr = '\0';
-				break;
-			}
-		}
-		/* If not schema-qualified, don't need to add OPERATOR() */
-		if (!sawdot)
-			return name;
-		oname = pg_malloc(strlen(name) + 11);
-		sprintf(oname, "OPERATOR(%s)", name);
-		free(name);
-		return oname;
-	}
-
-	oprInfo = findOprByOid(atooid(opr));
+	oprInfo = findOprByOid(atooid(oproid));
 	if (oprInfo == NULL)
 	{
 		write_msg(NULL, "WARNING: could not find operator with OID %s\n",
-				  opr);
+				  oproid);
 		return NULL;
 	}
-	return oprInfo->dobj.name;
+
+	oprschema = fmtId(oprInfo->dobj.namespace->dobj.name);
+	result = pg_malloc(strlen(oprschema) + strlen(oprInfo->dobj.name) + 12);
+	sprintf(result, "OPERATOR(%s.%s)", oprschema, oprInfo->dobj.name);
+	return result;
 }
 
 /*
@@ -10668,7 +10520,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	PQExpBuffer nameusing;
 	PGresult   *res;
 	int			ntups;
 	int			i_opcintype;
@@ -10721,10 +10573,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
-
-	/* Make sure we are in proper schema so regoperator works correctly */
-	selectSourceSchema(fout, opcinfo->dobj.namespace->dobj.name);
+	nameusing = createPQExpBuffer();
 
 	/* Get additional fields from the pg_opclass row */
 	if (fout->remoteVersion >= 80300)
@@ -10775,19 +10624,14 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	/* amname will still be needed after we PQclear res */
 	amname = pg_strdup(PQgetvalue(res, 0, i_amname));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delq, "DROP OPERATOR CLASS %s",
-					  fmtId(opcinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s",
-					  fmtId(opcinfo->dobj.name));
+					  fmtQualifiedDumpable(opcinfo));
 	appendPQExpBuffer(delq, " USING %s;\n",
 					  fmtId(amname));
 
 	/* Build the fixed portion of the CREATE command */
 	appendPQExpBuffer(q, "CREATE OPERATOR CLASS %s\n    ",
-					  fmtId(opcinfo->dobj.name));
+					  fmtQualifiedDumpable(opcinfo));
 	if (strcmp(opcdefault, "t") == 0)
 		appendPQExpBuffer(q, "DEFAULT ");
 	appendPQExpBuffer(q, "FOR TYPE %s USING %s",
@@ -10796,8 +10640,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	if (strlen(opcfamilyname) > 0)
 	{
 		appendPQExpBuffer(q, " FAMILY ");
-		if (strcmp(opcfamilynsp, opcinfo->dobj.namespace->dobj.name) != 0)
-			appendPQExpBuffer(q, "%s.", fmtId(opcfamilynsp));
+		appendPQExpBuffer(q, "%s.", fmtId(opcfamilynsp));
 		appendPQExpBuffer(q, "%s", fmtId(opcfamilyname));
 	}
 	appendPQExpBuffer(q, " AS\n    ");
@@ -10915,8 +10758,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 		if (strlen(sortfamily) > 0)
 		{
 			appendPQExpBuffer(q, " FOR ORDER BY ");
-			if (strcmp(sortfamilynsp, opcinfo->dobj.namespace->dobj.name) != 0)
-				appendPQExpBuffer(q, "%s.", fmtId(sortfamilynsp));
+			appendPQExpBuffer(q, "%s.", fmtId(sortfamilynsp));
 			appendPQExpBuffer(q, "%s", fmtId(sortfamily));
 		}
 
@@ -11010,13 +10852,14 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 
 	appendPQExpBuffer(q, ";\n");
 
-	appendPQExpBuffer(labelq, "OPERATOR CLASS %s",
-					  fmtId(opcinfo->dobj.name));
-	appendPQExpBuffer(labelq, " USING %s",
+	appendPQExpBuffer(nameusing, "%s", fmtId(opcinfo->dobj.name));
+	appendPQExpBuffer(nameusing, " USING %s",
 					  fmtId(amname));
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &opcinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &opcinfo->dobj,
+										"OPERATOR CLASS", nameusing->data,
+										opcinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, opcinfo->dobj.catId, opcinfo->dobj.dumpId,
 				 opcinfo->dobj.name,
@@ -11029,7 +10872,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 				 NULL, NULL);
 
 	/* Dump Operator Class Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "OPERATOR CLASS", nameusing->data,
 				opcinfo->dobj.namespace->dobj.name, opcinfo->rolname,
 				opcinfo->dobj.catId, 0, opcinfo->dobj.dumpId);
 
@@ -11039,7 +10882,7 @@ dumpOpclass(Archive *fout, OpclassInfo *opcinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(nameusing);
 }
 
 /*
@@ -11055,7 +10898,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	PQExpBuffer nameusing;
 	PGresult   *res;
 	PGresult   *res_ops;
 	PGresult   *res_procs;
@@ -11090,10 +10933,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
-
-	/* Make sure we are in proper schema so regoperator works correctly */
-	selectSourceSchema(fout, opfinfo->dobj.namespace->dobj.name);
+	nameusing = createPQExpBuffer();
 
 	/*
 	 * Fetch only those opfamily members that are tied directly to the
@@ -11185,19 +11025,14 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	/* amname will still be needed after we PQclear res */
 	amname = pg_strdup(PQgetvalue(res, 0, i_amname));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delq, "DROP OPERATOR FAMILY %s",
-					  fmtId(opfinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s",
-					  fmtId(opfinfo->dobj.name));
+					  fmtQualifiedDumpable(opfinfo));
 	appendPQExpBuffer(delq, " USING %s;\n",
 					  fmtId(amname));
 
 	/* Build the fixed portion of the CREATE command */
 	appendPQExpBuffer(q, "CREATE OPERATOR FAMILY %s",
-					  fmtId(opfinfo->dobj.name));
+					  fmtQualifiedDumpable(opfinfo));
 	appendPQExpBuffer(q, " USING %s;\n",
 					  fmtId(amname));
 
@@ -11207,7 +11042,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	if (PQntuples(res_ops) > 0 || PQntuples(res_procs) > 0)
 	{
 		appendPQExpBuffer(q, "ALTER OPERATOR FAMILY %s",
-						  fmtId(opfinfo->dobj.name));
+						  fmtQualifiedDumpable(opfinfo));
 		appendPQExpBuffer(q, " USING %s ADD\n    ",
 						  fmtId(amname));
 
@@ -11241,8 +11076,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 			if (strlen(sortfamily) > 0)
 			{
 				appendPQExpBuffer(q, " FOR ORDER BY ");
-				if (strcmp(sortfamilynsp, opfinfo->dobj.namespace->dobj.name) != 0)
-					appendPQExpBuffer(q, "%s.", fmtId(sortfamilynsp));
+				appendPQExpBuffer(q, "%s.", fmtId(sortfamilynsp));
 				appendPQExpBuffer(q, "%s", fmtId(sortfamily));
 			}
 
@@ -11282,13 +11116,14 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 		appendPQExpBuffer(q, ";\n");
 	}
 
-	appendPQExpBuffer(labelq, "OPERATOR FAMILY %s",
-					  fmtId(opfinfo->dobj.name));
-	appendPQExpBuffer(labelq, " USING %s",
+	appendPQExpBuffer(nameusing, "%s", fmtId(opfinfo->dobj.name));
+	appendPQExpBuffer(nameusing, " USING %s",
 					  fmtId(amname));
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &opfinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &opfinfo->dobj,
+										"OPERATOR FAMILY", nameusing->data,
+										opfinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, opfinfo->dobj.catId, opfinfo->dobj.dumpId,
 				 opfinfo->dobj.name,
@@ -11301,7 +11136,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 				 NULL, NULL);
 
 	/* Dump Operator Family Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "OPERATOR FAMILY", nameusing->data,
 				opfinfo->dobj.namespace->dobj.name, opfinfo->rolname,
 				opfinfo->dobj.catId, 0, opfinfo->dobj.dumpId);
 
@@ -11311,7 +11146,7 @@ dumpOpfamily(Archive *fout, OpfamilyInfo *opfinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(nameusing);
 }
 
 /*
@@ -11324,7 +11159,7 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qcollname;
 	PGresult   *res;
 	int			i_collcollate;
 	int			i_collctype;
@@ -11338,10 +11173,8 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, collinfo->dobj.namespace->dobj.name);
+	qcollname = pg_strdup(fmtId(collinfo->dobj.name));
 
 	/* Get conversion-specific details */
 	appendPQExpBuffer(query, "SELECT "
@@ -11359,25 +11192,20 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	collcollate = PQgetvalue(res, 0, i_collcollate);
 	collctype = PQgetvalue(res, 0, i_collctype);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP COLLATION %s",
-					  fmtId(collinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(collinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP COLLATION %s;\n",
+					  fmtQualifiedDumpable(collinfo));
 
 	appendPQExpBuffer(q, "CREATE COLLATION %s (lc_collate = ",
-					  fmtId(collinfo->dobj.name));
+					  fmtQualifiedDumpable(collinfo));
 	appendStringLiteralAH(q, collcollate, fout);
 	appendPQExpBuffer(q, ", lc_ctype = ");
 	appendStringLiteralAH(q, collctype, fout);
 	appendPQExpBuffer(q, ");\n");
 
-	appendPQExpBuffer(labelq, "COLLATION %s", fmtId(collinfo->dobj.name));
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &collinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &collinfo->dobj,
+										"COLLATION", qcollname,
+										collinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, collinfo->dobj.catId, collinfo->dobj.dumpId,
 				 collinfo->dobj.name,
@@ -11390,7 +11218,7 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 				 NULL, NULL);
 
 	/* Dump Collation Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "COLLATION", qcollname,
 				collinfo->dobj.namespace->dobj.name, collinfo->rolname,
 				collinfo->dobj.catId, 0, collinfo->dobj.dumpId);
 
@@ -11399,7 +11227,7 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qcollname);
 }
 
 /*
@@ -11412,7 +11240,7 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qconvname;
 	PGresult   *res;
 	int			i_conforencoding;
 	int			i_contoencoding;
@@ -11430,10 +11258,8 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, convinfo->dobj.namespace->dobj.name);
+	qconvname = pg_strdup(fmtId(convinfo->dobj.name));
 
 	/* Get conversion-specific details */
 	appendPQExpBuffer(query, "SELECT "
@@ -11456,27 +11282,22 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 	conproc = PQgetvalue(res, 0, i_conproc);
 	condefault = (PQgetvalue(res, 0, i_condefault)[0] == 't');
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP CONVERSION %s",
-					  fmtId(convinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(convinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP CONVERSION %s;\n",
+					  fmtQualifiedDumpable(convinfo));
 
 	appendPQExpBuffer(q, "CREATE %sCONVERSION %s FOR ",
 					  (condefault) ? "DEFAULT " : "",
-					  fmtId(convinfo->dobj.name));
+					  fmtQualifiedDumpable(convinfo));
 	appendStringLiteralAH(q, conforencoding, fout);
 	appendPQExpBuffer(q, " TO ");
 	appendStringLiteralAH(q, contoencoding, fout);
 	/* regproc is automatically quoted in 7.3 and above */
 	appendPQExpBuffer(q, " FROM %s;\n", conproc);
 
-	appendPQExpBuffer(labelq, "CONVERSION %s", fmtId(convinfo->dobj.name));
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &convinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &convinfo->dobj,
+										"CONVERSION", qconvname,
+										convinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, convinfo->dobj.catId, convinfo->dobj.dumpId,
 				 convinfo->dobj.name,
@@ -11489,7 +11310,7 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 				 NULL, NULL);
 
 	/* Dump Conversion Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "CONVERSION", qconvname,
 				convinfo->dobj.namespace->dobj.name, convinfo->rolname,
 				convinfo->dobj.catId, 0, convinfo->dobj.dumpId);
 
@@ -11498,7 +11319,7 @@ dumpConversion(Archive *fout, ConvInfo *convinfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qconvname);
 }
 
 /*
@@ -11552,7 +11373,6 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	PQExpBuffer query;
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer details;
 	char	   *aggsig;
 	char	   *aggsig_tag;
@@ -11577,18 +11397,14 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	query = createPQExpBuffer();
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	details = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, agginfo->aggfn.dobj.namespace->dobj.name);
-
 	/* Get aggregate-specific details */
 	if (fout->remoteVersion >= 80100)
 	{
 		appendPQExpBuffer(query, "SELECT aggtransfn, "
 						  "aggfinalfn, aggtranstype::pg_catalog.regtype, "
-						  "aggsortop::pg_catalog.regoperator, "
+						  "aggsortop, "
 						  "agginitval, "
 						  "'t'::boolean AS convertok "
 					  "FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "
@@ -11693,27 +11509,25 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 						  aggfinalfn);
 	}
 
-	aggsortop = convertOperatorReference(fout, aggsortop);
+	aggsortop = getFormattedOperatorName(fout, aggsortop);
 	if (aggsortop)
 	{
 		appendPQExpBuffer(details, ",\n    SORTOP = %s",
 						  aggsortop);
 	}
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delq, "DROP AGGREGATE %s.%s;\n",
 					  fmtId(agginfo->aggfn.dobj.namespace->dobj.name),
 					  aggsig);
 
-	appendPQExpBuffer(q, "CREATE AGGREGATE %s (\n%s\n);\n",
+	appendPQExpBuffer(q, "CREATE AGGREGATE %s.%s (\n%s\n);\n",
+					  fmtId(agginfo->aggfn.dobj.namespace->dobj.name),
 					  aggsig, details->data);
 
-	appendPQExpBuffer(labelq, "AGGREGATE %s", aggsig);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &agginfo->aggfn.dobj, labelq->data);
+		binary_upgrade_extension_member(q, &agginfo->aggfn.dobj,
+										"AGGREGATE", aggsig,
+								   agginfo->aggfn.dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, agginfo->aggfn.dobj.catId, agginfo->aggfn.dobj.dumpId,
 				 aggsig_tag,
@@ -11726,10 +11540,10 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 				 NULL, NULL);
 
 	/* Dump Aggregate Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "AGGREGATE", aggsig,
 			agginfo->aggfn.dobj.namespace->dobj.name, agginfo->aggfn.rolname,
 				agginfo->aggfn.dobj.catId, 0, agginfo->aggfn.dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "AGGREGATE", aggsig,
 			agginfo->aggfn.dobj.namespace->dobj.name, agginfo->aggfn.rolname,
 				 agginfo->aggfn.dobj.catId, 0, agginfo->aggfn.dobj.dumpId);
 
@@ -11743,8 +11557,7 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	aggsig = format_function_signature(fout, &agginfo->aggfn, true);
 
 	dumpACL(fout, agginfo->aggfn.dobj.catId, agginfo->aggfn.dobj.dumpId,
-			"FUNCTION",
-			aggsig, NULL, labelq->data,
+			"FUNCTION", aggsig, NULL,
 			agginfo->aggfn.dobj.namespace->dobj.name,
 			agginfo->aggfn.rolname, agginfo->aggfn.proacl);
 
@@ -11756,7 +11569,6 @@ dumpAgg(Archive *fout, AggInfo *agginfo)
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(details);
 }
 
@@ -11769,7 +11581,7 @@ dumpTSParser(Archive *fout, TSParserInfo *prsinfo)
 {
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qprsname;
 
 	/* Skip if not to be dumped */
 	if (!prsinfo->dobj.dump || dataOnly)
@@ -11777,13 +11589,11 @@ dumpTSParser(Archive *fout, TSParserInfo *prsinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, prsinfo->dobj.namespace->dobj.name);
+	qprsname = pg_strdup(fmtId(prsinfo->dobj.name));
 
 	appendPQExpBuffer(q, "CREATE TEXT SEARCH PARSER %s (\n",
-					  fmtId(prsinfo->dobj.name));
+					  fmtQualifiedDumpable(prsinfo));
 
 	appendPQExpBuffer(q, "    START = %s,\n",
 					  convertTSFunction(fout, prsinfo->prsstart));
@@ -11797,19 +11607,13 @@ dumpTSParser(Archive *fout, TSParserInfo *prsinfo)
 	appendPQExpBuffer(q, "    LEXTYPES = %s );\n",
 					  convertTSFunction(fout, prsinfo->prslextype));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TEXT SEARCH PARSER %s",
-					  fmtId(prsinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(prsinfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "TEXT SEARCH PARSER %s",
-					  fmtId(prsinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP TEXT SEARCH PARSER %s;\n",
+					  fmtQualifiedDumpable(prsinfo));
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &prsinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &prsinfo->dobj,
+										"TEXT SEARCH PARSER", qprsname,
+										prsinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, prsinfo->dobj.catId, prsinfo->dobj.dumpId,
 				 prsinfo->dobj.name,
@@ -11822,13 +11626,13 @@ dumpTSParser(Archive *fout, TSParserInfo *prsinfo)
 				 NULL, NULL);
 
 	/* Dump Parser Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TEXT SEARCH PARSER", qprsname,
 				prsinfo->dobj.namespace->dobj.name, "",
 				prsinfo->dobj.catId, 0, prsinfo->dobj.dumpId);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qprsname);
 }
 
 /*
@@ -11840,8 +11644,8 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 {
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer query;
+	char	   *qdictname;
 	PGresult   *res;
 	char	   *nspname;
 	char	   *tmplname;
@@ -11852,11 +11656,11 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	query = createPQExpBuffer();
 
+	qdictname = pg_strdup(fmtId(dictinfo->dobj.name));
+
 	/* Fetch name and namespace of the dictionary's template */
-	selectSourceSchema(fout, "pg_catalog");
 	appendPQExpBuffer(query, "SELECT nspname, tmplname "
 					  "FROM pg_ts_template p, pg_namespace n "
 					  "WHERE p.oid = '%u' AND n.oid = tmplnamespace",
@@ -11865,15 +11669,11 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 	nspname = PQgetvalue(res, 0, 0);
 	tmplname = PQgetvalue(res, 0, 1);
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, dictinfo->dobj.namespace->dobj.name);
-
 	appendPQExpBuffer(q, "CREATE TEXT SEARCH DICTIONARY %s (\n",
-					  fmtId(dictinfo->dobj.name));
+					  fmtQualifiedDumpable(dictinfo));
 
 	appendPQExpBuffer(q, "    TEMPLATE = ");
-	if (strcmp(nspname, dictinfo->dobj.namespace->dobj.name) != 0)
-		appendPQExpBuffer(q, "%s.", fmtId(nspname));
+	appendPQExpBuffer(q, "%s.", fmtId(nspname));
 	appendPQExpBuffer(q, "%s", fmtId(tmplname));
 
 	PQclear(res);
@@ -11884,19 +11684,13 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 
 	appendPQExpBuffer(q, " );\n");
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TEXT SEARCH DICTIONARY %s",
-					  fmtId(dictinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(dictinfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "TEXT SEARCH DICTIONARY %s",
-					  fmtId(dictinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP TEXT SEARCH DICTIONARY %s;\n",
+					  fmtQualifiedDumpable(dictinfo));
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &dictinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &dictinfo->dobj,
+										"TEXT SEARCH DICTIONARY", qdictname,
+										dictinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, dictinfo->dobj.catId, dictinfo->dobj.dumpId,
 				 dictinfo->dobj.name,
@@ -11909,14 +11703,14 @@ dumpTSDictionary(Archive *fout, TSDictInfo *dictinfo)
 				 NULL, NULL);
 
 	/* Dump Dictionary Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TEXT SEARCH DICTIONARY", qdictname,
 				dictinfo->dobj.namespace->dobj.name, dictinfo->rolname,
 				dictinfo->dobj.catId, 0, dictinfo->dobj.dumpId);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qdictname);
 }
 
 /*
@@ -11928,7 +11722,7 @@ dumpTSTemplate(Archive *fout, TSTemplateInfo *tmplinfo)
 {
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qtmplname;
 
 	/* Skip if not to be dumped */
 	if (!tmplinfo->dobj.dump || dataOnly)
@@ -11936,13 +11730,11 @@ dumpTSTemplate(Archive *fout, TSTemplateInfo *tmplinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, tmplinfo->dobj.namespace->dobj.name);
+	qtmplname = pg_strdup(fmtId(tmplinfo->dobj.name));
 
 	appendPQExpBuffer(q, "CREATE TEXT SEARCH TEMPLATE %s (\n",
-					  fmtId(tmplinfo->dobj.name));
+					  fmtQualifiedDumpable(tmplinfo));
 
 	if (tmplinfo->tmplinit != InvalidOid)
 		appendPQExpBuffer(q, "    INIT = %s,\n",
@@ -11950,19 +11742,13 @@ dumpTSTemplate(Archive *fout, TSTemplateInfo *tmplinfo)
 	appendPQExpBuffer(q, "    LEXIZE = %s );\n",
 					  convertTSFunction(fout, tmplinfo->tmpllexize));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TEXT SEARCH TEMPLATE %s",
-					  fmtId(tmplinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(tmplinfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "TEXT SEARCH TEMPLATE %s",
-					  fmtId(tmplinfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP TEXT SEARCH TEMPLATE %s;\n",
+					  fmtQualifiedDumpable(tmplinfo));
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &tmplinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tmplinfo->dobj,
+										"TEXT SEARCH TEMPLATE", qtmplname,
+										tmplinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tmplinfo->dobj.catId, tmplinfo->dobj.dumpId,
 				 tmplinfo->dobj.name,
@@ -11975,13 +11761,13 @@ dumpTSTemplate(Archive *fout, TSTemplateInfo *tmplinfo)
 				 NULL, NULL);
 
 	/* Dump Template Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TEXT SEARCH TEMPLATE", qtmplname,
 				tmplinfo->dobj.namespace->dobj.name, "",
 				tmplinfo->dobj.catId, 0, tmplinfo->dobj.dumpId);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qtmplname);
 }
 
 /*
@@ -11993,8 +11779,8 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 {
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer query;
+	char	   *qcfgname;
 	PGresult   *res;
 	char	   *nspname;
 	char	   *prsname;
@@ -12009,11 +11795,11 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	query = createPQExpBuffer();
 
+	qcfgname = pg_strdup(fmtId(cfginfo->dobj.name));
+
 	/* Fetch name and namespace of the config's parser */
-	selectSourceSchema(fout, "pg_catalog");
 	appendPQExpBuffer(query, "SELECT nspname, prsname "
 					  "FROM pg_ts_parser p, pg_namespace n "
 					  "WHERE p.oid = '%u' AND n.oid = prsnamespace",
@@ -12022,15 +11808,10 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 	nspname = PQgetvalue(res, 0, 0);
 	prsname = PQgetvalue(res, 0, 1);
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, cfginfo->dobj.namespace->dobj.name);
-
 	appendPQExpBuffer(q, "CREATE TEXT SEARCH CONFIGURATION %s (\n",
-					  fmtId(cfginfo->dobj.name));
+					  fmtQualifiedDumpable(cfginfo));
 
-	appendPQExpBuffer(q, "    PARSER = ");
-	if (strcmp(nspname, cfginfo->dobj.namespace->dobj.name) != 0)
-		appendPQExpBuffer(q, "%s.", fmtId(nspname));
+	appendPQExpBuffer(q, "    PARSER = %s.", fmtId(nspname));
 	appendPQExpBuffer(q, "%s );\n", fmtId(prsname));
 
 	PQclear(res);
@@ -12064,7 +11845,7 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 			if (i > 0)
 				appendPQExpBuffer(q, ";\n");
 			appendPQExpBuffer(q, "\nALTER TEXT SEARCH CONFIGURATION %s\n",
-							  fmtId(cfginfo->dobj.name));
+							  fmtQualifiedDumpable(cfginfo));
 			/* tokenname needs quoting, dictname does NOT */
 			appendPQExpBuffer(q, "    ADD MAPPING FOR %s WITH %s",
 							  fmtId(tokenname), dictname);
@@ -12078,19 +11859,13 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 
 	PQclear(res);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "DROP TEXT SEARCH CONFIGURATION %s",
-					  fmtId(cfginfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, ".%s;\n",
-					  fmtId(cfginfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "TEXT SEARCH CONFIGURATION %s",
-					  fmtId(cfginfo->dobj.name));
+	appendPQExpBuffer(delq, "DROP TEXT SEARCH CONFIGURATION %s;\n",
+					  fmtQualifiedDumpable(cfginfo));
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &cfginfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &cfginfo->dobj,
+										"TEXT SEARCH CONFIGURATION", qcfgname,
+										cfginfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, cfginfo->dobj.catId, cfginfo->dobj.dumpId,
 				 cfginfo->dobj.name,
@@ -12103,14 +11878,14 @@ dumpTSConfig(Archive *fout, TSConfigInfo *cfginfo)
 				 NULL, NULL);
 
 	/* Dump Configuration Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "TEXT SEARCH CONFIGURATION", qcfgname,
 				cfginfo->dobj.namespace->dobj.name, cfginfo->rolname,
 				cfginfo->dobj.catId, 0, cfginfo->dobj.dumpId);
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 	destroyPQExpBuffer(query);
+	free(qcfgname);
 }
 
 /*
@@ -12122,7 +11897,6 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 {
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	char	   *qfdwname;
 
 	/* Skip if not to be dumped */
@@ -12131,7 +11905,6 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
 	qfdwname = pg_strdup(fmtId(fdwinfo->dobj.name));
 
@@ -12152,11 +11925,10 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 	appendPQExpBuffer(delq, "DROP FOREIGN DATA WRAPPER %s;\n",
 					  qfdwname);
 
-	appendPQExpBuffer(labelq, "FOREIGN DATA WRAPPER %s",
-					  qfdwname);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &fdwinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &fdwinfo->dobj,
+										"FOREIGN DATA WRAPPER", qfdwname,
+										NULL);
 
 	ArchiveEntry(fout, fdwinfo->dobj.catId, fdwinfo->dobj.dumpId,
 				 fdwinfo->dobj.name,
@@ -12170,13 +11942,12 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 
 	/* Handle the ACL */
 	dumpACL(fout, fdwinfo->dobj.catId, fdwinfo->dobj.dumpId,
-			"FOREIGN DATA WRAPPER",
-			qfdwname, NULL, labelq->data,
+			"FOREIGN DATA WRAPPER", qfdwname, NULL,
 			NULL, fdwinfo->rolname,
 			fdwinfo->fdwacl);
 
 	/* Dump Foreign Data Wrapper Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "FOREIGN DATA WRAPPER", qfdwname,
 				NULL, fdwinfo->rolname,
 				fdwinfo->dobj.catId, 0, fdwinfo->dobj.dumpId);
 
@@ -12184,7 +11955,6 @@ dumpForeignDataWrapper(Archive *fout, FdwInfo *fdwinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
 }
 
 /*
@@ -12196,7 +11966,6 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 {
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
 	PQExpBuffer query;
 	PGresult   *res;
 	char	   *qsrvname;
@@ -12208,13 +11977,11 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 	query = createPQExpBuffer();
 
 	qsrvname = pg_strdup(fmtId(srvinfo->dobj.name));
 
 	/* look up the foreign-data wrapper */
-	selectSourceSchema(fout, "pg_catalog");
 	appendPQExpBuffer(query, "SELECT fdwname "
 					  "FROM pg_foreign_data_wrapper w "
 					  "WHERE w.oid = '%u'",
@@ -12245,10 +12012,9 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 	appendPQExpBuffer(delq, "DROP SERVER %s;\n",
 					  qsrvname);
 
-	appendPQExpBuffer(labelq, "SERVER %s", qsrvname);
-
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &srvinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &srvinfo->dobj,
+										"SERVER", qsrvname, NULL);
 
 	ArchiveEntry(fout, srvinfo->dobj.catId, srvinfo->dobj.dumpId,
 				 srvinfo->dobj.name,
@@ -12262,8 +12028,7 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 
 	/* Handle the ACL */
 	dumpACL(fout, srvinfo->dobj.catId, srvinfo->dobj.dumpId,
-			"FOREIGN SERVER",
-			qsrvname, NULL, labelq->data,
+			"FOREIGN SERVER", qsrvname, NULL,
 			NULL, srvinfo->rolname,
 			srvinfo->srvacl);
 
@@ -12274,7 +12039,7 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 					 srvinfo->dobj.catId, srvinfo->dobj.dumpId);
 
 	/* Dump Foreign Server Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "SERVER", qsrvname,
 				NULL, srvinfo->rolname,
 				srvinfo->dobj.catId, 0, srvinfo->dobj.dumpId);
 
@@ -12282,7 +12047,7 @@ dumpForeignServer(Archive *fout, ForeignServerInfo *srvinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(query);
 }
 
 /*
@@ -12321,8 +12086,6 @@ dumpUserMappings(Archive *fout,
 	 * OPTIONS clause.  A possible alternative is to skip such mappings
 	 * altogether, but it's not clear that that's an improvement.
 	 */
-	selectSourceSchema(fout, "pg_catalog");
-
 	appendPQExpBuffer(query,
 					  "SELECT usename, "
 					  "array_to_string(ARRAY("
@@ -12461,8 +12224,7 @@ dumpDefaultACL(Archive *fout, DefaultACLInfo *daclinfo)
  *		FOREIGN DATA WRAPPER, SERVER, or LARGE OBJECT.
  * 'name' is the formatted name of the object.  Must be quoted etc. already.
  * 'subname' is the formatted name of the sub-object, if any.  Must be quoted.
- * 'tag' is the tag for the archive entry (should be the same tag as would be
- *		used for comments etc; for example "TABLE foo").
+ *		(Currently we assume that subname is only provided for table columns.)
  * 'nspname' is the namespace the object is in (NULL if none).
  * 'owner' is the owner, NULL if there is no owner (for languages).
  * 'acls' is the string read out of the fooacl system catalog field;
@@ -12472,7 +12234,7 @@ dumpDefaultACL(Archive *fout, DefaultACLInfo *daclinfo)
 static void
 dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
 		const char *type, const char *name, const char *subname,
-		const char *tag, const char *nspname, const char *owner,
+		const char *nspname, const char *owner,
 		const char *acls)
 {
 	PQExpBuffer sql;
@@ -12487,21 +12249,31 @@ dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
 
 	sql = createPQExpBuffer();
 
-	if (!buildACLCommands(name, subname, type, acls, owner,
+	if (!buildACLCommands(name, subname, nspname, type, acls, owner,
 						  "", fout->remoteVersion, sql))
 		exit_horribly(NULL,
 					"could not parse ACL list (%s) for object \"%s\" (%s)\n",
 					  acls, name, type);
 
 	if (sql->len > 0)
+	{
+		PQExpBuffer tag = createPQExpBuffer();
+
+		if (subname)
+			appendPQExpBuffer(tag, "COLUMN %s.%s", name, subname);
+		else
+			appendPQExpBuffer(tag, "%s %s", type, name);
+
 		ArchiveEntry(fout, nilCatalogId, createDumpId(),
-					 tag, nspname,
+					 tag->data, nspname,
 					 NULL,
 					 owner ? owner : "",
 					 false, "ACL", SECTION_NONE,
 					 sql->data, "", NULL,
 					 &(objDumpId), 1,
 					 NULL, NULL);
+		destroyPQExpBuffer(tag);
+	}
 
 	destroyPQExpBuffer(sql);
 }
@@ -12510,8 +12282,8 @@ dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
  * dumpSecLabel
  *
  * This routine is used to dump any security labels associated with the
- * object handed to this routine. The routine takes a constant character
- * string for the target part of the security-label command, plus
+ * object handed to this routine. The routine takes the object type
+ * and object name (ready to print, except for schema decoration), plus
  * the namespace and owner of the object (for labeling the ArchiveEntry),
  * plus catalog ID and subid which are the lookup key for pg_seclabel,
  * plus the dump ID for the object (for setting a dependency).
@@ -12525,7 +12297,7 @@ dumpACL(Archive *fout, CatalogId objCatId, DumpId objDumpId,
  * calling ArchiveEntry() for the specified object.
  */
 static void
-dumpSecLabel(Archive *fout, const char *target,
+dumpSecLabel(Archive *fout, const char *type, const char *name,
 			 const char *namespace, const char *owner,
 			 CatalogId catalogId, int subid, DumpId dumpId)
 {
@@ -12539,7 +12311,7 @@ dumpSecLabel(Archive *fout, const char *target,
 		return;
 
 	/* Security labels are schema not data ... except blob labels are data */
-	if (strncmp(target, "LARGE OBJECT ", 13) != 0)
+	if (strcmp(type, "LARGE OBJECT") != 0)
 	{
 		if (dataOnly)
 			return;
@@ -12565,21 +12337,29 @@ dumpSecLabel(Archive *fout, const char *target,
 			continue;
 
 		appendPQExpBuffer(query,
-						  "SECURITY LABEL FOR %s ON %s IS ",
-						  fmtId(labels[i].provider), target);
+						  "SECURITY LABEL FOR %s ON %s ",
+						  fmtId(labels[i].provider), type);
+		if (namespace && *namespace)
+			appendPQExpBuffer(query, "%s.", fmtId(namespace));
+		appendPQExpBuffer(query, "%s IS ", name);
 		appendStringLiteralAH(query, labels[i].label, fout);
 		appendPQExpBuffer(query, ";\n");
 	}
 
 	if (query->len > 0)
 	{
+		PQExpBuffer tag = createPQExpBuffer();
+
+		appendPQExpBuffer(tag, "%s %s", type, name);
 		ArchiveEntry(fout, nilCatalogId, createDumpId(),
-					 target, namespace, NULL, owner,
+					 tag->data, namespace, NULL, owner,
 					 false, "SECURITY LABEL", SECTION_NONE,
 					 query->data, "", NULL,
 					 &(dumpId), 1,
 					 NULL, NULL);
+		destroyPQExpBuffer(tag);
 	}
+
 	destroyPQExpBuffer(query);
 }
 
@@ -12630,13 +12410,14 @@ dumpTableSecLabel(Archive *fout, TableInfo *tbinfo, const char *reltypename)
 		if (objsubid == 0)
 		{
 			appendPQExpBuffer(target, "%s %s", reltypename,
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
 		}
 		else
 		{
 			colname = getAttrName(objsubid, tbinfo);
-			/* first fmtId result must be consumed before calling it again */
-			appendPQExpBuffer(target, "COLUMN %s", fmtId(tbinfo->dobj.name));
+			/* first fmtXXX result must be consumed before calling again */
+			appendPQExpBuffer(target, "COLUMN %s",
+							  fmtQualifiedDumpable(tbinfo));
 			appendPQExpBuffer(target, ".%s", fmtId(colname));
 		}
 		appendPQExpBuffer(query, "SECURITY LABEL FOR %s ON %s IS ",
@@ -12817,7 +12598,6 @@ dumpTable(Archive *fout, TableInfo *tbinfo)
 	{
 		char	   *namecopy;
 		const char *objtype;
-		char	   *acltag;
 
 		if (tbinfo->relkind == RELKIND_SEQUENCE)
 			dumpSequence(fout, tbinfo);
@@ -12827,13 +12607,10 @@ dumpTable(Archive *fout, TableInfo *tbinfo)
 		/* Handle the ACL here */
 		namecopy = pg_strdup(fmtId(tbinfo->dobj.name));
 		objtype = (tbinfo->relkind == RELKIND_SEQUENCE) ? "SEQUENCE" : "TABLE";
-		acltag = pg_malloc(strlen(objtype) + strlen(namecopy) + 2);
-		sprintf(acltag, "%s %s", objtype, namecopy);
 		dumpACL(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId,
-				objtype, namecopy, NULL, acltag,
+				objtype, namecopy, NULL,
 				tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 				tbinfo->relacl);
-		free(acltag);
 
 		/*
 		 * Handle column ACLs, if any.  Note: we pull these with a separate
@@ -12860,15 +12637,12 @@ dumpTable(Archive *fout, TableInfo *tbinfo)
 				char	   *attnamecopy;
 
 				attnamecopy = pg_strdup(fmtId(attname));
-				acltag = pg_malloc(strlen(namecopy) + strlen(attnamecopy) + 9);
-				sprintf(acltag, "COLUMN %s.%s", namecopy, attnamecopy);
 				/* Column's GRANT type is always TABLE */
-				dumpACL(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId, "TABLE",
-						namecopy, attnamecopy, acltag,
+				dumpACL(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId,
+						"TABLE", namecopy, attnamecopy,
 						tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 						attacl);
 				free(attnamecopy);
-				free(acltag);
 			}
 			PQclear(res);
 			destroyPQExpBuffer(query);
@@ -12945,7 +12719,8 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 {
 	PQExpBuffer q = createPQExpBuffer();
 	PQExpBuffer delq = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
+	char	   *qrelname;
+	char	   *qualrelname;
 	int			numParents;
 	TableInfo **parents;
 	int			actual_atts;	/* number of attrs in this CREATE statement */
@@ -12956,8 +12731,8 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 	int			j,
 				k;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
+	qrelname = pg_strdup(fmtId(tbinfo->dobj.name));
+	qualrelname = pg_strdup(fmtQualifiedDumpable(tbinfo));
 
 	if (binary_upgrade)
 		binary_upgrade_set_type_oids_by_rel_oid(fout, q,
@@ -12970,20 +12745,14 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 		reltypename = "VIEW";
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "DROP VIEW %s.",
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s;\n",
-						  fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(delq, "DROP VIEW %s;\n", qualrelname);
 
 		if (binary_upgrade)
 			binary_upgrade_set_pg_class_oids(fout, q,
 											 tbinfo->dobj.catId.oid, false);
 
-		appendPQExpBuffer(q, "CREATE VIEW %s", fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(q, "CREATE VIEW %s", qualrelname);
+
 		if (nonemptyReloptions(tbinfo->reloptions))
 		{
 			appendPQExpBufferStr(q, " WITH (");
@@ -12993,9 +12762,6 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 		result = createViewAsClause(fout, tbinfo);
 		appendPQExpBuffer(q, " AS\n%s;\n", result->data);
 		destroyPQExpBuffer(result);
-
-		appendPQExpBuffer(labelq, "VIEW %s",
-						  fmtId(tbinfo->dobj.name));
 	}
 	else
 	{
@@ -13047,17 +12813,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 		numParents = tbinfo->numParents;
 		parents = tbinfo->parents;
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "DROP %s %s.", reltypename,
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s;\n",
-						  fmtId(tbinfo->dobj.name));
-
-		appendPQExpBuffer(labelq, "%s %s", reltypename,
-						  fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(delq, "DROP %s %s;\n", reltypename, qualrelname);
 
 		if (binary_upgrade)
 			binary_upgrade_set_pg_class_oids(fout, q,
@@ -13067,7 +12823,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 						  tbinfo->relpersistence == RELPERSISTENCE_UNLOGGED ?
 						  "UNLOGGED " : "",
 						  reltypename,
-						  fmtId(tbinfo->dobj.name));
+						  qualrelname);
 
 		/*
 		 * Attach to type, if reloftype; except in case of a binary upgrade,
@@ -13159,13 +12915,8 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 						coll = findCollationByOid(tbinfo->attcollation[j]);
 						if (coll)
-						{
-							/* always schema-qualify, don't try to be smart */
-							appendPQExpBuffer(q, " COLLATE %s.",
-									 fmtId(coll->dobj.namespace->dobj.name));
-							appendPQExpBuffer(q, "%s",
-											  fmtId(coll->dobj.name));
-						}
+							appendPQExpBuffer(q, " COLLATE %s",
+											  fmtQualifiedDumpable(coll));
 					}
 
 					if (has_default)
@@ -13219,11 +12970,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 					if (k > 0)
 						appendPQExpBuffer(q, ", ");
-					if (parentRel->dobj.namespace != tbinfo->dobj.namespace)
-						appendPQExpBuffer(q, "%s.",
-								fmtId(parentRel->dobj.namespace->dobj.name));
-					appendPQExpBuffer(q, "%s",
-									  fmtId(parentRel->dobj.name));
+					appendPQExpBuffer(q, "%s", fmtQualifiedDumpable(parentRel));
 				}
 				appendPQExpBuffer(q, ")");
 			}
@@ -13308,16 +13055,16 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 									  tbinfo->attalign[j]);
 					appendStringLiteralAH(q, tbinfo->attnames[j], fout);
 					appendPQExpBuffer(q, "\n  AND attrelid = ");
-					appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+					appendStringLiteralAH(q, qualrelname, fout);
 					appendPQExpBuffer(q, "::pg_catalog.regclass;\n");
 
 					if (tbinfo->relkind == RELKIND_RELATION)
 						appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-										  fmtId(tbinfo->dobj.name));
+										  qualrelname);
 					else
 						appendPQExpBuffer(q, "ALTER FOREIGN TABLE %s ",
-										  fmtId(tbinfo->dobj.name));
-						
+										  qualrelname);
+
 					appendPQExpBuffer(q, "DROP COLUMN %s;\n",
 									  fmtId(tbinfo->attnames[j]));
 				}
@@ -13330,7 +13077,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 									  "WHERE attname = ");
 					appendStringLiteralAH(q, tbinfo->attnames[j], fout);
 					appendPQExpBuffer(q, "\n  AND attrelid = ");
-					appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+					appendStringLiteralAH(q, qualrelname, fout);
 					appendPQExpBuffer(q, "::pg_catalog.regclass;\n");
 				}
 			}
@@ -13344,7 +13091,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 				appendPQExpBuffer(q, "\n-- For binary upgrade, set up inherited constraint.\n");
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, " ADD CONSTRAINT %s ",
 								  fmtId(constr->dobj.name));
 				appendPQExpBuffer(q, "%s;\n", constr->condef);
@@ -13353,7 +13100,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 								  "WHERE contype = 'c' AND conname = ");
 				appendStringLiteralAH(q, constr->dobj.name, fout);
 				appendPQExpBuffer(q, "\n  AND conrelid = ");
-				appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+				appendStringLiteralAH(q, qualrelname, fout);
 				appendPQExpBuffer(q, "::pg_catalog.regclass;\n");
 			}
 
@@ -13365,12 +13112,9 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 					TableInfo  *parentRel = parents[k];
 
 					appendPQExpBuffer(q, "ALTER TABLE ONLY %s INHERIT ",
-									  fmtId(tbinfo->dobj.name));
-					if (parentRel->dobj.namespace != tbinfo->dobj.namespace)
-						appendPQExpBuffer(q, "%s.",
-								fmtId(parentRel->dobj.namespace->dobj.name));
+									  qualrelname);
 					appendPQExpBuffer(q, "%s;\n",
-									  fmtId(parentRel->dobj.name));
+									  fmtQualifiedDumpable(parentRel));
 				}
 			}
 
@@ -13378,7 +13122,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 			{
 				appendPQExpBuffer(q, "\n-- For binary upgrade, set up typed tables this way.\n");
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s OF %s;\n",
-								  fmtId(tbinfo->dobj.name),
+								  qualrelname,
 								  tbinfo->reloftype);
 			}
 		}
@@ -13399,7 +13143,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 							  "SET relfrozenxid = '%u', relminmxid = '%u'\n"
 							  "WHERE oid = ",
 							  tbinfo->frozenxid, tbinfo->minmxid);
-			appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+			appendStringLiteralAH(q, qualrelname, fout);
 			appendPQExpBuffer(q, "::pg_catalog.regclass;\n");
 
 			if (tbinfo->toast_oid)
@@ -13431,7 +13175,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 			appendPQExpBuffer(q, "UPDATE pg_catalog.pg_class\n"
 							  "SET relispopulated = 't'\n"
 							  "WHERE oid = ");
-			appendStringLiteralAH(q, fmtId(tbinfo->dobj.name), fout);
+			appendStringLiteralAH(q, qualrelname, fout);
 			appendPQExpBuffer(q, "::pg_catalog.regclass;\n");
 		}
 
@@ -13454,7 +13198,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 				tbinfo->notnull[j] && !tbinfo->inhNotNull[j])
 			{
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, "ALTER COLUMN %s SET NOT NULL;\n",
 								  fmtId(tbinfo->attnames[j]));
 			}
@@ -13467,7 +13211,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 			if (tbinfo->attstattarget[j] >= 0)
 			{
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, "ALTER COLUMN %s ",
 								  fmtId(tbinfo->attnames[j]));
 				appendPQExpBuffer(q, "SET STATISTICS %d;\n",
@@ -13504,7 +13248,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 				if (storage != NULL)
 				{
 					appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-									  fmtId(tbinfo->dobj.name));
+									  qualrelname);
 					appendPQExpBuffer(q, "ALTER COLUMN %s ",
 									  fmtId(tbinfo->attnames[j]));
 					appendPQExpBuffer(q, "SET STORAGE %s;\n",
@@ -13518,7 +13262,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 			if (tbinfo->attoptions[j] && tbinfo->attoptions[j][0] != '\0')
 			{
 				appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, "ALTER COLUMN %s ",
 								  fmtId(tbinfo->attnames[j]));
 				appendPQExpBuffer(q, "SET (%s);\n",
@@ -13533,7 +13277,7 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 				tbinfo->attfdwoptions[j][0] != '\0')
 			{
 				appendPQExpBuffer(q, "ALTER FOREIGN TABLE %s ",
-								  fmtId(tbinfo->dobj.name));
+								  qualrelname);
 				appendPQExpBuffer(q, "ALTER COLUMN %s ",
 								  fmtId(tbinfo->attnames[j]));
 				appendPQExpBuffer(q, "OPTIONS (\n    %s\n);\n",
@@ -13543,7 +13287,9 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 	}
 
 	if (binary_upgrade)
-		binary_upgrade_extension_member(q, &tbinfo->dobj, labelq->data);
+		binary_upgrade_extension_member(q, &tbinfo->dobj,
+										reltypename, qrelname,
+										tbinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId,
 				 tbinfo->dobj.name,
@@ -13577,7 +13323,8 @@ dumpTableSchema(Archive *fout, TableInfo *tbinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qrelname);
+	free(qualrelname);
 }
 
 /*
@@ -13590,6 +13337,7 @@ dumpAttrDef(Archive *fout, AttrDefInfo *adinfo)
 	int			adnum = adinfo->adnum;
 	PQExpBuffer q;
 	PQExpBuffer delq;
+	char	   *qualrelname;
 
 	/* Skip if table definition not to be dumped */
 	if (!tbinfo->dobj.dump || dataOnly)
@@ -13602,19 +13350,16 @@ dumpAttrDef(Archive *fout, AttrDefInfo *adinfo)
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
 
+	qualrelname = pg_strdup(fmtQualifiedDumpable(tbinfo));
+
 	appendPQExpBuffer(q, "ALTER TABLE ONLY %s ",
-					  fmtId(tbinfo->dobj.name));
+					  qualrelname);
 	appendPQExpBuffer(q, "ALTER COLUMN %s SET DEFAULT %s;\n",
 					  fmtId(tbinfo->attnames[adnum - 1]),
 					  adinfo->adef_expr);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delq, "ALTER TABLE %s.",
-					  fmtId(tbinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delq, "%s ",
-					  fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delq, "ALTER TABLE %s ",
+					  qualrelname);
 	appendPQExpBuffer(delq, "ALTER COLUMN %s DROP DEFAULT;\n",
 					  fmtId(tbinfo->attnames[adnum - 1]));
 
@@ -13630,6 +13375,7 @@ dumpAttrDef(Archive *fout, AttrDefInfo *adinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
+	free(qualrelname);
 }
 
 /*
@@ -13677,17 +13423,15 @@ dumpIndex(Archive *fout, IndxInfo *indxinfo)
 	bool		is_constraint = (indxinfo->indexconstraint != 0);
 	PQExpBuffer q;
 	PQExpBuffer delq;
-	PQExpBuffer labelq;
+	char	   *qindxname;
 
 	if (dataOnly)
 		return;
 
 	q = createPQExpBuffer();
 	delq = createPQExpBuffer();
-	labelq = createPQExpBuffer();
 
-	appendPQExpBuffer(labelq, "INDEX %s",
-					  fmtId(indxinfo->dobj.name));
+	qindxname = pg_strdup(fmtId(indxinfo->dobj.name));
 
 	/*
 	 * If there's an associated constraint, don't dump the index per se, but
@@ -13709,19 +13453,14 @@ dumpIndex(Archive *fout, IndxInfo *indxinfo)
 		if (indxinfo->indisclustered)
 		{
 			appendPQExpBuffer(q, "\nALTER TABLE %s CLUSTER",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
+			/* index name is not qualified in this syntax */
 			appendPQExpBuffer(q, " ON %s;\n",
-							  fmtId(indxinfo->dobj.name));
+							  qindxname);
 		}
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "DROP INDEX %s.",
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s;\n",
-						  fmtId(indxinfo->dobj.name));
+		appendPQExpBuffer(delq, "DROP INDEX %s;\n",
+						  fmtQualifiedDumpable(indxinfo));
 
 		ArchiveEntry(fout, indxinfo->dobj.catId, indxinfo->dobj.dumpId,
 					 indxinfo->dobj.name,
@@ -13735,7 +13474,7 @@ dumpIndex(Archive *fout, IndxInfo *indxinfo)
 	}
 
 	/* Dump Index Comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "INDEX", qindxname,
 				tbinfo->dobj.namespace->dobj.name,
 				tbinfo->rolname,
 				indxinfo->dobj.catId, 0,
@@ -13744,7 +13483,7 @@ dumpIndex(Archive *fout, IndxInfo *indxinfo)
 
 	destroyPQExpBuffer(q);
 	destroyPQExpBuffer(delq);
-	destroyPQExpBuffer(labelq);
+	free(qindxname);
 }
 
 /*
@@ -13784,7 +13523,7 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 											 indxinfo->dobj.catId.oid, true);
 
 		appendPQExpBuffer(q, "ALTER TABLE ONLY %s\n",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(q, "    ADD CONSTRAINT %s ",
 						  fmtId(coninfo->dobj.name));
 
@@ -13834,19 +13573,14 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 		if (indxinfo->indisclustered)
 		{
 			appendPQExpBuffer(q, "\nALTER TABLE %s CLUSTER",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
+			/* index name is not qualified in this syntax */
 			appendPQExpBuffer(q, " ON %s;\n",
 							  fmtId(indxinfo->dobj.name));
 		}
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "ALTER TABLE ONLY %s.",
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s ",
-						  fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(delq, "ALTER TABLE ONLY %s ",
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(delq, "DROP CONSTRAINT %s;\n",
 						  fmtId(coninfo->dobj.name));
 
@@ -13867,19 +13601,13 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 		 * current table data is not processed
 		 */
 		appendPQExpBuffer(q, "ALTER TABLE ONLY %s\n",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(q, "    ADD CONSTRAINT %s %s;\n",
 						  fmtId(coninfo->dobj.name),
 						  coninfo->condef);
 
-		/*
-		 * DROP must be fully qualified in case same name appears in
-		 * pg_catalog
-		 */
-		appendPQExpBuffer(delq, "ALTER TABLE ONLY %s.",
-						  fmtId(tbinfo->dobj.namespace->dobj.name));
-		appendPQExpBuffer(delq, "%s ",
-						  fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(delq, "ALTER TABLE ONLY %s ",
+						  fmtQualifiedDumpable(tbinfo));
 		appendPQExpBuffer(delq, "DROP CONSTRAINT %s;\n",
 						  fmtId(coninfo->dobj.name));
 
@@ -13902,19 +13630,13 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 		{
 			/* not ONLY since we want it to propagate to children */
 			appendPQExpBuffer(q, "ALTER TABLE %s\n",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
 			appendPQExpBuffer(q, "    ADD CONSTRAINT %s %s;\n",
 							  fmtId(coninfo->dobj.name),
 							  coninfo->condef);
 
-			/*
-			 * DROP must be fully qualified in case same name appears in
-			 * pg_catalog
-			 */
-			appendPQExpBuffer(delq, "ALTER TABLE %s.",
-							  fmtId(tbinfo->dobj.namespace->dobj.name));
-			appendPQExpBuffer(delq, "%s ",
-							  fmtId(tbinfo->dobj.name));
+			appendPQExpBuffer(delq, "ALTER TABLE %s ",
+							  fmtQualifiedDumpable(tbinfo));
 			appendPQExpBuffer(delq, "DROP CONSTRAINT %s;\n",
 							  fmtId(coninfo->dobj.name));
 
@@ -13938,19 +13660,13 @@ dumpConstraint(Archive *fout, ConstraintInfo *coninfo)
 		if (coninfo->separate)
 		{
 			appendPQExpBuffer(q, "ALTER DOMAIN %s\n",
-							  fmtId(tyinfo->dobj.name));
+							  fmtQualifiedDumpable(tyinfo));
 			appendPQExpBuffer(q, "    ADD CONSTRAINT %s %s;\n",
 							  fmtId(coninfo->dobj.name),
 							  coninfo->condef);
 
-			/*
-			 * DROP must be fully qualified in case same name appears in
-			 * pg_catalog
-			 */
-			appendPQExpBuffer(delq, "ALTER DOMAIN %s.",
-							  fmtId(tyinfo->dobj.namespace->dobj.name));
-			appendPQExpBuffer(delq, "%s ",
-							  fmtId(tyinfo->dobj.name));
+			appendPQExpBuffer(delq, "ALTER DOMAIN %s ",
+							  fmtQualifiedDumpable(tyinfo));
 			appendPQExpBuffer(delq, "DROP CONSTRAINT %s;\n",
 							  fmtId(coninfo->dobj.name));
 
@@ -13990,19 +13706,22 @@ static void
 dumpTableConstraintComment(Archive *fout, ConstraintInfo *coninfo)
 {
 	TableInfo  *tbinfo = coninfo->contable;
-	PQExpBuffer labelq = createPQExpBuffer();
+	PQExpBuffer conprefix = createPQExpBuffer();
+	char	   *qtabname;
 
-	appendPQExpBuffer(labelq, "CONSTRAINT %s ",
+	qtabname = pg_strdup(fmtId(tbinfo->dobj.name));
+
+	appendPQExpBuffer(conprefix, "CONSTRAINT %s ON",
 					  fmtId(coninfo->dobj.name));
-	appendPQExpBuffer(labelq, "ON %s",
-					  fmtId(tbinfo->dobj.name));
-	dumpComment(fout, labelq->data,
+
+	dumpComment(fout, conprefix->data, qtabname,
 				tbinfo->dobj.namespace->dobj.name,
 				tbinfo->rolname,
 				coninfo->dobj.catId, 0,
 			 coninfo->separate ? coninfo->dobj.dumpId : tbinfo->dobj.dumpId);
 
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(conprefix);
+	free(qtabname);
 }
 
 /*
@@ -14069,10 +13788,9 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 	bool		cycled;
 	PQExpBuffer query = createPQExpBuffer();
 	PQExpBuffer delqry = createPQExpBuffer();
-	PQExpBuffer labelq = createPQExpBuffer();
+	char	   *qseqname;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
+	qseqname = pg_strdup(fmtId(tbinfo->dobj.name));
 
 	snprintf(bufm, sizeof(bufm), INT64_FORMAT, SEQ_MINVALUE);
 	snprintf(bufx, sizeof(bufx), INT64_FORMAT, SEQ_MAXVALUE);
@@ -14092,7 +13810,7 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 						  "END AS min_value, "
 						  "cache_value, is_cycled FROM %s",
 						  bufx, bufm,
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 	}
 	else
 	{
@@ -14109,7 +13827,7 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 						  "END AS min_value, "
 						  "cache_value, is_cycled FROM %s",
 						  bufx, bufm,
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 	}
 
 	res = ExecuteSqlQuery(fout, query->data, PGRES_TUPLES_OK);
@@ -14142,13 +13860,8 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 	cache = PQgetvalue(res, 0, 5);
 	cycled = (strcmp(PQgetvalue(res, 0, 6), "t") == 0);
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
-	appendPQExpBuffer(delqry, "DROP SEQUENCE %s.",
-					  fmtId(tbinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delqry, "%s;\n",
-					  fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delqry, "DROP SEQUENCE %s;\n",
+					  fmtQualifiedDumpable(tbinfo));
 
 	resetPQExpBuffer(query);
 
@@ -14162,7 +13875,7 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 
 	appendPQExpBuffer(query,
 					  "CREATE SEQUENCE %s\n",
-					  fmtId(tbinfo->dobj.name));
+					  fmtQualifiedDumpable(tbinfo));
 
 	if (fout->remoteVersion >= 80400)
 		appendPQExpBuffer(query, "    START WITH %s\n", startv);
@@ -14185,13 +13898,12 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 
 	appendPQExpBuffer(query, ";\n");
 
-	appendPQExpBuffer(labelq, "SEQUENCE %s", fmtId(tbinfo->dobj.name));
-
 	/* binary_upgrade:	no need to clear TOAST table oid */
 
 	if (binary_upgrade)
 		binary_upgrade_extension_member(query, &tbinfo->dobj,
-										labelq->data);
+										"SEQUENCE", qseqname,
+										tbinfo->dobj.namespace->dobj.name);
 
 	ArchiveEntry(fout, tbinfo->dobj.catId, tbinfo->dobj.dumpId,
 				 tbinfo->dobj.name,
@@ -14223,9 +13935,9 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 		{
 			resetPQExpBuffer(query);
 			appendPQExpBuffer(query, "ALTER SEQUENCE %s",
-							  fmtId(tbinfo->dobj.name));
+							  fmtQualifiedDumpable(tbinfo));
 			appendPQExpBuffer(query, " OWNED BY %s",
-							  fmtId(owning_tab->dobj.name));
+							  fmtQualifiedDumpable(owning_tab));
 			appendPQExpBuffer(query, ".%s;\n",
 						fmtId(owning_tab->attnames[tbinfo->owning_col - 1]));
 
@@ -14242,10 +13954,10 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 	}
 
 	/* Dump Sequence Comments and Security Labels */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "SEQUENCE", qseqname,
 				tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 				tbinfo->dobj.catId, 0, tbinfo->dobj.dumpId);
-	dumpSecLabel(fout, labelq->data,
+	dumpSecLabel(fout, "SEQUENCE", qseqname,
 				 tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 				 tbinfo->dobj.catId, 0, tbinfo->dobj.dumpId);
 
@@ -14253,7 +13965,7 @@ dumpSequence(Archive *fout, TableInfo *tbinfo)
 
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
+	free(qseqname);
 }
 
 /*
@@ -14269,12 +13981,9 @@ dumpSequenceData(Archive *fout, TableDataInfo *tdinfo)
 	bool		called;
 	PQExpBuffer query = createPQExpBuffer();
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 	appendPQExpBuffer(query,
 					  "SELECT last_value, is_called FROM %s",
-					  fmtId(tbinfo->dobj.name));
+					  fmtQualifiedDumpable(tbinfo));
 
 	res = ExecuteSqlQuery(fout, query->data, PGRES_TUPLES_OK);
 
@@ -14292,7 +14001,7 @@ dumpSequenceData(Archive *fout, TableDataInfo *tdinfo)
 
 	resetPQExpBuffer(query);
 	appendPQExpBuffer(query, "SELECT pg_catalog.setval(");
-	appendStringLiteralAH(query, fmtId(tbinfo->dobj.name), fout);
+	appendStringLiteralAH(query, fmtQualifiedDumpable(tbinfo), fout);
 	appendPQExpBuffer(query, ", %s, %s);\n",
 					  last, (called ? "true" : "false"));
 
@@ -14321,7 +14030,8 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 	TableInfo  *tbinfo = tginfo->tgtable;
 	PQExpBuffer query;
 	PQExpBuffer delqry;
-	PQExpBuffer labelq;
+	PQExpBuffer trigprefix;
+	char	   *qtabname;
 	char	   *tgargs;
 	size_t		lentgargs;
 	const char *p;
@@ -14336,17 +14046,14 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 
 	query = createPQExpBuffer();
 	delqry = createPQExpBuffer();
-	labelq = createPQExpBuffer();
+	trigprefix = createPQExpBuffer();
+
+	qtabname = pg_strdup(fmtId(tbinfo->dobj.name));
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delqry, "DROP TRIGGER %s ",
 					  fmtId(tginfo->dobj.name));
-	appendPQExpBuffer(delqry, "ON %s.",
-					  fmtId(tbinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delqry, "%s;\n",
-					  fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delqry, "ON %s;\n",
+					  fmtQualifiedDumpable(tbinfo));
 
 	if (tginfo->tgdef)
 	{
@@ -14410,7 +14117,7 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 			findx++;
 		}
 		appendPQExpBuffer(query, " ON %s\n",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 
 		if (tginfo->tgisconstraint)
 		{
@@ -14476,7 +14183,7 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 	if (tginfo->tgenabled != 't' && tginfo->tgenabled != 'O')
 	{
 		appendPQExpBuffer(query, "\nALTER TABLE %s ",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		switch (tginfo->tgenabled)
 		{
 			case 'D':
@@ -14497,10 +14204,8 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 						  fmtId(tginfo->dobj.name));
 	}
 
-	appendPQExpBuffer(labelq, "TRIGGER %s ",
+	appendPQExpBuffer(trigprefix, "TRIGGER %s ON",
 					  fmtId(tginfo->dobj.name));
-	appendPQExpBuffer(labelq, "ON %s",
-					  fmtId(tbinfo->dobj.name));
 
 	ArchiveEntry(fout, tginfo->dobj.catId, tginfo->dobj.dumpId,
 				 tginfo->dobj.name,
@@ -14512,13 +14217,14 @@ dumpTrigger(Archive *fout, TriggerInfo *tginfo)
 				 NULL, 0,
 				 NULL, NULL);
 
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, trigprefix->data, qtabname,
 				tbinfo->dobj.namespace->dobj.name, tbinfo->rolname,
 				tginfo->dobj.catId, 0, tginfo->dobj.dumpId);
 
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(trigprefix);
+	free(qtabname);
 }
 
 /*
@@ -14530,7 +14236,7 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 {
 	PQExpBuffer query;
 	PQExpBuffer delqry;
-	PQExpBuffer labelq;
+	char	   *qevtname;
 
 	/* Skip if not to be dumped */
 	if (!evtinfo->dobj.dump || dataOnly)
@@ -14538,28 +14244,29 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 
 	query = createPQExpBuffer();
 	delqry = createPQExpBuffer();
-	labelq = createPQExpBuffer();
+
+	qevtname = pg_strdup(fmtId(evtinfo->dobj.name));
 
 	appendPQExpBuffer(query, "CREATE EVENT TRIGGER ");
-	appendPQExpBufferStr(query, fmtId(evtinfo->dobj.name));
+	appendPQExpBuffer(query, "%s", qevtname);
 	appendPQExpBuffer(query, " ON ");
-	appendPQExpBufferStr(query, fmtId(evtinfo->evtevent));
+	appendPQExpBuffer(query, "%s", fmtId(evtinfo->evtevent));
 
 	if (strcmp("", evtinfo->evttags) != 0)
 	{
-		appendPQExpBufferStr(query, "\n         WHEN TAG IN (");
-		appendPQExpBufferStr(query, evtinfo->evttags);
+		appendPQExpBuffer(query, "\n         WHEN TAG IN (");
+		appendPQExpBuffer(query, "%s", evtinfo->evttags);
 		appendPQExpBufferChar(query, ')');
 	}
 
 	appendPQExpBuffer(query, "\n   EXECUTE PROCEDURE ");
-	appendPQExpBufferStr(query, evtinfo->evtfname);
+	appendPQExpBuffer(query, "%s", evtinfo->evtfname);
 	appendPQExpBuffer(query, "();\n");
 
 	if (evtinfo->evtenabled != 'O')
 	{
 		appendPQExpBuffer(query, "\nALTER EVENT TRIGGER %s ",
-						  fmtId(evtinfo->dobj.name));
+						  qevtname);
 		switch (evtinfo->evtenabled)
 		{
 			case 'D':
@@ -14579,10 +14286,7 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 	}
 
 	appendPQExpBuffer(delqry, "DROP EVENT TRIGGER %s;\n",
-					  fmtId(evtinfo->dobj.name));
-
-	appendPQExpBuffer(labelq, "EVENT TRIGGER %s",
-					  fmtId(evtinfo->dobj.name));
+					  qevtname);
 
 	ArchiveEntry(fout, evtinfo->dobj.catId, evtinfo->dobj.dumpId,
 				 evtinfo->dobj.name, NULL, NULL,
@@ -14592,13 +14296,13 @@ dumpEventTrigger(Archive *fout, EventTriggerInfo *evtinfo)
 				 NULL, 0,
 				 NULL, NULL);
 
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, "EVENT TRIGGER", qevtname,
 				NULL, evtinfo->evtowner,
 				evtinfo->dobj.catId, 0, evtinfo->dobj.dumpId);
 
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(delqry);
-	destroyPQExpBuffer(labelq);
+	free(qevtname);
 }
 
 /*
@@ -14612,8 +14316,10 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	PQExpBuffer query;
 	PQExpBuffer cmd;
 	PQExpBuffer delcmd;
-	PQExpBuffer labelq;
+	PQExpBuffer ruleprefix;
+	char	   *qtabname;
 	PGresult   *res;
+	char	   *tag;
 
 	/* Skip if not to be dumped */
 	if (!rinfo->dobj.dump || dataOnly)
@@ -14626,15 +14332,12 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	if (!rinfo->separate)
 		return;
 
-	/*
-	 * Make sure we are in proper schema.
-	 */
-	selectSourceSchema(fout, tbinfo->dobj.namespace->dobj.name);
-
 	query = createPQExpBuffer();
 	cmd = createPQExpBuffer();
 	delcmd = createPQExpBuffer();
-	labelq = createPQExpBuffer();
+	ruleprefix = createPQExpBuffer();
+
+	qtabname = pg_strdup(fmtId(tbinfo->dobj.name));
 
 	if (fout->remoteVersion >= 70300)
 	{
@@ -14667,7 +14370,7 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	 */
 	if (rinfo->ev_enabled != 'O')
 	{
-		appendPQExpBuffer(cmd, "ALTER TABLE %s ", fmtId(tbinfo->dobj.name));
+		appendPQExpBuffer(cmd, "ALTER TABLE %s ", fmtQualifiedDumpable(tbinfo));
 		switch (rinfo->ev_enabled)
 		{
 			case 'A':
@@ -14691,28 +14394,24 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 	if (nonemptyReloptions(rinfo->reloptions))
 	{
 		appendPQExpBuffer(cmd, "ALTER VIEW %s SET (",
-						  fmtId(tbinfo->dobj.name));
+						  fmtQualifiedDumpable(tbinfo));
 		fmtReloptionsArray(fout, cmd, rinfo->reloptions, "");
-		appendPQExpBufferStr(cmd, ");\n");
+		appendPQExpBuffer(cmd, ");\n");
 	}
 
-	/*
-	 * DROP must be fully qualified in case same name appears in pg_catalog
-	 */
 	appendPQExpBuffer(delcmd, "DROP RULE %s ",
 					  fmtId(rinfo->dobj.name));
-	appendPQExpBuffer(delcmd, "ON %s.",
-					  fmtId(tbinfo->dobj.namespace->dobj.name));
-	appendPQExpBuffer(delcmd, "%s;\n",
-					  fmtId(tbinfo->dobj.name));
+	appendPQExpBuffer(delcmd, "ON %s;\n",
+					  fmtQualifiedDumpable(tbinfo));
 
-	appendPQExpBuffer(labelq, "RULE %s",
+	appendPQExpBuffer(ruleprefix, "RULE %s ON",
 					  fmtId(rinfo->dobj.name));
-	appendPQExpBuffer(labelq, " ON %s",
-					  fmtId(tbinfo->dobj.name));
+
+	tag = pg_malloc(strlen(tbinfo->dobj.name) + strlen(rinfo->dobj.name) + 2);
+	sprintf(tag, "%s %s", tbinfo->dobj.name, rinfo->dobj.name);
 
 	ArchiveEntry(fout, rinfo->dobj.catId, rinfo->dobj.dumpId,
-				 rinfo->dobj.name,
+				 tag,
 				 tbinfo->dobj.namespace->dobj.name,
 				 NULL,
 				 tbinfo->rolname, false,
@@ -14722,17 +14421,19 @@ dumpRule(Archive *fout, RuleInfo *rinfo)
 				 NULL, NULL);
 
 	/* Dump rule comments */
-	dumpComment(fout, labelq->data,
+	dumpComment(fout, ruleprefix->data, qtabname,
 				tbinfo->dobj.namespace->dobj.name,
 				tbinfo->rolname,
 				rinfo->dobj.catId, 0, rinfo->dobj.dumpId);
 
 	PQclear(res);
 
+	free(tag);
 	destroyPQExpBuffer(query);
 	destroyPQExpBuffer(cmd);
 	destroyPQExpBuffer(delcmd);
-	destroyPQExpBuffer(labelq);
+	destroyPQExpBuffer(ruleprefix);
+	free(qtabname);
 }
 
 /*
@@ -14764,9 +14465,6 @@ getExtensionMembership(Archive *fout, ExtensionInfo extinfo[],
 	if (numExtensions == 0)
 		return;
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	query = createPQExpBuffer();
 
 	/* refclassid constraint is redundant but may speed the search */
@@ -14963,9 +14661,6 @@ processExtensionTables(Archive *fout, ExtensionInfo extinfo[],
 	 * recreated after the data has been loaded.
 	 */
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	query = createPQExpBuffer();
 
 	printfPQExpBuffer(query,
@@ -15035,9 +14730,6 @@ getDependencies(Archive *fout)
 	if (g_verbose)
 		write_msg(NULL, "reading dependency data\n");
 
-	/* Make sure we are in proper schema */
-	selectSourceSchema(fout, "pg_catalog");
-
 	query = createPQExpBuffer();
 
 	/*
@@ -15357,50 +15049,14 @@ findDumpableDependencies(ArchiveHandle *AH, DumpableObject *dobj,
 }
 
 
-/*
- * selectSourceSchema - make the specified schema the active search path
- * in the source database.
- *
- * NB: pg_catalog is explicitly searched after the specified schema;
- * so user names are only qualified if they are cross-schema references,
- * and system names are only qualified if they conflict with a user name
- * in the current schema.
- *
- * Whenever the selected schema is not pg_catalog, be careful to qualify
- * references to system catalogs and types in our emitted commands!
- *
- * This function is called only from selectSourceSchemaOnAH and
- * selectSourceSchema.
- */
-static void
-selectSourceSchema(Archive *fout, const char *schemaName)
-{
-	PQExpBuffer query;
-
-	/* This is checked by the callers already */
-	Assert(schemaName != NULL && *schemaName != '\0');
-
-	/* Not relevant if fetching from pre-7.3 DB */
-	if (fout->remoteVersion < 70300)
-		return;
-
-	query = createPQExpBuffer();
-	appendPQExpBuffer(query, "SET search_path = %s",
-					  fmtId(schemaName));
-	if (strcmp(schemaName, "pg_catalog") != 0)
-		appendPQExpBuffer(query, ", pg_catalog");
-
-	ExecuteSqlStatement(fout, query->data);
-
-	destroyPQExpBuffer(query);
-}
-
 /*
  * getFormattedTypeName - retrieve a nicely-formatted type name for the
- * given type name.
+ * given type OID.
+ *
+ * This does not guarantee to schema-qualify the output, so it should not
+ * be used to create the target object name for CREATE or ALTER commands.
  *
- * NB: in 7.3 and up the result may depend on the currently-selected
- * schema; this is why we don't try to cache the names.
+ * TODO: there might be some value in caching the results.
  */
 static char *
 getFormattedTypeName(Archive *fout, Oid oid, OidOptions opts)
diff --git a/src/bin/pg_dump/pg_dumpall.c b/src/bin/pg_dump/pg_dumpall.c
index e36d6106e6..a93a7edf52 100644
--- a/src/bin/pg_dump/pg_dumpall.c
+++ b/src/bin/pg_dump/pg_dumpall.c
@@ -51,9 +51,10 @@ static void dumpDatabases(PGconn *conn);
 static void dumpTimestamp(char *msg);
 
 static int	runPgDump(const char *dbname);
-static void buildShSecLabels(PGconn *conn, const char *catalog_name,
-				 uint32 objectId, PQExpBuffer buffer,
-				 const char *target, const char *objname);
+static void buildShSecLabels(PGconn *conn,
+				 const char *catalog_name, Oid objectId,
+				 const char *objtype, const char *objname,
+				 PQExpBuffer buffer);
 static PGconn *connectDatabase(const char *dbname, const char *connstr, const char *pghost, const char *pgport,
 	  const char *pguser, enum trivalue prompt_password, bool fail_on_error);
 static char *constructConnStr(const char **keywords, const char **values);
@@ -823,7 +824,8 @@ dumpRoles(PGconn *conn)
 
 		if (!no_security_labels && server_version >= 90200)
 			buildShSecLabels(conn, "pg_authid", auth_oid,
-							 buf, "ROLE", rolename);
+							 "ROLE", rolename,
+							 buf);
 
 		fprintf(OPF, "%s", buf->data);
 	}
@@ -1056,7 +1058,7 @@ dumpTablespaces(PGconn *conn)
 	for (i = 0; i < PQntuples(res); i++)
 	{
 		PQExpBuffer buf = createPQExpBuffer();
-		uint32		spcoid = atooid(PQgetvalue(res, i, 0));
+		Oid			spcoid = atooid(PQgetvalue(res, i, 0));
 		char	   *spcname = PQgetvalue(res, i, 1);
 		char	   *spcowner = PQgetvalue(res, i, 2);
 		char	   *spclocation = PQgetvalue(res, i, 3);
@@ -1080,11 +1082,12 @@ dumpTablespaces(PGconn *conn)
 							  fspcname, spcoptions);
 
 		if (!skip_acls &&
-			!buildACLCommands(fspcname, NULL, "TABLESPACE", spcacl, spcowner,
+			!buildACLCommands(fspcname, NULL, NULL, "TABLESPACE",
+							  spcacl, spcowner,
 							  "", server_version, buf))
 		{
 			fprintf(stderr, _("%s: could not parse ACL list (%s) for tablespace \"%s\"\n"),
-					progname, spcacl, fspcname);
+					progname, spcacl, spcname);
 			PQfinish(conn);
 			exit_nicely(1);
 		}
@@ -1098,7 +1101,8 @@ dumpTablespaces(PGconn *conn)
 
 		if (!no_security_labels && server_version >= 90200)
 			buildShSecLabels(conn, "pg_tablespace", spcoid,
-							 buf, "TABLESPACE", fspcname);
+							 "TABLESPACE", spcname,
+							 buf);
 
 		fprintf(OPF, "%s", buf->data);
 
@@ -1413,7 +1417,7 @@ dumpCreateDB(PGconn *conn)
 		}
 
 		if (!skip_acls &&
-			!buildACLCommands(fdbname, NULL, "DATABASE", dbacl, dbowner,
+			!buildACLCommands(fdbname, NULL, NULL, "DATABASE", dbacl, dbowner,
 							  "", server_version, buf))
 		{
 			fprintf(stderr, _("%s: could not parse ACL list (%s) for database \"%s\"\n"),
@@ -1727,19 +1731,23 @@ runPgDump(const char *dbname)
  *
  * Build SECURITY LABEL command(s) for an shared object
  *
- * The caller has to provide object type and identifier to select security
- * labels from pg_seclabels system view.
+ * The caller has to provide object type and identity in two separate formats:
+ * catalog_name (e.g., "pg_database") and object OID, as well as
+ * type name (e.g., "DATABASE") and object name (not pre-quoted).
+ *
+ * The command(s) are appended to "buffer".
  */
 static void
-buildShSecLabels(PGconn *conn, const char *catalog_name, uint32 objectId,
-				 PQExpBuffer buffer, const char *target, const char *objname)
+buildShSecLabels(PGconn *conn, const char *catalog_name, Oid objectId,
+				 const char *objtype, const char *objname,
+				 PQExpBuffer buffer)
 {
 	PQExpBuffer sql = createPQExpBuffer();
 	PGresult   *res;
 
 	buildShSecLabelQuery(conn, catalog_name, objectId, sql);
 	res = executeQuery(conn, sql->data);
-	emitShSecLabels(conn, res, buffer, target, objname);
+	emitShSecLabels(conn, res, buffer, objtype, objname);
 
 	PQclear(res);
 	destroyPQExpBuffer(sql);
diff --git a/src/test/regress/expected/collate.linux.utf8.out b/src/test/regress/expected/collate.linux.utf8.out
index 495e4ad448..1e435ce44a 100644
--- a/src/test/regress/expected/collate.linux.utf8.out
+++ b/src/test/regress/expected/collate.linux.utf8.out
@@ -943,12 +943,12 @@ ERROR:  collations are not supported by type integer
 LINE 1: ...ATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "C...
                                                              ^
 SELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
-      relname       |                                           pg_get_indexdef                                           
---------------------+-----------------------------------------------------------------------------------------------------
- collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_test1 USING btree (b)
- collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_test1 USING btree (b COLLATE "C")
- collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_test1 USING btree (b COLLATE "C")
- collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
+      relname       |                                              pg_get_indexdef                                               
+--------------------+------------------------------------------------------------------------------------------------------------
+ collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON public.collate_test1 USING btree (b)
+ collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON public.collate_test1 USING btree (b COLLATE "C")
+ collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON public.collate_test1 USING btree (b COLLATE "C")
+ collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON public.collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
 (4 rows)
 
 -- schema manipulation commands
diff --git a/src/test/regress/expected/collate.out b/src/test/regress/expected/collate.out
index 91d574dbe4..49a8561e17 100644
--- a/src/test/regress/expected/collate.out
+++ b/src/test/regress/expected/collate.out
@@ -572,12 +572,12 @@ ERROR:  collations are not supported by type integer
 LINE 1: ...ATE INDEX collate_test1_idx6 ON collate_test1 ((a COLLATE "P...
                                                              ^
 SELECT relname, pg_get_indexdef(oid) FROM pg_class WHERE relname LIKE 'collate_test%_idx%' ORDER BY 1;
-      relname       |                                           pg_get_indexdef                                           
---------------------+-----------------------------------------------------------------------------------------------------
- collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_test1 USING btree (b)
- collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_test1 USING btree (b COLLATE "POSIX")
- collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_test1 USING btree (b COLLATE "POSIX")
- collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
+      relname       |                                                  pg_get_indexdef                                                  
+--------------------+-------------------------------------------------------------------------------------------------------------------
+ collate_test1_idx1 | CREATE INDEX collate_test1_idx1 ON collate_tests.collate_test1 USING btree (b)
+ collate_test1_idx2 | CREATE INDEX collate_test1_idx2 ON collate_tests.collate_test1 USING btree (b COLLATE "POSIX")
+ collate_test1_idx3 | CREATE INDEX collate_test1_idx3 ON collate_tests.collate_test1 USING btree (b COLLATE "POSIX")
+ collate_test1_idx4 | CREATE INDEX collate_test1_idx4 ON collate_tests.collate_test1 USING btree (((b || 'foo'::text)) COLLATE "POSIX")
 (4 rows)
 
 -- foreign keys
diff --git a/src/test/regress/expected/rules.out b/src/test/regress/expected/rules.out
index cfc1e21f4c..2ce5cd59b3 100644
--- a/src/test/regress/expected/rules.out
+++ b/src/test/regress/expected/rules.out
@@ -2145,106 +2145,106 @@ SELECT viewname, definition FROM pg_views WHERE schemaname <> 'information_schem
 
 SELECT tablename, rulename, definition FROM pg_rules
 	ORDER BY tablename, rulename;
-   tablename   |    rulename     |                                                                                     definition                                                                                     
----------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- pg_settings   | pg_settings_n   | CREATE RULE pg_settings_n AS                                                                                                                                                      +
-               |                 |     ON UPDATE TO pg_settings DO INSTEAD NOTHING;
- pg_settings   | pg_settings_u   | CREATE RULE pg_settings_u AS                                                                                                                                                      +
-               |                 |     ON UPDATE TO pg_settings                                                                                                                                                      +
+   tablename   |    rulename     |                                                                                        definition                                                                                         
+---------------+-----------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ pg_settings   | pg_settings_n   | CREATE RULE pg_settings_n AS                                                                                                                                                             +
+               |                 |     ON UPDATE TO pg_catalog.pg_settings DO INSTEAD NOTHING;
+ pg_settings   | pg_settings_u   | CREATE RULE pg_settings_u AS                                                                                                                                                             +
+               |                 |     ON UPDATE TO pg_catalog.pg_settings                                                                                                                                                  +
                |                 |    WHERE (new.name = old.name) DO  SELECT set_config(old.name, new.setting, false) AS set_config;
- rtest_emp     | rtest_emp_del   | CREATE RULE rtest_emp_del AS                                                                                                                                                      +
-               |                 |     ON DELETE TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)                                                                                      +
+ rtest_emp     | rtest_emp_del   | CREATE RULE rtest_emp_del AS                                                                                                                                                             +
+               |                 |     ON DELETE TO public.rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)                                                                                      +
                |                 |   VALUES (old.ename, "current_user"(), 'fired'::bpchar, '$0.00'::money, old.salary);
- rtest_emp     | rtest_emp_ins   | CREATE RULE rtest_emp_ins AS                                                                                                                                                      +
-               |                 |     ON INSERT TO rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)                                                                                      +
+ rtest_emp     | rtest_emp_ins   | CREATE RULE rtest_emp_ins AS                                                                                                                                                             +
+               |                 |     ON INSERT TO public.rtest_emp DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)                                                                                      +
                |                 |   VALUES (new.ename, "current_user"(), 'hired'::bpchar, new.salary, '$0.00'::money);
- rtest_emp     | rtest_emp_upd   | CREATE RULE rtest_emp_upd AS                                                                                                                                                      +
-               |                 |     ON UPDATE TO rtest_emp                                                                                                                                                        +
-               |                 |    WHERE (new.salary <> old.salary) DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)                                                                             +
+ rtest_emp     | rtest_emp_upd   | CREATE RULE rtest_emp_upd AS                                                                                                                                                             +
+               |                 |     ON UPDATE TO public.rtest_emp                                                                                                                                                        +
+               |                 |    WHERE (new.salary <> old.salary) DO  INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal)                                                                                    +
                |                 |   VALUES (new.ename, "current_user"(), 'honored'::bpchar, new.salary, old.salary);
- rtest_nothn1  | rtest_nothn_r1  | CREATE RULE rtest_nothn_r1 AS                                                                                                                                                     +
-               |                 |     ON INSERT TO rtest_nothn1                                                                                                                                                     +
+ rtest_nothn1  | rtest_nothn_r1  | CREATE RULE rtest_nothn_r1 AS                                                                                                                                                            +
+               |                 |     ON INSERT TO public.rtest_nothn1                                                                                                                                                     +
                |                 |    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD NOTHING;
- rtest_nothn1  | rtest_nothn_r2  | CREATE RULE rtest_nothn_r2 AS                                                                                                                                                     +
-               |                 |     ON INSERT TO rtest_nothn1                                                                                                                                                     +
+ rtest_nothn1  | rtest_nothn_r2  | CREATE RULE rtest_nothn_r2 AS                                                                                                                                                            +
+               |                 |     ON INSERT TO public.rtest_nothn1                                                                                                                                                     +
                |                 |    WHERE ((new.a >= 30) AND (new.a < 40)) DO INSTEAD NOTHING;
- rtest_nothn2  | rtest_nothn_r3  | CREATE RULE rtest_nothn_r3 AS                                                                                                                                                     +
-               |                 |     ON INSERT TO rtest_nothn2                                                                                                                                                     +
-               |                 |    WHERE (new.a >= 100) DO INSTEAD  INSERT INTO rtest_nothn3 (a, b)                                                                                                               +
+ rtest_nothn2  | rtest_nothn_r3  | CREATE RULE rtest_nothn_r3 AS                                                                                                                                                            +
+               |                 |     ON INSERT TO public.rtest_nothn2                                                                                                                                                     +
+               |                 |    WHERE (new.a >= 100) DO INSTEAD  INSERT INTO rtest_nothn3 (a, b)                                                                                                                      +
                |                 |   VALUES (new.a, new.b);
- rtest_nothn2  | rtest_nothn_r4  | CREATE RULE rtest_nothn_r4 AS                                                                                                                                                     +
-               |                 |     ON INSERT TO rtest_nothn2 DO INSTEAD NOTHING;
- rtest_order1  | rtest_order_r1  | CREATE RULE rtest_order_r1 AS                                                                                                                                                     +
-               |                 |     ON INSERT TO rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)                                                                                                      +
+ rtest_nothn2  | rtest_nothn_r4  | CREATE RULE rtest_nothn_r4 AS                                                                                                                                                            +
+               |                 |     ON INSERT TO public.rtest_nothn2 DO INSTEAD NOTHING;
+ rtest_order1  | rtest_order_r1  | CREATE RULE rtest_order_r1 AS                                                                                                                                                            +
+               |                 |     ON INSERT TO public.rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)                                                                                                      +
                |                 |   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 1 - this should run 1st'::text);
- rtest_order1  | rtest_order_r2  | CREATE RULE rtest_order_r2 AS                                                                                                                                                     +
-               |                 |     ON INSERT TO rtest_order1 DO  INSERT INTO rtest_order2 (a, b, c)                                                                                                              +
+ rtest_order1  | rtest_order_r2  | CREATE RULE rtest_order_r2 AS                                                                                                                                                            +
+               |                 |     ON INSERT TO public.rtest_order1 DO  INSERT INTO rtest_order2 (a, b, c)                                                                                                              +
                |                 |   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 2 - this should run 2nd'::text);
- rtest_order1  | rtest_order_r3  | CREATE RULE rtest_order_r3 AS                                                                                                                                                     +
-               |                 |     ON INSERT TO rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)                                                                                                      +
+ rtest_order1  | rtest_order_r3  | CREATE RULE rtest_order_r3 AS                                                                                                                                                            +
+               |                 |     ON INSERT TO public.rtest_order1 DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)                                                                                                      +
                |                 |   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 3 - this should run 3rd'::text);
- rtest_order1  | rtest_order_r4  | CREATE RULE rtest_order_r4 AS                                                                                                                                                     +
-               |                 |     ON INSERT TO rtest_order1                                                                                                                                                     +
-               |                 |    WHERE (new.a < 100) DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)                                                                                                             +
+ rtest_order1  | rtest_order_r4  | CREATE RULE rtest_order_r4 AS                                                                                                                                                            +
+               |                 |     ON INSERT TO public.rtest_order1                                                                                                                                                     +
+               |                 |    WHERE (new.a < 100) DO INSTEAD  INSERT INTO rtest_order2 (a, b, c)                                                                                                                    +
                |                 |   VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 4 - this should run 4th'::text);
- rtest_person  | rtest_pers_del  | CREATE RULE rtest_pers_del AS                                                                                                                                                     +
-               |                 |     ON DELETE TO rtest_person DO  DELETE FROM rtest_admin                                                                                                                         +
+ rtest_person  | rtest_pers_del  | CREATE RULE rtest_pers_del AS                                                                                                                                                            +
+               |                 |     ON DELETE TO public.rtest_person DO  DELETE FROM rtest_admin                                                                                                                         +
                |                 |   WHERE (rtest_admin.pname = old.pname);
- rtest_person  | rtest_pers_upd  | CREATE RULE rtest_pers_upd AS                                                                                                                                                     +
-               |                 |     ON UPDATE TO rtest_person DO  UPDATE rtest_admin SET pname = new.pname                                                                                                        +
+ rtest_person  | rtest_pers_upd  | CREATE RULE rtest_pers_upd AS                                                                                                                                                            +
+               |                 |     ON UPDATE TO public.rtest_person DO  UPDATE rtest_admin SET pname = new.pname                                                                                                        +
                |                 |   WHERE (rtest_admin.pname = old.pname);
- rtest_system  | rtest_sys_del   | CREATE RULE rtest_sys_del AS                                                                                                                                                      +
-               |                 |     ON DELETE TO rtest_system DO ( DELETE FROM rtest_interface                                                                                                                    +
-               |                 |   WHERE (rtest_interface.sysname = old.sysname);                                                                                                                                  +
-               |                 |  DELETE FROM rtest_admin                                                                                                                                                          +
-               |                 |   WHERE (rtest_admin.sysname = old.sysname);                                                                                                                                      +
+ rtest_system  | rtest_sys_del   | CREATE RULE rtest_sys_del AS                                                                                                                                                             +
+               |                 |     ON DELETE TO public.rtest_system DO ( DELETE FROM rtest_interface                                                                                                                    +
+               |                 |   WHERE (rtest_interface.sysname = old.sysname);                                                                                                                                         +
+               |                 |  DELETE FROM rtest_admin                                                                                                                                                                 +
+               |                 |   WHERE (rtest_admin.sysname = old.sysname);                                                                                                                                             +
                |                 | );
- rtest_system  | rtest_sys_upd   | CREATE RULE rtest_sys_upd AS                                                                                                                                                      +
-               |                 |     ON UPDATE TO rtest_system DO ( UPDATE rtest_interface SET sysname = new.sysname                                                                                               +
-               |                 |   WHERE (rtest_interface.sysname = old.sysname);                                                                                                                                  +
-               |                 |  UPDATE rtest_admin SET sysname = new.sysname                                                                                                                                     +
-               |                 |   WHERE (rtest_admin.sysname = old.sysname);                                                                                                                                      +
+ rtest_system  | rtest_sys_upd   | CREATE RULE rtest_sys_upd AS                                                                                                                                                             +
+               |                 |     ON UPDATE TO public.rtest_system DO ( UPDATE rtest_interface SET sysname = new.sysname                                                                                               +
+               |                 |   WHERE (rtest_interface.sysname = old.sysname);                                                                                                                                         +
+               |                 |  UPDATE rtest_admin SET sysname = new.sysname                                                                                                                                            +
+               |                 |   WHERE (rtest_admin.sysname = old.sysname);                                                                                                                                             +
                |                 | );
- rtest_t4      | rtest_t4_ins1   | CREATE RULE rtest_t4_ins1 AS                                                                                                                                                      +
-               |                 |     ON INSERT TO rtest_t4                                                                                                                                                         +
-               |                 |    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD  INSERT INTO rtest_t5 (a, b)                                                                                                 +
+ rtest_t4      | rtest_t4_ins1   | CREATE RULE rtest_t4_ins1 AS                                                                                                                                                             +
+               |                 |     ON INSERT TO public.rtest_t4                                                                                                                                                         +
+               |                 |    WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD  INSERT INTO rtest_t5 (a, b)                                                                                                        +
                |                 |   VALUES (new.a, new.b);
- rtest_t4      | rtest_t4_ins2   | CREATE RULE rtest_t4_ins2 AS                                                                                                                                                      +
-               |                 |     ON INSERT TO rtest_t4                                                                                                                                                         +
-               |                 |    WHERE ((new.a >= 20) AND (new.a < 30)) DO  INSERT INTO rtest_t6 (a, b)                                                                                                         +
+ rtest_t4      | rtest_t4_ins2   | CREATE RULE rtest_t4_ins2 AS                                                                                                                                                             +
+               |                 |     ON INSERT TO public.rtest_t4                                                                                                                                                         +
+               |                 |    WHERE ((new.a >= 20) AND (new.a < 30)) DO  INSERT INTO rtest_t6 (a, b)                                                                                                                +
                |                 |   VALUES (new.a, new.b);
- rtest_t5      | rtest_t5_ins    | CREATE RULE rtest_t5_ins AS                                                                                                                                                       +
-               |                 |     ON INSERT TO rtest_t5                                                                                                                                                         +
-               |                 |    WHERE (new.a > 15) DO  INSERT INTO rtest_t7 (a, b)                                                                                                                             +
+ rtest_t5      | rtest_t5_ins    | CREATE RULE rtest_t5_ins AS                                                                                                                                                              +
+               |                 |     ON INSERT TO public.rtest_t5                                                                                                                                                         +
+               |                 |    WHERE (new.a > 15) DO  INSERT INTO rtest_t7 (a, b)                                                                                                                                    +
                |                 |   VALUES (new.a, new.b);
- rtest_t6      | rtest_t6_ins    | CREATE RULE rtest_t6_ins AS                                                                                                                                                       +
-               |                 |     ON INSERT TO rtest_t6                                                                                                                                                         +
-               |                 |    WHERE (new.a > 25) DO INSTEAD  INSERT INTO rtest_t8 (a, b)                                                                                                                     +
+ rtest_t6      | rtest_t6_ins    | CREATE RULE rtest_t6_ins AS                                                                                                                                                              +
+               |                 |     ON INSERT TO public.rtest_t6                                                                                                                                                         +
+               |                 |    WHERE (new.a > 25) DO INSTEAD  INSERT INTO rtest_t8 (a, b)                                                                                                                            +
                |                 |   VALUES (new.a, new.b);
- rtest_v1      | rtest_v1_del    | CREATE RULE rtest_v1_del AS                                                                                                                                                       +
-               |                 |     ON DELETE TO rtest_v1 DO INSTEAD  DELETE FROM rtest_t1                                                                                                                        +
+ rtest_v1      | rtest_v1_del    | CREATE RULE rtest_v1_del AS                                                                                                                                                              +
+               |                 |     ON DELETE TO public.rtest_v1 DO INSTEAD  DELETE FROM rtest_t1                                                                                                                        +
                |                 |   WHERE (rtest_t1.a = old.a);
- rtest_v1      | rtest_v1_ins    | CREATE RULE rtest_v1_ins AS                                                                                                                                                       +
-               |                 |     ON INSERT TO rtest_v1 DO INSTEAD  INSERT INTO rtest_t1 (a, b)                                                                                                                 +
+ rtest_v1      | rtest_v1_ins    | CREATE RULE rtest_v1_ins AS                                                                                                                                                              +
+               |                 |     ON INSERT TO public.rtest_v1 DO INSTEAD  INSERT INTO rtest_t1 (a, b)                                                                                                                 +
                |                 |   VALUES (new.a, new.b);
- rtest_v1      | rtest_v1_upd    | CREATE RULE rtest_v1_upd AS                                                                                                                                                       +
-               |                 |     ON UPDATE TO rtest_v1 DO INSTEAD  UPDATE rtest_t1 SET a = new.a, b = new.b                                                                                                    +
+ rtest_v1      | rtest_v1_upd    | CREATE RULE rtest_v1_upd AS                                                                                                                                                              +
+               |                 |     ON UPDATE TO public.rtest_v1 DO INSTEAD  UPDATE rtest_t1 SET a = new.a, b = new.b                                                                                                    +
                |                 |   WHERE (rtest_t1.a = old.a);
- shoelace      | shoelace_del    | CREATE RULE shoelace_del AS                                                                                                                                                       +
-               |                 |     ON DELETE TO shoelace DO INSTEAD  DELETE FROM shoelace_data                                                                                                                   +
+ shoelace      | shoelace_del    | CREATE RULE shoelace_del AS                                                                                                                                                              +
+               |                 |     ON DELETE TO public.shoelace DO INSTEAD  DELETE FROM shoelace_data                                                                                                                   +
                |                 |   WHERE (shoelace_data.sl_name = old.sl_name);
- shoelace      | shoelace_ins    | CREATE RULE shoelace_ins AS                                                                                                                                                       +
-               |                 |     ON INSERT TO shoelace DO INSTEAD  INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit)                                                                    +
+ shoelace      | shoelace_ins    | CREATE RULE shoelace_ins AS                                                                                                                                                              +
+               |                 |     ON INSERT TO public.shoelace DO INSTEAD  INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit)                                                                    +
                |                 |   VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);
- shoelace      | shoelace_upd    | CREATE RULE shoelace_upd AS                                                                                                                                                       +
-               |                 |     ON UPDATE TO shoelace DO INSTEAD  UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit+
+ shoelace      | shoelace_upd    | CREATE RULE shoelace_upd AS                                                                                                                                                              +
+               |                 |     ON UPDATE TO public.shoelace DO INSTEAD  UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit+
                |                 |   WHERE (shoelace_data.sl_name = old.sl_name);
- shoelace_data | log_shoelace    | CREATE RULE log_shoelace AS                                                                                                                                                       +
-               |                 |     ON UPDATE TO shoelace_data                                                                                                                                                    +
-               |                 |    WHERE (new.sl_avail <> old.sl_avail) DO  INSERT INTO shoelace_log (sl_name, sl_avail, log_who, log_when)                                                                       +
+ shoelace_data | log_shoelace    | CREATE RULE log_shoelace AS                                                                                                                                                              +
+               |                 |     ON UPDATE TO public.shoelace_data                                                                                                                                                    +
+               |                 |    WHERE (new.sl_avail <> old.sl_avail) DO  INSERT INTO shoelace_log (sl_name, sl_avail, log_who, log_when)                                                                              +
                |                 |   VALUES (new.sl_name, new.sl_avail, 'Al Bundy'::name, 'Thu Jan 01 00:00:00 1970'::timestamp without time zone);
- shoelace_ok   | shoelace_ok_ins | CREATE RULE shoelace_ok_ins AS                                                                                                                                                    +
-               |                 |     ON INSERT TO shoelace_ok DO INSTEAD  UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant)                                                                        +
+ shoelace_ok   | shoelace_ok_ins | CREATE RULE shoelace_ok_ins AS                                                                                                                                                           +
+               |                 |     ON INSERT TO public.shoelace_ok DO INSTEAD  UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant)                                                                        +
                |                 |   WHERE (shoelace.sl_name = new.ok_name);
 (29 rows)
 
diff --git a/src/test/regress/expected/triggers.out b/src/test/regress/expected/triggers.out
index f1a5fde107..6706021051 100644
--- a/src/test/regress/expected/triggers.out
+++ b/src/test/regress/expected/triggers.out
@@ -381,9 +381,9 @@ SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'
 (1 row)
 
 SELECT pg_get_triggerdef(oid, false) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
-                                                              pg_get_triggerdef                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------
- CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN ((old.a <> new.a)) EXECUTE PROCEDURE trigger_func('modified_a')
+                                                                  pg_get_triggerdef                                                                  
+-----------------------------------------------------------------------------------------------------------------------------------------------------
+ CREATE TRIGGER modified_a BEFORE UPDATE OF a ON public.main_table FOR EACH ROW WHEN ((old.a <> new.a)) EXECUTE PROCEDURE trigger_func('modified_a')
 (1 row)
 
 SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_any';
@@ -411,9 +411,9 @@ FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
 CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_table
 FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
 SELECT pg_get_triggerdef(oid) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'after_upd_a_b_row_trig';
-                                                             pg_get_triggerdef                                                             
--------------------------------------------------------------------------------------------------------------------------------------------
- CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row')
+                                                                pg_get_triggerdef                                                                 
+--------------------------------------------------------------------------------------------------------------------------------------------------
+ CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON public.main_table FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row')
 (1 row)
 
 UPDATE main_table SET a = 50;
