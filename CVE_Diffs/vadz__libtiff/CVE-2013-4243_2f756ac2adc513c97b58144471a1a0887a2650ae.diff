vadz__libtiff
commit 2f756ac2adc513c97b58144471a1a0887a2650ae
Author:     erouault <erouault>
AuthorDate: Thu Nov 20 16:47:21 2014 +0000
Commit:     erouault <erouault>
CommitDate: Thu Nov 20 16:47:21 2014 +0000

    * libtiff/tif_lzw.c: prevent potential null dereference of
    sp->dec_codetab in LZWPreDecode (bug #2459)
    
    * libtiff/tif_read.c: in TIFFReadBufferSetup(), avoid passing -1 size
    to TIFFmalloc() if passed user buffer size is 0 (bug #2459)
    
    * libtiff/tif_ojpeg.c: make Coverity happier (not a bug, #2459)
    
    * libtiff/tif_dir.c: in _TIFFVGetField() and _TIFFVSetField(), make
    Coverity happier (not a bug, #2459)
    
    * libtiff/tif_dirread.c: in TIFFFetchNormalTag(), make Coverity happier
    (not a bug, #2459)
    
    * tools/tiff2pdf.c: close PDF file (bug #2479)
    
    * tools/fax2ps.c: check malloc()/realloc() result (bug #2470)
    
    * tools/tiffdump.c: detect cycle in TIFF directory chaining (bug #2463)
    and avoid passing a NULL pointer to read() if seek() failed before (bug #2459)
    
    * tools/tiffcrop.c: fix segfault if bad value passed to -Z option
    (bug #2459) and add missing va_end in dump_info (#2459)
    
    * tools/gif2tif.c: apply patch for CVE-2013-4243 (#2451)

diff --git a/ChangeLog b/ChangeLog
index 4586670e..e24fe626 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,31 @@
+2014-11-20  Even Rouault  <even.rouault@spatialys.com>
+
+	* libtiff/tif_lzw.c: prevent potential null dereference of
+	sp->dec_codetab in LZWPreDecode (bug #2459)
+
+	* libtiff/tif_read.c: in TIFFReadBufferSetup(), avoid passing -1 size
+	to TIFFmalloc() if passed user buffer size is 0 (bug #2459)
+
+	* libtiff/tif_ojpeg.c: make Coverity happier (not a bug, #2459)
+
+	* libtiff/tif_dir.c: in _TIFFVGetField() and _TIFFVSetField(), make
+	Coverity happier (not a bug, #2459)
+
+	* libtiff/tif_dirread.c: in TIFFFetchNormalTag(), make Coverity happier
+	(not a bug, #2459)
+
+	* tools/tiff2pdf.c: close PDF file (bug #2479)
+
+	* tools/fax2ps.c: check malloc()/realloc() result (bug #2470)
+
+	* tools/tiffdump.c: detect cycle in TIFF directory chaining (bug #2463)
+	and avoid passing a NULL pointer to read() if seek() failed before (bug #2459)
+
+	* tools/tiffcrop.c: fix segfault if bad value passed to -Z option
+	(bug #2459) and add missing va_end in dump_info (#2459)
+
+	* tools/gif2tif.c: apply patch for CVE-2013-4243 (#2451)
+
 2014-11-20  Even Rouault  <even.rouault@spatialys.com>
 	* libtiff/tif_jpeg.c: fix segfault in JPEGFixupTagsSubsampling() on
 	corrupted image where tif->tif_dir.td_stripoffset == NULL (bug #2471)
diff --git a/libtiff/tif_dir.c b/libtiff/tif_dir.c
index 88970098..98cf66df 100644
--- a/libtiff/tif_dir.c
+++ b/libtiff/tif_dir.c
@@ -163,7 +163,8 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 	char* s;
 	const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);
 	uint32 standard_tag = tag;
-
+	if( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */
+	    return 0;
 	/*
 	 * We want to force the custom code to be used for custom
 	 * fields even if the tag happens to match a well known 
@@ -449,11 +450,11 @@ _TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)
 		 * happens, for example, when tiffcp is used to convert between
 		 * compression schemes and codec-specific tags are blindly copied.
 		 */
-		if(fip == NULL || fip->field_bit != FIELD_CUSTOM) {
+		if(fip->field_bit != FIELD_CUSTOM) {
 			TIFFErrorExt(tif->tif_clientdata, module,
 			    "%s: Invalid %stag \"%s\" (not supported by codec)",
 			    tif->tif_name, isPseudoTag(tag) ? "pseudo-" : "",
-			    fip ? fip->field_name : "Unknown");
+			    fip->field_name);
 			status = 0;
 			break;
 		}
@@ -809,6 +810,8 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 	int ret_val = 1;
 	uint32 standard_tag = tag;
 	const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);
+	if( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */
+	    return 0;
 	
 	/*
 	 * We want to force the custom code to be used for custom
@@ -1006,14 +1009,14 @@ _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)
 				 * get a tag that is not valid for the image's
 				 * codec then we'll arrive here.
 				 */
-				if( fip == NULL || fip->field_bit != FIELD_CUSTOM )
+				if( fip->field_bit != FIELD_CUSTOM )
 				{
 					TIFFErrorExt(tif->tif_clientdata, "_TIFFVGetField",
 					    "%s: Invalid %stag \"%s\" "
 					    "(not supported by codec)",
 					    tif->tif_name,
 					    isPseudoTag(tag) ? "pseudo-" : "",
-					    fip ? fip->field_name : "Unknown");
+					    fip->field_name);
 					ret_val = 0;
 					break;
 				}
diff --git a/libtiff/tif_dirread.c b/libtiff/tif_dirread.c
index 41b044af..391c823c 100644
--- a/libtiff/tif_dirread.c
+++ b/libtiff/tif_dirread.c
@@ -4708,6 +4708,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
             return 0;
         }
 	fip=tif->tif_fields[fii];
+	assert(fip != NULL); /* should not happen */
 	assert(fip->set_field_type!=TIFF_SETGET_OTHER);  /* if so, we shouldn't arrive here but deal with this in specialized code */
 	assert(fip->set_field_type!=TIFF_SETGET_INT);    /* if so, we shouldn't arrive here as this is only the case for pseudo-tags */
 	err=TIFFReadDirEntryErrOk;
@@ -5355,7 +5356,7 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
 	}
 	if (err!=TIFFReadDirEntryErrOk)
 	{
-		TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",recover);
+		TIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);
 		return(0);
 	}
 	return(1);
diff --git a/libtiff/tif_lzw.c b/libtiff/tif_lzw.c
index 8d4e373a..18cecf34 100644
--- a/libtiff/tif_lzw.c
+++ b/libtiff/tif_lzw.c
@@ -268,6 +268,8 @@ LZWPreDecode(TIFF* tif, uint16 s)
 	if( sp->dec_codetab == NULL )
         {
             tif->tif_setupdecode( tif );
+	    if( sp->dec_codetab == NULL )
+		return (0);
         }
 
 	/*
diff --git a/libtiff/tif_ojpeg.c b/libtiff/tif_ojpeg.c
index 81b055cb..f03b432c 100644
--- a/libtiff/tif_ojpeg.c
+++ b/libtiff/tif_ojpeg.c
@@ -528,6 +528,8 @@ OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)
 	uint32 ma;
 	uint64* mb;
 	uint32 n;
+	const TIFFField* fip;
+
 	switch(tag)
 	{
 		case TIFFTAG_JPEGIFOFFSET:
@@ -597,7 +599,10 @@ OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)
 		default:
 			return (*sp->vsetparent)(tif,tag,ap);
 	}
-	TIFFSetFieldBit(tif,TIFFFieldWithTag(tif,tag)->field_bit);
+	fip = TIFFFieldWithTag(tif,tag);
+	if( fip == NULL ) /* shouldn't happen */
+	    return(0);
+	TIFFSetFieldBit(tif,fip->field_bit);
 	tif->tif_flags|=TIFF_DIRTYDIRECT;
 	return(1);
 }
diff --git a/libtiff/tif_read.c b/libtiff/tif_read.c
index e17bae20..2ba822ad 100644
--- a/libtiff/tif_read.c
+++ b/libtiff/tif_read.c
@@ -930,8 +930,11 @@ TIFFReadBufferSetup(TIFF* tif, void* bp, tmsize_t size)
 		tif->tif_flags &= ~TIFF_MYBUFFER;
 	} else {
 		tif->tif_rawdatasize = (tmsize_t)TIFFroundup_64((uint64)size, 1024);
-		if (tif->tif_rawdatasize==0)
-			tif->tif_rawdatasize=(tmsize_t)(-1);
+		if (tif->tif_rawdatasize==0) {
+		    TIFFErrorExt(tif->tif_clientdata, module,
+				 "Invalid buffer size");
+		    return (0);
+		}
 		tif->tif_rawdata = (uint8*) _TIFFmalloc(tif->tif_rawdatasize);
 		tif->tif_flags |= TIFF_MYBUFFER;
 	}
diff --git a/tools/fax2ps.c b/tools/fax2ps.c
index 36deb7fd..ff216453 100644
--- a/tools/fax2ps.c
+++ b/tools/fax2ps.c
@@ -346,6 +346,11 @@ main(int argc, char** argv)
 		pages = (uint16*) realloc(pages, (npages+1)*sizeof(uint16));
 	    else
 		pages = (uint16*) malloc(sizeof(uint16));
+	    if( pages == NULL )
+	    {
+		fprintf(stderr, "Out of memory\n");
+		exit(-1);
+	    }
 	    pages[npages++] = pageNumber;
 	    break;
 	case 'w':
diff --git a/tools/gif2tiff.c b/tools/gif2tiff.c
index 97ed45db..75696e5a 100644
--- a/tools/gif2tiff.c
+++ b/tools/gif2tiff.c
@@ -275,11 +275,15 @@ readgifimage(char* mode)
     height = buf[6] + (buf[7] << 8);
     local = buf[8] & 0x80;
     interleaved = buf[8] & 0x40;
-
+    if (width == 0 || height == 0 || width > 2000000000 / height) {
+        fprintf(stderr, "Invalid value of width or height\n");
+        return(0);
+    }
     if (local == 0 && global == 0) {
         fprintf(stderr, "no colormap present for image\n");
         return (0);
     }
+
     if ((raster = (unsigned char*) _TIFFmalloc(width*height+EXTRAFUDGE)) == NULL) {
         fprintf(stderr, "not enough memory for image\n");
         return (0);
@@ -404,6 +408,10 @@ process(register int code, unsigned char** fill)
             fprintf(stderr, "bad input: code=%d is larger than clear=%d\n",code, clear);
             return 0;
         }
+        if (*fill >= raster + width*height) {
+            fprintf(stderr, "raster full before eoi code\n");
+            return 0;
+        }
 	*(*fill)++ = suffix[code];
 	firstchar = oldcode = code;
 	return 1;
@@ -434,6 +442,10 @@ process(register int code, unsigned char** fill)
     }
     oldcode = incode;
     do {
+        if (*fill >= raster + width*height) {
+            fprintf(stderr, "raster full before eoi code\n");
+            return 0;
+        }
 	*(*fill)++ = *--stackp;
     } while (stackp > stack);
     return 1;
diff --git a/tools/tiff2pdf.c b/tools/tiff2pdf.c
index 903cfa87..c986e6d2 100644
--- a/tools/tiff2pdf.c
+++ b/tools/tiff2pdf.c
@@ -411,8 +411,8 @@ t2p_seekproc(thandle_t handle, uint64 offset, int whence)
 static int 
 t2p_closeproc(thandle_t handle)
 { 
-	(void) handle;
-	return 0; 
+	T2P *t2p = (T2P*) handle;
+	return fclose(t2p->outputfile);
 }
 
 static uint64 
diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index e22ed2b0..7e526ea8 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -2012,6 +2012,10 @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32
                     {
 		    crop_data->zones++;
 		    opt_offset = strchr(opt_ptr, ':');
+		    if (!opt_offset) {
+			TIFFError("Wrong parameter syntax for -Z", "tiffcrop -h");
+			exit(-1);
+		    }
                     *opt_offset = '\0';
                     crop_data->zonelist[i].position = atoi(opt_ptr);
                     crop_data->zonelist[i].total    = atoi(opt_offset + 1);
@@ -2595,6 +2599,7 @@ static void dump_info(FILE *dumpfile, int format, char *prefix, char *msg, ...)
     fprintf(dumpfile, "%s ", prefix);
     vfprintf(dumpfile, msg, ap);
     fprintf(dumpfile, "\n");
+    va_end(ap);
     }
   }
 
diff --git a/tools/tiffdump.c b/tools/tiffdump.c
index aca74574..1b751132 100644
--- a/tools/tiffdump.c
+++ b/tools/tiffdump.c
@@ -162,7 +162,9 @@ static void Fatal(const char*, ...);
 static void
 dump(int fd, uint64 diroff)
 {
-	unsigned i;
+	unsigned i, j;
+	uint64* visited_diroff = NULL;
+	unsigned int count_visited_dir = 0;
 
 	lseek(fd, (off_t) 0, 0);
 	if (read(fd, (char*) &hdr, sizeof (TIFFHeaderCommon)) != sizeof (TIFFHeaderCommon))
@@ -223,10 +225,27 @@ dump(int fd, uint64 diroff)
 		Fatal("Not a TIFF file, bad version number %u (%#x)",
 		    hdr.common.tiff_version, hdr.common.tiff_version);
 	for (i = 0; diroff != 0; i++) {
+		for(j=0; j<count_visited_dir; j++)
+		{
+		    if( visited_diroff[j] == diroff )
+		    {
+			free(visited_diroff);
+			Fatal("Cycle detected in chaining of TIFF directories!");
+		    }
+		}
+		visited_diroff = (uint64*) realloc(visited_diroff,
+				    (count_visited_dir + 1) * sizeof(uint64));
+		if( !visited_diroff )
+		    Fatal("Out of memory");
+		visited_diroff[count_visited_dir] = diroff;
+		count_visited_dir ++;
+
 		if (i > 0)
 			putchar('\n');
 		diroff = ReadDirectory(fd, i, diroff);
 	}
+	if( visited_diroff )
+	    free(visited_diroff);
 }
 
 static const int datawidth[] = {
@@ -452,7 +471,7 @@ ReadDirectory(int fd, unsigned int ix, uint64 off)
 					_TIFFfree(datamem);
 					datamem = NULL;
 				}
-				if (read(fd, datamem, (size_t)datasize) != (TIFF_SSIZE_T)datasize)
+				else if (read(fd, datamem, (size_t)datasize) != (TIFF_SSIZE_T)datasize)
 				{
 					Error(
 				"Read error accessing tag %u value", tag);
