matthewdalex__N6
commit 257d6cffd6e7f679617f08eb4f57b5565229d851
Author:     Eric W. Biederman <ebiederm@xmission.com>
AuthorDate: Wed Oct 8 10:42:27 2014 -0700
Commit:     despairfactor <matthewdalex92@gmail.com>
CommitDate: Mon Sep 21 08:32:40 2015 -0400

    mnt: Prevent pivot_root from creating a loop in the mount tree
    
    Andy Lutomirski recently demonstrated that when chroot is used to set
    the root path below the path for the new ``root'' passed to pivot_root
    the pivot_root system call succeeds and leaks mounts.
    
    In examining the code I see that starting with a new root that is
    below the current root in the mount tree will result in a loop in the
    mount tree after the mounts are detached and then reattached to one
    another.  Resulting in all kinds of ugliness including a leak of that
    mounts involved in the leak of the mount loop.
    
    Prevent this problem by ensuring that the new mount is reachable from
    the current root of the mount tree.
    
    [Added stable cc.  Fixes CVE-2014-7970.  --Andy]
    
    Change-Id: I63cd6dfb16846d87386af1800b717420004db9f4
    Cc: stable@vger.kernel.org
    Reported-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>
    Link: http://lkml.kernel.org/r/87bnpmihks.fsf@x220.int.ebiederm.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: franciscofranco <franciscofranco.1990@gmail.com>

diff --git a/fs/namespace.c b/fs/namespace.c
index a438e4c81b0..0bf31150fde 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -2649,6 +2649,9 @@ SYSCALL_DEFINE2(pivot_root, const char __user *, new_root,
 	/* make sure we can reach put_old from new_root */
 	if (!is_path_reachable(old_mnt, old.dentry, &new))
 		goto out4;
+	/* make certain new is below the root */
+	if (!is_path_reachable(new_mnt, new.dentry, &root))
+		goto out4;
 	root_mp->m_count++; /* pin it so it won't go away */
 	br_write_lock(&vfsmount_lock);
 	detach_mnt(new_mnt, &parent_path);
