OpenVZ__vzkernel
commit 9db9ad0c15927c8774dc431ff4d75aead7481039
Author:     Jason A. Donenfeld <Jason@zx2c4.com>
AuthorDate: Fri Apr 21 23:14:48 2017 +0200
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Wed Apr 26 11:50:49 2017 +0400

    ms/macsec: avoid heap overflow in skb_to_sgvec
    
    While this may appear as a humdrum one line change, it's actually quite
    important. An sk_buff stores data in three places:
    
    1. A linear chunk of allocated memory in skb->data. This is the easiest
       one to work with, but it precludes using scatterdata since the memory
       must be linear.
    2. The array skb_shinfo(skb)->frags, which is of maximum length
       MAX_SKB_FRAGS. This is nice for scattergather, since these fragments
       can point to different pages.
    3. skb_shinfo(skb)->frag_list, which is a pointer to another sk_buff,
       which in turn can have data in either (1) or (2).
    
    The first two are rather easy to deal with, since they're of a fixed
    maximum length, while the third one is not, since there can be
    potentially limitless chains of fragments. Fortunately dealing with
    frag_list is opt-in for drivers, so drivers don't actually have to deal
    with this mess. For whatever reason, macsec decided it wanted pain, and
    so it explicitly specified NETIF_F_FRAGLIST.
    
    Because dealing with (1), (2), and (3) is insane, most users of sk_buff
    doing any sort of crypto or paging operation calls a convenient function
    called skb_to_sgvec (which happens to be recursive if (3) is in use!).
    This takes a sk_buff as input, and writes into its output pointer an
    array of scattergather list items. Sometimes people like to declare a
    fixed size scattergather list on the stack; othertimes people like to
    allocate a fixed size scattergather list on the heap. However, if you're
    doing it in a fixed-size fashion, you really shouldn't be using
    NETIF_F_FRAGLIST too (unless you're also ensuring the sk_buff and its
    frag_list children arent't shared and then you check the number of
    fragments in total required.)
    
    Macsec specifically does this:
    
            size += sizeof(struct scatterlist) * (MAX_SKB_FRAGS + 1);
            tmp = kmalloc(size, GFP_ATOMIC);
            *sg = (struct scatterlist *)(tmp + sg_offset);
            ...
            sg_init_table(sg, MAX_SKB_FRAGS + 1);
            skb_to_sgvec(skb, sg, 0, skb->len);
    
    Specifying MAX_SKB_FRAGS + 1 is the right answer usually, but not if you're
    using NETIF_F_FRAGLIST, in which case the call to skb_to_sgvec will
    overflow the heap, and disaster ensues.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Cc: stable@vger.kernel.org
    Cc: security@kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>
    
    https://jira.sw.ru/browse/PSBM-65529
    
    CVE-2017-7477 kernel: net: Heap overflow in skb_to_sgvec in macsec.c
    https://bugzilla.redhat.com/show_bug.cgi?id=1445207
    http://seclists.org/oss-sec/2017/q2/119
    
    The LKML discussion took place here:
    https://lkml.org/lkml/2017/4/21/689
    
    Patch is in David S. Miller's tree (net):
    https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?id=f6478218e6edc2a587b8f132f66373baa7b2497c
    
    Signed-off-by: Konstantin Khorenko <khorenko@virtuozzo.com>

diff --git a/drivers/net/macsec.c b/drivers/net/macsec.c
index 91e6618a6436..77ad4237795a 100644
--- a/drivers/net/macsec.c
+++ b/drivers/net/macsec.c
@@ -2676,7 +2676,7 @@ static netdev_tx_t macsec_start_xmit(struct sk_buff *skb,
 }
 
 #define MACSEC_FEATURES \
-	(NETIF_F_SG | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST)
+	(NETIF_F_SG | NETIF_F_HIGHDMA)
 static int macsec_dev_init(struct net_device *dev)
 {
 	struct macsec_dev *macsec = macsec_priv(dev);
