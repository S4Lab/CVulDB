OpenVZ__vzkernel
commit 4e23726eb3c7804830161664f0d9c14efacf6efd
Author:     Matt Delco <delco@chromium.org>
AuthorDate: Wed Nov 6 18:28:46 2019 +0300
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Wed Nov 13 18:33:34 2019 +0300

    ms/KVM: coalesced_mmio: add bounds checking
    
    Commit b60fe990c6b07ef6d4df67bc0530c7c90a62623a in the mainline kernel.
    
    The first/last indexes are typically shared with a user app.
    The app can change the 'last' index that the kernel uses
    to store the next result.  This change sanity checks the index
    before using it for writing to a potentially arbitrary address.
    
    This fixes CVE-2019-14821.
    
    Cc: stable@vger.kernel.org
    mFixes: 5f94c1741bdc ("KVM: Add coalesced MMIO support (common part)")
    Signed-off-by: Matt Delco <delco@chromium.org>
    Signed-off-by: Jim Mattson <jmattson@google.com>
    Reported-by: syzbot+983c866c3dd6efa3662a@syzkaller.appspotmail.com
    [Use READ_ONCE. - Paolo]
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    
    https://jira.sw.ru/browse/PSBM-99242
    
    eshatokhin@: the patch was backported to the kernel vz7.115.x:
    pio-related statements were omitted because our kernel does not inclide
    ML commits 0804c849f1df "kvm/x86 : add coalesced pio support" and
    987d1149be7d "KVM: fix unregistering coalesced mmio zone from wrong bus".
    
    Signed-off-by: Evgenii Shatokhin <eshatokhin@virtuozzo.com>

diff --git a/virt/kvm/coalesced_mmio.c b/virt/kvm/coalesced_mmio.c
index 00d86427af0f..1c51f7b933ec 100644
--- a/virt/kvm/coalesced_mmio.c
+++ b/virt/kvm/coalesced_mmio.c
@@ -39,7 +39,7 @@ static int coalesced_mmio_in_range(struct kvm_coalesced_mmio_dev *dev,
 	return 1;
 }
 
-static int coalesced_mmio_has_room(struct kvm_coalesced_mmio_dev *dev)
+static int coalesced_mmio_has_room(struct kvm_coalesced_mmio_dev *dev, u32 last)
 {
 	struct kvm_coalesced_mmio_ring *ring;
 	unsigned avail;
@@ -51,7 +51,7 @@ static int coalesced_mmio_has_room(struct kvm_coalesced_mmio_dev *dev)
 	 * there is always one unused entry in the buffer
 	 */
 	ring = dev->kvm->coalesced_mmio_ring;
-	avail = (ring->first - ring->last - 1) % KVM_COALESCED_MMIO_MAX;
+	avail = (ring->first - last - 1) % KVM_COALESCED_MMIO_MAX;
 	if (avail == 0) {
 		/* full */
 		return 0;
@@ -65,24 +65,27 @@ static int coalesced_mmio_write(struct kvm_io_device *this,
 {
 	struct kvm_coalesced_mmio_dev *dev = to_mmio(this);
 	struct kvm_coalesced_mmio_ring *ring = dev->kvm->coalesced_mmio_ring;
+	__u32 insert;
 
 	if (!coalesced_mmio_in_range(dev, addr, len))
 		return -EOPNOTSUPP;
 
 	spin_lock(&dev->kvm->ring_lock);
 
-	if (!coalesced_mmio_has_room(dev)) {
+	insert = READ_ONCE(ring->last);
+	if (!coalesced_mmio_has_room(dev, insert) ||
+	    insert >= KVM_COALESCED_MMIO_MAX) {
 		spin_unlock(&dev->kvm->ring_lock);
 		return -EOPNOTSUPP;
 	}
 
 	/* copy data in first free entry of the ring */
 
-	ring->coalesced_mmio[ring->last].phys_addr = addr;
-	ring->coalesced_mmio[ring->last].len = len;
-	memcpy(ring->coalesced_mmio[ring->last].data, val, len);
+	ring->coalesced_mmio[insert].phys_addr = addr;
+	ring->coalesced_mmio[insert].len = len;
+	memcpy(ring->coalesced_mmio[insert].data, val, len);
 	smp_wmb();
-	ring->last = (ring->last + 1) % KVM_COALESCED_MMIO_MAX;
+	ring->last = (insert + 1) % KVM_COALESCED_MMIO_MAX;
 	spin_unlock(&dev->kvm->ring_lock);
 	return 0;
 }
