OpenVZ__vzkernel
commit 85379c0b9cdbde4f16cc98d38110f1de501b766f
Author:     Alexander Popov <alex.popov@linux.com>
AuthorDate: Tue Feb 28 19:54:40 2017 +0300
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Wed Dec 13 12:42:42 2017 +0300

    ms/tty: n_hdlc: get rid of racy n_hdlc.tbuf
    
    Currently N_HDLC line discipline uses a self-made singly linked list for
    data buffers and has n_hdlc.tbuf pointer for buffer retransmitting after
    an error.
    
    The commit be10eb7589337e5defbe214dae038a53dd21add8
    ("tty: n_hdlc add buffer flushing") introduced racy access to n_hdlc.tbuf.
    After tx error concurrent flush_tx_queue() and n_hdlc_send_frames() can put
    one data buffer to tx_free_buf_list twice. That causes double free in
    n_hdlc_release().
    
    Let's use standard kernel linked list and get rid of n_hdlc.tbuf:
    in case of tx error put current data buffer after the head of tx_buf_list.
    
    Signed-off-by: Alexander Popov <alex.popov@linux.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    (cherry picked from commit 82f2341c94d270421f383641b7cd670e474db56b)
    
    Fixes CVE-2017-2636
    https://jira.sw.ru/browse/PSBM-61962
    
    Signed-off-by:  Vasily Averin <vvs@virtuozzo.com>
    Acked-by: Konstantin Khorenko <khorenko@virtuozzo.com>

diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c
index fa92a2050b59..66fb07684133 100644
--- a/drivers/tty/n_hdlc.c
+++ b/drivers/tty/n_hdlc.c
@@ -847,7 +847,12 @@ static struct n_hdlc *n_hdlc_alloc(void)
 	spin_lock_init(&n_hdlc->tx_free_buf_list.spinlock);
 	spin_lock_init(&n_hdlc->rx_buf_list.spinlock);
 	spin_lock_init(&n_hdlc->tx_buf_list.spinlock);
-	
+
+	INIT_LIST_HEAD(&n_hdlc->rx_free_buf_list.list);
+	INIT_LIST_HEAD(&n_hdlc->tx_free_buf_list.list);
+	INIT_LIST_HEAD(&n_hdlc->rx_buf_list.list);
+	INIT_LIST_HEAD(&n_hdlc->tx_buf_list.list);
+
 	/* allocate free rx buffer list */
 	for(i=0;i<DEFAULT_RX_BUF_COUNT;i++) {
 		buf = kmalloc(N_HDLC_BUF_SIZE, GFP_KERNEL);
