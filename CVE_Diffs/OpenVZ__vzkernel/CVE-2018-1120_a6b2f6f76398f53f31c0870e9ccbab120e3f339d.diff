OpenVZ__vzkernel
commit a6b2f6f76398f53f31c0870e9ccbab120e3f339d
Author:     Willy Tarreau <w@1wt.eu>
AuthorDate: Thu Jul 5 11:02:42 2018 +0300
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Thu Sep 27 18:47:01 2018 +0300

    ms/proc: do not access cmdline nor environ from file-backed areas
    
    This is a backport of ML commit 7f7ccc2ccc2e70c6054685f5e3522efa81556830.
    
    proc_pid_cmdline_read() and environ_read() directly access the target
    process' VM to retrieve the command line and environment. If this
    process remaps these areas onto a file via mmap(), the requesting
    process may experience various issues such as extra delays if the
    underlying device is slow to respond.
    
    Let's simply refuse to access file-backed areas in these functions.
    For this we add a new FOLL_ANON gup flag that is passed to all calls
    to access_remote_vm(). The code already takes care of such failures
    (including unmapped areas). Accesses via /proc/pid/mem were not
    changed though.
    
    This was assigned CVE-2018-1120.
    
    Note for stable backports: the patch may apply to kernels prior to 4.11
    but silently miss one location; it must be checked that no call to
    access_remote_vm() keeps zero as the last argument.
    
    Reported-by: Qualys Security Advisory <qsa@qualys.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Willy Tarreau <w@1wt.eu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
    https://jira.sw.ru/browse/PSBM-86221
    
    Signed-off-by: Evgenii Shatokhin <eshatokhin@virtuozzo.com>
    Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    
    ==========================================
    Patchset description:
    A user in the CT with support for FUSE can make some commands on the host
    hang if these commands read /proc/*/cmdline of the processes in that CT,
    e.g., ps aux. This is CVE-2018-1120
    
    The second patch of the series is a backport of the fix from mainline,
    7f7ccc2ccc2e ("proc: do not access cmdline nor environ from file-backed areas").
    
    That fix has prerequisites (mainline: https://lkml.org/lkml/2016/10/12/659),
    however, they are quite invasive. So, instead, a more lightweight
    approach is used in the first patch of this series. Unlike mainline, it
    provides get_user_pages_remote_flags() to keep other components using
    get_user_pages_remote() unchanged, it does not meddle with FOLL_FORCE either.

diff --git a/fs/proc/base.c b/fs/proc/base.c
index f390ac4afcbc..64bbbc387afc 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -253,7 +253,7 @@ static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,
 	 * Inherently racy -- command line shares address space
 	 * with code and data.
 	 */
-	rv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);
+	rv = access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON);
 	if (rv <= 0)
 		goto out_free_page;
 
@@ -271,7 +271,7 @@ static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,
 			int nr_read;
 
 			_count = min3(count, len, PAGE_SIZE);
-			nr_read = access_remote_vm(mm, p, page, _count, 0);
+			nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);
 			if (nr_read < 0)
 				rv = nr_read;
 			if (nr_read <= 0)
@@ -306,7 +306,7 @@ static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,
 			bool final;
 
 			_count = min3(count, len, PAGE_SIZE);
-			nr_read = access_remote_vm(mm, p, page, _count, 0);
+			nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);
 			if (nr_read < 0)
 			        rv = nr_read;
 			if (nr_read <= 0)
@@ -355,7 +355,7 @@ skip_argv:
 			bool final;
 
 			_count = min3(count, len, PAGE_SIZE);
-			nr_read = access_remote_vm(mm, p, page, _count, 0);
+			nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);
 			if (nr_read < 0)
 			        rv = nr_read;
 			if (nr_read <= 0)
@@ -1154,7 +1154,7 @@ static ssize_t environ_read(struct file *file, char __user *buf,
 		this_len = min(max_len, this_len);
 
 		retval = access_remote_vm(mm, (env_start + src),
-			page, this_len, 0);
+			page, this_len, FOLL_ANON);
 
 		if (retval <= 0) {
 			ret = retval;
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 50375e097ccc..dfb6580263d9 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2234,6 +2234,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
 #define FOLL_TRIED	0x800	/* a retry, previous pass started an IO */
 #define FOLL_REMOTE	0x2000	/* we are working on non-current tsk/mm */
 #define FOLL_COW	0x4000	/* internal GUP flag */
+#define FOLL_ANON	0x8000	/* don't do file mappings */
 
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
diff --git a/mm/gup.c b/mm/gup.c
index 297db213b4e3..1dbbe645ef74 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -428,7 +428,8 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 
 		if (!vma ||
 		    (vma->vm_flags & (VM_IO | VM_PFNMAP)) ||
-		    !(vm_flags & vma->vm_flags))
+		    !(vm_flags & vma->vm_flags) ||
+		    ((gup_flags & FOLL_ANON) && !vma_is_anonymous(vma)))
 			return i ? : -EFAULT;
 
 		/*
