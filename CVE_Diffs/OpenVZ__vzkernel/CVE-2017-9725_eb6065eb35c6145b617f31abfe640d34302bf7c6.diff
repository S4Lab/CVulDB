OpenVZ__vzkernel
commit eb6065eb35c6145b617f31abfe640d34302bf7c6
Author:     Rohit Vaswani <rvaswani@codeaurora.org>
AuthorDate: Thu Oct 22 13:32:11 2015 -0700
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Tue Dec 5 19:23:16 2017 +0300

    ms/mm: cma: fix incorrect type conversion for size during dma allocation
    
    This was found during userspace fuzzing test when a large size dma cma
    allocation is made by driver(like ion) through userspace.
    
      show_stack+0x10/0x1c
      dump_stack+0x74/0xc8
      kasan_report_error+0x2b0/0x408
      kasan_report+0x34/0x40
      __asan_storeN+0x15c/0x168
      memset+0x20/0x44
      __dma_alloc_coherent+0x114/0x18c
    
    Signed-off-by: Rohit Vaswani <rvaswani@codeaurora.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
    =========================
    (cherry picked from commit 67a2e213e7e937c41c52ab5bc46bf3f4de469f6e)
    Signed-off-by: Konstantin Khorenko <khorenko@virtuozzo.com>
    
    Conflicts:
            include/linux/cma.h
            mm/cma.c
    
    Backport changes: dropped hunks related to cma_alloc()
    as it does not exist.
    
    https://jira.sw.ru/browse/PSBM-73053
    
    CVE-2017-9725 kernel: Incorrect type conversion for size during dma allocation
    
    A flaw was found in the Linux kernels implementation of DMA memory allocation.
    
    When allocating a DMA buffer, a section of memory is allocated and then set to
    zeros.  The size parameter of allocation was truncated due to an incorrect
    casting when the allocation function is called.  During clearing the allocation
    used an untruncated value as the size to clear and would "zero" a larger
    section of kernel memory than was allocated, possibly corrupting memory and
    allowing for privilege escalation.
    
    At this time Red Hat Product Security believes that there is no direct control
    of the size parameter used in this function in Red Hat kernels.

diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
index 99802d6f3c60..1447e3b3ef84 100644
--- a/drivers/base/dma-contiguous.c
+++ b/drivers/base/dma-contiguous.c
@@ -272,7 +272,7 @@ err:
  * global one. Requires architecture specific get_dev_cma_area() helper
  * function.
  */
-struct page *dma_alloc_from_contiguous(struct device *dev, int count,
+struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,
 				       unsigned int align)
 {
 	unsigned long mask, pfn, pageno, start = 0;
diff --git a/include/linux/dma-contiguous.h b/include/linux/dma-contiguous.h
index 3b28f937d959..1421a9587a37 100644
--- a/include/linux/dma-contiguous.h
+++ b/include/linux/dma-contiguous.h
@@ -115,7 +115,7 @@ static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
 	return ret;
 }
 
-struct page *dma_alloc_from_contiguous(struct device *dev, int count,
+struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,
 				       unsigned int order);
 bool dma_release_from_contiguous(struct device *dev, struct page *pages,
 				 int count);
@@ -148,7 +148,7 @@ int dma_declare_contiguous(struct device *dev, phys_addr_t size,
 }
 
 static inline
-struct page *dma_alloc_from_contiguous(struct device *dev, int count,
+struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,
 				       unsigned int order)
 {
 	return NULL;
