OpenVZ__vzkernel
commit 15db646e6a776cccb0874d829f72f49666b425ee
Author:     Florian Westphal <fw@strlen.de>
AuthorDate: Thu Mar 22 13:19:33 2018 +0300
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Thu Mar 22 13:19:33 2018 +0300

    ms/netfilter: ebtables: CONFIG_COMPAT: don't trust userland offsets
    
    Commit b71812168571fa55e44cdd0254471331b9c4c4c6 in the mainline kernel.
    
    We need to make sure the offsets are not out of range of the
    total size.
    Also check that they are in ascending order.
    
    The WARN_ON triggered by syzkaller (it sets panic_on_warn) is
    changed to also bail out, no point in continuing parsing.
    
    Briefly tested with simple ruleset of
    -A INPUT --limit 1/s' --log
    plus jump to custom chains using 32bit ebtables binary.
    
    Reported-by: <syzbot+845a53d13171abf8bf29@syzkaller.appspotmail.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    
    CVE-2018-1068: Out-of-bounds write via userland offsets in ebt_entry struct in
    netfilter/ebtables.c
    A flaw was found in the latest Linux kernel. A out-of-bounds write of kernel
    address space may be triggered via uncontrolled userland provided offset in
    ebt_entry struct in netfilter/ebtables.c.
    https://bugzilla.redhat.com/show_bug.cgi?id=1552048
    
    https://jira.sw.ru/browse/PSBM-82544
    
    Signed-off-by: Evgenii Shatokhin <eshatokhin@virtuozzo.com>

diff --git a/net/bridge/netfilter/ebtables.c b/net/bridge/netfilter/ebtables.c
index 1f2a248d80c7..e342fde2471e 100644
--- a/net/bridge/netfilter/ebtables.c
+++ b/net/bridge/netfilter/ebtables.c
@@ -2034,7 +2034,9 @@ static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,
 		if (match_kern)
 			match_kern->match_size = ret;
 
-		WARN_ON(type == EBT_COMPAT_TARGET && size_left);
+		if (WARN_ON(type == EBT_COMPAT_TARGET && size_left))
+			return -EINVAL;
+
 		match32 = (struct compat_ebt_entry_mwt *) buf;
 	}
 
@@ -2091,6 +2093,15 @@ static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,
 	 *
 	 * offsets are relative to beginning of struct ebt_entry (i.e., 0).
 	 */
+	for (i = 0; i < 4 ; ++i) {
+		if (offsets[i] >= *total)
+			return -EINVAL;
+		if (i == 0)
+			continue;
+		if (offsets[i-1] > offsets[i])
+			return -EINVAL;
+	}
+
 	for (i = 0, j = 1 ; j < 4 ; j++, i++) {
 		struct compat_ebt_entry_mwt *match32;
 		unsigned int size;
