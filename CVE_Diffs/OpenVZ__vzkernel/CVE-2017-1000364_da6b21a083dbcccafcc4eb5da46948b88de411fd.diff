OpenVZ__vzkernel
commit da6b21a083dbcccafcc4eb5da46948b88de411fd
Author:     Larry Woodman <lwoodman@redhat.com>
AuthorDate: Tue Jun 20 13:20:24 2017 +0400
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Tue Jun 20 13:20:24 2017 +0400

    ms/mm: larger stack guard gap, between vmas
    
    The commit message of the mainstream version of the patch:
    1be7107 ("mm: larger stack guard gap, between vmas")
    
        Stack guard page is a useful feature to reduce a risk of stack smashing
        into a different mapping. We have been using a single page gap which
        is sufficient to prevent having stack adjacent to a different mapping.
        But this seems to be insufficient in the light of the stack usage in
        userspace. E.g. glibc uses as large as 64kB alloca() in many commonly
        used functions. Others use constructs liks gid_t buffer[NGROUPS_MAX]
        which is 256kB or stack strings with MAX_ARG_STRLEN.
    
        This will become especially dangerous for suid binaries and the default
        no limit for the stack size limit because those applications can be
        tricked to consume a large portion of the stack and a single glibc call
        could jump over the guard page. These attacks are not theoretical,
        unfortunatelly.
    
        Make those attacks less probable by increasing the stack guard gap
        to 1MB (on systems with 4k pages; but make it depend on the page size
        because systems with larger base pages might cap stack allocations in
        the PAGE_SIZE units) which should cover larger alloca() and VLA stack
        allocations. It is obviously not a full fix because the problem is
        somehow inherent, but it should reduce attack space a lot.
    
        One could argue that the gap size should be configurable from userspace,
        but that can be done later when somebody finds that the new 1MB is wrong
        for some special case applications.  For now, add a kernel command line
        option (stack_guard_gap) to specify the stack gap size (in page units).
    
        Implementation wise, first delete all the old code for stack guard page:
        because although we could get away with accounting one extra page in a
        stack vma, accounting a larger gap can break userspace - case in point,
        a program run with "ulimit -S -v 20000" failed when the 1MB gap was
        counted for RLIMIT_AS; similar problems could come with RLIMIT_MLOCK
        and strict non-overcommit mode.
    
        Instead of keeping gap inside the stack vma, maintain the stack guard
        gap as a gap between vmas: using vm_start_gap() in place of vm_start
        (or vm_end_gap() in place of vm_end if VM_GROWSUP) in just those few
        places which need to respect the gap - mainly arch_get_unmapped_area(),
        and and the vma tree's subtree_gap support for that.
    
        Original-patch-by: Oleg Nesterov <oleg@redhat.com>
        Original-patch-by: Michal Hocko <mhocko@suse.com>
        Signed-off-by: Hugh Dickins <hughd@google.com>
        Acked-by: Michal Hocko <mhocko@suse.com>
        Tested-by: Helge Deller <deller@gmx.de> # parisc
        Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1461333
    
    CVE-2017-1000364 kernel: heap/stack gap jumping via unbounded stack allocations
    
    A flaw was found in the way memory was being allocated on the stack for user
    space binaries. If heap (or different memory region) and stack memory regions
    were adjacent to each other, an attacker could use this flaw to jump over the
    stack guard gap, cause controlled memory corruption on process stack or the
    adjacent memory region, and thus increase their privileges on the system. This
    is a kernel-side mitigation which increases the stack guard gap size from one
    page to 1 MiB to make successful exploitation of this issue more difficult.
    
    https://jira.sw.ru/browse/PSBM-67428
    
    Signed-off-by: Konstantin Khorenko <khorenko@virtuozzo.com>

diff --git a/fs/exec.c b/fs/exec.c
index 6c53de84b879..6b6ef4dc8ade 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -187,7 +187,7 @@ static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
 
 #ifdef CONFIG_STACK_GROWSUP
 	if (write) {
-		ret = expand_downwards(bprm->vma, pos);
+		ret = expand_downwards(bprm->vma, pos, 0);
 		if (ret < 0)
 			return NULL;
 	}
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index be3c4dd47535..8f515ac3d40c 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -294,11 +294,13 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 
 	/* We don't show the stack guard page in /proc/maps */
 	start = vma->vm_start;
-	if (stack_guard_page_start(vma, start))
-		start += PAGE_SIZE;
 	end = vma->vm_end;
-	if (stack_guard_page_end(vma, end))
-		end -= PAGE_SIZE;
+	if (stack_guard_area(vma, start)) {
+		if (vma->vm_flags & VM_GROWSDOWN)
+			start += stack_guard_gap;
+		else
+			end -= stack_guard_gap;
+	}
 
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",
 			start,
diff --git a/include/linux/mm.h b/include/linux/mm.h
index a8f5630fc997..190e6ca6e5b0 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1244,34 +1244,6 @@ int set_page_dirty_mm(struct page *page, struct mm_struct *mm);
 int set_page_dirty_lock(struct page *page);
 int clear_page_dirty_for_io(struct page *page);
 
-/* Is the vma a continuation of the stack vma above it? */
-static inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)
-{
-	return vma && (vma->vm_end == addr) && (vma->vm_flags & VM_GROWSDOWN);
-}
-
-static inline int stack_guard_page_start(struct vm_area_struct *vma,
-					     unsigned long addr)
-{
-	return (vma->vm_flags & VM_GROWSDOWN) &&
-		(vma->vm_start == addr) &&
-		!vma_growsdown(vma->vm_prev, addr);
-}
-
-/* Is the vma a continuation of the stack vma below it? */
-static inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)
-{
-	return vma && (vma->vm_start == addr) && (vma->vm_flags & VM_GROWSUP);
-}
-
-static inline int stack_guard_page_end(struct vm_area_struct *vma,
-					   unsigned long addr)
-{
-	return (vma->vm_flags & VM_GROWSUP) &&
-		(vma->vm_end == addr) &&
-		!vma_growsup(vma->vm_next, addr);
-}
-
 extern pid_t
 vm_is_stack(struct task_struct *task, struct vm_area_struct *vma, int in_group);
 
@@ -1957,16 +1929,22 @@ unsigned long ra_submit(struct file_ra_state *ra,
 			struct address_space *mapping,
 			struct file *filp);
 
+extern unsigned long stack_guard_gap;
 /* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */
 extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
+extern int stack_guard_area(struct vm_area_struct *vma, unsigned long address);
 
 /* CONFIG_STACK_GROWSUP still needs to to grow downwards at some places */
 extern int expand_downwards(struct vm_area_struct *vma,
-		unsigned long address);
+		unsigned long address, unsigned long gap);
+unsigned long expandable_stack_area(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap);
+
 #if VM_GROWSUP
-extern int expand_upwards(struct vm_area_struct *vma, unsigned long address);
+extern int expand_upwards(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap);
 #else
-  #define expand_upwards(vma, address) do { } while (0)
+  #define expand_upwards(vma, address, gap) do { } while (0)
 #endif
 
 /* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
diff --git a/mm/gup.c b/mm/gup.c
index 988c8d021856..45efd9fc4989 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -276,12 +276,6 @@ no_page_table:
 	return page;
 }
 
-static inline int stack_guard_page(struct vm_area_struct *vma, unsigned long addr)
-{
-	return stack_guard_page_start(vma, addr) ||
-	       stack_guard_page_end(vma, addr+PAGE_SIZE);
-}
-
 /**
  * __get_user_pages() - pin user pages in memory
  * @tsk:	task_struct of target task
@@ -451,7 +445,7 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 
 				/* For mlock, just skip the stack guard page. */
 				if (foll_flags & FOLL_MLOCK) {
-					if (stack_guard_page(vma, start))
+					if (stack_guard_area(vma, start))
 						goto next_page;
 				}
 				if (foll_flags & FOLL_WRITE)
diff --git a/mm/memory.c b/mm/memory.c
index 33e8acb4d4fa..d846083dfc72 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2661,40 +2661,6 @@ out_release:
 	return ret;
 }
 
-/*
- * This is like a special single-page "expand_{down|up}wards()",
- * except we must first make sure that 'address{-|+}PAGE_SIZE'
- * doesn't hit another vma.
- */
-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)
-{
-	address &= PAGE_MASK;
-	if ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {
-		struct vm_area_struct *prev = vma->vm_prev;
-
-		/*
-		 * Is there a mapping abutting this one below?
-		 *
-		 * That's only ok if it's the same stack mapping
-		 * that has gotten split..
-		 */
-		if (prev && prev->vm_end == address)
-			return prev->vm_flags & VM_GROWSDOWN ? 0 : -ENOMEM;
-
-		expand_downwards(vma, address - PAGE_SIZE);
-	}
-	if ((vma->vm_flags & VM_GROWSUP) && address + PAGE_SIZE == vma->vm_end) {
-		struct vm_area_struct *next = vma->vm_next;
-
-		/* As VM_GROWSDOWN but s/below/above/ */
-		if (next && next->vm_start == address + PAGE_SIZE)
-			return next->vm_flags & VM_GROWSUP ? 0 : -ENOMEM;
-
-		expand_upwards(vma, address + PAGE_SIZE);
-	}
-	return 0;
-}
-
 /*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
@@ -2716,7 +2682,8 @@ static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 		return VM_FAULT_SIGBUS;
 
 	/* Check if we need to add a guard page to the stack */
-	if (check_stack_guard_page(vma, address) < 0)
+	if ((vma->vm_flags & (VM_GROWSDOWN|VM_GROWSUP)) &&
+			expand_stack(vma, address) < 0)
 		return VM_FAULT_SIGBUS;
 
 	/* Use the zero-page for reads */
diff --git a/mm/mmap.c b/mm/mmap.c
index 54c188e8b0f1..b03767f8e124 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2131,19 +2131,23 @@ find_vma_prev(struct mm_struct *mm, unsigned long addr,
  * update accounting. This is shared with both the
  * grow-up and grow-down cases.
  */
-static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)
+static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow,
+		unsigned long gap)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct rlimit *rlim = current->signal->rlim;
-	unsigned long new_start;
+	unsigned long new_start, actual_size;
 
 	/* address space limit tests */
 	if (!may_expand_vm(mm, grow))
 		return -ENOMEM;
 
 	/* Stack limit test */
-	if (size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))
-		return -ENOMEM;
+ 	actual_size = size;
+ 	if (size && (vma->vm_flags & (VM_GROWSUP | VM_GROWSDOWN)))
+		actual_size -= gap;
+ 	if (actual_size > READ_ONCE(rlim[RLIMIT_STACK].rlim_cur))
+ 		return -ENOMEM;
 
 	/* mlock limit tests */
 	if (vma->vm_flags & VM_LOCKED) {
@@ -2190,9 +2194,9 @@ fail_charge:
  * PA-RISC uses this for its stack; IA64 for its Register Backing Store.
  * vma is the last one with address > vma->vm_end.  Have to extend vma.
  */
-int expand_upwards(struct vm_area_struct *vma, unsigned long address)
+int expand_upwards(struct vm_area_struct *vma, unsigned long address, unsigned long gap)
 {
-	int error;
+	int error = 0;
 
 	if (!(vma->vm_flags & VM_GROWSUP))
 		return -EFAULT;
@@ -2209,15 +2213,7 @@ int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 	 * vma->vm_start/vm_end cannot change under us because the caller
 	 * is required to hold the mmap_sem in read mode.  We need the
 	 * anon_vma lock to serialize against concurrent expand_stacks.
-	 * Also guard against wrapping around to address 0.
 	 */
-	if (address < PAGE_ALIGN(address+4))
-		address = PAGE_ALIGN(address+4);
-	else {
-		vma_unlock_anon_vma(vma);
-		return -ENOMEM;
-	}
-	error = 0;
 
 	/* Somebody else might have raced and expanded it already */
 	if (address > vma->vm_end) {
@@ -2228,7 +2224,7 @@ int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 
 		error = -ENOMEM;
 		if (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {
-			error = acct_stack_growth(vma, size, grow);
+			error = acct_stack_growth(vma, size, grow, gap);
 			if (!error) {
 				/*
 				 * vma_gap_update() doesn't support concurrent
@@ -2266,7 +2262,7 @@ int expand_upwards(struct vm_area_struct *vma, unsigned long address)
  * vma is the first one with address < vma->vm_start.  Have to extend vma.
  */
 int expand_downwards(struct vm_area_struct *vma,
-				   unsigned long address)
+				   unsigned long address, unsigned long gap)
 {
 	int error;
 
@@ -2299,7 +2295,7 @@ int expand_downwards(struct vm_area_struct *vma,
 
 		error = -ENOMEM;
 		if (grow <= vma->vm_pgoff) {
-			error = acct_stack_growth(vma, size, grow);
+			error = acct_stack_growth(vma, size, grow, gap);
 			if (!error) {
 				/*
 				 * vma_gap_update() doesn't support concurrent
@@ -2330,31 +2326,74 @@ int expand_downwards(struct vm_area_struct *vma,
 	return error;
 }
 
+/* enforced gap between the expanding stack and other mappings. */
+unsigned long stack_guard_gap = 1UL<<20;
+
 /*
  * Note how expand_stack() refuses to expand the stack all the way to
  * abut the next virtual mapping, *unless* that mapping itself is also
  * a stack mapping. We want to leave room for a guard page, after all
  * (the guard page itself is not added here, that is done by the
  * actual page faulting logic)
- *
- * This matches the behavior of the guard page logic (see mm/memory.c:
- * check_stack_guard_page()), which only allows the guard page to be
- * removed under these circumstances.
  */
 #ifdef CONFIG_STACK_GROWSUP
+unsigned long expandable_stack_area(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap)
+{
+	struct vm_area_struct *next = vma->vm_next;
+	unsigned long guard_gap = stack_guard_gap;
+	unsigned long guard_addr;
+ 
+	address = ALIGN(address, PAGE_SIZE);;
+	if (!next)
+		goto out;
+
+	if (next->vm_flags & VM_GROWSUP) {
+		guard_gap = min(guard_gap, next->vm_start - address);
+		goto out;
+ 	}
+
+	if (next->vm_start - address < guard_gap)
+		return -ENOMEM;
+out:
+	if (TASK_SIZE - address < guard_gap)
+		guard_gap = TASK_SIZE - address;
+	guard_addr = address + guard_gap;
+	*gap = guard_gap;
+
+	return guard_addr;
+}
+
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
-	struct vm_area_struct *next;
+	unsigned long gap;
 
-	address &= PAGE_MASK;
-	next = vma->vm_next;
-	if (next && next->vm_start == address + PAGE_SIZE) {
-		if (!(next->vm_flags & VM_GROWSUP))
-			return -ENOMEM;
-	}
-	return expand_upwards(vma, address);
+	address = expandable_stack_area(vma, address, &gap);
+	if (IS_ERR_VALUE(address))
+		return -ENOMEM;
+	return expand_upwards(vma, address, gap);
 }
 
+int stack_guard_area(struct vm_area_struct *vma, unsigned long address)
+{
+ 	struct vm_area_struct *next;
+ 
+	if (!(vma->vm_flags & VM_GROWSUP))
+		return 0;
+
+	/*
+	 * strictly speaking there is a guard gap between disjoint stacks
+	 * but the gap is not canonical (it might be smaller) and it is
+	 * reasonably safe to assume that we can ignore that gap for stack
+	 * POPULATE or /proc/<pid>[s]maps purposes
+	 */
+ 	next = vma->vm_next;
+	if (next && next->vm_flags & VM_GROWSUP)
+		return 0;
+
+	return vma->vm_end - address < stack_guard_gap;
+}
+ 
 struct vm_area_struct *
 find_extend_vma(struct mm_struct *mm, unsigned long addr)
 {
@@ -2371,17 +2410,73 @@ find_extend_vma(struct mm_struct *mm, unsigned long addr)
 	return prev;
 }
 #else
+unsigned long expandable_stack_area(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap)
+{
+	struct vm_area_struct *prev = vma->vm_prev;
+	unsigned long guard_gap = stack_guard_gap;
+	unsigned long guard_addr;
+ 
+ 	address &= PAGE_MASK;
+	if (!prev)
+		goto out;
+
+	/*
+	 * Is there a mapping abutting this one below?
+	 *
+	 * That's only ok if it's the same stack mapping
+	 * that has gotten split or there is sufficient gap
+	 * between mappings
+	 */
+	if (prev->vm_flags & VM_GROWSDOWN) {
+		guard_gap = min(guard_gap, address - prev->vm_end);
+		goto out;
+ 	}
+
+	if (address - prev->vm_end < guard_gap)
+		return -ENOMEM;
+
+out:
+	/* make sure we won't underflow */
+	if (address < mmap_min_addr)
+		return -ENOMEM;
+	if (address - mmap_min_addr < guard_gap)
+		guard_gap = address - mmap_min_addr;
+
+	guard_addr = address - guard_gap;
+	*gap = guard_gap;
+
+	return guard_addr;
+}
+
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
-	struct vm_area_struct *prev;
+	unsigned long gap;
 
-	address &= PAGE_MASK;
-	prev = vma->vm_prev;
-	if (prev && prev->vm_end == address) {
-		if (!(prev->vm_flags & VM_GROWSDOWN))
-			return -ENOMEM;
-	}
-	return expand_downwards(vma, address);
+	address = expandable_stack_area(vma, address, &gap);
+	if (IS_ERR_VALUE(address))
+		return -ENOMEM;
+	return expand_downwards(vma, address, gap);
+}
+
+int stack_guard_area(struct vm_area_struct *vma, unsigned long address)
+{
+ 	struct vm_area_struct *prev;
+ 
+	if (!(vma->vm_flags & VM_GROWSDOWN))
+		return 0;
+
+	/*
+	 * strictly speaking there is a guard gap between disjoint stacks
+	 * but the gap is not canonical (it might be smaller) and it is
+	 * reasonably safe to assume that we can ignore that gap for stack
+	 * POPULATE or /proc/<pid>[s]maps purposes
+	 */
+ 	prev = vma->vm_prev;
+	if (prev && prev->vm_flags & VM_GROWSDOWN)
+		return 0;
+
+	return address - vma->vm_start < stack_guard_gap;
 }
 
 struct vm_area_struct *
