OpenVZ__vzkernel
commit a8a698f792e11659e32008a5ce8a168c14a60b8c
Author:     Eric Dumazet <edumazet@google.com>
AuthorDate: Fri Feb 3 14:59:38 2017 -0800
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Fri Apr 14 16:58:49 2017 +0400

    ms/tcp: avoid infinite loop in tcp_splice_read()
    
    Splicing from TCP socket is vulnerable when a packet with URG flag is
    received and stored into receive queue.
    
    __tcp_splice_read() returns 0, and sk_wait_data() immediately
    returns since there is the problematic skb in queue.
    
    This is a nice way to burn cpu (aka infinite loop) and trigger
    soft lockups.
    
    Again, this gem was found by syzkaller tool.
    
    Fixes: 9c55e01c0cc8 ("[TCP]: Splice receive support.")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov  <dvyukov@google.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    
    https://jira.sw.ru/browse/PSBM-61135
    https://bugzilla.redhat.com/show_bug.cgi?id=1426542
    CVE-2017-6214 kernel: ipv4/tcp: Infinite loop in tcp_splice_read()
    
    (cherry picked from commit ccf7abb93af09ad0868ae9033d1ca8108bdaec82)
    Signed-off-by: Konstantin Khorenko <khorenko@virtuozzo.com>

diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 277e3d24bc3b..1f7df79cd8b3 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -768,6 +768,12 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
 				ret = -EAGAIN;
 				break;
 			}
+			/* if __tcp_splice_read() got nothing while we have
+			 * an skb in receive queue, we do not want to loop.
+			 * This might happen with URG data.
+			 */
+			if (!skb_queue_empty(&sk->sk_receive_queue))
+				break;
 			sk_wait_data(sk, &timeo, NULL);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);
