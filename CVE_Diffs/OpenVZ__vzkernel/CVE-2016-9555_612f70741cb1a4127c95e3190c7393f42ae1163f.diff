OpenVZ__vzkernel
commit 612f70741cb1a4127c95e3190c7393f42ae1163f
Author:     Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
AuthorDate: Mon Nov 28 16:13:08 2016 +0400
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Mon Nov 28 16:13:08 2016 +0400

    ms/sctp: validate chunk len before actually using it
    
        sctp: validate chunk len before actually using it
    
        Andrey Konovalov reported that KASAN detected that SCTP was using a slab
        beyond the boundaries. It was caused because when handling out of the
        blue packets in function sctp_sf_ootb() it was checking the chunk len
        only after already processing the first chunk, validating only for the
        2nd and subsequent ones.
    
        The fix is to just move the check upwards so it's also validated for the
        1st chunk.
    
        Reported-by: Andrey Konovalov <andreyknvl@google.com>
        Tested-by: Andrey Konovalov <andreyknvl@google.com>
        Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
        Reviewed-by: Xin Long <lucien.xin@gmail.com>
        Acked-by: Neil Horman <nhorman@tuxdriver.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1397930
    https://jira.sw.ru/browse/PSBM-56174
    
    It fixes CVE-2016-9555 kernel: Slab out-of-bounds access in sctp_sf_ootb()
    
    ms commit: bf911e985d6bbaa328c20c3e05f4eb03de11fdd6
    Signed-off-by:  Vasily Averin <vvs@virtuozzo.com>

diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c
index 9fb37c853651..d8c63865a6e3 100644
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@ -3433,6 +3433,12 @@ sctp_disposition_t sctp_sf_ootb(struct net *net,
 			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
 						  commands);
 
+		/* Report violation if chunk len overflows */
+		ch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));
+		if (ch_end > skb_tail_pointer(skb))
+			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
+						  commands);
+
 		/* Now that we know we at least have a chunk header,
 		 * do things that are type appropriate.
 		 */
@@ -3464,12 +3470,6 @@ sctp_disposition_t sctp_sf_ootb(struct net *net,
 			}
 		}
 
-		/* Report violation if chunk len overflows */
-		ch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));
-		if (ch_end > skb_tail_pointer(skb))
-			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
-						  commands);
-
 		ch = (sctp_chunkhdr_t *) ch_end;
 	} while (ch_end < skb_tail_pointer(skb));
 
