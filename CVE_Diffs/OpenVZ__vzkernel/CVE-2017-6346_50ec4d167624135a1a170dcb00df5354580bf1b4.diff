OpenVZ__vzkernel
commit 50ec4d167624135a1a170dcb00df5354580bf1b4
Author:     Willem de Bruijn <willemb@google.com>
AuthorDate: Mon Oct 30 12:53:19 2017 +0300
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Wed Dec 20 18:24:18 2017 +0300

    ms/packet: hold bind lock when rebinding to fanout hook
    
    Packet socket bind operations must hold the po->bind_lock. This keeps
    po->running consistent with whether the socket is actually on a ptype
    list to receive packets.
    
    fanout_add unbinds a socket and its packet_rcv/tpacket_rcv call, then
    binds the fanout object to receive through packet_rcv_fanout.
    
    Make it hold the po->bind_lock when testing po->running and rebinding.
    Else, it can race with other rebind operations, such as that in
    packet_set_ring from packet_rcv to tpacket_rcv. Concurrent updates
    can result in a socket being added to a fanout group twice, causing
    use-after-free KASAN bug reports, among others.
    
    Reported independently by both trinity and syzkaller.
    Verified that the syzkaller reproducer passes after this patch.
    
    Fixes: dc99f600698d ("packet: Add fanout support.")
    Reported-by: nixioaming <nixiaoming@huawei.com>
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    
    ========================================================
    CVE-2017-15649 kernel: Use-after-free in the af_packet.c
    
    net/packet/af_packet.c in the Linux kernel before 4.13.6 allows local users to
    gain privileges via crafted system calls that trigger mishandling of
    packet_fanout data structures, because of a race condition (involving
    fanout_add and packet_do_bind) that leads to a use-after-free, a different
    vulnerability than CVE-2017-6346.
    
    https://jira.sw.ru/browse/PSBM-75808
    Commit 008ba2a13f2d04c947adc536d19debb8fe66f110 in the mainline kernel.
    
    vz-specific changes:
    
    1. Replaced refcount_read with atomic_read: this kernel version has not
    switched to refcount API yet.
    
    2. Added the call to __dev_remove_pack in the error path and moved the
    error handling under po->bind_lock (__dev_remove_pack should be called
    under po->bind_lock, it seems).
    
    The call to __dev_remove_pack() is needed on error, because fanout_add()
    calls dev_add_pack(&match->prot_hook) and it is needed to roll that
    back.
    
    An alternative would be to backport the following commits:
    * 6664498280cf "packet: call fanout_release, while UNREGISTERING a netdev"
    * 2bd624b4611f "packet: Do not call fanout_release from atomic contexts"
    
    The second one moves the call to dev_add_pack() out of fanout_add(), so
    the additional call to __dev_remove_pack() would be unnecessary. That
    change is a bit more invasive than I would like it to be though.
    
    Signed-off-by: Evgenii Shatokhin <eshatokhin@virtuozzo.com>

diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 2407c3bcf10a..2e9401d793ac 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -1379,9 +1379,6 @@ static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 		return -EINVAL;
 	}
 
-	if (!po->running)
-		return -EINVAL;
-
 	if (po->fanout)
 		return -EALREADY;
 
@@ -1419,7 +1416,10 @@ static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 		list_add(&match->list, &fanout_list);
 	}
 	err = -EINVAL;
-	if (match->type == type &&
+
+	spin_lock(&po->bind_lock);
+	if (po->running &&
+	    match->type == type &&
 	    match->prot_hook.type == po->prot_hook.type &&
 	    match->prot_hook.dev == po->prot_hook.dev) {
 		err = -ENOSPC;
@@ -1431,6 +1431,14 @@ static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 			err = 0;
 		}
 	}
+
+	if (err && !atomic_read(&match->sk_ref)) {
+		__dev_remove_pack(&match->prot_hook);
+		list_del(&match->list);
+		kfree(match);
+	}
+	spin_unlock(&po->bind_lock);
+
 out:
 	mutex_unlock(&fanout_mutex);
 	return err;
