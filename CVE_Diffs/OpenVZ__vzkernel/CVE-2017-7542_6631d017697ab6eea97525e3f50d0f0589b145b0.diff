OpenVZ__vzkernel
commit 6631d017697ab6eea97525e3f50d0f0589b145b0
Author:     Sabrina Dubroca <sd@queasysnail.net>
AuthorDate: Wed Jul 19 22:28:55 2017 +0200
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Wed Aug 30 14:49:03 2017 +0300

    ms/ipv6: avoid overflow of offset in ip6_find_1stfragopt
    
    In some cases, offset can overflow and can cause an infinite loop in
    ip6_find_1stfragopt(). Make it unsigned int to prevent the overflow, and
    cap it at IPV6_MAXPLEN, since packets larger than that should be invalid.
    
    This problem has been here since before the beginning of git history.
    
    Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    
    (cherry picked from commit 6399f1fae4ec29fab5ec76070435555e256ca3a6)
    
    CVE-2017-7542 kernel: Integer overflow in ip6_find_1stfragopt() causes infinite
    loop
    
    Integer overflow vulnerability in ip6_find_1stfragopt() function was found.
    Local attacker that has privileges to open raw socket can cause infinite loop
    inside ip6_find_1stfragopt() function.
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1473649
    https://jira.sw.ru/browse/PSBM-69372
    
    Signed-off-by: Konstantin Khorenko <khorenko@virtuozzo.com>

diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c
index fb2e412d1267..6a4ce7b1a045 100644
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@ -76,7 +76,7 @@ EXPORT_SYMBOL(ipv6_select_ident);
 
 int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
-	u16 offset = sizeof(struct ipv6hdr);
+	unsigned int offset = sizeof(struct ipv6hdr);
 	unsigned int packet_len = skb_tail_pointer(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
@@ -84,6 +84,7 @@ int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 
 	while (offset <= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
+		unsigned int len;
 
 		switch (**nexthdr) {
 
@@ -109,7 +110,10 @@ int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
-		offset += ipv6_optlen(exthdr);
+		len = ipv6_optlen(exthdr);
+		if (len + offset >= IPV6_MAXPLEN)
+			return -EINVAL;
+		offset += len;
 		*nexthdr = &exthdr->nexthdr;
 	}
 
