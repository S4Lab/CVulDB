OpenVZ__vzkernel
commit 04ab5d0e117ee18b19d83ff6d604bec2d53a3f4e
Author:     Roman Kagan <rkagan@virtuozzo.com>
AuthorDate: Thu May 26 18:42:20 2016 +0400
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Wed Aug 15 10:20:03 2018 +0300

    ms/kvm:vmx: more complete state update on APICv on/off
    
    The function to update APICv on/off state (in particular, to deactivate
    it when enabling Hyper-V SynIC) is incomplete: it doesn't adjust
    APICv-related fields among secondary processor-based VM-execution
    controls.  As a result, Windows 2012 guests get stuck when SynIC-based
    auto-EOI interrupt intersected with e.g. an IPI in the guest.
    
    In addition, the MSR intercept bitmap isn't updated every time "virtualize
    x2APIC mode" is toggled.  This path can only be triggered by a malicious
    guest, because Windows didn't use x2APIC but rather their own synthetic
    APIC access MSRs; however a guest running in a SynIC-enabled VM could
    switch to x2APIC and thus obtain direct access to host APIC MSRs
    (CVE-2016-4440).
    
    The patch fixes those omissions.
    
    Signed-off-by: Roman Kagan <rkagan@virtuozzo.com>
    Reported-by: Steve Rutherford <srutherford@google.com>
    Reported-by: Yang Zhang <yang.zhang.wz@gmail.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    (cherry picked from commit 3ce424e45411cf5a13105e0386b6ecf6eeb4f66f)
    
    https://jira.sw.ru/browse/PSBM-46939
    
    Signed-off-by: Roman Kagan <rkagan@virtuozzo.com>
    
    ======
    Notes for rebase to RHEL7.5:
    dropped hunk:
    
       commit 527e62b9b48fcc6ff1e307ffd618e29f952673de
           ms/kvm:vmx: more complete state update on APICv on/off
    
       diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
       index f7220aea6745..900fe15ee49c 100644
       --- a/arch/x86/kvm/vmx.c
       +++ b/arch/x86/kvm/vmx.c
       @@ -6221,23 +6234,20 @@ static __init int hardware_setup(void)
    
               set_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */
    
       -       if (enable_apicv) {
       -               for (msr = 0x800; msr <= 0x8ff; msr++)
       -                       vmx_disable_intercept_msr_read_x2apic(msr);
       -
       -               /* According SDM, in x2apic mode, the whole id reg is used.
       -                * But in KVM, it only use the highest eight bits. Need to
       -                * intercept it */
       -               vmx_enable_intercept_msr_read_x2apic(0x802);
       -               /* TMCCT */
       -               vmx_enable_intercept_msr_read_x2apic(0x839);
       -               /* TPR */
       -               vmx_disable_intercept_msr_write_x2apic(0x808);
       -               /* EOI */
       -               vmx_disable_intercept_msr_write_x2apic(0x80b);
       -               /* SELF-IPI */
       -               vmx_disable_intercept_msr_write_x2apic(0x83f);
       -       }
       +       for (msr = 0x800; msr <= 0x8ff; msr++)
       +               vmx_disable_intercept_msr_read_x2apic(msr);
       +
       +       /* According SDM, in x2apic mode, the whole id reg is used.  But in
       +        * KVM, it only use the highest eight bits. Need to intercept it */
       +       vmx_enable_intercept_msr_read_x2apic(0x802);
       +       /* TMCCT */
       +       vmx_enable_intercept_msr_read_x2apic(0x839);
       +       /* TPR */
       +       vmx_disable_intercept_msr_write_x2apic(0x808);
       +       /* EOI */
       +       vmx_disable_intercept_msr_write_x2apic(0x80b);
       +       /* SELF-IPI */
       +       vmx_disable_intercept_msr_write_x2apic(0x83f);
    
               if (enable_ept) {
                       kvm_mmu_set_mask_ptes(0ull,
    
    Signed-off-by: Konstantin Khorenko <khorenko@virtuozzo.com>

diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index cf3136eda128..6b50fe8e91f5 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -5209,6 +5209,16 @@ static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 
 	vmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));
+	if (cpu_has_secondary_exec_ctrls()) {
+		if (kvm_vcpu_apicv_active(vcpu))
+			vmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,
+				      SECONDARY_EXEC_APIC_REGISTER_VIRT |
+				      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
+		else
+			vmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,
+					SECONDARY_EXEC_APIC_REGISTER_VIRT |
+					SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
+	}
 
 	if (cpu_has_vmx_msr_bitmap())
 		vmx_update_msr_bitmap(vcpu);
