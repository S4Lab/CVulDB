OpenVZ__vzkernel
commit 61d7f5aa4b46691dc0204afa947bbe43ab31f289
Author:     Kevin Cernekee <cernekee@chromium.org>
AuthorDate: Fri Apr 27 13:20:21 2018 +0300
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Fri Apr 27 13:20:21 2018 +0300

    ms/netfilter: nfnetlink_cthelper: Add missing permission checks
    
    ML commit: 4b380c42f7d00a395feede754f0bc2292eebe6e5
    
    The capability check in nfnetlink_rcv() verifies that the caller
    has CAP_NET_ADMIN in the namespace that "owns" the netlink socket.
    However, nfnl_cthelper_list is shared by all net namespaces on the
    system.  An unprivileged user can create user and net namespaces
    in which he holds CAP_NET_ADMIN to bypass the netlink_net_capable()
    check:
    
        $ nfct helper list
        nfct v1.4.4: netlink error: Operation not permitted
        $ vpnns -- nfct helper list
        {
                .name = ftp,
                .queuenum = 0,
                .l3protonum = 2,
                .l4protonum = 6,
                .priv_data_len = 24,
                .status = enabled,
        };
    
    Add capable() checks in nfnetlink_cthelper, as this is cleaner than
    trying to generalize the solution.
    
    Signed-off-by: Kevin Cernekee <cernekee@chromium.org>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    
    CVE-2017-17448
    https://jira.sw.ru/browse/PSBM-83575
    
    Signed-off-by: Evgenii Shatokhin <eshatokhin@virtuozzo.com>
    
    khorenko@: Shouldn't we use ve_capable here instead?
    
    eshatokhin@: Nope. The whole point of this is to make it available to the host
    root only rather than for any root in netns. It was available for the root
    users in any netns, including the root users in CTs before this fix. It allowed
    all these users to monitor things they should not.
    
    Same for "[PATCH RH7] netfilter: xt_osf: Add missing permission checks".  If,
    for any reason, the host uses iptables for OS-based filtering, we cannot allow
    the CTs to affect these host rules. I doubt there are host that use that, but
    still.

diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c
index a5599fc51a6f..cb5f4ce77724 100644
--- a/net/netfilter/nfnetlink_cthelper.c
+++ b/net/netfilter/nfnetlink_cthelper.c
@@ -17,6 +17,7 @@
 #include <linux/types.h>
 #include <linux/list.h>
 #include <linux/errno.h>
+#include <linux/capability.h>
 #include <net/netlink.h>
 #include <net/sock.h>
 
@@ -292,6 +293,9 @@ nfnl_cthelper_new(struct sock *nfnl, struct sk_buff *skb,
 	struct nf_conntrack_tuple tuple;
 	int ret = 0, i;
 
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
 	if (!tb[NFCTH_NAME] || !tb[NFCTH_TUPLE])
 		return -EINVAL;
 
@@ -506,6 +510,9 @@ nfnl_cthelper_get(struct sock *nfnl, struct sk_buff *skb,
 	struct nf_conntrack_tuple tuple;
 	bool tuple_set = false;
 
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
 	if (nlh->nlmsg_flags & NLM_F_DUMP) {
 		struct netlink_dump_control c = {
 			.dump = nfnl_cthelper_dump_table,
@@ -578,6 +585,9 @@ nfnl_cthelper_del(struct sock *nfnl, struct sk_buff *skb,
 	bool tuple_set = false, found = false;
 	int i, j = 0, ret;
 
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
 	if (tb[NFCTH_NAME])
 		helper_name = nla_data(tb[NFCTH_NAME]);
 
