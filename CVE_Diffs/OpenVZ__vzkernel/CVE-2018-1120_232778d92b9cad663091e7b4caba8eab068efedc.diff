OpenVZ__vzkernel
commit 232778d92b9cad663091e7b4caba8eab068efedc
Author:     Evgenii Shatokhin <eshatokhin@virtuozzo.com>
AuthorDate: Thu Jul 5 11:02:41 2018 +0300
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Thu Nov 8 13:31:38 2018 +0300

    mm: replace access_remote_vm() write parameter with gup_flags
    
    https://jira.sw.ru/browse/PSBM-86221
    
    This is a prerequisite to the fix for CVE-2018-1120. This patch allows
    passing additional flags to access_remove_vm() which will be ultimately
    passed to __get_user_pages().
    
    Based on the following mainline commits but less invasive than the
    series these commits belong to (https://lkml.org/lkml/2016/10/12/659):
    * 442486ec1096 ("mm: replace __access_remote_vm() write parameter with gup_flags")
    * 6347e8d5bcce ("mm: replace access_remote_vm() write parameter with gup_flags")
    
    Signed-off-by: Evgenii Shatokhin <eshatokhin@virtuozzo.com>
    Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    
    ==========================================
    Patchset description:
    A user in the CT with support for FUSE can make some commands on the host
    hang if these commands read /proc/*/cmdline of the processes in that CT,
    e.g., ps aux. This is CVE-2018-1120
    
    The second patch of the series is a backport of the fix from mainline,
    7f7ccc2ccc2e ("proc: do not access cmdline nor environ from file-backed areas").
    
    That fix has prerequisites (mainline: https://lkml.org/lkml/2016/10/12/659),
    however, they are quite invasive. So, instead, a more lightweight
    approach is used in the first patch of this series. Unlike mainline, it
    provides get_user_pages_remote_flags() to keep other components using
    get_user_pages_remote() unchanged, it does not meddle with FOLL_FORCE either.

diff --git a/fs/proc/base.c b/fs/proc/base.c
index 4b1860bdd0fd..f390ac4afcbc 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -1021,6 +1021,7 @@ static ssize_t mem_rw(struct file *file, char __user *buf,
 	unsigned long addr = *ppos;
 	ssize_t copied;
 	char *page;
+	unsigned int flags = (write ? FOLL_WRITE : 0);
 
 	if (!mm)
 		return 0;
@@ -1041,7 +1042,7 @@ static ssize_t mem_rw(struct file *file, char __user *buf,
 			break;
 		}
 
-		this_len = access_remote_vm(mm, addr, page, this_len, write);
+		this_len = access_remote_vm(mm, addr, page, this_len, flags);
 		if (!this_len) {
 			if (!copied)
 				copied = -EIO;
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 4ce327ab6d17..50375e097ccc 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1315,7 +1315,7 @@ static inline int fixup_user_fault(struct task_struct *tsk,
 extern unsigned long vma_address(struct page *page, struct vm_area_struct *vma);
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
 extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,
-		void *buf, int len, int write);
+		void *buf, int len, unsigned int gup_flags);
 
 long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 		      unsigned long start, unsigned long nr_pages,
@@ -1325,6 +1325,11 @@ long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
 			    unsigned long start, unsigned long nr_pages,
 			    int write, int force, struct page **pages,
 			    struct vm_area_struct **vmas);
+long get_user_pages_remote_flags(struct task_struct *tsk, struct mm_struct *mm,
+				 unsigned long start, unsigned long nr_pages,
+				 int write, int force, struct page **pages,
+				 struct vm_area_struct **vmas,
+				 unsigned int gup_flags);
 long get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 		    unsigned long start, unsigned long nr_pages,
 		    int write, int force, struct page **pages,
diff --git a/mm/gup.c b/mm/gup.c
index 8094c05d03fe..297db213b4e3 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -889,6 +889,21 @@ long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
 }
 EXPORT_SYMBOL(get_user_pages_remote);
 
+/*
+ * Same as get_user_pages_remote() but can be used to pass additional flags
+ * to __get_user_pages().
+ */
+long get_user_pages_remote_flags(struct task_struct *tsk, struct mm_struct *mm,
+		unsigned long start, unsigned long nr_pages,
+		int write, int force, struct page **pages,
+		struct vm_area_struct **vmas, unsigned int gup_flags)
+{
+	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
+				       pages, vmas, NULL, false,
+				       gup_flags | FOLL_TOUCH | FOLL_REMOTE);
+}
+EXPORT_SYMBOL(get_user_pages_remote_flags);
+
 /*
  * This is the same as get_user_pages_remote() for the time
  * being.
diff --git a/mm/memory.c b/mm/memory.c
index 6633f6705808..3d26170d4529 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -3771,10 +3771,12 @@ EXPORT_SYMBOL_GPL(generic_access_phys);
  * given task for page fault accounting.
  */
 static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
-		unsigned long addr, void *buf, int len, int write)
+		unsigned long addr, void *buf, int len,
+		unsigned int gup_flags)
 {
 	struct vm_area_struct *vma;
 	void *old_buf = buf;
+	int write = gup_flags & FOLL_WRITE;
 
 	down_read(&mm->mmap_sem);
 	/* ignore errors, just check how much was successfully transferred */
@@ -3783,8 +3785,8 @@ static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
 		void *maddr;
 		struct page *page = NULL;
 
-		ret = get_user_pages_remote(tsk, mm, addr, 1,
-				write, 1, &page, &vma);
+		ret = get_user_pages_remote_flags(tsk, mm, addr, 1,
+				write, 1, &page, &vma, gup_flags);
 		if (ret <= 0) {
 			/*
 			 * Check if this is a VM_IO | VM_PFNMAP VMA, which
@@ -3834,14 +3836,14 @@ static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
  * @addr:	start address to access
  * @buf:	source or destination buffer
  * @len:	number of bytes to transfer
- * @write:	whether the access is a write
+ * @gup_flags:	flags modifying lookup behaviour
  *
  * The caller must hold a reference on @mm.
  */
 int access_remote_vm(struct mm_struct *mm, unsigned long addr,
-		void *buf, int len, int write)
+		void *buf, int len, unsigned int gup_flags)
 {
-	return __access_remote_vm(NULL, mm, addr, buf, len, write);
+	return __access_remote_vm(NULL, mm, addr, buf, len, gup_flags);
 }
 
 /*
@@ -3859,7 +3861,8 @@ int access_process_vm(struct task_struct *tsk, unsigned long addr,
 	if (!mm)
 		return 0;
 
-	ret = __access_remote_vm(tsk, mm, addr, buf, len, write);
+	ret = __access_remote_vm(tsk, mm, addr, buf, len,
+				 (write ? FOLL_WRITE : 0));
 	mmput(mm);
 
 	return ret;
diff --git a/mm/nommu.c b/mm/nommu.c
index e3c480bb29ed..4ad47976b81c 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -2028,9 +2028,11 @@ int filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 EXPORT_SYMBOL(filemap_fault);
 
 static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
-		unsigned long addr, void *buf, int len, int write)
+		unsigned long addr, void *buf, int len,
+		unsigned int gup_flags)
 {
 	struct vm_area_struct *vma;
+	int write = gup_flags & FOLL_WRITE;
 
 	down_read(&mm->mmap_sem);
 
@@ -2065,14 +2067,14 @@ static int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
  * @addr:	start address to access
  * @buf:	source or destination buffer
  * @len:	number of bytes to transfer
- * @write:	whether the access is a write
+ * @gup_flags:	flags modifying lookup behaviour
  *
  * The caller must hold a reference on @mm.
  */
 int access_remote_vm(struct mm_struct *mm, unsigned long addr,
-		void *buf, int len, int write)
+		void *buf, int len, unsigned int gup_flags)
 {
-	return __access_remote_vm(NULL, mm, addr, buf, len, write);
+	return __access_remote_vm(NULL, mm, addr, buf, len, gup_flags);
 }
 
 /*
@@ -2090,7 +2092,8 @@ int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, in
 	if (!mm)
 		return 0;
 
-	len = __access_remote_vm(tsk, mm, addr, buf, len, write);
+	len = __access_remote_vm(tsk, mm, addr, buf, len,
+				 (write ? FOLL_WRITE : 0));
 
 	mmput(mm);
 	return len;
