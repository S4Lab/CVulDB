OpenVZ__vzkernel
commit 6d8814a4c9797aaf6c38ff449cfea974d979473a
Author:     Ladi Prosek <lprosek@redhat.com>
AuthorDate: Mon Oct 16 13:51:59 2017 +0300
Commit:     Konstantin Khorenko <khorenko@virtuozzo.com>
CommitDate: Thu Dec 21 11:30:59 2017 +0300

    ms/KVM: MMU: always terminate page walks at level 1
    
    is_last_gpte() is not equivalent to the pseudo-code given in commit
    6bb69c9b69c31 ("KVM: MMU: simplify last_pte_bitmap") because an incorrect
    value of last_nonleaf_level may override the result even if level == 1.
    
    It is critical for is_last_gpte() to return true on level == 1 to
    terminate page walks. Otherwise memory corruption may occur as level
    is used as an index to various data structures throughout the page
    walking code.  Even though the actual bug would be wherever the MMU is
    initialized (as in the previous patch), be defensive and ensure here
    that is_last_gpte() returns the correct value.
    
    This patch is also enough to fix CVE-2017-12188.
    
    Fixes: 6bb69c9b69c315200ddc2bc79aee14c0184cf5b2
    Cc: stable@vger.kernel.org
    Cc: Andy Honig <ahonig@google.com>
    Signed-off-by: Ladi Prosek <lprosek@redhat.com>
    [Panic if walk_addr_generic gets an incorrect level; this is a serious
     bug and it's not worth a WARN_ON where the recovery path might hide
     further exploitable issues; suggested by Andrew Honig. - Paolo]
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    
    (cherry picked from commit 829ee279aed43faa5cb1e4d65c0cad52f2426c53)
    https://jira.sw.ru/browse/PSBM-74910
    Signed-off-by: Denis Plotnikov <dplotnikov@virtuozzo.com>

diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index 5b643906f2a2..d1f5589dce82 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -3675,13 +3675,6 @@ static bool sync_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,
 static inline bool is_last_gpte(struct kvm_mmu *mmu,
 				unsigned level, unsigned gpte)
 {
-	/*
-	 * PT_PAGE_TABLE_LEVEL always terminates.  The RHS has bit 7 set
-	 * iff level <= PT_PAGE_TABLE_LEVEL, which for our purpose means
-	 * level == PT_PAGE_TABLE_LEVEL; set PT_PAGE_SIZE_MASK in gpte then.
-	 */
-	gpte |= level - PT_PAGE_TABLE_LEVEL - 1;
-
 	/*
 	 * The RHS has bit 7 set iff level < mmu->last_nonleaf_level.
 	 * If it is clear, there are no large pages at this level, so clear
@@ -3689,6 +3682,13 @@ static inline bool is_last_gpte(struct kvm_mmu *mmu,
 	 */
 	gpte &= level - mmu->last_nonleaf_level;
 
+	/*
+	 * PT_PAGE_TABLE_LEVEL always terminates.  The RHS has bit 7 set
+	 * iff level <= PT_PAGE_TABLE_LEVEL, which for our purpose means
+	 * level == PT_PAGE_TABLE_LEVEL; set PT_PAGE_SIZE_MASK in gpte then.
+	 */
+	gpte |= level - PT_PAGE_TABLE_LEVEL - 1;
+
 	return gpte & PT_PAGE_SIZE_MASK;
 }
 
diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h
index 1545467e29cc..bc6a43aadea0 100644
--- a/arch/x86/kvm/paging_tmpl.h
+++ b/arch/x86/kvm/paging_tmpl.h
@@ -307,10 +307,11 @@ retry_walk:
 		--walker->level;
 
 		index = PT_INDEX(addr, walker->level);
-
 		table_gfn = gpte_to_gfn(pte);
 		offset    = index * sizeof(pt_element_t);
 		pte_gpa   = gfn_to_gpa(table_gfn) + offset;
+
+		BUG_ON(walker->level < 1);
 		walker->table_gfn[walker->level - 1] = table_gfn;
 		walker->pte_gpa[walker->level - 1] = pte_gpa;
 
