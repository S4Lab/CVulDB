jav__systemtap
commit ed51cfa24ca27746ab09b59280b94117dd58cba3
Author:     Josh Stone <jistone@redhat.com>
AuthorDate: Mon Jul 25 11:48:31 2011 -0400
Commit:     Frank Ch. Eigler <fche@redhat.com>
CommitDate: Mon Jul 25 11:49:30 2011 -0400

    CVE-2011-2503: read instead of mmap to load modules
    
    As staprun is preparing to load a kernel module, we first mmap the whole
    module as MAP_PRIVATE. Then we proceed with our security checks,
    including a trusted-signature validation on the mapped region, and if
    all checks out, we'll call init_module() with that same mapped region.
    
    However, MMAP(2) says of MAP_PRIVATE, "It is unspecified whether changes
    made to the file after the mmap() call are visible in the mapped
    region."  From my testing, it appears that file changes do indeed show
    up in our mapped memory.  This means we have a TOCTOU race between
    verifying the signature of that memory and then calling init_module().
    
    By using read() instead of mmap(), we ensure that we have a fully
    private copy of the module to verify and load, without fear of change.

diff --git a/runtime/staprun/staprun_funcs.c b/runtime/staprun/staprun_funcs.c
index d76aea14..d7ac4218 100644
--- a/runtime/staprun/staprun_funcs.c
+++ b/runtime/staprun/staprun_funcs.c
@@ -7,7 +7,7 @@
  * Public License (GPL); either version 2, or (at your option) any
  * later version.
  *
- * Copyright (C) 2007-2009 Red Hat Inc.
+ * Copyright (C) 2007-2011 Red Hat Inc.
  */
 
 #include "config.h"
@@ -58,7 +58,7 @@ int insert_module(
   assert_permissions_func assert_permissions
 ) {
 	int i;
-	long ret;
+	long ret, module_read;
 	void *module_file;
 	char *opts;
 	int saved_errno;
@@ -124,17 +124,39 @@ int insert_module(
 		return -1;
 	}
 
-	/* mmap in the entire module. Work with the memory mapped data from this
-	   point on to avoid a TOCTOU race between path and signature checking
-	   below and module loading.  */
-	module_file = mmap(NULL, sbuf.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, module_fd, 0);
-	if (module_file == MAP_FAILED) {
-		_perr("Error mapping '%s'", module_realpath);
+        /* Allocate memory for the entire module. */
+        module_file = calloc(1, sbuf.st_size);
+        if (module_file == NULL) {
+                _perr("Error allocating memory to read '%s'", module_realpath);
 		close(module_fd);
 		free(opts);
 		return -1;
 	}
 
+        /* Read in the entire module.  Work with this copy of the data from this
+           point on to avoid a TOCTOU race between path and signature checking
+           below and module loading.  */
+        module_read = 0;
+        while (module_read < sbuf.st_size) {
+                ret = read(module_fd, module_file + module_read,
+                           sbuf.st_size - module_read);
+                if (ret > 0)
+                        module_read += ret;
+                else if (ret == 0) {
+                        _err("Unexpected EOF reading '%s'", module_realpath);
+                        free(module_file);
+                        close(module_fd);
+                        free(opts);
+                        return -1;
+                } else if (errno != EINTR) {
+                        _perr("Error reading '%s'", module_realpath);
+                        free(module_file);
+                        close(module_fd);
+                        free(opts);
+                        return -1;
+                }
+        }
+
 	/* Check whether this module can be loaded by the current user.
 	 * check_permissions will exit(-1) if permissions are insufficient*/
 	assert_permissions (module_realpath, module_fd, module_file, sbuf.st_size);
@@ -159,7 +181,7 @@ int insert_module(
 
 	/* Cleanup. */
 	free(opts);
-	munmap(module_file, sbuf.st_size);
+	free(module_file);
 	close(module_fd);
 
 	if (ret != 0) {
