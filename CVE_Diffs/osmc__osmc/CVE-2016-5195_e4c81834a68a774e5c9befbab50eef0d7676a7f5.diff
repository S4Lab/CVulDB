osmc__osmc
commit e4c81834a68a774e5c9befbab50eef0d7676a7f5
Author:     Sam Nazarko <email@samnazarko.co.uk>
AuthorDate: Sat Oct 22 18:06:53 2016 +0100
Commit:     Sam Nazarko <email@samnazarko.co.uk>
CommitDate: Sat Oct 22 18:06:53 2016 +0100

    [package] [kernel-osmc] Add patch for CVE-2016-5195 for all devices. Update Raspberry Pi kernel to 4.4.27.
    
    Signed-off-by: Sam Nazarko <email@samnazarko.co.uk>

diff --git a/package/kernel-osmc/build.sh b/package/kernel-osmc/build.sh
index 4ff224bbb..9561a7245 100755
--- a/package/kernel-osmc/build.sh
+++ b/package/kernel-osmc/build.sh
@@ -10,11 +10,11 @@ INITRAMFS_EMBED=2
 INITRAMFS_NOBUILD=4
 
 . ../common.sh
-test $1 == rbp1 && VERSION="4.4.16" && REV="7" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD + $INITRAMFS_EMBED)) && IMG_TYPE="zImage"
-test $1 == rbp2 && VERSION="4.4.16" && REV="7" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD + $INITRAMFS_EMBED)) && IMG_TYPE="zImage"
-test $1 == vero && VERSION="4.4.0" && REV="6" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD + $INITRAMFS_EMBED)) && IMG_TYPE="zImage"
-test $1 == vero2 && VERSION="3.10.102" && REV="13" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD)) && IMG_TYPE="uImage"
-test $1 == atv && VERSION="4.2.3" && REV="17" && FLAGS_INITRAMFS=$(($INITRAMFS_NOBUILD)) && IMG_TYPE="zImage"
+test $1 == rbp1 && VERSION="4.4.27" && REV="1" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD + $INITRAMFS_EMBED)) && IMG_TYPE="zImage"
+test $1 == rbp2 && VERSION="4.4.27" && REV="1" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD + $INITRAMFS_EMBED)) && IMG_TYPE="zImage"
+test $1 == vero && VERSION="4.4.0" && REV="7" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD + $INITRAMFS_EMBED)) && IMG_TYPE="zImage"
+test $1 == vero2 && VERSION="3.10.104" && REV="1" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD)) && IMG_TYPE="uImage"
+test $1 == atv && VERSION="4.2.3" && REV="18" && FLAGS_INITRAMFS=$(($INITRAMFS_NOBUILD)) && IMG_TYPE="zImage"
 test $1 == pc && VERSION="4.2.3" && REV="7" && FLAGS_INITRAMFS=$(($INITRAMFS_BUILD + $INITRAMFS_EMBED)) && IMG_TYPE="zImage"
 if [ $1 == "rbp1" ] || [ $1 == "rbp2" ] || [ $1 == "atv" ] || [ $1 == "pc" ]
 then
diff --git a/package/kernel-osmc/files/DEBIAN/control b/package/kernel-osmc/files/DEBIAN/control
index ad49d5b41..3c8c38179 100644
--- a/package/kernel-osmc/files/DEBIAN/control
+++ b/package/kernel-osmc/files/DEBIAN/control
@@ -1,5 +1,5 @@
 Origin: OSMC
-Version: 3.0.5
+Version: 3.0.6
 Section: kernel
 Essential: No
 Priority: required
diff --git a/package/kernel-osmc/patches/atv-030-CVE-fix-CVE-2016-5195.patch b/package/kernel-osmc/patches/atv-030-CVE-fix-CVE-2016-5195.patch
new file mode 100644
index 000000000..34cdf6b80
--- /dev/null
+++ b/package/kernel-osmc/patches/atv-030-CVE-fix-CVE-2016-5195.patch
@@ -0,0 +1,96 @@
+From da391ff1088eb16bc546f84874aeec834c9aa331 Mon Sep 17 00:00:00 2001
+From: Linus Torvalds <torvalds@linux-foundation.org>
+Date: Thu, 13 Oct 2016 13:07:36 -0700
+Subject: [PATCH] mm: remove gup_flags FOLL_WRITE games from __get_user_pages()
+
+commit 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619 upstream.
+
+This is an ancient bug that was actually attempted to be fixed once
+(badly) by me eleven years ago in commit 4ceb5db9757a ("Fix
+get_user_pages() race for write access") but that was then undone due to
+problems on s390 by commit f33ea7f404e5 ("fix get_user_pages bug").
+
+In the meantime, the s390 situation has long been fixed, and we can now
+fix it by checking the pte_dirty() bit properly (and do it better).  The
+s390 dirty bit was implemented in abf09bed3cce ("s390/mm: implement
+software dirty bits") which made it into v3.9.  Earlier kernels will
+have to look at the page state itself.
+
+Also, the VM has become more scalable, and what used a purely
+theoretical race back then has become easier to trigger.
+
+To fix it, we introduce a new internal FOLL_COW flag to mark the "yes,
+we already did a COW" rather than play racy games with FOLL_WRITE that
+is very fundamental, and then use the pte dirty flag to validate that
+the FOLL_COW flag is still valid.
+
+Reported-and-tested-by: Phil "not Paul" Oester <kernel@linuxace.com>
+Acked-by: Hugh Dickins <hughd@google.com>
+Reviewed-by: Michal Hocko <mhocko@suse.com>
+Cc: Andy Lutomirski <luto@kernel.org>
+Cc: Kees Cook <keescook@chromium.org>
+Cc: Oleg Nesterov <oleg@redhat.com>
+Cc: Willy Tarreau <w@1wt.eu>
+Cc: Nick Piggin <npiggin@gmail.com>
+Cc: Greg Thelen <gthelen@google.com>
+Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ include/linux/mm.h |  1 +
+ mm/gup.c           | 14 ++++++++++++--
+ 2 files changed, 13 insertions(+), 2 deletions(-)
+
+diff --git a/include/linux/mm.h b/include/linux/mm.h
+index bf6f117..d59d07d 100644
+--- a/include/linux/mm.h
++++ b/include/linux/mm.h
+@@ -2071,6 +2071,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
+ #define FOLL_NUMA	0x200	/* force NUMA hinting page fault */
+ #define FOLL_MIGRATION	0x400	/* wait for page to replace migration entry */
+ #define FOLL_TRIED	0x800	/* a retry, previous pass started an IO */
++#define FOLL_COW       0x4000  /* internal GUP flag */
+ 
+ typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
+ 			void *data);
+diff --git a/mm/gup.c b/mm/gup.c
+index 6297f6b..af19ed5 100644
+--- a/mm/gup.c
++++ b/mm/gup.c
+@@ -32,6 +32,16 @@ static struct page *no_page_table(struct vm_area_struct *vma,
+ 	return NULL;
+ }
+ 
++/*
++ * FOLL_FORCE can write to even unwritable pte's, but only
++ * after we've gone through a COW cycle and they are dirty.
++ */
++static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
++{
++       return pte_write(pte) ||
++               ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
++}
++
+ static struct page *follow_page_pte(struct vm_area_struct *vma,
+ 		unsigned long address, pmd_t *pmd, unsigned int flags)
+ {
+@@ -66,7 +76,7 @@ retry:
+ 	}
+ 	if ((flags & FOLL_NUMA) && pte_protnone(pte))
+ 		goto no_page;
+-	if ((flags & FOLL_WRITE) && !pte_write(pte)) {
++	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {
+ 		pte_unmap_unlock(ptep, ptl);
+ 		return NULL;
+ 	}
+@@ -315,7 +325,7 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
+ 	 * reCOWed by userspace write).
+ 	 */
+ 	if ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))
+-		*flags &= ~FOLL_WRITE;
++	        *flags |= FOLL_COW;
+ 	return 0;
+ }
+ 
+-- 
+2.7.4
+
diff --git a/package/kernel-osmc/patches/rbp-012-add-rbp-support.patch b/package/kernel-osmc/patches/rbp-012-add-rbp-support.patch
index f71eec137..39c6991f4 100644
--- a/package/kernel-osmc/patches/rbp-012-add-rbp-support.patch
+++ b/package/kernel-osmc/patches/rbp-012-add-rbp-support.patch
@@ -35,6 +35,29 @@ index 0000000..7a837d2
 +		reg = <0x7e215000 0x8>;
 +		clocks = <&clocks BCM2835_CLOCK_VPU>;
 +	};
+diff --git a/Documentation/devicetree/bindings/clock/brcm,bcm2835-cprman.txt b/Documentation/devicetree/bindings/clock/brcm,bcm2835-cprman.txt
+index e56a1df..f04e45d 100644
+--- a/Documentation/devicetree/bindings/clock/brcm,bcm2835-cprman.txt
++++ b/Documentation/devicetree/bindings/clock/brcm,bcm2835-cprman.txt
+@@ -16,7 +16,17 @@ Required properties:
+ - #clock-cells:	Should be <1>. The permitted clock-specifier values can be
+ 		  found in include/dt-bindings/clock/bcm2835.h
+ - reg:		Specifies base physical address and size of the registers
+-- clocks:	The external oscillator clock phandle
++- clocks:	phandles to the parent clocks used as input to the module, in
++		  the following order:
++
++		  - External oscillator
++		  - DSI1 byte clock
++		  - DSI1 DDR2 clock
++		  - DSI1 DDR clock
++
++		  Only external oscillator is required.  The DSI clocks may
++		  not be present, in which case their children will be
++		  unusable.
+ 
+ Example:
+ 
 diff --git a/Documentation/devicetree/bindings/display/brcm,bcm-vc4.txt b/Documentation/devicetree/bindings/display/brcm,bcm-vc4.txt
 index 56a961a..a5ea451 100644
 --- a/Documentation/devicetree/bindings/display/brcm,bcm-vc4.txt
@@ -255,6 +278,71 @@ index 0000000..159544d
 +	};
 +};
 \ No newline at end of file
+diff --git a/Documentation/devicetree/bindings/net/microchip,enc28j60.txt b/Documentation/devicetree/bindings/net/microchip,enc28j60.txt
+new file mode 100644
+index 0000000..1dc3bc7
+--- /dev/null
++++ b/Documentation/devicetree/bindings/net/microchip,enc28j60.txt
+@@ -0,0 +1,59 @@
++* Microchip ENC28J60
++
++This is a standalone 10 MBit ethernet controller with SPI interface.
++
++For each device connected to a SPI bus, define a child node within
++the SPI master node.
++
++Required properties:
++- compatible: Should be "microchip,enc28j60"
++- reg: Specify the SPI chip select the ENC28J60 is wired to
++- interrupt-parent: Specify the phandle of the source interrupt, see interrupt
++                    binding documentation for details. Usually this is the GPIO bank
++                    the interrupt line is wired to.
++- interrupts: Specify the interrupt index within the interrupt controller (referred
++              to above in interrupt-parent) and interrupt type. The ENC28J60 natively
++              generates falling edge interrupts, however, additional board logic
++              might invert the signal.
++- pinctrl-names: List of assigned state names, see pinctrl binding documentation.
++- pinctrl-0: List of phandles to configure the GPIO pin used as interrupt line,
++             see also generic and your platform specific pinctrl binding
++             documentation.
++
++Optional properties:
++- spi-max-frequency: Maximum frequency of the SPI bus when accessing the ENC28J60.
++  According to the ENC28J80 datasheet, the chip allows a maximum of 20 MHz, however,
++  board designs may need to limit this value.
++- local-mac-address: See ethernet.txt in the same directory.
++
++
++Example (for NXP i.MX28 with pin control stuff for GPIO irq):
++
++        ssp2: ssp@80014000 {
++                compatible = "fsl,imx28-spi";
++                pinctrl-names = "default";
++                pinctrl-0 = <&spi2_pins_b &spi2_sck_cfg>;
++                status = "okay";
++
++                enc28j60: ethernet@0 {
++                        compatible = "microchip,enc28j60";
++                        pinctrl-names = "default";
++                        pinctrl-0 = <&enc28j60_pins>;
++                        reg = <0>;
++                        interrupt-parent = <&gpio3>;
++                        interrupts = <3 IRQ_TYPE_EDGE_FALLING>;
++                        spi-max-frequency = <12000000>;
++                };
++        };
++
++        pinctrl@80018000 {
++                enc28j60_pins: enc28j60_pins@0 {
++                        reg = <0>;
++                        fsl,pinmux-ids = <
++                                MX28_PAD_AUART0_RTS__GPIO_3_3    /* Interrupt */
++                        >;
++                        fsl,drive-strength = <MXS_DRIVE_4mA>;
++                        fsl,voltage = <MXS_VOLTAGE_HIGH>;
++                        fsl,pull-up = <MXS_PULL_DISABLE>;
++                };
++        };
 diff --git a/Documentation/devicetree/bindings/sound/brcm,bcm2835-i2s.txt b/Documentation/devicetree/bindings/sound/brcm,bcm2835-i2s.txt
 index 65783de..a89fe42 100644
 --- a/Documentation/devicetree/bindings/sound/brcm,bcm2835-i2s.txt
@@ -565,10 +653,10 @@ index 3c79f85..eaaeb17 100644
 -*.dtb
 +*.dtb*
 diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
-index 30bbc37..49badba 100644
+index 30bbc37..151121b 100644
 --- a/arch/arm/boot/dts/Makefile
 +++ b/arch/arm/boot/dts/Makefile
-@@ -1,5 +1,26 @@
+@@ -1,5 +1,27 @@
  ifeq ($(CONFIG_OF),y)
  
 +dtb-$(CONFIG_ARCH_BCM2708) += bcm2708-rpi-b.dtb
@@ -577,6 +665,7 @@ index 30bbc37..49badba 100644
 +dtb-$(CONFIG_ARCH_BCM2835) += bcm2835-rpi-cm.dtb
 +dtb-$(CONFIG_ARCH_BCM2709) += bcm2709-rpi-2-b.dtb
 +dtb-$(CONFIG_ARCH_BCM2709) += bcm2710-rpi-3-b.dtb
++dtb-$(CONFIG_ARCH_BCM2709) += bcm2710-rpi-cm3.dtb
 +
 +# Raspberry Pi
 +ifeq ($(CONFIG_ARCH_BCM2708),y)
@@ -595,7 +684,7 @@ index 30bbc37..49badba 100644
  dtb-$(CONFIG_ARCH_ALPINE) += \
  	alpine-db.dtb
  dtb-$(CONFIG_MACH_ASM9260) += \
-@@ -777,10 +798,20 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += \
+@@ -777,10 +799,20 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += \
  	mt8127-moose.dtb \
  	mt8135-evbp1.dtb
  dtb-$(CONFIG_ARCH_ZX) += zx296702-ad1.dtb
@@ -948,10 +1037,10 @@ index 0000000..beae037
 +};
 diff --git a/arch/arm/boot/dts/bcm2708-rpi-cm.dts b/arch/arm/boot/dts/bcm2708-rpi-cm.dts
 new file mode 100755
-index 0000000..cd0e1ac
+index 0000000..1cda047
 --- /dev/null
 +++ b/arch/arm/boot/dts/bcm2708-rpi-cm.dts
-@@ -0,0 +1,102 @@
+@@ -0,0 +1,107 @@
 +/dts-v1/;
 +
 +#include "bcm2708-rpi-cm.dtsi"
@@ -989,6 +1078,11 @@ index 0000000..cd0e1ac
 +		brcm,pins = <18 19 20 21>;
 +		brcm,function = <4>; /* alt0 */
 +	};
++
++	audio_pins: audio_pins {
++		brcm,pins;
++		brcm,function;
++	};
 +};
 +
 +&spi0 {
@@ -1056,7 +1150,7 @@ index 0000000..cd0e1ac
 +};
 diff --git a/arch/arm/boot/dts/bcm2708-rpi-cm.dtsi b/arch/arm/boot/dts/bcm2708-rpi-cm.dtsi
 new file mode 100644
-index 0000000..90e330d
+index 0000000..0a3a962
 --- /dev/null
 +++ b/arch/arm/boot/dts/bcm2708-rpi-cm.dtsi
 @@ -0,0 +1,52 @@
@@ -1085,9 +1179,9 @@ index 0000000..90e330d
 +};
 +
 +
-+&mmc {
++&sdhost {
 +	pinctrl-names = "default";
-+	pinctrl-0 = <&mmc_pins>;
++	pinctrl-0 = <&sdhost_pins>;
 +	non-removable;
 +	bus-width = <4>;
 +	status = "okay";
@@ -1160,14 +1254,15 @@ index 0000000..f5a44cd
 +};
 diff --git a/arch/arm/boot/dts/bcm2708_common.dtsi b/arch/arm/boot/dts/bcm2708_common.dtsi
 new file mode 100644
-index 0000000..74434b9
+index 0000000..c449493
 --- /dev/null
 +++ b/arch/arm/boot/dts/bcm2708_common.dtsi
-@@ -0,0 +1,471 @@
+@@ -0,0 +1,500 @@
 +#include "dt-bindings/clock/bcm2835.h"
 +#include <dt-bindings/clock/bcm2835-aux.h>
 +#include "dt-bindings/power/raspberrypi-power.h"
 +#include "dt-bindings/gpio/gpio.h"
++#include "dt-bindings/pinctrl/bcm2835.h"
 +#include "skeleton.dtsi"
 +
 +/ {
@@ -1276,9 +1371,10 @@ index 0000000..74434b9
 +			reg = <0x7e101000 0x2000>;
 +
 +			/* CPRMAN derives everything from the platform's
-+			 * oscillator.
++			 * oscillator except for a few clocks that may
++			 * derive from something else derived from CPRMAN..
 +			 */
-+			clocks = <&clk_osc>;
++			clocks = <&clk_osc>, <&dsi1 0>, <&dsi1 1>, <&dsi1 2>;
 +			status = "disabled";
 +		};
 +
@@ -1448,6 +1544,44 @@ index 0000000..74434b9
 +			status = "disabled";
 +		};
 +
++		firmwarekms: firmwarekms@7e600000 {
++			compatible = "raspberrypi,rpi-firmware-kms";
++			/* SMI interrupt reg */
++			reg = <0x7e600000 0x100>;
++			interrupts = <2 16>;
++			brcm,firmware = <&firmware>;
++			status = "disabled";
++		};
++
++		smi: smi@7e600000 {
++			compatible = "brcm,bcm2835-smi";
++			reg = <0x7e600000 0x44>, <0x7e1010b0 0x8>;
++			interrupts = <2 16>;
++			brcm,smi-clock-source = <6>;
++			brcm,smi-clock-divisor = <4>;
++			dmas = <&dma 4>;
++			dma-names = "rx-tx";
++			status = "disabled";
++		};
++
++		dsi1: dsi@7e700000 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			#clock-cells = <1>;
++
++			compatible = "brcm,bcm2835-dsi1";
++			reg = <0x7e700000 0x8c>;
++			interrupts = <2 12>;
++
++			clocks = <&cprman BCM2835_PLLD_DSI1>,
++				 <&cprman BCM2835_CLOCK_DSI1E>,
++				 <&cprman BCM2835_CLOCK_DSI1P>;
++			clock-names = "phy", "escape", "pixel";
++			clock-output-names = "dsi1_byte", "dsi1_ddr2", "dsi1_ddr";
++			status = "disabled";
++			power-domains = <&power RPI_POWER_DOMAIN_DSI1>;
++		};
++
 +		i2c1: i2c@7e804000 {
 +			compatible = "brcm,bcm2708-i2c";
 +			reg = <0x7e804000 0x1000>;
@@ -1471,17 +1605,6 @@ index 0000000..74434b9
 +			status = "disabled";
 +		};
 +
-+		smi: smi@7e600000 {
-+			compatible = "brcm,bcm2835-smi";
-+			reg = <0x7e600000 0x44>, <0x7e1010b0 0x8>;
-+			interrupts = <2 16>;
-+			brcm,smi-clock-source = <6>;
-+			brcm,smi-clock-divisor = <4>;
-+			dmas = <&dma 4>;
-+			dma-names = "rx-tx";
-+			status = "disabled";
-+		};
-+
 +		pixelvalve2: pixelvalve@7e807000 {
 +			compatible = "brcm,bcm2835-pixelvalve2";
 +			reg = <0x7e807000 0x100>;
@@ -1493,7 +1616,6 @@ index 0000000..74434b9
 +			reg = <0x7e902000 0x600>,
 +			      <0x7e808000 0x100>;
 +			ddc = <&i2c2>;
-+			hpd-gpios = <&gpio 46 GPIO_ACTIVE_HIGH>;
 +			clocks = <&cprman BCM2835_PLLH_PIX>,
 +				 <&cprman BCM2835_CLOCK_HSM>;
 +			clock-names = "pixel", "hdmi";
@@ -1512,6 +1634,7 @@ index 0000000..74434b9
 +		v3d: v3d@7ec00000 {
 +			compatible = "brcm,vc4-v3d";
 +			reg = <0x7ec00000 0x1000>;
++			power-domains = <&power RPI_POWER_DOMAIN_V3D>;
 +			status = "disabled";
 +		};
 +
@@ -1915,10 +2038,10 @@ index 0000000..a8cfd7c
 +};
 diff --git a/arch/arm/boot/dts/bcm2710-rpi-3-b.dts b/arch/arm/boot/dts/bcm2710-rpi-3-b.dts
 new file mode 100644
-index 0000000..a72e6e5
+index 0000000..98352b5
 --- /dev/null
 +++ b/arch/arm/boot/dts/bcm2710-rpi-3-b.dts
-@@ -0,0 +1,211 @@
+@@ -0,0 +1,207 @@
 +/dts-v1/;
 +
 +#include "bcm2710.dtsi"
@@ -2087,10 +2210,6 @@ index 0000000..a72e6e5
 +	};
 +};
 +
-+&hdmi {
-+	hpd-gpios = <&gpio 46 GPIO_ACTIVE_LOW>;
-+};
-+
 +&audio {
 +	pinctrl-names = "default";
 +	pinctrl-0 = <&audio_pins>;
@@ -2130,184 +2249,88 @@ index 0000000..a72e6e5
 +		sd_debug     = <&sdhost>,"brcm,debug";
 +	};
 +};
-diff --git a/arch/arm/boot/dts/bcm2710.dtsi b/arch/arm/boot/dts/bcm2710.dtsi
+diff --git a/arch/arm/boot/dts/bcm2710-rpi-cm3.dts b/arch/arm/boot/dts/bcm2710-rpi-cm3.dts
 new file mode 100644
-index 0000000..1a48686
+index 0000000..98e6f92
 --- /dev/null
-+++ b/arch/arm/boot/dts/bcm2710.dtsi
-@@ -0,0 +1,102 @@
-+#include "bcm2708_common.dtsi"
++++ b/arch/arm/boot/dts/bcm2710-rpi-cm3.dts
+@@ -0,0 +1,163 @@
++/dts-v1/;
++
++#include "bcm2710.dtsi"
 +
 +/ {
 +	compatible = "brcm,bcm2710","brcm,bcm2709";
-+	model = "BCM2710";
-+
-+	chosen {
-+		/* No padding required - the boot loader can do that. */
-+		bootargs = "";
-+	};
-+
-+	soc {
-+		ranges = <0x7e000000 0x3f000000 0x01000000>,
-+		         <0x40000000 0x40000000 0x00040000>;
-+
-+		local_intc: local_intc {
-+			compatible = "brcm,bcm2836-l1-intc";
-+			reg = <0x40000000 0x100>;
-+			interrupt-controller;
-+			#interrupt-cells = <1>;
-+			interrupt-parent = <&local_intc>;
-+		};
-+
-+		arm-pmu {
-+			compatible = "arm,cortex-a7-pmu";
-+			interrupt-parent = <&local_intc>;
-+			interrupts = <9>;
-+		};
-+
-+		gpiomem {
-+			compatible = "brcm,bcm2835-gpiomem";
-+			reg = <0x7e200000 0x1000>;
-+			status = "okay";
-+		};
-+
-+		timer {
-+			compatible = "arm,armv7-timer";
-+			clock-frequency = <19200000>;
-+			interrupt-parent = <&local_intc>;
-+			interrupts = <0>, // PHYS_SECURE_PPI
-+				     <1>, // PHYS_NONSECURE_PPI
-+				     <3>, // VIRT_PPI
-+				     <2>; // HYP_PPI
-+			always-on;
-+		};
++	model = "Raspberry Pi Compute Module 3";
++};
 +
-+		syscon@40000000 {
-+			compatible = "brcm,bcm2836-arm-local", "syscon";
-+			reg = <0x40000000 0x100>;
-+		};
++&gpio {
++	sdhost_pins: sdhost_pins {
++		brcm,pins = <48 49 50 51 52 53>;
++		brcm,function = <4>; /* alt0 */
++		brcm,pull = <0 2 2 2 2 2>;
 +	};
 +
-+	cpus: cpus {
-+		#address-cells = <1>;
-+		#size-cells = <0>;
-+
-+		v7_cpu0: cpu@0 {
-+			device_type = "cpu";
-+			compatible = "arm,cortex-a7";
-+			reg = <0x000>;
-+			clock-frequency = <800000000>;
-+		};
-+
-+		v7_cpu1: cpu@1 {
-+			device_type = "cpu";
-+			compatible = "arm,cortex-a7";
-+			reg = <0x001>;
-+			clock-frequency = <800000000>;
-+		};
-+
-+		v7_cpu2: cpu@2 {
-+			device_type = "cpu";
-+			compatible = "arm,cortex-a7";
-+			reg = <0x002>;
-+			clock-frequency = <800000000>;
-+		};
-+
-+		v7_cpu3: cpu@3 {
-+			device_type = "cpu";
-+			compatible = "arm,cortex-a7";
-+			reg = <0x003>;
-+			clock-frequency = <800000000>;
-+		};
++	spi0_pins: spi0_pins {
++		brcm,pins = <9 10 11>;
++		brcm,function = <4>; /* alt0 */
 +	};
 +
-+	__overrides__ {
-+		arm_freq = <&v7_cpu0>, "clock-frequency:0",
-+		       <&v7_cpu1>, "clock-frequency:0",
-+		       <&v7_cpu2>, "clock-frequency:0",
-+		       <&v7_cpu3>, "clock-frequency:0";
++	spi0_cs_pins: spi0_cs_pins {
++		brcm,pins = <8 7>;
++		brcm,function = <1>; /* output */
 +	};
-+};
-+
-+&watchdog {
-+	status = "okay";
-+};
 +
-+&intc {
-+        compatible = "brcm,bcm2836-armctrl-ic";
-+        interrupt-parent = <&local_intc>;
-+        interrupts = <8>;
-+};
-diff --git a/arch/arm/boot/dts/bcm2835-rpi-b-plus.dts b/arch/arm/boot/dts/bcm2835-rpi-b-plus.dts
-index 668442b..17e2443 100644
---- a/arch/arm/boot/dts/bcm2835-rpi-b-plus.dts
-+++ b/arch/arm/boot/dts/bcm2835-rpi-b-plus.dts
-@@ -1,30 +1,128 @@
- /dts-v1/;
--#include "bcm2835-rpi.dtsi"
-+#include "bcm2835.dtsi"
- 
- / {
- 	compatible = "raspberrypi,model-b-plus", "brcm,bcm2835";
- 	model = "Raspberry Pi Model B+";
-+};
- 
--	leds {
--		act {
--			gpios = <&gpio 47 0>;
--		};
-+&gpio {
-+	spi0_pins: spi0_pins {
-+		brcm,pins = <7 8 9 10 11>;
-+		brcm,function = <4>; /* alt0 */
-+	};
- 
--		pwr {
--			label = "PWR";
--			gpios = <&gpio 35 0>;
--			default-state = "keep";
--			linux,default-trigger = "default-on";
--		};
 +	i2c0_pins: i2c0 {
 +		brcm,pins = <0 1>;
 +		brcm,function = <4>;
- 	};
--};
- 
--&gpio {
--	pinctrl-0 = <&gpioout &alt0 &i2s_alt0 &alt3>;
++	};
++
 +	i2c1_pins: i2c1 {
 +		brcm,pins = <2 3>;
 +		brcm,function = <4>;
 +	};
- 
--	/* I2S interface */
--	i2s_alt0: i2s_alt0 {
++
 +	i2s_pins: i2s {
- 		brcm,pins = <18 19 20 21>;
--		brcm,function = <BCM2835_FSEL_ALT0>;
++		brcm,pins = <18 19 20 21>;
 +		brcm,function = <4>; /* alt0 */
 +	};
++
++	audio_pins: audio_pins {
++		brcm,pins;
++		brcm,function;
++	};
 +};
 +
-+&mmc {
-+	status = "okay";
++&sdhost {
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdhost_pins>;
++	non-removable;
 +	bus-width = <4>;
++	status = "okay";
++	brcm,overclock-50 = <0>;
 +};
 +
-+&fb {
-+	status = "okay";
++&soc {
++	virtgpio: virtgpio {
++		compatible = "brcm,bcm2835-virtgpio";
++		gpio-controller;
++		#gpio-cells = <2>;
++		firmware = <&firmware>;
++		status = "okay";
++	};
 +};
 +
-+&uart0 {
++&fb {
 +	status = "okay";
 +};
 +
 +&spi0 {
 +	pinctrl-names = "default";
-+	pinctrl-0 = <&spi0_pins>;
++	pinctrl-0 = <&spi0_pins &spi0_cs_pins>;
++	cs-gpios = <&gpio 8 1>, <&gpio 7 1>;
 +
-+	spidev@0{
++	spidev0: spidev@0{
 +		compatible = "spidev";
 +		reg = <0>;	/* CE0 */
 +		#address-cells = <1>;
@@ -2315,7 +2338,272 @@ index 668442b..17e2443 100644
 +		spi-max-frequency = <500000>;
 +	};
 +
-+	spidev@1{
++	spidev1: spidev@1{
++		compatible = "spidev";
++		reg = <1>;	/* CE1 */
++		#address-cells = <1>;
++		#size-cells = <0>;
++		spi-max-frequency = <500000>;
++	};
++};
++
++&i2c0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&i2c0_pins>;
++	clock-frequency = <100000>;
++};
++
++&i2c1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&i2c1_pins>;
++	clock-frequency = <100000>;
++};
++
++&i2c2 {
++	clock-frequency = <100000>;
++};
++
++&i2s {
++	#sound-dai-cells = <0>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&i2s_pins>;
++};
++
++&random {
++	status = "okay";
++};
++
++&leds {
++	act_led: act {
++		label = "led0";
++		linux,default-trigger = "mmc0";
++		gpios = <&virtgpio 0 0>;
++	};
++};
++
++&hdmi {
++	hpd-gpios = <&gpio 46 GPIO_ACTIVE_LOW>;
++};
++
++&audio {
++	pinctrl-names = "default";
++	pinctrl-0 = <&audio_pins>;
++};
++
++/ {
++	__overrides__ {
++		uart0 = <&uart0>,"status";
++		uart0_clkrate = <&clk_uart0>,"clock-frequency:0";
++		uart1 = <&uart1>,"status";
++		i2s = <&i2s>,"status";
++		spi = <&spi0>,"status";
++		i2c0 = <&i2c0>,"status";
++		i2c1 = <&i2c1>,"status";
++		i2c2_iknowwhatimdoing = <&i2c2>,"status";
++		i2c0_baudrate = <&i2c0>,"clock-frequency:0";
++		i2c1_baudrate = <&i2c1>,"clock-frequency:0";
++		i2c2_baudrate = <&i2c2>,"clock-frequency:0";
++		core_freq = <&clk_core>,"clock-frequency:0";
++
++		act_led_gpio = <&act_led>,"gpios:4";
++		act_led_activelow = <&act_led>,"gpios:8";
++		act_led_trigger = <&act_led>,"linux,default-trigger";
++
++		audio = <&audio>,"status";
++		watchdog = <&watchdog>,"status";
++		random = <&random>,"status";
++		sd_overclock = <&sdhost>,"brcm,overclock-50:0";
++		sd_force_pio = <&sdhost>,"brcm,force-pio?";
++		sd_pio_limit = <&sdhost>,"brcm,pio-limit:0";
++		sd_debug     = <&sdhost>,"brcm,debug";
++	};
++};
+diff --git a/arch/arm/boot/dts/bcm2710.dtsi b/arch/arm/boot/dts/bcm2710.dtsi
+new file mode 100644
+index 0000000..1a48686
+--- /dev/null
++++ b/arch/arm/boot/dts/bcm2710.dtsi
+@@ -0,0 +1,102 @@
++#include "bcm2708_common.dtsi"
++
++/ {
++	compatible = "brcm,bcm2710","brcm,bcm2709";
++	model = "BCM2710";
++
++	chosen {
++		/* No padding required - the boot loader can do that. */
++		bootargs = "";
++	};
++
++	soc {
++		ranges = <0x7e000000 0x3f000000 0x01000000>,
++		         <0x40000000 0x40000000 0x00040000>;
++
++		local_intc: local_intc {
++			compatible = "brcm,bcm2836-l1-intc";
++			reg = <0x40000000 0x100>;
++			interrupt-controller;
++			#interrupt-cells = <1>;
++			interrupt-parent = <&local_intc>;
++		};
++
++		arm-pmu {
++			compatible = "arm,cortex-a7-pmu";
++			interrupt-parent = <&local_intc>;
++			interrupts = <9>;
++		};
++
++		gpiomem {
++			compatible = "brcm,bcm2835-gpiomem";
++			reg = <0x7e200000 0x1000>;
++			status = "okay";
++		};
++
++		timer {
++			compatible = "arm,armv7-timer";
++			clock-frequency = <19200000>;
++			interrupt-parent = <&local_intc>;
++			interrupts = <0>, // PHYS_SECURE_PPI
++				     <1>, // PHYS_NONSECURE_PPI
++				     <3>, // VIRT_PPI
++				     <2>; // HYP_PPI
++			always-on;
++		};
++
++		syscon@40000000 {
++			compatible = "brcm,bcm2836-arm-local", "syscon";
++			reg = <0x40000000 0x100>;
++		};
++	};
++
++	cpus: cpus {
++		#address-cells = <1>;
++		#size-cells = <0>;
++
++		v7_cpu0: cpu@0 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a7";
++			reg = <0x000>;
++			clock-frequency = <800000000>;
++		};
++
++		v7_cpu1: cpu@1 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a7";
++			reg = <0x001>;
++			clock-frequency = <800000000>;
++		};
++
++		v7_cpu2: cpu@2 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a7";
++			reg = <0x002>;
++			clock-frequency = <800000000>;
++		};
++
++		v7_cpu3: cpu@3 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a7";
++			reg = <0x003>;
++			clock-frequency = <800000000>;
++		};
++	};
++
++	__overrides__ {
++		arm_freq = <&v7_cpu0>, "clock-frequency:0",
++		       <&v7_cpu1>, "clock-frequency:0",
++		       <&v7_cpu2>, "clock-frequency:0",
++		       <&v7_cpu3>, "clock-frequency:0";
++	};
++};
++
++&watchdog {
++	status = "okay";
++};
++
++&intc {
++        compatible = "brcm,bcm2836-armctrl-ic";
++        interrupt-parent = <&local_intc>;
++        interrupts = <8>;
++};
+diff --git a/arch/arm/boot/dts/bcm2835-rpi-b-plus.dts b/arch/arm/boot/dts/bcm2835-rpi-b-plus.dts
+index 668442b..17e2443 100644
+--- a/arch/arm/boot/dts/bcm2835-rpi-b-plus.dts
++++ b/arch/arm/boot/dts/bcm2835-rpi-b-plus.dts
+@@ -1,30 +1,128 @@
+ /dts-v1/;
+-#include "bcm2835-rpi.dtsi"
++#include "bcm2835.dtsi"
+ 
+ / {
+ 	compatible = "raspberrypi,model-b-plus", "brcm,bcm2835";
+ 	model = "Raspberry Pi Model B+";
++};
+ 
+-	leds {
+-		act {
+-			gpios = <&gpio 47 0>;
+-		};
++&gpio {
++	spi0_pins: spi0_pins {
++		brcm,pins = <7 8 9 10 11>;
++		brcm,function = <4>; /* alt0 */
++	};
+ 
+-		pwr {
+-			label = "PWR";
+-			gpios = <&gpio 35 0>;
+-			default-state = "keep";
+-			linux,default-trigger = "default-on";
+-		};
++	i2c0_pins: i2c0 {
++		brcm,pins = <0 1>;
++		brcm,function = <4>;
+ 	};
+-};
+ 
+-&gpio {
+-	pinctrl-0 = <&gpioout &alt0 &i2s_alt0 &alt3>;
++	i2c1_pins: i2c1 {
++		brcm,pins = <2 3>;
++		brcm,function = <4>;
++	};
+ 
+-	/* I2S interface */
+-	i2s_alt0: i2s_alt0 {
++	i2s_pins: i2s {
+ 		brcm,pins = <18 19 20 21>;
+-		brcm,function = <BCM2835_FSEL_ALT0>;
++		brcm,function = <4>; /* alt0 */
++	};
++};
++
++&mmc {
++	status = "okay";
++	bus-width = <4>;
++};
++
++&fb {
++	status = "okay";
++};
++
++&uart0 {
++	status = "okay";
++};
++
++&spi0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi0_pins>;
++
++	spidev@0{
++		compatible = "spidev";
++		reg = <0>;	/* CE0 */
++		#address-cells = <1>;
++		#size-cells = <0>;
++		spi-max-frequency = <500000>;
++	};
++
++	spidev@1{
 +		compatible = "spidev";
 +		reg = <1>;	/* CE1 */
 +		#address-cells = <1>;
@@ -2880,10 +3168,10 @@ index aef64de..3256bff 100644
 +};
 diff --git a/arch/arm/boot/dts/overlays/Makefile b/arch/arm/boot/dts/overlays/Makefile
 new file mode 100644
-index 0000000..7e740c8
+index 0000000..ea9e3bb
 --- /dev/null
 +++ b/arch/arm/boot/dts/overlays/Makefile
-@@ -0,0 +1,106 @@
+@@ -0,0 +1,114 @@
 +ifeq ($(CONFIG_OF),y)
 +
 +# Overlays for the Raspberry Pi platform
@@ -2902,11 +3190,14 @@ index 0000000..7e740c8
 +dtbo-$(RPI_DT_OVERLAYS) += ads1015.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += ads7846.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += akkordion-iqdacplus.dtbo
++dtbo-$(RPI_DT_OVERLAYS) += allo-piano-dac-pcm512x-audio.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += at86rf233.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += audioinjector-wm8731-audio.dtbo
++dtbo-$(RPI_DT_OVERLAYS) += audremap.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += bmp085_i2c-sensor.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += dht11.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += dionaudio-loco.dtbo
++dtbo-$(RPI_DT_OVERLAYS) += dpi18.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += dpi24.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += dwc-otg.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += dwc2.dtbo
@@ -2917,6 +3208,7 @@ index 0000000..7e740c8
 +dtbo-$(RPI_DT_OVERLAYS) += hifiberry-dac.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += hifiberry-dacplus.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += hifiberry-digi.dtbo
++dtbo-$(RPI_DT_OVERLAYS) += hifiberry-digi-pro.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += hy28a.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += hy28b.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += i2c-gpio.dtbo
@@ -2934,6 +3226,7 @@ index 0000000..7e740c8
 +dtbo-$(RPI_DT_OVERLAYS) += justboom-digi.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += lirc-rpi.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += mcp23017.dtbo
++dtbo-$(RPI_DT_OVERLAYS) += mcp23s17.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += mcp2515-can0.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += mcp2515-can1.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += mmc.dtbo
@@ -2946,6 +3239,7 @@ index 0000000..7e740c8
 +dtbo-$(RPI_DT_OVERLAYS) += pitft22.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += pitft28-capacitive.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += pitft28-resistive.dtbo
++dtbo-$(RPI_DT_OVERLAYS) += pitft35-resistive.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += pps-gpio.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += pwm.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += pwm-2chan.dtbo
@@ -2958,6 +3252,7 @@ index 0000000..7e740c8
 +dtbo-$(RPI_DT_OVERLAYS) += rpi-proto.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += rpi-sense.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += rra-digidac1-wm8741-audio.dtbo
++dtbo-$(RPI_DT_OVERLAYS) += sc16is750-i2c.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += sc16is752-spi1.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += sdhost.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += sdio.dtbo
@@ -2977,6 +3272,7 @@ index 0000000..7e740c8
 +dtbo-$(RPI_DT_OVERLAYS) += spi2-3cs.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += tinylcd35.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += uart1.dtbo
++dtbo-$(RPI_DT_OVERLAYS) += vc4-fkms-v3d.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += vc4-kms-v3d.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += vga666.dtbo
 +dtbo-$(RPI_DT_OVERLAYS) += w1-gpio.dtbo
@@ -2992,10 +3288,10 @@ index 0000000..7e740c8
 +clean-files	:= *.dtbo
 diff --git a/arch/arm/boot/dts/overlays/README b/arch/arm/boot/dts/overlays/README
 new file mode 100644
-index 0000000..780bf6d
+index 0000000..450804a
 --- /dev/null
 +++ b/arch/arm/boot/dts/overlays/README
-@@ -0,0 +1,1229 @@
+@@ -0,0 +1,1331 @@
 +Introduction
 +============
 +
@@ -3233,6 +3529,26 @@ index 0000000..780bf6d
 +                                that does not result in clipping/distortion!)
 +
 +
++Name:   allo-piano-dac-pcm512x-audio
++Info:   Configures the Allo Piano DAC (2.0/2.1) audio cards.
++        (NB. This initial support is for 2.0 channel audio ONLY! ie. stereo.
++        The subwoofer outputs on the Piano 2.1 are not currently supported!)
++Load:   dtoverlay=allo-piano-dac-pcm512x-audio,<param>
++Params: 24db_digital_gain       Allow gain to be applied via the PCM512x codec
++                                Digital volume control.
++                                (The default behaviour is that the Digital
++                                volume control is limited to a maximum of
++                                0dB. ie. it can attenuate but not provide
++                                gain. For most users, this will be desired
++                                as it will prevent clipping. By appending
++                                the 24db_digital_gain parameter, the Digital
++                                volume control will allow up to 24dB of
++                                gain. If this parameter is enabled, it is the
++                                responsibility of the user to ensure that
++                                the Digital volume control is set to a value
++                                that does not result in clipping/distortion!)
++
++
 +Name:   at86rf233
 +Info:   Configures the Atmel AT86RF233 802.15.4 low-power WPAN transceiver,
 +        connected to spi0.0
@@ -3251,6 +3567,15 @@ index 0000000..780bf6d
 +Params: <None>
 +
 +
++Name:   audremap
++Info:   Switches PWM sound output to pins 12 (Right) & 13 (Left)
++Load:   dtoverlay=audremap,<param>=<val>
++Params: swap_lr                 Reverse the channel allocation, which will also
++                                swap the audio jack outputs (default off)
++        enable_jack             Don't switch off the audio jack output
++                                (default off)
++
++
 +Name:   bmp085_i2c-sensor
 +Info:   Configures the BMP085/BMP180 digital barometric pressure and temperature
 +        sensors from Bosch Sensortec
@@ -3272,6 +3597,14 @@ index 0000000..780bf6d
 +Params: <None>
 +
 +
++Name:   dpi18
++Info:   Overlay for a generic 18-bit DPI display
++        This uses GPIOs 0-21 (so no I2C, uart etc.), and activates the output
++        2-3 seconds after the kernel has started.
++Load:   dtoverlay=dpi18
++Params: <None>
++
++
 +Name:   dpi24
 +Info:   Overlay for a generic 24-bit DPI display
 +        This uses GPIOs 0-27 (so no I2C, uart etc.), and activates the output
@@ -3329,7 +3662,7 @@ index 0000000..780bf6d
 +
 +
 +Name:   gpio-poweroff
-+Info:   Drives a GPIO high or low on reboot
++Info:   Drives a GPIO high or low on poweroff (including halt)
 +Load:   dtoverlay=gpio-poweroff,<param>=<val>
 +Params: gpiopin                 GPIO for signalling (default 26)
 +
@@ -3375,11 +3708,17 @@ index 0000000..780bf6d
 +
 +
 +Name:   hifiberry-digi
-+Info:   Configures the HifiBerry Digi audio card
++Info:   Configures the HifiBerry Digi and Digi+ audio card
 +Load:   dtoverlay=hifiberry-digi
 +Params: <None>
 +
 +
++Name:   hifiberry-digi-pro
++Info:   Configures the HifiBerry Digi+ Pro audio card
++Load:   dtoverlay=hifiberry-digi-pro
++Params: <None>
++
++
 +Name:   hy28a
 +Info:   HY28A - 2.8" TFT LCD Display Module by HAOYU Electronics
 +        Default values match Texy's display shield
@@ -3620,6 +3959,30 @@ index 0000000..780bf6d
 +        addr                    I2C address of the MCP23017 (default: 0x20)
 +
 +
++Name:   mcp23s17
++Info:   Configures the MCP23S08/17 SPI GPIO expanders.
++        If devices are present on SPI1 or SPI2, those interfaces must be enabled
++        with one of the spi1-1/2/3cs and/or spi2-1/2/3cs overlays.
++        If interrupts are enabled for a device on a given CS# on a SPI bus, that
++        device must be the only one present on that SPI bus/CS#.
++Load:   dtoverlay=mcp23s17,<param>=<val>
++Params: s08-spi<n>-<m>-present  4-bit integer, bitmap indicating MCP23S08
++                                devices present on SPI<n>, CS#<m>
++
++        s17-spi<n>-<m>-present  8-bit integer, bitmap indicating MCP23S17
++                                devices present on SPI<n>, CS#<m>
++
++        s08-spi<n>-<m>-int-gpio integer, enables interrupts on a single
++                                MCP23S08 device on SPI<n>, CS#<m>, specifies
++                                the GPIO pin to which INT output of MCP23S08
++                                is connected.
++
++        s17-spi<n>-<m>-int-gpio integer, enables mirrored interrupts on a
++                                single MCP23S17 device on SPI<n>, CS#<m>,
++                                specifies the GPIO pin to which either INTA
++                                or INTB output of MCP23S17 is connected.
++
++
 +Name:   mcp2515-can0
 +Info:   Configures the MCP2515 CAN controller on spi0.0
 +Load:   dtoverlay=mcp2515-can0,<param>=<val>
@@ -3785,10 +4148,24 @@ index 0000000..780bf6d
 +        debug                   Debug output level {0-7}
 +
 +
++Name:   pitft35-resistive
++Info:   Adafruit PiTFT 3.5" resistive touch screen
++Load:   dtoverlay=pitft35-resistive,<param>=<val>
++Params: speed                   Display SPI bus speed
++
++        rotate                  Display rotation {0,90,180,270}
++
++        fps                     Delay between frame updates
++
++        debug                   Debug output level {0-7}
++
++
 +Name:   pps-gpio
 +Info:   Configures the pps-gpio (pulse-per-second time signal via GPIO).
 +Load:   dtoverlay=pps-gpio,<param>=<val>
 +Params: gpiopin                 Input GPIO (default "18")
++        assert_falling_edge     When present, assert is indicated by a falling
++                                edge, rather than by a rising edge
 +
 +
 +Name:   pwm
@@ -3892,6 +4269,16 @@ index 0000000..780bf6d
 +Params: <None>
 +
 +
++Name:   sc16is750-i2c
++Info:   Overlay for the NXP SC16IS750 UART with I2C Interface
++        Enables the chip on I2C1 at 0x48. To select another address,
++        please refer to table 10 in reference manual.
++
++Load:   dtoverlay=sc16is750-i2c,<param>=<val>
++Params: int_pin                 GPIO used for IRQ (default 24)
++        addr                    Address (default 0x48)
++
++
 +Name:   sc16is752-spi1
 +Info:   Overlay for the NXP SC16IS752 Dual UART with SPI Interface
 +        Enables the chip on SPI1.
@@ -4154,6 +4541,17 @@ index 0000000..780bf6d
 +        rxd1_pin                GPIO pin for RXD1 (15, 33 or 41 - default 15)
 +
 +
++Name:   vc4-fkms-v3d
++Info:   Enable Eric Anholt's DRM VC4 V3D driver on top of the dispmanx
++        display stack.
++Load:   dtoverlay=vc4-fkms-v3d,<param>
++Params: cma-256                 CMA is 256MB, 256MB-aligned (needs 1GB)
++        cma-192                 CMA is 192MB, 256MB-aligned (needs 1GB)
++        cma-128                 CMA is 128MB, 128MB-aligned
++        cma-96                  CMA is 96MB, 128MB-aligned
++        cma-64                  CMA is 64MB, 64MB-aligned
++
++
 +Name:   vc4-kms-v3d
 +Info:   Enable Eric Anholt's DRM VC4 HDMI/HVS/V3D driver. Running startx or
 +        booting to GUI while this overlay is in use will cause interesting
@@ -4535,6 +4933,66 @@ index 0000000..208849d
 +		24db_digital_gain = <&frag2>,"iqaudio,24db_digital_gain?";
 +	};
 +};
+diff --git a/arch/arm/boot/dts/overlays/allo-piano-dac-pcm512x-audio-overlay.dts b/arch/arm/boot/dts/overlays/allo-piano-dac-pcm512x-audio-overlay.dts
+new file mode 100644
+index 0000000..a5468d8
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/allo-piano-dac-pcm512x-audio-overlay.dts
+@@ -0,0 +1,54 @@
++/*
++ * Definitions for Allo Piano DAC (2.0/2.1) boards
++ *
++ * NB. The Piano DAC 2.1 board contains 2x TI PCM5142 DAC's. One DAC is stereo
++ * (left/right) and the other provides a subwoofer output, using DSP on the
++ * chip for digital high/low pass crossover.
++ * The initial support for this hardware, that doesn't require any codec driver
++ * modifications, uses only one DAC chip for stereo (left/right) output, the
++ * chip with 0x4c slave address. The other chip at 0x4d is currently ignored!
++ */
++
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "brcm,bcm2708";
++
++	fragment@0 {
++		target = <&i2s>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@1 {
++		target = <&i2c1>;
++		__overlay__ {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "okay";
++
++			pcm5142@4c {
++				#sound-dai-cells = <0>;
++				compatible = "ti,pcm5142";
++				reg = <0x4c>;
++				status = "okay";
++			};
++		};
++	};
++
++	fragment@2 {
++		target = <&sound>;
++		piano_dac: __overlay__ {
++			compatible = "allo,piano-dac";
++			i2s-controller = <&i2s>;
++			status = "okay";
++		};
++	};
++
++	__overrides__ {
++		24db_digital_gain =
++			<&piano_dac>,"allo,24db_digital_gain?";
++	};
++};
 diff --git a/arch/arm/boot/dts/overlays/at86rf233-overlay.dts b/arch/arm/boot/dts/overlays/at86rf233-overlay.dts
 new file mode 100644
 index 0000000..880c753
@@ -4643,6 +5101,31 @@ index 0000000..4ed66577
 +		};
 +	};
 +};
+diff --git a/arch/arm/boot/dts/overlays/audremap-overlay.dts b/arch/arm/boot/dts/overlays/audremap-overlay.dts
+new file mode 100644
+index 0000000..9582d6a
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/audremap-overlay.dts
+@@ -0,0 +1,19 @@
++/dts-v1/;
++/plugin/;
++
++/ {
++        compatible = "brcm,bcm2708";
++
++        fragment@0 {
++                target = <&audio_pins>;
++                frag0: __overlay__ {
++                        brcm,pins = < 12 13 >;
++                        brcm,function = < 4 >; /* alt0 alt0 */
++                };
++        };
++
++	__overrides__ {
++		swap_lr = <&frag0>, "swap_lr?";
++		enable_jack = <&frag0>, "enable_jack?";
++	};
++};
 diff --git a/arch/arm/boot/dts/overlays/bmp085_i2c-sensor-overlay.dts b/arch/arm/boot/dts/overlays/bmp085_i2c-sensor-overlay.dts
 new file mode 100644
 index 0000000..782b171
@@ -4762,6 +5245,43 @@ index 0000000..3930f41
 +		};
 +	};
 +};
+diff --git a/arch/arm/boot/dts/overlays/dpi18-overlay.dts b/arch/arm/boot/dts/overlays/dpi18-overlay.dts
+new file mode 100644
+index 0000000..8098d5e
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/dpi18-overlay.dts
+@@ -0,0 +1,31 @@
++/dts-v1/;
++/plugin/;
++
++/{
++	compatible = "brcm,bcm2708";
++
++	// There is no DPI driver module, but we need a platform device
++	// node (that doesn't already use pinctrl) to hang the pinctrl
++	// reference on - leds will do
++
++	fragment@0 {
++		target = <&leds>;
++		__overlay__ {
++			pinctrl-names = "default";
++			pinctrl-0 = <&dpi18_pins>;
++		};
++	};
++
++	fragment@1 {
++		target = <&gpio>;
++		__overlay__ {
++			dpi18_pins: dpi18_pins {
++				brcm,pins = <0 1 2 3 4 5 6 7 8 9 10 11
++					     12 13 14 15 16 17 18 19 20
++					     21>;
++				brcm,function = <6>; /* alt2 */
++				brcm,pull = <0>; /* no pull */
++			};
++		};
++	};
++};
 diff --git a/arch/arm/boot/dts/overlays/dpi24-overlay.dts b/arch/arm/boot/dts/overlays/dpi24-overlay.dts
 new file mode 100644
 index 0000000..e4dbe40
@@ -5201,6 +5721,53 @@ index 0000000..f5e41f4
 +		};
 +	};
 +};
+diff --git a/arch/arm/boot/dts/overlays/hifiberry-digi-pro-overlay.dts b/arch/arm/boot/dts/overlays/hifiberry-digi-pro-overlay.dts
+new file mode 100644
+index 0000000..2a26d9c
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/hifiberry-digi-pro-overlay.dts
+@@ -0,0 +1,41 @@
++// Definitions for HiFiBerry Digi Pro
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "brcm,bcm2708";
++
++	fragment@0 {
++		target = <&i2s>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@1 {
++		target = <&i2c1>;
++		__overlay__ {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "okay";
++
++			wm8804@3b {
++				#sound-dai-cells = <0>;
++				compatible = "wlf,wm8804";
++				reg = <0x3b>;
++				status = "okay";
++			};
++		};
++	};
++
++	fragment@2 {
++		target = <&sound>;
++		__overlay__ {
++			compatible = "hifiberry,hifiberry-digi";
++			i2s-controller = <&i2s>;
++			status = "okay";
++			clock44-gpio = <&gpio 5 0>;
++			clock48-gpio = <&gpio 6 0>;
++		};
++	};
++};
 diff --git a/arch/arm/boot/dts/overlays/hy28a-overlay.dts b/arch/arm/boot/dts/overlays/hy28a-overlay.dts
 new file mode 100644
 index 0000000..ac0f3c2
@@ -6283,6 +6850,744 @@ index 0000000..412f966
 +	};
 +};
 +
+diff --git a/arch/arm/boot/dts/overlays/mcp23s17-overlay.dts b/arch/arm/boot/dts/overlays/mcp23s17-overlay.dts
+new file mode 100644
+index 0000000..7dcbacb
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/mcp23s17-overlay.dts
+@@ -0,0 +1,732 @@
++// Overlay for MCP23S08/17 GPIO Extenders from Microchip Semiconductor
++
++// dtparams:
++//     s08-spi<n>-<m>-present  - 4-bit integer, bitmap indicating MCP23S08 devices present on SPI<n>, CS#<m>.
++//     s17-spi<n>-<m>-present  - 8-bit integer, bitmap indicating MCP23S17 devices present on SPI<n>, CS#<m>.
++//     s08-spi<n>-<m>-int-gpio - integer, enables interrupts on a single MCP23S08 device on SPI<n>, CS#<m>, specifies the GPIO pin to which INT output is connected.
++//     s17-spi<n>-<m>-int-gpio - integer, enables mirrored interrupts on a single MCP23S17 device on SPI<n>, CS#<m>, specifies the GPIO pin to which either INTA or INTB output is connected.
++//
++// If devices are present on SPI1 or SPI2, those interfaces must be enabled with one of the spi1-1/2/3cs and/or spi2-1/2/3cs overlays.
++// If interrupts are enabled for a device on a given CS# on a SPI bus, that device must be the only one present on that SPI bus/CS#.
++//
++// Example 1: A single MCP23S17 device on SPI0, CS#0 with its SPI addr set to 0 and INTA output connected to GPIO25:
++// dtoverlay=mcp23s17:s17-spi0-0-present=1,s17-spi0-0-int-gpio=25
++//
++// Example 2: Two MCP23S08 devices on SPI1, CS#0 with their addrs set to 2 and 3. Three MCP23S17 devices on SPI1, CS#1 with their addrs set to 0, 1 and 7:
++// dtoverlay=spi1-2cs
++// dtoverlay=mcp23s17:s08-spi1-0-present=12,s17-spi1-1-present=131
++
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
++
++	// disable spi-dev on spi0.0
++	fragment@0 {
++		target = <&spidev0>;
++		__dormant__ {
++			status = "disabled";
++		};
++	};
++
++	// disable spi-dev on spi0.1
++	fragment@1 {
++		target = <&spidev1>;
++		__dormant__ {
++			status = "disabled";
++		};
++	};
++
++	// disable spi-dev on spi1.0
++	fragment@2 {
++		target-path = "spi1/spidev@0";
++		__dormant__ {
++			status = "disabled";
++		};
++	};
++
++	// disable spi-dev on spi1.1
++	fragment@3 {
++		target-path = "spi1/spidev@1";
++		__dormant__ {
++			status = "disabled";
++		};
++	};
++
++	// disable spi-dev on spi1.2
++	fragment@4 {
++		target-path = "spi1/spidev@2";
++		__dormant__ {
++			status = "disabled";
++		};
++	};
++
++	// disable spi-dev on spi2.0
++	fragment@5 {
++		target-path = "spi2/spidev@0";
++		__dormant__ {
++			status = "disabled";
++		};
++	};
++
++	// disable spi-dev on spi2.1
++	fragment@6 {
++		target-path = "spi2/spidev@1";
++		__dormant__ {
++			status = "disabled";
++		};
++	};
++
++	// disable spi-dev on spi2.2
++	fragment@7 {
++		target-path = "spi2/spidev@2";
++		__dormant__ {
++			status = "disabled";
++		};
++	};
++
++	// enable one or more mcp23s08s on spi0.0
++	fragment@8 {
++		target = <&spi0>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s08_00: mcp23s08@0 {
++				compatible = "microchip,mcp23s08";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s08-spi0-0-present parameter */
++     				reg = <0>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s08-spi0-0-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s08s on spi0.1
++	fragment@9 {
++		target = <&spi0>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s08_01: mcp23s08@1 {
++				compatible = "microchip,mcp23s08";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s08-spi0-1-present parameter */
++     				reg = <1>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s08-spi0-1-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s08s on spi1.0
++	fragment@10 {
++		target = <&spi1>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s08_10: mcp23s08@0 {
++				compatible = "microchip,mcp23s08";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s08-spi1-0-present parameter */
++     				reg = <0>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s08-spi1-0-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s08s on spi1.1
++	fragment@11 {
++		target = <&spi1>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s08_11: mcp23s08@1 {
++				compatible = "microchip,mcp23s08";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s08-spi1-1-present parameter */
++     				reg = <1>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s08-spi1-1-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s08s on spi1.2
++	fragment@12 {
++		target = <&spi1>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s08_12: mcp23s08@2 {
++				compatible = "microchip,mcp23s08";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s08-spi1-2-present parameter */
++     				reg = <2>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s08-spi1-2-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s08s on spi2.0
++	fragment@13 {
++		target = <&spi2>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s08_20: mcp23s08@0 {
++				compatible = "microchip,mcp23s08";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s08-spi2-0-present parameter */
++     				reg = <0>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s08-spi2-0-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s08s on spi2.1
++	fragment@14 {
++		target = <&spi2>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s08_21: mcp23s08@1 {
++				compatible = "microchip,mcp23s08";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s08-spi2-1-present parameter */
++     				reg = <1>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s08-spi2-1-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s08s on spi2.2
++	fragment@15 {
++		target = <&spi2>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s08_22: mcp23s08@2 {
++				compatible = "microchip,mcp23s08";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s08-spi2-2-present parameter */
++     				reg = <2>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s08-spi2-2-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s17s on spi0.0
++	fragment@16 {
++		target = <&spi0>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s17_00: mcp23s17@0 {
++				compatible = "microchip,mcp23s17";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s17-spi0-0-present parameter */
++     				reg = <0>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s17-spi0-0-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s17s on spi0.1
++	fragment@17 {
++		target = <&spi0>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s17_01: mcp23s17@1 {
++				compatible = "microchip,mcp23s17";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s17-spi0-1-present parameter */
++     				reg = <1>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s17-spi0-1-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s17s on spi1.0
++	fragment@18 {
++		target = <&spi1>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s17_10: mcp23s17@0 {
++				compatible = "microchip,mcp23s17";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s17-spi1-0-present parameter */
++     				reg = <0>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s17-spi1-0-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s17s on spi1.1
++	fragment@19 {
++		target = <&spi1>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s17_11: mcp23s17@1 {
++				compatible = "microchip,mcp23s17";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s17-spi1-1-present parameter */
++     				reg = <1>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s17-spi1-1-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s17s on spi1.2
++	fragment@20 {
++		target = <&spi1>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s17_12: mcp23s17@2 {
++				compatible = "microchip,mcp23s17";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s17-spi1-2-present parameter */
++     				reg = <2>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s17-spi1-2-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s17s on spi2.0
++	fragment@21 {
++		target = <&spi2>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s17_20: mcp23s17@0 {
++				compatible = "microchip,mcp23s17";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s17-spi2-0-present parameter */
++     				reg = <0>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s17-spi2-0-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s17s on spi2.1
++	fragment@22 {
++		target = <&spi2>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s17_21: mcp23s17@1 {
++				compatible = "microchip,mcp23s17";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s17-spi2-1-present parameter */
++     				reg = <1>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s17-spi2-1-int-gpio parameter */
++			};
++		};
++	};
++
++	// enable one or more mcp23s17s on spi2.2
++	fragment@23 {
++		target = <&spi2>;
++		__dormant__ {
++			status = "okay";
++                        #address-cells = <1>;
++                        #size-cells = <0>;
++			mcp23s17_22: mcp23s17@2 {
++				compatible = "microchip,mcp23s17";
++  				gpio-controller;
++  				#gpio-cells = <2>;
++    				microchip,spi-present-mask = <0x00>;  /* overwritten by mcp23s17-spi2-2-present parameter */
++     				reg = <2>;
++    				spi-max-frequency = <500000>;
++				status = "okay";
++				#interrupt-cells=<2>;
++				interrupts = <0 2>;  /* 1st word overwritten by mcp23s17-spi2-2-int-gpio parameter */
++			};
++		};
++	};
++
++	// Configure GPIO pin connected to INT(A/B) output of mcp23s08/17 on spi0.0 as a input with no pull-up/down
++	fragment@24 {
++		target = <&gpio>;
++		__dormant__ {
++			spi0_0_int_pins: spi0_0_int_pins {
++				brcm,pins = <0>;  /* overwritten by mcp23s08/17-spi0-0-int-gpio parameter */
++				brcm,function = <0>;
++				brcm,pull = <0>;
++			};
++		};
++	};
++
++	// Configure GPIO pin connected to INT(A/B) output of mcp23s08/17 on spi0.1 as a input with no pull-up/down
++	fragment@25 {
++		target = <&gpio>;
++		__dormant__ {
++			spi0_1_int_pins: spi0_1_int_pins {
++				brcm,pins = <0>;  /* overwritten by mcp23s08/17-spi0-1-int-gpio parameter */
++				brcm,function = <0>;
++				brcm,pull = <0>;
++			};
++		};
++	};
++
++	// Configure GPIO pin connected to INT(A/B) output of mcp23s08/17 on spi1.0 as a input with no pull-up/down
++	fragment@26 {
++		target = <&gpio>;
++		__dormant__ {
++			spi1_0_int_pins: spi1_0_int_pins {
++				brcm,pins = <0>;  /* overwritten by mcp23s08/17-spi1-0-int-gpio parameter */
++				brcm,function = <0>;
++				brcm,pull = <0>;
++			};
++		};
++	};
++
++	// Configure GPIO pin connected to INT(A/B) output of mcp23s08/17 on spi1.1 as a input with no pull-up/down
++	fragment@27 {
++		target = <&gpio>;
++		__dormant__ {
++			spi1_1_int_pins: spi1_1_int_pins {
++				brcm,pins = <0>;  /* overwritten by mcp23s08/17-spi1-1-int-gpio parameter */
++				brcm,function = <0>;
++				brcm,pull = <0>;
++			};
++		};
++	};
++
++	// Configure GPIO pin connected to INT(A/B) output of mcp23s08/17 on spi1.2 as a input with no pull-up/down
++	fragment@28 {
++		target = <&gpio>;
++		__dormant__ {
++			spi1_2_int_pins: spi1_2_int_pins {
++				brcm,pins = <0>;  /* overwritten by mcp23s08/17-spi1-2-int-gpio parameter */
++				brcm,function = <0>;
++				brcm,pull = <0>;
++			};
++		};
++	};
++
++	// Configure GPIO pin connected to INT(A/B) output of mcp23s08/17 on spi2.0 as a input with no pull-up/down
++	fragment@29 {
++		target = <&gpio>;
++		__dormant__ {
++			spi2_0_int_pins: spi2_0_int_pins {
++				brcm,pins = <0>;  /* overwritten by mcp23s08/17-spi2-0-int-gpio parameter */
++				brcm,function = <0>;
++				brcm,pull = <0>;
++			};
++		};
++	};
++
++	// Configure GPIO pin connected to INT(A/B) output of mcp23s08/17 on spi2.1 as a input with no pull-up/down
++	fragment@30 {
++		target = <&gpio>;
++		__dormant__ {
++			spi2_1_int_pins: spi2_1_int_pins {
++				brcm,pins = <0>;  /* overwritten by mcp23s08/17-spi2-1-int-gpio parameter */
++				brcm,function = <0>;
++				brcm,pull = <0>;
++			};
++		};
++	};
++
++	// Configure GPIO pin connected to INT(A/B) output of mcp23s08/17 on spi2.2 as a input with no pull-up/down
++	fragment@31 {
++		target = <&gpio>;
++		__dormant__ {
++			spi2_2_int_pins: spi2_2_int_pins {
++				brcm,pins = <0>;  /* overwritten by mcp23s08/17-spi2-2-int-gpio parameter */
++				brcm,function = <0>;
++				brcm,pull = <0>;
++			};
++		};
++	};
++
++	// Enable interrupts for a mcp23s08 on spi0.0.
++	// Use default active low interrupt signalling.
++	fragment@32 {
++		target = <&mcp23s08_00>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++		};
++	};
++
++	// Enable interrupts for a mcp23s08 on spi0.1.
++	// Use default active low interrupt signalling.
++	fragment@33 {
++		target = <&mcp23s08_01>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++		};
++	};
++
++	// Enable interrupts for a mcp23s08 on spi1.0.
++	// Use default active low interrupt signalling.
++	fragment@34 {
++		target = <&mcp23s08_10>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++		};
++	};
++
++	// Enable interrupts for a mcp23s08 on spi1.1.
++	// Use default active low interrupt signalling.
++	fragment@35 {
++		target = <&mcp23s08_11>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++		};
++	};
++
++	// Enable interrupts for a mcp23s08 on spi1.2.
++	// Use default active low interrupt signalling.
++	fragment@36 {
++		target = <&mcp23s08_12>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++		};
++	};
++
++	// Enable interrupts for a mcp23s08 on spi2.0.
++	// Use default active low interrupt signalling.
++	fragment@37 {
++		target = <&mcp23s08_20>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++		};
++	};
++
++	// Enable interrupts for a mcp23s08 on spi2.1.
++	// Use default active low interrupt signalling.
++	fragment@38 {
++		target = <&mcp23s08_21>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++		};
++	};
++
++	// Enable interrupts for a mcp23s08 on spi2.2.
++	// Use default active low interrupt signalling.
++	fragment@39 {
++		target = <&mcp23s08_22>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++		};
++	};
++
++	// Enable interrupts for a mcp23s17 on spi0.0.
++	// Enable mirroring so that either INTA or INTB output of mcp23s17 can be connected to the GPIO pin.
++	// Use default active low interrupt signalling.
++	fragment@40 {
++		target = <&mcp23s17_00>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++			microchip,irq-mirror;
++		};
++	};
++
++	// Enable interrupts for a mcp23s17 on spi0.1.
++	// Enable mirroring so that either INTA or INTB output of mcp23s17 can be connected to the GPIO pin.
++	// Configure INTA/B outputs of mcp23s08/17 as active low.
++	fragment@41 {
++		target = <&mcp23s17_01>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++			microchip,irq-mirror;
++		};
++	};
++
++	// Enable interrupts for a mcp23s17 on spi1.0.
++	// Enable mirroring so that either INTA or INTB output of mcp23s17 can be connected to the GPIO pin.
++	// Configure INTA/B outputs of mcp23s08/17 as active low.
++	fragment@42 {
++		target = <&mcp23s17_10>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++			microchip,irq-mirror;
++		};
++	};
++
++	// Enable interrupts for a mcp23s17 on spi1.1.
++	// Enable mirroring so that either INTA or INTB output of mcp23s17 can be connected to the GPIO pin.
++	// Configure INTA/B outputs of mcp23s08/17 as active low.
++	fragment@43 {
++		target = <&mcp23s17_11>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++			microchip,irq-mirror;
++		};
++	};
++
++	// Enable interrupts for a mcp23s17 on spi1.2.
++	// Enable mirroring so that either INTA or INTB output of mcp23s17 can be connected to the GPIO pin.
++	// Configure INTA/B outputs of mcp23s08/17 as active low.
++	fragment@44 {
++		target = <&mcp23s17_12>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++			microchip,irq-mirror;
++		};
++	};
++
++	// Enable interrupts for a mcp23s17 on spi2.0.
++	// Enable mirroring so that either INTA or INTB output of mcp23s17 can be connected to the GPIO pin.
++	// Configure INTA/B outputs of mcp23s08/17 as active low.
++	fragment@45 {
++		target = <&mcp23s17_20>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++			microchip,irq-mirror;
++		};
++	};
++
++	// Enable interrupts for a mcp23s17 on spi2.1.
++	// Enable mirroring so that either INTA or INTB output of mcp23s17 can be connected to the GPIO pin.
++	// Configure INTA/B outputs of mcp23s08/17 as active low.
++	fragment@46 {
++		target = <&mcp23s17_21>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++			microchip,irq-mirror;
++		};
++	};
++
++	// Enable interrupts for a mcp23s17 on spi2.2.
++	// Enable mirroring so that either INTA or INTB output of mcp23s17 can be connected to the GPIO pin.
++	// Configure INTA/B outputs of mcp23s08/17 as active low.
++	fragment@47 {
++		target = <&mcp23s17_22>;
++		__dormant__ {
++			interrupt-parent = <&gpio>;
++			interrupt-controller;
++			microchip,irq-mirror;
++		};
++	};
++
++	__overrides__ {
++		s08-spi0-0-present = <0>,"+0+8",  <&mcp23s08_00>,"microchip,spi-present-mask:0";
++		s08-spi0-1-present = <0>,"+1+9",  <&mcp23s08_01>,"microchip,spi-present-mask:0";
++		s08-spi1-0-present = <0>,"+2+10", <&mcp23s08_10>,"microchip,spi-present-mask:0";
++		s08-spi1-1-present = <0>,"+3+11", <&mcp23s08_11>,"microchip,spi-present-mask:0";
++		s08-spi1-2-present = <0>,"+4+12", <&mcp23s08_12>,"microchip,spi-present-mask:0";
++		s08-spi2-0-present = <0>,"+5+13", <&mcp23s08_20>,"microchip,spi-present-mask:0";
++		s08-spi2-1-present = <0>,"+6+14", <&mcp23s08_21>,"microchip,spi-present-mask:0";
++		s08-spi2-2-present = <0>,"+7+15", <&mcp23s08_22>,"microchip,spi-present-mask:0";
++		s17-spi0-0-present = <0>,"+0+16", <&mcp23s17_00>,"microchip,spi-present-mask:0";
++		s17-spi0-1-present = <0>,"+1+17", <&mcp23s17_01>,"microchip,spi-present-mask:0";
++		s17-spi1-0-present = <0>,"+2+18", <&mcp23s17_10>,"microchip,spi-present-mask:0";
++		s17-spi1-1-present = <0>,"+3+19", <&mcp23s17_11>,"microchip,spi-present-mask:0";
++		s17-spi1-2-present = <0>,"+4+20", <&mcp23s17_12>,"microchip,spi-present-mask:0";
++		s17-spi2-0-present = <0>,"+5+21", <&mcp23s17_20>,"microchip,spi-present-mask:0";
++		s17-spi2-1-present = <0>,"+6+22", <&mcp23s17_21>,"microchip,spi-present-mask:0";
++		s17-spi2-2-present = <0>,"+7+23", <&mcp23s17_22>,"microchip,spi-present-mask:0";
++		s08-spi0-0-int-gpio = <0>,"+24+32", <&spi0_0_int_pins>,"brcm,pins:0", <&mcp23s08_00>,"interrupts:0";
++		s08-spi0-1-int-gpio = <0>,"+25+33", <&spi0_1_int_pins>,"brcm,pins:0", <&mcp23s08_01>,"interrupts:0";
++		s08-spi1-0-int-gpio = <0>,"+26+34", <&spi1_0_int_pins>,"brcm,pins:0", <&mcp23s08_10>,"interrupts:0";
++		s08-spi1-1-int-gpio = <0>,"+27+35", <&spi1_1_int_pins>,"brcm,pins:0", <&mcp23s08_11>,"interrupts:0";
++		s08-spi1-2-int-gpio = <0>,"+28+36", <&spi1_2_int_pins>,"brcm,pins:0", <&mcp23s08_12>,"interrupts:0";
++		s08-spi2-0-int-gpio = <0>,"+29+37", <&spi2_0_int_pins>,"brcm,pins:0", <&mcp23s08_20>,"interrupts:0";
++		s08-spi2-1-int-gpio = <0>,"+30+38", <&spi2_1_int_pins>,"brcm,pins:0", <&mcp23s08_21>,"interrupts:0";
++		s08-spi2-2-int-gpio = <0>,"+31+39", <&spi2_2_int_pins>,"brcm,pins:0", <&mcp23s08_22>,"interrupts:0";
++		s17-spi0-0-int-gpio = <0>,"+24+40", <&spi0_0_int_pins>,"brcm,pins:0", <&mcp23s17_00>,"interrupts:0";
++		s17-spi0-1-int-gpio = <0>,"+25+41", <&spi0_1_int_pins>,"brcm,pins:0", <&mcp23s17_01>,"interrupts:0";
++		s17-spi1-0-int-gpio = <0>,"+26+42", <&spi1_0_int_pins>,"brcm,pins:0", <&mcp23s17_10>,"interrupts:0";
++		s17-spi1-1-int-gpio = <0>,"+27+43", <&spi1_1_int_pins>,"brcm,pins:0", <&mcp23s17_11>,"interrupts:0";
++		s17-spi1-2-int-gpio = <0>,"+28+44", <&spi1_2_int_pins>,"brcm,pins:0", <&mcp23s17_12>,"interrupts:0";
++		s17-spi2-0-int-gpio = <0>,"+29+45", <&spi2_0_int_pins>,"brcm,pins:0", <&mcp23s17_20>,"interrupts:0";
++		s17-spi2-1-int-gpio = <0>,"+30+46", <&spi2_1_int_pins>,"brcm,pins:0", <&mcp23s17_21>,"interrupts:0";
++		s17-spi2-2-int-gpio = <0>,"+31+47", <&spi2_2_int_pins>,"brcm,pins:0", <&mcp23s17_22>,"interrupts:0";
++	};
++};
++
 diff --git a/arch/arm/boot/dts/overlays/mcp2515-can0-overlay.dts b/arch/arm/boot/dts/overlays/mcp2515-can0-overlay.dts
 new file mode 100755
 index 0000000..c96cdae
@@ -7282,12 +8587,139 @@ index 0000000..ed2afc2
 +		debug =   <&pitft>,"debug:0";
 +	};
 +};
+diff --git a/arch/arm/boot/dts/overlays/pitft35-resistive-overlay.dts b/arch/arm/boot/dts/overlays/pitft35-resistive-overlay.dts
+new file mode 100644
+index 0000000..25cb5cc
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/pitft35-resistive-overlay.dts
+@@ -0,0 +1,121 @@
++/*
++ * Device Tree overlay for Adafruit PiTFT 3.5" resistive touch screen
++ *
++ */
++
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
++
++	fragment@0 {
++		target = <&spi0>;
++		__overlay__ {
++			status = "okay";
++		};
++	};
++
++	fragment@1 {
++		target = <&spidev0>;
++		__overlay__ {
++			status = "disabled";
++		};
++	};
++
++	fragment@2 {
++		target = <&spidev1>;
++		__overlay__ {
++			status = "disabled";
++		};
++	};
++
++	fragment@3 {
++		target = <&gpio>;
++		__overlay__ {
++			pitft_pins: pitft_pins {
++				brcm,pins = <24 25>;
++				brcm,function = <0 1>; /* in out */
++				brcm,pull = <2 0>; /* pullup none */
++			};
++		};
++	};
++
++	fragment@4 {
++		target = <&spi0>;
++		__overlay__ {
++			/* needed to avoid dtc warning */
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			pitft: pitft@0{
++				compatible = "himax,hx8357d";
++				reg = <0>;
++				pinctrl-names = "default";
++				pinctrl-0 = <&pitft_pins>;
++
++				spi-max-frequency = <32000000>;
++				rotate = <90>;
++				fps = <25>;
++				bgr;
++				buswidth = <8>;
++				dc-gpios = <&gpio 25 0>;
++				debug = <0>;
++			};
++
++			pitft_ts@1 {
++				#address-cells = <1>;
++				#size-cells = <0>;
++				compatible = "st,stmpe610";
++				reg = <1>;
++
++				spi-max-frequency = <500000>;
++				irq-gpio = <&gpio 24 0x2>; /* IRQF_TRIGGER_FALLING */
++				interrupts = <24 2>; /* high-to-low edge triggered */
++				interrupt-parent = <&gpio>;
++				interrupt-controller;
++
++				stmpe_touchscreen {
++					compatible = "st,stmpe-ts";
++					st,sample-time = <4>;
++					st,mod-12b = <1>;
++					st,ref-sel = <0>;
++					st,adc-freq = <2>;
++					st,ave-ctrl = <3>;
++					st,touch-det-delay = <4>;
++					st,settling = <2>;
++					st,fraction-z = <7>;
++					st,i-drive = <0>;
++				};
++
++				stmpe_gpio: stmpe_gpio {
++					#gpio-cells = <2>;
++					compatible = "st,stmpe-gpio";
++					/*
++					 * only GPIO2 is wired/available
++					 * and it is wired to the backlight
++					 */
++					st,norequest-mask = <0x7b>;
++				};
++			};
++		};
++	};
++
++	fragment@5 {
++		target-path = "/soc";
++		__overlay__ {
++			backlight {
++				compatible = "gpio-backlight";
++				gpios = <&stmpe_gpio 2 0>;
++				default-on;
++			};
++		};
++	};
++
++	__overrides__ {
++		speed =   <&pitft>,"spi-max-frequency:0";
++		rotate =  <&pitft>,"rotate:0";
++		fps =     <&pitft>,"fps:0";
++		debug =   <&pitft>,"debug:0";
++	};
++};
 diff --git a/arch/arm/boot/dts/overlays/pps-gpio-overlay.dts b/arch/arm/boot/dts/overlays/pps-gpio-overlay.dts
 new file mode 100644
-index 0000000..40bf0e1
+index 0000000..50143a4b
 --- /dev/null
 +++ b/arch/arm/boot/dts/overlays/pps-gpio-overlay.dts
-@@ -0,0 +1,34 @@
+@@ -0,0 +1,35 @@
 +/dts-v1/;
 +/plugin/;
 +
@@ -7320,6 +8752,7 @@ index 0000000..40bf0e1
 +	__overrides__ {
 +		gpiopin = <&pps>,"gpios:4",
 +			  <&pps_pins>,"brcm,pins:0";
++		assert_falling_edge = <&pps>,"assert-falling-edge?";
 +	};
 +};
 diff --git a/arch/arm/boot/dts/overlays/pwm-2chan-overlay.dts b/arch/arm/boot/dts/overlays/pwm-2chan-overlay.dts
@@ -7915,6 +9348,49 @@ index 0000000..16b1247
 +		};
 +	};
 +};
+diff --git a/arch/arm/boot/dts/overlays/sc16is750-i2c-overlay.dts b/arch/arm/boot/dts/overlays/sc16is750-i2c-overlay.dts
+new file mode 100644
+index 0000000..339d0d1
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/sc16is750-i2c-overlay.dts
+@@ -0,0 +1,37 @@
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
++
++	fragment@0 {
++		target = <&i2c_arm>;
++		__overlay__ {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "okay";
++
++			sc16is750: sc16is750@48 {
++				compatible = "nxp,sc16is750";
++				reg = <0x48>; /* address */
++				clocks = <&sc16is750_clk>;
++				interrupt-parent = <&gpio>;
++				interrupts = <24 2>; /* IRQ_TYPE_EDGE_FALLING */
++				#gpio-cells = <2>;
++
++				sc16is750_clk: sc16is750_clk {
++					compatible = "fixed-clock";
++					#clock-cells = <0>;
++					clock-frequency = <14745600>;
++				};
++			};
++		};
++	};
++
++
++	__overrides__ {
++		int_pin = <&sc16is750>,"interrupts:0";
++		addr = <&sc16is750>,"reg:0";
++	};
++
++};
 diff --git a/arch/arm/boot/dts/overlays/sc16is752-spi1-overlay.dts b/arch/arm/boot/dts/overlays/sc16is752-spi1-overlay.dts
 new file mode 100644
 index 0000000..d0a9e82
@@ -8277,7 +9753,7 @@ index 0000000..095f52c
 +};
 diff --git a/arch/arm/boot/dts/overlays/spi-gpio35-39-overlay.dts b/arch/arm/boot/dts/overlays/spi-gpio35-39-overlay.dts
 new file mode 100644
-index 0000000..9648063
+index 0000000..49803b3
 --- /dev/null
 +++ b/arch/arm/boot/dts/overlays/spi-gpio35-39-overlay.dts
 @@ -0,0 +1,31 @@
@@ -8301,14 +9777,14 @@ index 0000000..9648063
 +	fragment@1 {
 +		target = <&spi0_cs_pins>;
 +		__overlay__ {
-+			bcrm,pins = <36 35>;
++			brcm,pins = <36 35>;
 +		};
 +	};
 +
 +	fragment@2 {
 +		target = <&spi0_pins>;
 +		__overlay__ {
-+			bcrm,pins = <37 38 39>;
++			brcm,pins = <37 38 39>;
 +		};
 +	};
 +};
@@ -9107,12 +10583,107 @@ index 0000000..fa73e1f
 +		rxd1_pin = <&uart1_pins>,"brcm,pins:4";
 +	};
 +};
+diff --git a/arch/arm/boot/dts/overlays/vc4-fkms-v3d-overlay.dts b/arch/arm/boot/dts/overlays/vc4-fkms-v3d-overlay.dts
+new file mode 100644
+index 0000000..95a595a
+--- /dev/null
++++ b/arch/arm/boot/dts/overlays/vc4-fkms-v3d-overlay.dts
+@@ -0,0 +1,89 @@
++/*
++ * vc4-fkms-v3d-overlay.dts
++ */
++
++/dts-v1/;
++/plugin/;
++
++/ {
++	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
++
++	fragment@0 {
++		target-path = "/chosen";
++		__overlay__ {
++			bootargs = "cma=256M@256M";
++		};
++	};
++
++	fragment@1 {
++		target-path = "/chosen";
++		__dormant__ {
++			bootargs = "cma=192M@256M";
++		};
++	};
++
++	fragment@2 {
++		target-path = "/chosen";
++		__dormant__ {
++			bootargs = "cma=128M@128M";
++		};
++	};
++
++	fragment@3 {
++		target-path = "/chosen";
++		__dormant__ {
++			bootargs = "cma=96M@128M";
++		};
++	};
++
++	fragment@4 {
++		target-path = "/chosen";
++		__dormant__ {
++			bootargs = "cma=64M@64M";
++		};
++	};
++
++	fragment@5 {
++		target = <&fb>;
++		__overlay__  {
++			status = "disabled";
++		};
++	};
++
++	fragment@6 {
++		target = <&firmwarekms>;
++		__overlay__  {
++			status = "okay";
++		};
++	};
++
++	fragment@7 {
++		target = <&v3d>;
++		__overlay__  {
++			interrupts = <1 10>;
++			status = "okay";
++		};
++	};
++
++	fragment@8 {
++		target = <&gpu>;
++		__overlay__  {
++			status = "okay";
++		};
++	};
++
++	fragment@9 {
++		target-path = "/soc/dma";
++		__overlay__ {
++			brcm,dma-channel-mask = <0x7f35>;
++		};
++	};
++
++	__overrides__ {
++		cma-256 = <0>,"+0-1-2-3-4";
++		cma-192 = <0>,"-0+1-2-3-4";
++		cma-128 = <0>,"-0-1+2-3-4";
++		cma-96  = <0>,"-0-1-2+3-4";
++		cma-64  = <0>,"-0-1-2-3+4";
++	};
++};
 diff --git a/arch/arm/boot/dts/overlays/vc4-kms-v3d-overlay.dts b/arch/arm/boot/dts/overlays/vc4-kms-v3d-overlay.dts
 new file mode 100644
-index 0000000..4f1cc20
+index 0000000..a70f2e4
 --- /dev/null
 +++ b/arch/arm/boot/dts/overlays/vc4-kms-v3d-overlay.dts
-@@ -0,0 +1,136 @@
+@@ -0,0 +1,152 @@
 +/*
 + * vc4-kms-v3d-overlay.dts
 + */
@@ -9241,6 +10812,22 @@ index 0000000..4f1cc20
 +		};
 +	};
 +
++	fragment@16 {
++		target = <&dsi1>;
++		__overlay__  {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			status = "okay";
++
++			brcm,panel = <&pitouchscreen>;
++
++			pitouchscreen: panel {
++				compatible = "raspberrypi,touchscreen";
++				reg = <0>;
++			};
++		};
++	};
++
 +	__overrides__ {
 +		cma-256 = <0>,"+0-1-2-3-4";
 +		cma-192 = <0>,"-0+1-2-3-4";
@@ -9429,10 +11016,10 @@ index 0000000..8498134
 +};
 diff --git a/arch/arm/configs/bcm2709_defconfig b/arch/arm/configs/bcm2709_defconfig
 new file mode 100644
-index 0000000..af67b69
+index 0000000..1059e37
 --- /dev/null
 +++ b/arch/arm/configs/bcm2709_defconfig
-@@ -0,0 +1,1290 @@
+@@ -0,0 +1,1300 @@
 +# CONFIG_ARM_PATCH_PHYS_VIRT is not set
 +CONFIG_PHYS_OFFSET=0
 +CONFIG_LOCALVERSION="-v7"
@@ -9883,6 +11470,8 @@ index 0000000..af67b69
 +CONFIG_DUMMY=m
 +CONFIG_IFB=m
 +CONFIG_MACVLAN=m
++CONFIG_IPVLAN=m
++CONFIG_VXLAN=m
 +CONFIG_NETCONSOLE=m
 +CONFIG_TUN=m
 +CONFIG_VETH=m
@@ -10035,6 +11624,8 @@ index 0000000..af67b69
 +CONFIG_SERIAL_AMBA_PL011=y
 +CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
 +CONFIG_SERIAL_OF_PLATFORM=y
++CONFIG_SERIAL_SC16IS7XX=m
++CONFIG_SERIAL_SC16IS7XX_SPI=y
 +CONFIG_TTY_PRINTK=y
 +CONFIG_HW_RANDOM=y
 +CONFIG_RAW_DRIVER=y
@@ -10077,8 +11668,10 @@ index 0000000..af67b69
 +CONFIG_POWER_RESET=y
 +CONFIG_POWER_RESET_GPIO=y
 +CONFIG_HWMON=m
++CONFIG_SENSORS_LM75=m
 +CONFIG_SENSORS_SHT21=m
 +CONFIG_SENSORS_SHTC1=m
++CONFIG_SENSORS_INA2XX=m
 +CONFIG_THERMAL=y
 +CONFIG_THERMAL_BCM2835=y
 +CONFIG_WATCHDOG=y
@@ -10257,6 +11850,7 @@ index 0000000..af67b69
 +CONFIG_DRM_LOAD_EDID_FIRMWARE=y
 +CONFIG_DRM_UDL=m
 +CONFIG_DRM_PANEL_SIMPLE=m
++CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN=m
 +CONFIG_DRM_VC4=m
 +CONFIG_FB=y
 +CONFIG_FB_BCM2708=y
@@ -10307,6 +11901,7 @@ index 0000000..af67b69
 +CONFIG_SND_AUDIOINJECTOR_PI_SOUNDCARD=m
 +CONFIG_SND_DIGIDAC1_SOUNDCARD=m
 +CONFIG_SND_BCM2708_SOC_DIONAUDIO_LOCO=m
++CONFIG_SND_BCM2708_SOC_ALLO_PIANO_DAC=m
 +CONFIG_SND_SOC_ADAU1701=m
 +CONFIG_SND_SOC_WM8804_I2C=m
 +CONFIG_SND_SIMPLE_CARD=m
@@ -10326,6 +11921,7 @@ index 0000000..af67b69
 +CONFIG_HID_ELECOM=m
 +CONFIG_HID_ELO=m
 +CONFIG_HID_EZKEY=m
++CONFIG_HID_GEMBIRD=m
 +CONFIG_HID_HOLTEK=m
 +CONFIG_HID_KEYTOUCH=m
 +CONFIG_HID_KYE=m
@@ -10542,6 +12138,7 @@ index 0000000..af67b69
 +CONFIG_FB_TFT_HX8340BN=m
 +CONFIG_FB_TFT_HX8347D=m
 +CONFIG_FB_TFT_HX8353D=m
++CONFIG_FB_TFT_HX8357D=m
 +CONFIG_FB_TFT_ILI9163=m
 +CONFIG_FB_TFT_ILI9320=m
 +CONFIG_FB_TFT_ILI9325=m
@@ -12009,10 +13606,10 @@ index 31cb073..fdb2e2a 100644
  # CONFIG_XZ_DEC_ARMTHUMB is not set
 diff --git a/arch/arm/configs/bcmrpi_defconfig b/arch/arm/configs/bcmrpi_defconfig
 new file mode 100644
-index 0000000..ad278a2
+index 0000000..db61bb8
 --- /dev/null
 +++ b/arch/arm/configs/bcmrpi_defconfig
-@@ -0,0 +1,1300 @@
+@@ -0,0 +1,1310 @@
 +# CONFIG_ARM_PATCH_PHYS_VIRT is not set
 +CONFIG_PHYS_OFFSET=0
 +# CONFIG_LOCALVERSION_AUTO is not set
@@ -12456,6 +14053,8 @@ index 0000000..ad278a2
 +CONFIG_DUMMY=m
 +CONFIG_IFB=m
 +CONFIG_MACVLAN=m
++CONFIG_IPVLAN=m
++CONFIG_VXLAN=m
 +CONFIG_NETCONSOLE=m
 +CONFIG_TUN=m
 +CONFIG_VETH=m
@@ -12608,6 +14207,8 @@ index 0000000..ad278a2
 +CONFIG_SERIAL_AMBA_PL011=y
 +CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
 +CONFIG_SERIAL_OF_PLATFORM=y
++CONFIG_SERIAL_SC16IS7XX=m
++CONFIG_SERIAL_SC16IS7XX_SPI=y
 +CONFIG_TTY_PRINTK=y
 +CONFIG_HW_RANDOM=y
 +CONFIG_RAW_DRIVER=y
@@ -12649,8 +14250,10 @@ index 0000000..ad278a2
 +CONFIG_POWER_RESET=y
 +CONFIG_POWER_RESET_GPIO=y
 +CONFIG_HWMON=m
++CONFIG_SENSORS_LM75=m
 +CONFIG_SENSORS_SHT21=m
 +CONFIG_SENSORS_SHTC1=m
++CONFIG_SENSORS_INA2XX=m
 +CONFIG_THERMAL=y
 +CONFIG_THERMAL_BCM2835=y
 +CONFIG_WATCHDOG=y
@@ -12829,6 +14432,7 @@ index 0000000..ad278a2
 +CONFIG_DRM_LOAD_EDID_FIRMWARE=y
 +CONFIG_DRM_UDL=m
 +CONFIG_DRM_PANEL_SIMPLE=m
++CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN=m
 +CONFIG_DRM_VC4=m
 +CONFIG_FB=y
 +CONFIG_FB_BCM2708=y
@@ -12879,6 +14483,7 @@ index 0000000..ad278a2
 +CONFIG_SND_AUDIOINJECTOR_PI_SOUNDCARD=m
 +CONFIG_SND_DIGIDAC1_SOUNDCARD=m
 +CONFIG_SND_BCM2708_SOC_DIONAUDIO_LOCO=m
++CONFIG_SND_BCM2708_SOC_ALLO_PIANO_DAC=m
 +CONFIG_SND_SOC_ADAU1701=m
 +CONFIG_SND_SOC_WM8804_I2C=m
 +CONFIG_SND_SIMPLE_CARD=m
@@ -12898,6 +14503,7 @@ index 0000000..ad278a2
 +CONFIG_HID_ELECOM=m
 +CONFIG_HID_ELO=m
 +CONFIG_HID_EZKEY=m
++CONFIG_HID_GEMBIRD=m
 +CONFIG_HID_HOLTEK=m
 +CONFIG_HID_KEYTOUCH=m
 +CONFIG_HID_KYE=m
@@ -13129,6 +14735,7 @@ index 0000000..ad278a2
 +CONFIG_FB_TFT_HX8340BN=m
 +CONFIG_FB_TFT_HX8347D=m
 +CONFIG_FB_TFT_HX8353D=m
++CONFIG_FB_TFT_HX8357D=m
 +CONFIG_FB_TFT_ILI9163=m
 +CONFIG_FB_TFT_ILI9320=m
 +CONFIG_FB_TFT_ILI9325=m
@@ -23612,7 +25219,7 @@ index 0000000..3a177ad
 +MODULE_DESCRIPTION("BCM2835 auxiliary peripheral clock driver");
 +MODULE_LICENSE("GPL v2");
 diff --git a/drivers/clk/bcm/clk-bcm2835.c b/drivers/clk/bcm/clk-bcm2835.c
-index 6029313..6b6b279 100644
+index 6029313..08efc7c 100644
 --- a/drivers/clk/bcm/clk-bcm2835.c
 +++ b/drivers/clk/bcm/clk-bcm2835.c
 @@ -12,9 +12,6 @@
@@ -23625,15 +25232,17 @@ index 6029313..6b6b279 100644
   */
  
  /**
-@@ -40,6 +37,7 @@
+@@ -39,7 +36,9 @@
+ 
  #include <linux/clk-provider.h>
  #include <linux/clkdev.h>
++#include <linux/clk.h>
  #include <linux/clk/bcm2835.h>
 +#include <linux/debugfs.h>
  #include <linux/module.h>
  #include <linux/of.h>
  #include <linux/platform_device.h>
-@@ -51,6 +49,7 @@
+@@ -51,6 +50,7 @@
  #define CM_GNRICCTL		0x000
  #define CM_GNRICDIV		0x004
  # define CM_DIV_FRAC_BITS	12
@@ -23641,7 +25250,7 @@ index 6029313..6b6b279 100644
  
  #define CM_VPUCTL		0x008
  #define CM_VPUDIV		0x00c
-@@ -88,10 +87,23 @@
+@@ -88,10 +88,23 @@
  #define CM_HSMDIV		0x08c
  #define CM_OTPCTL		0x090
  #define CM_OTPDIV		0x094
@@ -23665,7 +25274,7 @@ index 6029313..6b6b279 100644
  #define CM_TSENSCTL		0x0e0
  #define CM_TSENSDIV		0x0e4
  #define CM_TIMERCTL		0x0e8
-@@ -105,6 +117,8 @@
+@@ -105,6 +118,8 @@
  #define CM_SDCCTL		0x1a8
  #define CM_SDCDIV		0x1ac
  #define CM_ARMCTL		0x1b0
@@ -23674,7 +25283,7 @@ index 6029313..6b6b279 100644
  #define CM_EMMCCTL		0x1c0
  #define CM_EMMCDIV		0x1c4
  
-@@ -115,6 +129,7 @@
+@@ -115,6 +130,7 @@
  # define CM_GATE			BIT(CM_GATE_BIT)
  # define CM_BUSY			BIT(7)
  # define CM_BUSYD			BIT(8)
@@ -23682,13 +25291,35 @@ index 6029313..6b6b279 100644
  # define CM_SRC_SHIFT			0
  # define CM_SRC_BITS			4
  # define CM_SRC_MASK			0xf
-@@ -284,11 +299,11 @@
+@@ -281,14 +297,32 @@
+ #define LOCK_TIMEOUT_NS		100000000
+ #define BCM2835_MAX_FB_RATE	1750000000u
+ 
++/*
++ * Names of clocks used within the driver that need to be replaced
++ * with an external parent's name.  This array is in the order that
++ * the clocks node in the DT references external clocks.
++ */
++static const char *cprman_parent_names[] = {
++	"xosc",
++	"dsi1_byte",
++	"dsi1_ddr2",
++	"dsi1_ddr",
++};
++
  struct bcm2835_cprman {
  	struct device *dev;
  	void __iomem *regs;
 -	spinlock_t regs_lock;
+-	const char *osc_name;
 +	spinlock_t regs_lock; /* spinlock for all clocks */
- 	const char *osc_name;
++
++	/*
++	 * Real names of cprman clock parents looked up through
++	 * of_clk_get_parent_name(), which will be used in the
++	 * parent_names[] arrays for clock registration.
++	 */
++	const char *real_parent_names[ARRAY_SIZE(cprman_parent_names)];
  
  	struct clk_onecell_data onecell;
 -	struct clk *clks[BCM2835_CLOCK_COUNT];
@@ -23696,7 +25327,7 @@ index 6029313..6b6b279 100644
  };
  
  static inline void cprman_write(struct bcm2835_cprman *cprman, u32 reg, u32 val)
-@@ -301,6 +316,27 @@ static inline u32 cprman_read(struct bcm2835_cprman *cprman, u32 reg)
+@@ -301,6 +335,27 @@ static inline u32 cprman_read(struct bcm2835_cprman *cprman, u32 reg)
  	return readl(cprman->regs + reg);
  }
  
@@ -23724,7 +25355,7 @@ index 6029313..6b6b279 100644
  /*
   * These are fixed clocks. They're probably not all root clocks and it may
   * be possible to turn them on and off but until this is mapped out better
-@@ -384,115 +420,10 @@ static const struct bcm2835_pll_ana_bits bcm2835_ana_pllh = {
+@@ -384,115 +439,10 @@ static const struct bcm2835_pll_ana_bits bcm2835_ana_pllh = {
  	.fb_prediv_mask = BIT(11),
  };
  
@@ -23842,7 +25473,7 @@ index 6029313..6b6b279 100644
  	u32 cm_reg;
  	u32 a2w_reg;
  
-@@ -501,124 +432,6 @@ struct bcm2835_pll_divider_data {
+@@ -501,124 +451,6 @@ struct bcm2835_pll_divider_data {
  	u32 fixed_divider;
  };
  
@@ -23967,7 +25598,7 @@ index 6029313..6b6b279 100644
  struct bcm2835_clock_data {
  	const char *name;
  
-@@ -633,178 +446,17 @@ struct bcm2835_clock_data {
+@@ -633,178 +465,17 @@ struct bcm2835_clock_data {
  	/* Number of fractional bits in the divider */
  	u32 frac_bits;
  
@@ -24029,8 +25660,7 @@ index 6029313..6b6b279 100644
 -	.int_bits = 4,
 -	.frac_bits = 0,
 -};
-+	u32 flags;
- 
+-
 -/*
 - * VPU clock.  This doesn't have an enable bit, since it drives the
 - * bus for everything else, and is special so it doesn't need to be
@@ -24077,7 +25707,8 @@ index 6029313..6b6b279 100644
 -	.int_bits = 4,
 -	.frac_bits = 8,
 -};
--
++	u32 flags;
+ 
 -/* TV encoder clock.  Only operating frequency is 108Mhz.  */
 -static const struct bcm2835_clock_data bcm2835_clock_vec_data = {
 -	.name = "vec",
@@ -24153,7 +25784,34 @@ index 6029313..6b6b279 100644
  };
  
  struct bcm2835_pll {
-@@ -1020,6 +672,36 @@ static int bcm2835_pll_set_rate(struct clk_hw *hw,
+@@ -852,8 +523,12 @@ static long bcm2835_pll_rate_from_divisors(unsigned long parent_rate,
+ static long bcm2835_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+ 				   unsigned long *parent_rate)
+ {
++	struct bcm2835_pll *pll = container_of(hw, struct bcm2835_pll, hw);
++	const struct bcm2835_pll_data *data = pll->data;
+ 	u32 ndiv, fdiv;
+ 
++	rate = clamp(rate, data->min_rate, data->max_rate);
++
+ 	bcm2835_pll_choose_ndiv_and_fdiv(rate, *parent_rate, &ndiv, &fdiv);
+ 
+ 	return bcm2835_pll_rate_from_divisors(*parent_rate, ndiv, fdiv, 1);
+@@ -958,13 +633,6 @@ static int bcm2835_pll_set_rate(struct clk_hw *hw,
+ 	u32 ana[4];
+ 	int i;
+ 
+-	if (rate < data->min_rate || rate > data->max_rate) {
+-		dev_err(cprman->dev, "%s: rate out of spec: %lu vs (%lu, %lu)\n",
+-			clk_hw_get_name(hw), rate,
+-			data->min_rate, data->max_rate);
+-		return -EINVAL;
+-	}
+-
+ 	if (rate > data->max_fb_rate) {
+ 		use_fb_prediv = true;
+ 		rate /= 2;
+@@ -1020,6 +688,36 @@ static int bcm2835_pll_set_rate(struct clk_hw *hw,
  	return 0;
  }
  
@@ -24190,7 +25848,7 @@ index 6029313..6b6b279 100644
  static const struct clk_ops bcm2835_pll_clk_ops = {
  	.is_prepared = bcm2835_pll_is_on,
  	.prepare = bcm2835_pll_on,
-@@ -1027,6 +709,7 @@ static const struct clk_ops bcm2835_pll_clk_ops = {
+@@ -1027,6 +725,7 @@ static const struct clk_ops bcm2835_pll_clk_ops = {
  	.recalc_rate = bcm2835_pll_get_rate,
  	.set_rate = bcm2835_pll_set_rate,
  	.round_rate = bcm2835_pll_round_rate,
@@ -24198,7 +25856,7 @@ index 6029313..6b6b279 100644
  };
  
  struct bcm2835_pll_divider {
-@@ -1127,6 +810,26 @@ static int bcm2835_pll_divider_set_rate(struct clk_hw *hw,
+@@ -1127,6 +826,26 @@ static int bcm2835_pll_divider_set_rate(struct clk_hw *hw,
  	return 0;
  }
  
@@ -24225,7 +25883,7 @@ index 6029313..6b6b279 100644
  static const struct clk_ops bcm2835_pll_divider_clk_ops = {
  	.is_prepared = bcm2835_pll_divider_is_on,
  	.prepare = bcm2835_pll_divider_on,
-@@ -1134,6 +837,7 @@ static const struct clk_ops bcm2835_pll_divider_clk_ops = {
+@@ -1134,6 +853,7 @@ static const struct clk_ops bcm2835_pll_divider_clk_ops = {
  	.recalc_rate = bcm2835_pll_divider_get_rate,
  	.set_rate = bcm2835_pll_divider_set_rate,
  	.round_rate = bcm2835_pll_divider_round_rate,
@@ -24233,7 +25891,7 @@ index 6029313..6b6b279 100644
  };
  
  /*
-@@ -1164,28 +868,42 @@ static int bcm2835_clock_is_on(struct clk_hw *hw)
+@@ -1164,28 +884,42 @@ static int bcm2835_clock_is_on(struct clk_hw *hw)
  
  static u32 bcm2835_clock_choose_div(struct clk_hw *hw,
  				    unsigned long rate,
@@ -24289,7 +25947,17 @@ index 6029313..6b6b279 100644
  
  	return div;
  }
-@@ -1214,16 +932,6 @@ static long bcm2835_clock_rate_from_divisor(struct bcm2835_clock *clock,
+@@ -1197,6 +931,9 @@ static long bcm2835_clock_rate_from_divisor(struct bcm2835_clock *clock,
+ 	const struct bcm2835_clock_data *data = clock->data;
+ 	u64 temp;
+ 
++	if (data->int_bits == 0 && data->frac_bits == 0)
++		return parent_rate;
++
+ 	/*
+ 	 * The divisor is a 12.12 fixed point field, but only some of
+ 	 * the bits are populated in any given clock.
+@@ -1214,23 +951,18 @@ static long bcm2835_clock_rate_from_divisor(struct bcm2835_clock *clock,
  	return temp;
  }
  
@@ -24306,7 +25974,20 @@ index 6029313..6b6b279 100644
  static unsigned long bcm2835_clock_get_rate(struct clk_hw *hw,
  					    unsigned long parent_rate)
  {
-@@ -1288,20 +996,147 @@ static int bcm2835_clock_set_rate(struct clk_hw *hw,
+ 	struct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);
+ 	struct bcm2835_cprman *cprman = clock->cprman;
+ 	const struct bcm2835_clock_data *data = clock->data;
+-	u32 div = cprman_read(cprman, data->div_reg);
++	u32 div;
++
++	if (data->int_bits == 0 && data->frac_bits == 0)
++		return parent_rate;
++
++	div = cprman_read(cprman, data->div_reg);
+ 
+ 	return bcm2835_clock_rate_from_divisor(clock, parent_rate, div);
+ }
+@@ -1288,20 +1020,147 @@ static int bcm2835_clock_set_rate(struct clk_hw *hw,
  	struct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);
  	struct bcm2835_cprman *cprman = clock->cprman;
  	const struct bcm2835_clock_data *data = clock->data;
@@ -24456,7 +26137,7 @@ index 6029313..6b6b279 100644
  };
  
  static int bcm2835_vpu_clock_is_on(struct clk_hw *hw)
-@@ -1317,7 +1152,10 @@ static const struct clk_ops bcm2835_vpu_clock_clk_ops = {
+@@ -1317,7 +1176,10 @@ static const struct clk_ops bcm2835_vpu_clock_clk_ops = {
  	.is_prepared = bcm2835_vpu_clock_is_on,
  	.recalc_rate = bcm2835_clock_get_rate,
  	.set_rate = bcm2835_clock_set_rate,
@@ -24468,7 +26149,16 @@ index 6029313..6b6b279 100644
  };
  
  static struct clk *bcm2835_register_pll(struct bcm2835_cprman *cprman,
-@@ -1366,7 +1204,7 @@ bcm2835_register_pll_divider(struct bcm2835_cprman *cprman,
+@@ -1329,7 +1191,7 @@ static struct clk *bcm2835_register_pll(struct bcm2835_cprman *cprman,
+ 	memset(&init, 0, sizeof(init));
+ 
+ 	/* All of the PLLs derive from the external oscillator. */
+-	init.parent_names = &cprman->osc_name;
++	init.parent_names = &cprman->real_parent_names[0];
+ 	init.num_parents = 1;
+ 	init.name = data->name;
+ 	init.ops = &bcm2835_pll_clk_ops;
+@@ -1366,11 +1228,11 @@ bcm2835_register_pll_divider(struct bcm2835_cprman *cprman,
  
  	memset(&init, 0, sizeof(init));
  
@@ -24477,19 +26167,24 @@ index 6029313..6b6b279 100644
  	init.num_parents = 1;
  	init.name = divider_name;
  	init.ops = &bcm2835_pll_divider_clk_ops;
-@@ -1411,47 +1249,34 @@ static struct clk *bcm2835_register_clock(struct bcm2835_cprman *cprman,
+-	init.flags = CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED;
++	init.flags = CLK_IGNORE_UNUSED;
+ 
+ 	divider = devm_kzalloc(cprman->dev, sizeof(*divider), GFP_KERNEL);
+ 	if (!divider)
+@@ -1411,47 +1273,38 @@ static struct clk *bcm2835_register_clock(struct bcm2835_cprman *cprman,
  {
  	struct bcm2835_clock *clock;
  	struct clk_init_data init;
 -	const char *parent;
 +	const char *parents[1 << CM_SRC_BITS];
-+	size_t i;
++	size_t i, j;
  
  	/*
 -	 * Most of the clock generators have a mux field, so we
 -	 * instantiate a generic mux as our parent to handle it.
-+	 * Replace our "xosc" references with the oscillator's
-+	 * actual name.
++	 * Replace our strings referencing parent clocks with the
++	 * actual clock-output-name of the parent.
  	 */
 -	if (data->num_mux_parents) {
 -		const char *parents[1 << CM_SRC_BITS];
@@ -24509,7 +26204,15 @@ index 6029313..6b6b279 100644
 -				parents[i] = cprman->osc_name;
 -			else
 -				parents[i] = data->parents[i];
--		}
++	for (i = 0; i < data->num_mux_parents; i++) {
++		parents[i] = data->parents[i];
++
++		for (j = 0; j < ARRAY_SIZE(cprman_parent_names); j++) {
++			if (strcmp(parents[i], cprman_parent_names[j]) == 0) {
++				parents[i] = cprman->real_parent_names[j];
++				break;
++			}
+ 		}
 -
 -		clk_register_mux(cprman->dev, parent,
 -				 parents, data->num_mux_parents,
@@ -24519,11 +26222,6 @@ index 6029313..6b6b279 100644
 -				 0, &cprman->regs_lock);
 -	} else {
 -		parent = data->parents[0];
-+	for (i = 0; i < data->num_mux_parents; i++) {
-+		if (strcmp(data->parents[i], "xosc") == 0)
-+			parents[i] = cprman->osc_name;
-+		else
-+			parents[i] = data->parents[i];
  	}
  
  	memset(&init, 0, sizeof(init));
@@ -24546,7 +26244,7 @@ index 6029313..6b6b279 100644
  
  	if (data->is_vpu_clock) {
  		init.ops = &bcm2835_vpu_clock_clk_ops;
-@@ -1471,14 +1296,562 @@ static struct clk *bcm2835_register_clock(struct bcm2835_cprman *cprman,
+@@ -1471,14 +1324,609 @@ static struct clk *bcm2835_register_clock(struct bcm2835_cprman *cprman,
  	return devm_clk_register(cprman->dev, &clock->hw);
  }
  
@@ -24634,6 +26332,28 @@ index 6029313..6b6b279 100644
 +	__VA_ARGS__)
 +
 +/*
++ * DSI1 parent clocks.  The DSI1 byte clock comes from the DSI1 PHY,
++ * which in turn sources from plld_dsi1.
++ */
++static const char *const bcm2835_clock_dsi1_parents[] = {
++	"gnd",
++	"xosc",
++	"testdebug0",
++	"testdebug1",
++	"dsi1_ddr",
++	"dsi1_ddr_inv",
++	"dsi1_ddr2",
++	"dsi1_ddr2_inv",
++	"dsi1_byte",
++	"dsi1_byte_inv",
++};
++
++#define REGISTER_DSI1_CLK(...)	REGISTER_CLK(				\
++	.num_mux_parents = ARRAY_SIZE(bcm2835_clock_dsi1_parents),	\
++	.parents = bcm2835_clock_dsi1_parents,				\
++	__VA_ARGS__)
++
++/*
 + * the real definition of all the pll, pll_dividers and clocks
 + * these make use of the above REGISTER_* macros
 + */
@@ -25078,7 +26798,12 @@ index 6029313..6b6b279 100644
 +		.div_reg = CM_DSI1EDIV,
 +		.int_bits = 4,
 +		.frac_bits = 8),
-+
++	[BCM2835_CLOCK_DSI1P]	= REGISTER_DSI1_CLK(
++		.name = "dsi1p",
++		.ctl_reg = CM_DSI1PCTL,
++		.div_reg = CM_DSI1PDIV,
++		.int_bits = 0,
++		.frac_bits = 0),
 +	/* the gates */
 +
 +	/*
@@ -25092,6 +26817,25 @@ index 6029313..6b6b279 100644
 +		.parent = "vpu",
 +		.ctl_reg = CM_PERIICTL),
 +};
++
++/*
++ * Permanently take a reference on the parent of the SDRAM clock.
++ *
++ * While the SDRAM is being driven by its dedicated PLL most of the
++ * time, there is a little loop running in the firmware that
++ * periodically switches the SDRAM to using our CM clock to do PVT
++ * recalibration, with the assumption that the previously configured
++ * SDRAM parent is still enabled and running.
++ */
++static int bcm2835_mark_sdc_parent_critical(struct clk *sdc)
++{
++	struct clk *parent = clk_get_parent(sdc);
++
++	if (IS_ERR(parent))
++		return PTR_ERR(parent);
++
++	return clk_prepare_enable(parent);
++}
 +
  static int bcm2835_clk_probe(struct platform_device *pdev)
  {
@@ -25102,6 +26846,7 @@ index 6029313..6b6b279 100644
 +	const struct bcm2835_clk_desc *desc;
 +	const size_t asize = ARRAY_SIZE(clk_desc_array);
 +	size_t i;
++	int ret;
  
 -	cprman = devm_kzalloc(dev, sizeof(*cprman), GFP_KERNEL);
 +	cprman = devm_kzalloc(dev,
@@ -25110,7 +26855,25 @@ index 6029313..6b6b279 100644
  	if (!cprman)
  		return -ENOMEM;
  
-@@ -1495,77 +1868,15 @@ static int bcm2835_clk_probe(struct platform_device *pdev)
+@@ -1489,83 +1937,35 @@ static int bcm2835_clk_probe(struct platform_device *pdev)
+ 	if (IS_ERR(cprman->regs))
+ 		return PTR_ERR(cprman->regs);
+ 
+-	cprman->osc_name = of_clk_get_parent_name(dev->of_node, 0);
+-	if (!cprman->osc_name)
++	for (i = 0; i < ARRAY_SIZE(cprman_parent_names); i++) {
++		cprman->real_parent_names[i] =
++			of_clk_get_parent_name(dev->of_node, i);
++	}
++	/*
++	 * Make sure the external oscillator has been registered.
++	 *
++	 * The other (DSI) clocks are not present on older device
++	 * trees, which we still need to support for backwards
++	 * compatibility.
++	 */
++	if (!cprman->real_parent_names[0])
+ 		return -ENODEV;
  
  	platform_set_drvdata(pdev, cprman);
  
@@ -25174,7 +26937,12 @@ index 6029313..6b6b279 100644
 -		bcm2835_register_clock(cprman, &bcm2835_clock_hsm_data);
 -	clks[BCM2835_CLOCK_EMMC] =
 -		bcm2835_register_clock(cprman, &bcm2835_clock_emmc_data);
--
++	for (i = 0; i < asize; i++) {
++		desc = &clk_desc_array[i];
++		if (desc->clk_register && desc->data)
++			clks[i] = desc->clk_register(cprman, desc->data);
++	}
+ 
 -	/*
 -	 * CM_PERIICTL (and CM_PERIACTL, CM_SYSCTL and CM_VPUCTL if
 -	 * you have the debug bit set in the power manager, which we
@@ -25186,11 +26954,9 @@ index 6029313..6b6b279 100644
 -				  CLK_IGNORE_UNUSED | CLK_SET_RATE_GATE,
 -				  cprman->regs + CM_PERIICTL, CM_GATE_BIT,
 -				  0, &cprman->regs_lock);
-+	for (i = 0; i < asize; i++) {
-+		desc = &clk_desc_array[i];
-+		if (desc->clk_register && desc->data)
-+			clks[i] = desc->clk_register(cprman, desc->data);
-+	}
++	ret = bcm2835_mark_sdc_parent_critical(clks[BCM2835_CLOCK_SDRAM]);
++	if (ret)
++		return ret;
  
  	return of_clk_add_provider(dev->of_node, of_clk_src_onecell_get,
  				   &cprman->onecell);
@@ -26896,7 +28662,7 @@ index 996c4b0..a98e2c2 100644
  MODULE_ALIAS("platform:bcm2835-dma");
  MODULE_DESCRIPTION("BCM2835 DMA engine driver");
 diff --git a/drivers/firmware/raspberrypi.c b/drivers/firmware/raspberrypi.c
-index dd506cd3..b980d53 100644
+index dd506cd3..8125051 100644
 --- a/drivers/firmware/raspberrypi.c
 +++ b/drivers/firmware/raspberrypi.c
 @@ -28,6 +28,8 @@ struct rpi_firmware {
@@ -26908,7 +28674,24 @@ index dd506cd3..b980d53 100644
  static DEFINE_MUTEX(transaction_lock);
  
  static void response_callback(struct mbox_client *cl, void *msg)
-@@ -183,6 +185,25 @@ rpi_firmware_print_firmware_revision(struct rpi_firmware *fw)
+@@ -40,7 +42,7 @@ static void response_callback(struct mbox_client *cl, void *msg)
+  * Sends a request to the firmware through the BCM2835 mailbox driver,
+  * and synchronously waits for the reply.
+  */
+-static int
++int
+ rpi_firmware_transaction(struct rpi_firmware *fw, u32 chan, u32 data)
+ {
+ 	u32 message = MBOX_MSG(chan, data);
+@@ -61,6 +63,7 @@ rpi_firmware_transaction(struct rpi_firmware *fw, u32 chan, u32 data)
+ 
+ 	return ret;
+ }
++EXPORT_SYMBOL_GPL(rpi_firmware_transaction);
+ 
+ /**
+  * rpi_firmware_property_list - Submit firmware property list
+@@ -183,6 +186,25 @@ rpi_firmware_print_firmware_revision(struct rpi_firmware *fw)
  	}
  }
  
@@ -26934,7 +28717,7 @@ index dd506cd3..b980d53 100644
  static int rpi_firmware_probe(struct platform_device *pdev)
  {
  	struct device *dev = &pdev->dev;
-@@ -207,9 +228,13 @@ static int rpi_firmware_probe(struct platform_device *pdev)
+@@ -207,9 +229,13 @@ static int rpi_firmware_probe(struct platform_device *pdev)
  	init_completion(&fw->c);
  
  	platform_set_drvdata(pdev, fw);
@@ -26948,7 +28731,7 @@ index dd506cd3..b980d53 100644
  	return 0;
  }
  
-@@ -218,6 +243,7 @@ static int rpi_firmware_remove(struct platform_device *pdev)
+@@ -218,6 +244,7 @@ static int rpi_firmware_remove(struct platform_device *pdev)
  	struct rpi_firmware *fw = platform_get_drvdata(pdev);
  
  	mbox_free_channel(fw->chan);
@@ -26956,7 +28739,7 @@ index dd506cd3..b980d53 100644
  
  	return 0;
  }
-@@ -230,7 +256,7 @@ static int rpi_firmware_remove(struct platform_device *pdev)
+@@ -230,7 +257,7 @@ static int rpi_firmware_remove(struct platform_device *pdev)
   */
  struct rpi_firmware *rpi_firmware_get(struct device_node *firmware_node)
  {
@@ -26965,7 +28748,7 @@ index dd506cd3..b980d53 100644
  
  	if (!pdev)
  		return NULL;
-@@ -253,7 +279,18 @@ static struct platform_driver rpi_firmware_driver = {
+@@ -253,7 +280,18 @@ static struct platform_driver rpi_firmware_driver = {
  	.probe		= rpi_firmware_probe,
  	.remove		= rpi_firmware_remove,
  };
@@ -26986,10 +28769,10 @@ index dd506cd3..b980d53 100644
  MODULE_AUTHOR("Eric Anholt <eric@anholt.net>");
  MODULE_DESCRIPTION("Raspberry Pi firmware driver");
 diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
-index b18bea0..a1f4cce 100644
+index 469dc37..45e6729 100644
 --- a/drivers/gpio/Kconfig
 +++ b/drivers/gpio/Kconfig
-@@ -132,6 +132,12 @@ config GPIO_BCM_KONA
+@@ -133,6 +133,12 @@ config GPIO_BCM_KONA
  	help
  	  Turn on GPIO support for Broadcom "Kona" chips.
  
@@ -27200,8 +28983,21 @@ index 0000000..53edcb4
 +MODULE_AUTHOR("Dom Cobley <popcornmix@gmail.com>");
 +MODULE_DESCRIPTION("brcmvirt GPIO driver");
 +MODULE_ALIAS("platform:brcmvirt-gpio");
+diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
+index c4bf9a1..567f95a 100644
+--- a/drivers/gpu/drm/Kconfig
++++ b/drivers/gpu/drm/Kconfig
+@@ -22,7 +22,7 @@ menuconfig DRM
+ 	  (/dev/agpgart) support if it is available for your platform.
+ 
+ config DRM_MIPI_DSI
+-	bool
++	tristate
+ 	depends on DRM
+ 
+ config DRM_KMS_HELPER
 diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
-index dc84003..4d96cc9 100644
+index 5e4bb48..3453844 100644
 --- a/drivers/gpu/drm/drm_crtc.c
 +++ b/drivers/gpu/drm/drm_crtc.c
 @@ -168,6 +168,7 @@ static struct drm_conn_prop_enum_list drm_connector_enum_list[] = {
@@ -27221,7 +29017,7 @@ index dc84003..4d96cc9 100644
  
  static const struct drm_prop_enum_list drm_subpixel_enum_list[] = {
 diff --git a/drivers/gpu/drm/drm_fb_cma_helper.c b/drivers/gpu/drm/drm_fb_cma_helper.c
-index c19a625..c1a37d3 100644
+index c19a625..6349d0c 100644
 --- a/drivers/gpu/drm/drm_fb_cma_helper.c
 +++ b/drivers/gpu/drm/drm_fb_cma_helper.c
 @@ -266,7 +266,7 @@ static int drm_fbdev_cma_create(struct drm_fb_helper *helper,
@@ -27244,6 +29040,16 @@ index c19a625..c1a37d3 100644
  	return ret;
  }
  
+@@ -348,9 +348,6 @@ struct drm_fbdev_cma *drm_fbdev_cma_init(struct drm_device *dev,
+ 
+ 	}
+ 
+-	/* disable all the possible outputs/crtcs before entering KMS mode */
+-	drm_helper_disable_unused_functions(dev);
+-
+ 	ret = drm_fb_helper_initial_config(helper, preferred_bpp);
+ 	if (ret < 0) {
+ 		dev_err(dev->dev, "Failed to set initial hw configuration.\n");
 diff --git a/drivers/gpu/drm/drm_gem_cma_helper.c b/drivers/gpu/drm/drm_gem_cma_helper.c
 index e109b49..e5df53b 100644
 --- a/drivers/gpu/drm/drm_gem_cma_helper.c
@@ -27284,6 +29090,451 @@ index e109b49..e5df53b 100644
  
  	return ERR_PTR(ret);
  }
+diff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c
+index 2d5ca8ee..fa6cc4d 100644
+--- a/drivers/gpu/drm/drm_mipi_dsi.c
++++ b/drivers/gpu/drm/drm_mipi_dsi.c
+@@ -50,6 +50,24 @@ static int mipi_dsi_device_match(struct device *dev, struct device_driver *drv)
+ 	return of_driver_match_device(dev, drv);
+ }
+ 
++/**
++ * Send modalias events when devices are created on the bus, so that
++ * modules can load automatically.
++ */
++static int mipi_dsi_uevent(struct device *dev, struct kobj_uevent_env *env)
++{
++	int rc;
++
++	/* Just do the OF uevent, which emits the compatible string so
++	 * that a MODULE_DEVICE_TABLE(of, ...) works.
++	 */
++	rc = of_device_uevent_modalias(dev, env);
++	if (rc != -ENODEV)
++		return rc;
++
++	return 0;
++}
++
+ static const struct dev_pm_ops mipi_dsi_device_pm_ops = {
+ 	.runtime_suspend = pm_generic_runtime_suspend,
+ 	.runtime_resume = pm_generic_runtime_resume,
+@@ -65,6 +83,7 @@ static struct bus_type mipi_dsi_bus_type = {
+ 	.name = "mipi-dsi",
+ 	.match = mipi_dsi_device_match,
+ 	.pm = &mipi_dsi_device_pm_ops,
++	.uevent = mipi_dsi_uevent,
+ };
+ 
+ static int of_device_match(struct device *dev, void *data)
+@@ -928,6 +947,12 @@ static int __init mipi_dsi_bus_init(void)
+ }
+ postcore_initcall(mipi_dsi_bus_init);
+ 
++static void __exit mipi_dsi_bus_exit(void)
++{
++	bus_unregister(&mipi_dsi_bus_type);
++}
++module_exit(mipi_dsi_bus_exit);
++
+ MODULE_AUTHOR("Andrzej Hajda <a.hajda@samsung.com>");
+ MODULE_DESCRIPTION("MIPI DSI Bus");
+ MODULE_LICENSE("GPL and additional rights");
+diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
+index 5378bdc..5f93622 100644
+--- a/drivers/gpu/drm/imx/imx-drm-core.c
++++ b/drivers/gpu/drm/imx/imx-drm-core.c
+@@ -313,6 +313,7 @@ static int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)
+ 		dev_warn(drm->dev, "Invalid legacyfb_depth.  Defaulting to 16bpp\n");
+ 		legacyfb_depth = 16;
+ 	}
++	drm_helper_disable_unused_functions(drm);
+ 	imxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth,
+ 				drm->mode_config.num_crtc, MAX_CRTC);
+ 	if (IS_ERR(imxdrm->fbhelper)) {
+diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
+index 7d4704b..409bd70 100644
+--- a/drivers/gpu/drm/panel/Kconfig
++++ b/drivers/gpu/drm/panel/Kconfig
+@@ -31,6 +31,15 @@ config DRM_PANEL_LG_LG4573
+ 	  Say Y here if you want to enable support for LG4573 RGB panel.
+ 	  To compile this driver as a module, choose M here.
+ 
++config DRM_PANEL_RASPBERRYPI_TOUCHSCREEN
++	tristate "Raspberry Pi 7-inch touchscreen panel"
++	depends on DRM_MIPI_DSI
++	depends on BACKLIGHT_CLASS_DEVICE
++	help
++	  Say Y here if you want to enable support for the Raspberry
++	  Pi 7" Touchscreen.  To compile this driver as a module,
++	  choose M here.
++
+ config DRM_PANEL_SAMSUNG_S6E8AA0
+ 	tristate "Samsung S6E8AA0 DSI video mode panel"
+ 	depends on OF
+diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
+index d0f016d..ebb6157 100644
+--- a/drivers/gpu/drm/panel/Makefile
++++ b/drivers/gpu/drm/panel/Makefile
+@@ -1,5 +1,6 @@
+ obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
+ obj-$(CONFIG_DRM_PANEL_LG_LG4573) += panel-lg-lg4573.o
++obj-$(CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN) += panel-raspberrypi-touchscreen.o
+ obj-$(CONFIG_DRM_PANEL_SAMSUNG_LD9040) += panel-samsung-ld9040.o
+ obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0) += panel-samsung-s6e8aa0.o
+ obj-$(CONFIG_DRM_PANEL_SHARP_LQ101R1SX01) += panel-sharp-lq101r1sx01.o
+diff --git a/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c b/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
+new file mode 100644
+index 0000000..be2c19b
+--- /dev/null
++++ b/drivers/gpu/drm/panel/panel-raspberrypi-touchscreen.c
+@@ -0,0 +1,346 @@
++/*
++ * Copyright  2016 Broadcom Limited
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ *
++ * Portions of this file (derived from panel-simple.c) are:
++ *
++ * Copyright (C) 2013, NVIDIA Corporation.  All rights reserved.
++ *
++ * Permission is hereby granted, free of charge, to any person obtaining a
++ * copy of this software and associated documentation files (the "Software"),
++ * to deal in the Software without restriction, including without limitation
++ * the rights to use, copy, modify, merge, publish, distribute, sub license,
++ * and/or sell copies of the Software, and to permit persons to whom the
++ * Software is furnished to do so, subject to the following conditions:
++ *
++ * The above copyright notice and this permission notice (including the
++ * next paragraph) shall be included in all copies or substantial portions
++ * of the Software.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
++ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
++ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
++ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
++ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
++ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
++ * DEALINGS IN THE SOFTWARE.
++ */
++
++/**
++ * DOC: Raspberry Pi 7" touchscreen panel driver.
++ *
++ * The 7" touchscreen consists of a DPI LCD panel, a Toshiba
++ * TC358762XBG DSI-DPI bridge, and an I2C-connected Atmel ATTINY88-MUR
++ * controlling power management, the LCD PWM, and the touchscreen.
++ *
++ * This driver presents this device as a MIPI DSI panel to the DRM
++ * driver, and should expose the touchscreen as a HID device.
++ */
++
++#include <linux/backlight.h>
++#include <linux/delay.h>
++#include <linux/err.h>
++#include <linux/fb.h>
++#include <linux/gpio.h>
++#include <linux/gpio/consumer.h>
++#include <linux/i2c.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/of_graph.h>
++#include <linux/pm.h>
++
++#include <drm/drm_panel.h>
++#include <drm/drmP.h>
++#include <drm/drm_crtc.h>
++#include <drm/drm_mipi_dsi.h>
++#include <drm/drm_panel.h>
++
++struct rpi_touchscreen {
++	struct drm_panel base;
++	struct mipi_dsi_device *dsi;
++	struct i2c_client *bridge_i2c;
++	struct backlight_device *backlight;
++
++	bool prepared;
++	bool enabled;
++
++	/* Version of the firmware on the bridge chip */
++	int atmel_ver;
++};
++
++static const struct drm_display_mode rpi_touchscreen_modes[] = {
++	{
++		/* This is assuming that we'll be running the DSI PLL
++		 * at 2Ghz / 3 (since we only get integer dividers),
++		 * so a pixel clock of 2Ghz / 3 / 8.
++		 */
++		.clock = 83333,
++		.hdisplay = 800,
++		.hsync_start = 800 + 61,
++		.hsync_end = 800 + 61 + 2,
++		.htotal = 800 + 61 + 2 + 44,
++		.vdisplay = 480,
++		.vsync_start = 480 + 7,
++		.vsync_end = 480 + 7 + 2,
++		.vtotal = 480 + 7 + 2 + 21,
++		.vrefresh = 60,
++	},
++};
++
++static struct rpi_touchscreen *panel_to_ts(struct drm_panel *panel)
++{
++	return container_of(panel, struct rpi_touchscreen, base);
++}
++
++struct regdump {
++	const char *reg;
++	u32 offset;
++};
++
++#define REGDUMP(reg) { #reg, reg }
++
++static int rpi_touchscreen_disable(struct drm_panel *panel)
++{
++	struct rpi_touchscreen *ts = panel_to_ts(panel);
++
++	if (!ts->enabled)
++		return 0;
++
++	if (ts->backlight) {
++		ts->backlight->props.power = FB_BLANK_POWERDOWN;
++		backlight_update_status(ts->backlight);
++	}
++
++	ts->enabled = false;
++
++	return 0;
++}
++
++static int rpi_touchscreen_unprepare(struct drm_panel *panel)
++{
++	struct rpi_touchscreen *ts = panel_to_ts(panel);
++
++	if (!ts->prepared)
++		return 0;
++
++	ts->prepared = false;
++
++	return 0;
++}
++
++static int rpi_touchscreen_prepare(struct drm_panel *panel)
++{
++	struct rpi_touchscreen *ts = panel_to_ts(panel);
++
++	if (ts->prepared)
++		return 0;
++
++	ts->prepared = true;
++
++	return 0;
++}
++
++/*
++ * Powers on the panel once the DSI link is up.
++ *
++ * The TC358762 is run in PLLOFF mode, where it usees the MIPI DSI
++ * byte clock instead of an external reference clock.  This means that
++ * we need the DSI host to be on and transmitting before we start
++ * talking to it.
++ */
++static int rpi_touchscreen_enable(struct drm_panel *panel)
++{
++	struct rpi_touchscreen *ts = panel_to_ts(panel);
++
++	if (ts->enabled)
++		return 0;
++
++	if (ts->backlight) {
++		ts->backlight->props.power = FB_BLANK_UNBLANK;
++		backlight_update_status(ts->backlight);
++	}
++
++	ts->enabled = true;
++
++	return 0;
++}
++
++static int rpi_touchscreen_get_modes(struct drm_panel *panel)
++{
++	struct drm_connector *connector = panel->connector;
++	struct drm_device *drm = panel->drm;
++	unsigned int i, num = 0;
++
++	for (i = 0; i < ARRAY_SIZE(rpi_touchscreen_modes); i++) {
++		const struct drm_display_mode *m = &rpi_touchscreen_modes[i];
++		struct drm_display_mode *mode;
++
++		mode = drm_mode_duplicate(drm, m);
++		if (!mode) {
++			dev_err(drm->dev, "failed to add mode %ux%u@%u\n",
++				m->hdisplay, m->vdisplay, m->vrefresh);
++			continue;
++		}
++
++		mode->type |= DRM_MODE_TYPE_DRIVER;
++
++		if (i == 0)
++			mode->type |= DRM_MODE_TYPE_PREFERRED;
++
++		drm_mode_set_name(mode);
++
++		drm_mode_probed_add(connector, mode);
++		num++;
++	}
++
++	connector->display_info.bpc = 8;
++	connector->display_info.width_mm = 217; /* XXX */
++	connector->display_info.height_mm = 136; /* XXX */
++
++	return num;
++}
++
++static int rpi_touchscreen_backlight_update(struct backlight_device *bl)
++{
++	int brightness = bl->props.brightness;
++
++	if (bl->props.power != FB_BLANK_UNBLANK ||
++	    bl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))
++		brightness = 0;
++
++	return 0;
++}
++
++static const struct backlight_ops rpi_touchscreen_backlight_ops = {
++	.update_status	= rpi_touchscreen_backlight_update,
++};
++
++static const struct drm_panel_funcs rpi_touchscreen_funcs = {
++	.disable = rpi_touchscreen_disable,
++	.unprepare = rpi_touchscreen_unprepare,
++	.prepare = rpi_touchscreen_prepare,
++	.enable = rpi_touchscreen_enable,
++	.get_modes = rpi_touchscreen_get_modes,
++};
++
++static struct i2c_client *rpi_touchscreen_get_i2c(struct device *dev,
++						  const char *name)
++{
++	struct device_node *node;
++	struct i2c_client *client;
++
++	node = of_parse_phandle(dev->of_node, name, 0);
++	if (!node)
++		return ERR_PTR(-ENODEV);
++
++	client = of_find_i2c_device_by_node(node);
++
++	of_node_put(node);
++
++	return client;
++}
++
++static int rpi_touchscreen_dsi_probe(struct mipi_dsi_device *dsi)
++{
++	struct device *dev = &dsi->dev;
++	struct rpi_touchscreen *ts;
++	int ret;
++
++	ts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);
++	if (!ts)
++		return -ENOMEM;
++
++	dev_set_drvdata(dev, ts);
++
++	ts->dsi = dsi;
++	dsi->mode_flags = (MIPI_DSI_MODE_VIDEO |
++			   MIPI_DSI_MODE_VIDEO_SYNC_PULSE);
++	dsi->format = MIPI_DSI_FMT_RGB888;
++	dsi->lanes = 1;
++
++	ts->bridge_i2c =
++		rpi_touchscreen_get_i2c(dev, "raspberrypi,touchscreen-bridge");
++	if (!ts->bridge_i2c) {
++		ret = -EPROBE_DEFER;
++		return ret;
++	}
++
++#if 0
++	ts->backlight =
++		devm_backlight_device_register(dev,
++					       "raspberrypi-touchscreen-backlight",
++					       dev, ts,
++					       &rpi_touchscreen_backlight_ops,
++					       NULL);
++	if (IS_ERR(ts->backlight)) {
++		DRM_ERROR("failed to register backlight\n");
++		return PTR_ERR(ts->backlight);
++	}
++	ts->backlight->props.max_brightness = RPI_TOUCHSCREEN_MAX_BRIGHTNESS;
++	ts->backlight->props.brightness = RPI_TOUCHSCREEN_MAX_BRIGHTNESS;
++#endif
++
++	drm_panel_init(&ts->base);
++	ts->base.dev = dev;
++	ts->base.funcs = &rpi_touchscreen_funcs;
++
++	ret = drm_panel_add(&ts->base);
++	if (ret < 0)
++		goto err_release_bridge;
++
++	return mipi_dsi_attach(dsi);
++
++err_release_bridge:
++	put_device(&ts->bridge_i2c->dev);
++	return ret;
++}
++
++static int rpi_touchscreen_dsi_remove(struct mipi_dsi_device *dsi)
++{
++	struct device *dev = &dsi->dev;
++	struct rpi_touchscreen *ts = dev_get_drvdata(dev);
++	int ret;
++
++	ret = mipi_dsi_detach(dsi);
++	if (ret < 0) {
++		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", ret);
++		return ret;
++	}
++
++	drm_panel_detach(&ts->base);
++	drm_panel_remove(&ts->base);
++
++	put_device(&ts->bridge_i2c->dev);
++
++	return 0;
++}
++
++static void rpi_touchscreen_dsi_shutdown(struct mipi_dsi_device *dsi)
++{
++	/* XXX: poweroff */
++}
++
++static const struct of_device_id rpi_touchscreen_of_match[] = {
++	{ .compatible = "raspberrypi,touchscreen" },
++	{ } /* sentinel */
++};
++MODULE_DEVICE_TABLE(of, rpi_touchscreen_of_match);
++
++static struct mipi_dsi_driver rpi_touchscreen_driver = {
++	.driver = {
++		.name = "raspberrypi-touchscreen",
++		.of_match_table = rpi_touchscreen_of_match,
++	},
++	.probe = rpi_touchscreen_dsi_probe,
++	.remove = rpi_touchscreen_dsi_remove,
++	.shutdown = rpi_touchscreen_dsi_shutdown,
++};
++module_mipi_dsi_driver(rpi_touchscreen_driver);
++
++MODULE_AUTHOR("Eric Anholt <eric@anholt.net>");
++MODULE_DESCRIPTION("Raspberry Pi 7-inch touchscreen driver");
++MODULE_LICENSE("GPL v2");
 diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
 index f97b73e..e4a2848 100644
 --- a/drivers/gpu/drm/panel/panel-simple.c
@@ -27339,11 +29590,35 @@ index f97b73e..e4a2848 100644
  		.compatible = "ortustech,com43h4m85ulc",
  		.data = &ortustech_com43h4m85ulc,
  	}, {
+diff --git a/drivers/gpu/drm/sti/sti_drv.c b/drivers/gpu/drm/sti/sti_drv.c
+index 1469987..506b562 100644
+--- a/drivers/gpu/drm/sti/sti_drv.c
++++ b/drivers/gpu/drm/sti/sti_drv.c
+@@ -160,6 +160,7 @@ static int sti_load(struct drm_device *dev, unsigned long flags)
+ 
+ 	drm_mode_config_reset(dev);
+ 
++	drm_helper_disable_unused_functions(dev);
+ 	drm_fbdev_cma_init(dev, 32,
+ 			   dev->mode_config.num_crtc,
+ 			   dev->mode_config.num_connector);
+diff --git a/drivers/gpu/drm/tilcdc/tilcdc_drv.c b/drivers/gpu/drm/tilcdc/tilcdc_drv.c
+index 876cad5..24be31d 100644
+--- a/drivers/gpu/drm/tilcdc/tilcdc_drv.c
++++ b/drivers/gpu/drm/tilcdc/tilcdc_drv.c
+@@ -294,6 +294,7 @@ static int tilcdc_load(struct drm_device *dev, unsigned long flags)
+ 			break;
+ 	}
+ 
++	drm_helper_disable_unused_functions(dev);
+ 	priv->fbdev = drm_fbdev_cma_init(dev, bpp,
+ 			dev->mode_config.num_crtc,
+ 			dev->mode_config.num_connector);
 diff --git a/drivers/gpu/drm/vc4/Kconfig b/drivers/gpu/drm/vc4/Kconfig
-index 2d7d115..33aa7f5 100644
+index 2d7d115..19b1ec8 100644
 --- a/drivers/gpu/drm/vc4/Kconfig
 +++ b/drivers/gpu/drm/vc4/Kconfig
-@@ -1,10 +1,11 @@
+@@ -1,10 +1,13 @@
  config DRM_VC4
  	tristate "Broadcom VC4 Graphics"
 -	depends on ARCH_BCM2835 || COMPILE_TEST
@@ -27353,18 +29628,22 @@ index 2d7d115..33aa7f5 100644
  	select DRM_KMS_CMA_HELPER
  	select DRM_GEM_CMA_HELPER
 +	select DRM_PANEL
++	select DRM_MIPI_DSI
++	select CLKSRC_OF
  	help
  	  Choose this option if you have a system that has a Broadcom
  	  VC4 GPU, such as the Raspberry Pi or other BCM2708/BCM2835.
 diff --git a/drivers/gpu/drm/vc4/Makefile b/drivers/gpu/drm/vc4/Makefile
-index 32b4f9c..fb77db7 100644
+index 32b4f9c..60f19e1 100644
 --- a/drivers/gpu/drm/vc4/Makefile
 +++ b/drivers/gpu/drm/vc4/Makefile
-@@ -7,11 +7,21 @@ vc4-y := \
+@@ -7,11 +7,23 @@ vc4-y := \
  	vc4_bo.o \
  	vc4_crtc.o \
  	vc4_drv.o \
 +	vc4_dpi.o \
++	vc4_dsi.o \
++	vc4_firmware_kms.o \
  	vc4_kms.o \
 +	vc4_gem.o \
  	vc4_hdmi.o \
@@ -27956,18 +30235,25 @@ index ab9f510..2953ab8 100644
 +	}
 +}
 diff --git a/drivers/gpu/drm/vc4/vc4_crtc.c b/drivers/gpu/drm/vc4/vc4_crtc.c
-index 265064c..07662bd 100644
+index 265064c..fb20449 100644
 --- a/drivers/gpu/drm/vc4/vc4_crtc.c
 +++ b/drivers/gpu/drm/vc4/vc4_crtc.c
-@@ -35,6 +35,7 @@
+@@ -35,6 +35,8 @@
  #include "drm_atomic_helper.h"
  #include "drm_crtc_helper.h"
  #include "linux/clk.h"
++#include "linux/debugfs.h"
 +#include "drm_fb_cma_helper.h"
  #include "linux/component.h"
  #include "linux/of_device.h"
  #include "vc4_drv.h"
-@@ -48,22 +49,31 @@ struct vc4_crtc {
+@@ -45,25 +47,39 @@ struct vc4_crtc {
+ 	const struct vc4_crtc_data *data;
+ 	void __iomem *regs;
+ 
++	/* Timestamp at start of vblank irq - unaffected by lock delays. */
++	ktime_t t_vblank;
++
  	/* Which HVS channel we're using for our CRTC. */
  	int channel;
  
@@ -27980,6 +30266,8 @@ index 265064c..07662bd 100644
 +	u8 lut_r[256];
 +	u8 lut_g[256];
 +	u8 lut_b[256];
++	/* Size in pixels of the COB memory allocated to this CRTC. */
++	u32 cob_size;
  
  	struct drm_pending_vblank_event *event;
  };
@@ -28005,16 +30293,211 @@ index 265064c..07662bd 100644
  struct vc4_crtc_data {
  	/* Which channel of the HVS this pixelvalve sources from. */
  	int hvs_channel;
-@@ -82,7 +92,7 @@ static const struct {
- } crtc_regs[] = {
- 	CRTC_REG(PV_CONTROL),
- 	CRTC_REG(PV_V_CONTROL),
+@@ -75,35 +91,25 @@ struct vc4_crtc_data {
+ #define CRTC_WRITE(offset, val) writel(val, vc4_crtc->regs + (offset))
+ #define CRTC_READ(offset) readl(vc4_crtc->regs + (offset))
+ 
+-#define CRTC_REG(reg) { reg, #reg }
+-static const struct {
+-	u32 reg;
+-	const char *name;
+-} crtc_regs[] = {
+-	CRTC_REG(PV_CONTROL),
+-	CRTC_REG(PV_V_CONTROL),
 -	CRTC_REG(PV_VSYNCD),
-+	CRTC_REG(PV_VSYNCD_EVEN),
- 	CRTC_REG(PV_HORZA),
- 	CRTC_REG(PV_HORZB),
- 	CRTC_REG(PV_VERTA),
-@@ -141,6 +151,46 @@ static void vc4_crtc_destroy(struct drm_crtc *crtc)
+-	CRTC_REG(PV_HORZA),
+-	CRTC_REG(PV_HORZB),
+-	CRTC_REG(PV_VERTA),
+-	CRTC_REG(PV_VERTB),
+-	CRTC_REG(PV_VERTA_EVEN),
+-	CRTC_REG(PV_VERTB_EVEN),
+-	CRTC_REG(PV_INTEN),
+-	CRTC_REG(PV_INTSTAT),
+-	CRTC_REG(PV_STAT),
+-	CRTC_REG(PV_HACT_ACT),
++static const struct debugfs_reg32 crtc_regs[] = {
++	VC4_DEBUG_REG(PV_CONTROL),
++	VC4_DEBUG_REG(PV_V_CONTROL),
++	VC4_DEBUG_REG(PV_VSYNCD_EVEN),
++	VC4_DEBUG_REG(PV_HORZA),
++	VC4_DEBUG_REG(PV_HORZB),
++	VC4_DEBUG_REG(PV_VERTA),
++	VC4_DEBUG_REG(PV_VERTB),
++	VC4_DEBUG_REG(PV_VERTA_EVEN),
++	VC4_DEBUG_REG(PV_VERTB_EVEN),
++	VC4_DEBUG_REG(PV_INTEN),
++	VC4_DEBUG_REG(PV_INTSTAT),
++	VC4_DEBUG_REG(PV_STAT),
++	VC4_DEBUG_REG(PV_HACT_ACT),
+ };
+ 
+ static void vc4_crtc_dump_regs(struct vc4_crtc *vc4_crtc)
+ {
+-	int i;
+-
+-	for (i = 0; i < ARRAY_SIZE(crtc_regs); i++) {
+-		DRM_INFO("0x%04x (%s): 0x%08x\n",
+-			 crtc_regs[i].reg, crtc_regs[i].name,
+-			 CRTC_READ(crtc_regs[i].reg));
+-	}
++	vc4_dump_regs32(crtc_regs, ARRAY_SIZE(crtc_regs), vc4_crtc->regs, "");
+ }
+ 
+ #ifdef CONFIG_DEBUG_FS
+@@ -126,21 +132,194 @@ int vc4_crtc_debugfs_regs(struct seq_file *m, void *unused)
+ 		return 0;
+ 	vc4_crtc = to_vc4_crtc(crtc);
+ 
+-	for (i = 0; i < ARRAY_SIZE(crtc_regs); i++) {
+-		seq_printf(m, "%s (0x%04x): 0x%08x\n",
+-			   crtc_regs[i].name, crtc_regs[i].reg,
+-			   CRTC_READ(crtc_regs[i].reg));
+-	}
++	debugfs_print_regs32(m, crtc_regs, ARRAY_SIZE(crtc_regs),
++			     vc4_crtc->regs, "");
+ 
+ 	return 0;
+ }
+ #endif
+ 
++int vc4_crtc_get_scanoutpos(struct drm_device *dev, unsigned int crtc_id,
++			    unsigned int flags, int *vpos, int *hpos,
++			    ktime_t *stime, ktime_t *etime,
++			    const struct drm_display_mode *mode)
++{
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct vc4_crtc *vc4_crtc = vc4->crtc[crtc_id];
++	u32 val;
++	int fifo_lines;
++	int vblank_lines;
++	int ret = 0;
++
++	if (vc4->firmware_kms)
++		return 0;
++
++	/* preempt_disable_rt() should go right here in PREEMPT_RT patchset. */
++
++	/* Get optional system timestamp before query. */
++	if (stime)
++		*stime = ktime_get();
++
++	/*
++	 * Read vertical scanline which is currently composed for our
++	 * pixelvalve by the HVS, and also the scaler status.
++	 */
++	val = HVS_READ(SCALER_DISPSTATX(vc4_crtc->channel));
++
++	/* Get optional system timestamp after query. */
++	if (etime)
++		*etime = ktime_get();
++
++	/* preempt_enable_rt() should go right here in PREEMPT_RT patchset. */
++
++	/* Vertical position of hvs composed scanline. */
++	*vpos = VC4_GET_FIELD(val, SCALER_DISPSTATX_LINE);
++	*hpos = 0;
++
++	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
++		*vpos /= 2;
++
++		/* Use hpos to correct for field offset in interlaced mode. */
++		if (VC4_GET_FIELD(val, SCALER_DISPSTATX_FRAME_COUNT) % 2)
++			*hpos += mode->crtc_htotal / 2;
++	}
++
++	/* This is the offset we need for translating hvs -> pv scanout pos. */
++	fifo_lines = vc4_crtc->cob_size / mode->crtc_hdisplay;
++
++	if (fifo_lines > 0)
++		ret |= DRM_SCANOUTPOS_VALID;
++
++	/* HVS more than fifo_lines into frame for compositing? */
++	if (*vpos > fifo_lines) {
++		/*
++		 * We are in active scanout and can get some meaningful results
++		 * from HVS. The actual PV scanout can not trail behind more
++		 * than fifo_lines as that is the fifo's capacity. Assume that
++		 * in active scanout the HVS and PV work in lockstep wrt. HVS
++		 * refilling the fifo and PV consuming from the fifo, ie.
++		 * whenever the PV consumes and frees up a scanline in the
++		 * fifo, the HVS will immediately refill it, therefore
++		 * incrementing vpos. Therefore we choose HVS read position -
++		 * fifo size in scanlines as a estimate of the real scanout
++		 * position of the PV.
++		 */
++		*vpos -= fifo_lines + 1;
++
++		ret |= DRM_SCANOUTPOS_ACCURATE;
++		return ret;
++	}
++
++	/*
++	 * Less: This happens when we are in vblank and the HVS, after getting
++	 * the VSTART restart signal from the PV, just started refilling its
++	 * fifo with new lines from the top-most lines of the new framebuffers.
++	 * The PV does not scan out in vblank, so does not remove lines from
++	 * the fifo, so the fifo will be full quickly and the HVS has to pause.
++	 * We can't get meaningful readings wrt. scanline position of the PV
++	 * and need to make things up in a approximative but consistent way.
++	 */
++	ret |= DRM_SCANOUTPOS_IN_VBLANK;
++	vblank_lines = mode->vtotal - mode->vdisplay;
++
++	if (flags & DRM_CALLED_FROM_VBLIRQ) {
++		/*
++		 * Assume the irq handler got called close to first
++		 * line of vblank, so PV has about a full vblank
++		 * scanlines to go, and as a base timestamp use the
++		 * one taken at entry into vblank irq handler, so it
++		 * is not affected by random delays due to lock
++		 * contention on event_lock or vblank_time lock in
++		 * the core.
++		 */
++		*vpos = -vblank_lines;
++
++		if (stime)
++			*stime = vc4_crtc->t_vblank;
++		if (etime)
++			*etime = vc4_crtc->t_vblank;
++
++		/*
++		 * If the HVS fifo is not yet full then we know for certain
++		 * we are at the very beginning of vblank, as the hvs just
++		 * started refilling, and the stime and etime timestamps
++		 * truly correspond to start of vblank.
++		 */
++		if ((val & SCALER_DISPSTATX_FULL) != SCALER_DISPSTATX_FULL)
++			ret |= DRM_SCANOUTPOS_ACCURATE;
++	} else {
++		/*
++		 * No clue where we are inside vblank. Return a vpos of zero,
++		 * which will cause calling code to just return the etime
++		 * timestamp uncorrected. At least this is no worse than the
++		 * standard fallback.
++		 */
++		*vpos = 0;
++	}
++
++	return ret;
++}
++
++int vc4_crtc_get_vblank_timestamp(struct drm_device *dev, unsigned int crtc_id,
++				  int *max_error, struct timeval *vblank_time,
++				  unsigned flags)
++{
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct vc4_crtc *vc4_crtc = vc4->crtc[crtc_id];
++	struct drm_crtc *crtc = &vc4_crtc->base;
++	struct drm_crtc_state *state = crtc->state;
++
++	/* Helper routine in DRM core does all the work: */
++	return drm_calc_vbltimestamp_from_scanoutpos(dev, crtc_id, max_error,
++						     vblank_time, flags,
++						     &state->adjusted_mode);
++}
++
+ static void vc4_crtc_destroy(struct drm_crtc *crtc)
+ {
  	drm_crtc_cleanup(crtc);
  }
  
@@ -28061,33 +30544,143 @@ index 265064c..07662bd 100644
  static u32 vc4_get_fifo_full_level(u32 format)
  {
  	static const u32 fifo_len_bytes = 64;
-@@ -182,6 +232,8 @@ static int vc4_get_clock_select(struct drm_crtc *crtc)
+@@ -160,36 +339,40 @@ static u32 vc4_get_fifo_full_level(u32 format)
+ }
+ 
+ /*
+- * Returns the clock select bit for the connector attached to the
+- * CRTC.
++ * Returns the encoder attached to the CRTC.
++ *
++ * VC4 can only scan out to one encoder at a type, while the DRM core
++ * allows drivers to push pixels to more than one encoder from the
++ * same CRTC.
+  */
+-static int vc4_get_clock_select(struct drm_crtc *crtc)
++static struct drm_encoder *vc4_get_crtc_encoder(struct drm_crtc *crtc)
+ {
+ 	struct drm_connector *connector;
+ 
+ 	drm_for_each_connector(connector, crtc->dev) {
+ 		if (connector->state->crtc == crtc) {
+-			struct drm_encoder *encoder = connector->encoder;
+-			struct vc4_encoder *vc4_encoder =
+-				to_vc4_encoder(encoder);
+-
+-			return vc4_encoder->clock_select;
++			return connector->encoder;
+ 		}
+ 	}
+ 
+-	return -1;
++	return NULL;
+ }
  
  static void vc4_crtc_mode_set_nofb(struct drm_crtc *crtc)
  {
 +	struct drm_device *dev = crtc->dev;
 +	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct drm_encoder *encoder = vc4_get_crtc_encoder(crtc);
++	struct vc4_encoder *vc4_encoder = to_vc4_encoder(encoder);
  	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
  	struct drm_crtc_state *state = crtc->state;
  	struct drm_display_mode *mode = &state->adjusted_mode;
-@@ -211,6 +263,16 @@ static void vc4_crtc_mode_set_nofb(struct drm_crtc *crtc)
- 				 PV_HORZB_HFP) |
- 		   VC4_SET_FIELD(mode->hdisplay, PV_HORZB_HACTIVE));
+ 	bool interlace = mode->flags & DRM_MODE_FLAG_INTERLACE;
+-	u32 vactive = (mode->vdisplay >> (interlace ? 1 : 0));
+-	u32 format = PV_CONTROL_FORMAT_24;
++	bool is_dsi = (vc4_encoder->type == VC4_ENCODER_TYPE_DSI0 ||
++		       vc4_encoder->type == VC4_ENCODER_TYPE_DSI1);
++	u32 format = is_dsi ? PV_CONTROL_FORMAT_DSIV_24 : PV_CONTROL_FORMAT_24;
++	u32 pixel_rep = (mode->flags & DRM_MODE_FLAG_DBLCLK) ? 2 : 1;
+ 	bool debug_dump_regs = false;
+-	int clock_select = vc4_get_clock_select(crtc);
  
+ 	if (debug_dump_regs) {
+ 		DRM_INFO("CRTC %d regs before:\n", drm_crtc_index(crtc));
+@@ -202,44 +385,85 @@ static void vc4_crtc_mode_set_nofb(struct drm_crtc *crtc)
+ 	CRTC_WRITE(PV_CONTROL, 0);
+ 
+ 	CRTC_WRITE(PV_HORZA,
+-		   VC4_SET_FIELD(mode->htotal - mode->hsync_end,
++		   VC4_SET_FIELD((mode->htotal -
++				  mode->hsync_end) * pixel_rep,
+ 				 PV_HORZA_HBP) |
+-		   VC4_SET_FIELD(mode->hsync_end - mode->hsync_start,
++		   VC4_SET_FIELD((mode->hsync_end -
++				  mode->hsync_start) * pixel_rep,
+ 				 PV_HORZA_HSYNC));
+ 	CRTC_WRITE(PV_HORZB,
+-		   VC4_SET_FIELD(mode->hsync_start - mode->hdisplay,
++		   VC4_SET_FIELD((mode->hsync_start -
++				  mode->hdisplay) * pixel_rep,
+ 				 PV_HORZB_HFP) |
+-		   VC4_SET_FIELD(mode->hdisplay, PV_HORZB_HACTIVE));
++		   VC4_SET_FIELD(mode->hdisplay * pixel_rep, PV_HORZB_HACTIVE));
++
 +	CRTC_WRITE(PV_VERTA,
-+		   VC4_SET_FIELD(mode->vtotal - mode->vsync_end,
++		   VC4_SET_FIELD(mode->crtc_vtotal - mode->crtc_vsync_end,
 +				 PV_VERTA_VBP) |
-+		   VC4_SET_FIELD(mode->vsync_end - mode->vsync_start,
++		   VC4_SET_FIELD(mode->crtc_vsync_end - mode->crtc_vsync_start,
 +				 PV_VERTA_VSYNC));
 +	CRTC_WRITE(PV_VERTB,
-+		   VC4_SET_FIELD(mode->vsync_start - mode->vdisplay,
++		   VC4_SET_FIELD(mode->crtc_vsync_start - mode->crtc_vdisplay,
 +				 PV_VERTB_VFP) |
-+		   VC4_SET_FIELD(vactive, PV_VERTB_VACTIVE));
-+
++		   VC4_SET_FIELD(mode->crtc_vdisplay, PV_VERTB_VACTIVE));
+ 
  	if (interlace) {
  		CRTC_WRITE(PV_VERTA_EVEN,
- 			   VC4_SET_FIELD(mode->vtotal - mode->vsync_end - 1,
-@@ -240,6 +302,16 @@ static void vc4_crtc_mode_set_nofb(struct drm_crtc *crtc)
+-			   VC4_SET_FIELD(mode->vtotal - mode->vsync_end - 1,
++			   VC4_SET_FIELD(mode->crtc_vtotal -
++					 mode->crtc_vsync_end - 1,
+ 					 PV_VERTA_VBP) |
+-			   VC4_SET_FIELD(mode->vsync_end - mode->vsync_start,
++			   VC4_SET_FIELD(mode->crtc_vsync_end -
++					 mode->crtc_vsync_start,
+ 					 PV_VERTA_VSYNC));
+ 		CRTC_WRITE(PV_VERTB_EVEN,
+-			   VC4_SET_FIELD(mode->vsync_start - mode->vdisplay,
++			   VC4_SET_FIELD(mode->crtc_vsync_start -
++					 mode->crtc_vdisplay,
+ 					 PV_VERTB_VFP) |
+-			   VC4_SET_FIELD(vactive, PV_VERTB_VACTIVE));
+-	}
++			   VC4_SET_FIELD(mode->crtc_vdisplay, PV_VERTB_VACTIVE));
+ 
+-	CRTC_WRITE(PV_HACT_ACT, mode->hdisplay);
++		/* We set up first field even mode for HDMI.  VEC's
++		 * NTSC mode would want first field odd instead, once
++		 * we support it (to do so, set ODD_FIRST and put the
++		 * delay in VSYNCD_EVEN instead).
++		 */
++		CRTC_WRITE(PV_V_CONTROL,
++			   PV_VCONTROL_CONTINUOUS |
++			   (is_dsi ? PV_VCONTROL_DSI : 0) |
++			   PV_VCONTROL_INTERLACE |
++			   VC4_SET_FIELD(mode->htotal * pixel_rep / 2,
++					 PV_VCONTROL_ODD_DELAY));
++		CRTC_WRITE(PV_VSYNCD_EVEN, 0);
++	} else {
++		CRTC_WRITE(PV_V_CONTROL,
++			   PV_VCONTROL_CONTINUOUS |
++			   (is_dsi ? PV_VCONTROL_DSI : 0));
++	}
+ 
+-	CRTC_WRITE(PV_V_CONTROL,
+-		   PV_VCONTROL_CONTINUOUS |
+-		   (interlace ? PV_VCONTROL_INTERLACE : 0));
++	CRTC_WRITE(PV_HACT_ACT, mode->hdisplay * pixel_rep);
+ 
+ 	CRTC_WRITE(PV_CONTROL,
+ 		   VC4_SET_FIELD(format, PV_CONTROL_FORMAT) |
+ 		   VC4_SET_FIELD(vc4_get_fifo_full_level(format),
+ 				 PV_CONTROL_FIFO_LEVEL) |
++		   VC4_SET_FIELD(pixel_rep - 1, PV_CONTROL_PIXEL_REP) |
+ 		   PV_CONTROL_CLR_AT_START |
+ 		   PV_CONTROL_TRIGGER_UNDERFLOW |
+ 		   PV_CONTROL_WAIT_HSTART |
+-		   VC4_SET_FIELD(clock_select, PV_CONTROL_CLK_SELECT) |
++		   VC4_SET_FIELD(vc4_encoder->clock_select,
++				 PV_CONTROL_CLK_SELECT) |
  		   PV_CONTROL_FIFO_CLR |
  		   PV_CONTROL_EN);
  
@@ -28104,7 +30697,52 @@ index 265064c..07662bd 100644
  	if (debug_dump_regs) {
  		DRM_INFO("CRTC %d regs after:\n", drm_crtc_index(crtc));
  		vc4_crtc_dump_regs(vc4_crtc);
-@@ -318,11 +390,13 @@ static void vc4_crtc_enable(struct drm_crtc *crtc)
+@@ -263,6 +487,22 @@ static void vc4_crtc_disable(struct drm_crtc *crtc)
+ 	int ret;
+ 	require_hvs_enabled(dev);
+ 
++	/* Disable vblank irq handling before crtc is disabled. */
++	drm_crtc_vblank_off(crtc);
++
++	if (VC4_DSI_USE_FIRMWARE_SETUP &&
++	    (CRTC_READ(PV_V_CONTROL) & PV_VCONTROL_DSI)) {
++		/* Skip disabling the PV/HVS for the channel if it was
++		 * connected to the DSI panel and we're using the
++		 * firmware setup.  Instead, just set it to stuff
++		 * black in the composite output buffer.
++		 */
++		HVS_WRITE(SCALER_DISPBKGNDX(vc4_crtc->channel),
++			  HVS_READ(SCALER_DISPBKGNDX(vc4_crtc->channel)) |
++			  SCALER_DISPBKGND_FILL);
++		return;
++	}
++
+ 	CRTC_WRITE(PV_V_CONTROL,
+ 		   CRTC_READ(PV_V_CONTROL) & ~PV_VCONTROL_VIDEN);
+ 	ret = wait_for(!(CRTC_READ(PV_V_CONTROL) & PV_VCONTROL_VIDEN), 1);
+@@ -313,16 +553,35 @@ static void vc4_crtc_enable(struct drm_crtc *crtc)
+ 	/* Turn on the pixel valve, which will emit the vstart signal. */
+ 	CRTC_WRITE(PV_V_CONTROL,
+ 		   CRTC_READ(PV_V_CONTROL) | PV_VCONTROL_VIDEN);
++
++	/* Enable vblank irq handling after crtc is started. */
++	drm_crtc_vblank_on(crtc);
++}
++
++static bool vc4_crtc_mode_fixup(struct drm_crtc *crtc,
++				const struct drm_display_mode *mode,
++				struct drm_display_mode *adjusted_mode)
++{
++	/* Do not allow doublescan modes from user space */
++	if (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN) {
++		DRM_DEBUG_KMS("[CRTC:%d] Doublescan mode rejected.\n",
++			      crtc->base.id);
++		return false;
++	}
++
++	return true;
+ }
+ 
  static int vc4_crtc_atomic_check(struct drm_crtc *crtc,
  				 struct drm_crtc_state *state)
  {
@@ -28119,7 +30757,33 @@ index 265064c..07662bd 100644
  
  	/* The pixelvalve can only feed one encoder (and encoders are
  	 * 1:1 with connectors.)
-@@ -345,18 +419,12 @@ static int vc4_crtc_atomic_check(struct drm_crtc *crtc,
+@@ -330,33 +589,29 @@ static int vc4_crtc_atomic_check(struct drm_crtc *crtc,
+ 	if (drm_atomic_connectors_for_crtc(state->state, crtc) > 1)
+ 		return -EINVAL;
+ 
+-	drm_atomic_crtc_state_for_each_plane(plane, state) {
+-		struct drm_plane_state *plane_state =
+-			state->state->plane_states[drm_plane_index(plane)];
++	if (state->active) {
++		drm_atomic_crtc_state_for_each_plane(plane, state) {
++			struct drm_plane_state *plane_state =
++				state->state->plane_states[drm_plane_index(plane)];
+ 
+-		/* plane might not have changed, in which case take
+-		 * current state:
+-		 */
+-		if (!plane_state)
+-			plane_state = plane->state;
++			/* plane might not have changed, in which case take
++			 * current state:
++			 */
++			if (!plane_state)
++				plane_state = plane->state;
+ 
+-		dlist_count += vc4_plane_dlist_size(plane_state);
++			dlist_count += vc4_plane_dlist_size(plane_state);
++		}
+ 	}
  
  	dlist_count++; /* Account for SCALER_CTL0_END. */
  
@@ -28144,7 +30808,7 @@ index 265064c..07662bd 100644
  
  	return 0;
  }
-@@ -367,47 +435,29 @@ static void vc4_crtc_atomic_flush(struct drm_crtc *crtc,
+@@ -367,52 +622,28 @@ static void vc4_crtc_atomic_flush(struct drm_crtc *crtc,
  	struct drm_device *dev = crtc->dev;
  	struct vc4_dev *vc4 = to_vc4_dev(dev);
  	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
@@ -28168,9 +30832,13 @@ index 265064c..07662bd 100644
 -	 * list.  For now, we're safe because we only have the two
 -	 * planes.
 -	 */
+-	drm_atomic_crtc_for_each_plane(plane, crtc) {
+-		dlist_next += vc4_plane_write_dlist(plane, dlist_next);
 +	/* Copy all the active planes' dlist contents to the hardware dlist. */
- 	drm_atomic_crtc_for_each_plane(plane, crtc) {
- 		dlist_next += vc4_plane_write_dlist(plane, dlist_next);
++	if (crtc->state->active) {
++		drm_atomic_crtc_for_each_plane(plane, crtc) {
++			dlist_next += vc4_plane_write_dlist(plane, dlist_next);
++		}
  	}
  
 -	if (dlist_next == vc4_crtc->dlist) {
@@ -28195,23 +30863,89 @@ index 265064c..07662bd 100644
 -	}
 +	writel(SCALER_CTL0_END, dlist_next);
 +	dlist_next++;
-+
+ 
+-	if (debug_dump_regs) {
+-		DRM_INFO("CRTC %d HVS after:\n", drm_crtc_index(crtc));
+-		vc4_hvs_dump_state(dev);
+-	}
 +	WARN_ON_ONCE(dlist_next - dlist_start != vc4_state->mm.size);
+ 
+ 	if (crtc->state->event) {
+ 		unsigned long flags;
+@@ -423,8 +654,20 @@ static void vc4_crtc_atomic_flush(struct drm_crtc *crtc,
+ 
+ 		spin_lock_irqsave(&dev->event_lock, flags);
+ 		vc4_crtc->event = crtc->state->event;
+-		spin_unlock_irqrestore(&dev->event_lock, flags);
+ 		crtc->state->event = NULL;
++
++		HVS_WRITE(SCALER_DISPLISTX(vc4_crtc->channel),
++			  vc4_state->mm.start);
 +
-+	HVS_WRITE(SCALER_DISPLISTX(vc4_crtc->channel),
-+		  vc4_state->mm.start);
++		spin_unlock_irqrestore(&dev->event_lock, flags);
++	} else {
++		HVS_WRITE(SCALER_DISPLISTX(vc4_crtc->channel),
++			  vc4_state->mm.start);
++	}
++
++	if (debug_dump_regs) {
++		DRM_INFO("CRTC %d HVS after:\n", drm_crtc_index(crtc));
++		vc4_hvs_dump_state(dev);
+ 	}
+ }
  
- 	if (debug_dump_regs) {
- 		DRM_INFO("CRTC %d HVS after:\n", drm_crtc_index(crtc));
-@@ -456,6 +506,7 @@ static void vc4_crtc_handle_page_flip(struct vc4_crtc *vc4_crtc)
- 	if (vc4_crtc->event) {
+@@ -433,6 +676,11 @@ int vc4_enable_vblank(struct drm_device *dev, unsigned int crtc_id)
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_crtc *vc4_crtc = vc4->crtc[crtc_id];
+ 
++	if (vc4->firmware_kms) {
++		/* XXX: Can we mask the SMI interrupt? */
++		return 0;
++	}
++
+ 	CRTC_WRITE(PV_INTEN, PV_INT_VFP_START);
+ 
+ 	return 0;
+@@ -443,6 +691,11 @@ void vc4_disable_vblank(struct drm_device *dev, unsigned int crtc_id)
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct vc4_crtc *vc4_crtc = vc4->crtc[crtc_id];
+ 
++	if (vc4->firmware_kms) {
++		/* XXX: Can we mask the SMI interrupt? */
++		return;
++	}
++
+ 	CRTC_WRITE(PV_INTEN, 0);
+ }
+ 
+@@ -450,12 +703,17 @@ static void vc4_crtc_handle_page_flip(struct vc4_crtc *vc4_crtc)
+ {
+ 	struct drm_crtc *crtc = &vc4_crtc->base;
+ 	struct drm_device *dev = crtc->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct vc4_crtc_state *vc4_state = to_vc4_crtc_state(crtc->state);
++	u32 chan = vc4_crtc->channel;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&dev->event_lock, flags);
+-	if (vc4_crtc->event) {
++	if (vc4_crtc->event &&
++	    (vc4_state->mm.start == HVS_READ(SCALER_DISPLACTX(chan)))) {
  		drm_crtc_send_vblank_event(crtc, vc4_crtc->event);
  		vc4_crtc->event = NULL;
 +		drm_crtc_vblank_put(crtc);
  	}
  	spin_unlock_irqrestore(&dev->event_lock, flags);
  }
-@@ -476,16 +527,147 @@ static irqreturn_t vc4_crtc_irq_handler(int irq, void *data)
+@@ -467,6 +725,7 @@ static irqreturn_t vc4_crtc_irq_handler(int irq, void *data)
+ 	irqreturn_t ret = IRQ_NONE;
+ 
+ 	if (stat & PV_INT_VFP_START) {
++		vc4_crtc->t_vblank = ktime_get();
+ 		CRTC_WRITE(PV_INTSTAT, PV_INT_VFP_START);
+ 		drm_crtc_handle_vblank(&vc4_crtc->base);
+ 		vc4_crtc_handle_page_flip(vc4_crtc);
+@@ -476,22 +735,154 @@ static irqreturn_t vc4_crtc_irq_handler(int irq, void *data)
  	return ret;
  }
  
@@ -28342,7 +31076,7 @@ index 265064c..07662bd 100644
 +
 +	}
 +
-+	__drm_atomic_helper_crtc_destroy_state(crtc, state);
++	drm_atomic_helper_crtc_destroy_state(crtc, state);
 +}
 +
  static const struct drm_crtc_funcs vc4_crtc_funcs = {
@@ -28362,7 +31096,53 @@ index 265064c..07662bd 100644
  };
  
  static const struct drm_crtc_helper_funcs vc4_crtc_helper_funcs = {
-@@ -567,9 +749,9 @@ static int vc4_crtc_bind(struct device *dev, struct device *master, void *data)
+ 	.mode_set_nofb = vc4_crtc_mode_set_nofb,
+ 	.disable = vc4_crtc_disable,
+ 	.enable = vc4_crtc_enable,
++	.mode_fixup = vc4_crtc_mode_fixup,
+ 	.atomic_check = vc4_crtc_atomic_check,
+ 	.atomic_flush = vc4_crtc_atomic_flush,
+ };
+@@ -517,13 +908,13 @@ void vc4_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file)
+ }
+ 
+ static const struct vc4_crtc_data pv0_data = {
+-	.hvs_channel = 0,
++	.hvs_channel = 2,
+ 	.encoder0_type = VC4_ENCODER_TYPE_DSI0,
+ 	.encoder1_type = VC4_ENCODER_TYPE_DPI,
+ };
+ 
+ static const struct vc4_crtc_data pv1_data = {
+-	.hvs_channel = 2,
++	.hvs_channel = 0,
+ 	.encoder0_type = VC4_ENCODER_TYPE_DSI1,
+ 	.encoder1_type = VC4_ENCODER_TYPE_SMI,
+ };
+@@ -560,6 +951,22 @@ static void vc4_set_crtc_possible_masks(struct drm_device *drm,
+ 	}
+ }
+ 
++static void
++vc4_crtc_get_cob_allocation(struct vc4_crtc *vc4_crtc)
++{
++	struct drm_device *drm = vc4_crtc->base.dev;
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
++	u32 dispbase = HVS_READ(SCALER_DISPBASEX(vc4_crtc->channel));
++	/* Top/base are supposed to be 4-pixel aligned, but the
++	 * Raspberry Pi firmware fills the low bits (which are
++	 * presumably ignored).
++	 */
++	u32 top = VC4_GET_FIELD(dispbase, SCALER_DISPBASEX_TOP) & ~3;
++	u32 base = VC4_GET_FIELD(dispbase, SCALER_DISPBASEX_BASE) & ~3;
++
++	vc4_crtc->cob_size = top - base + 4;
++}
++
+ static int vc4_crtc_bind(struct device *dev, struct device *master, void *data)
+ {
+ 	struct platform_device *pdev = to_platform_device(dev);
+@@ -567,9 +974,9 @@ static int vc4_crtc_bind(struct device *dev, struct device *master, void *data)
  	struct vc4_dev *vc4 = to_vc4_dev(drm);
  	struct vc4_crtc *vc4_crtc;
  	struct drm_crtc *crtc;
@@ -28374,7 +31154,7 @@ index 265064c..07662bd 100644
  
  	vc4_crtc = devm_kzalloc(dev, sizeof(*vc4_crtc), GFP_KERNEL);
  	if (!vc4_crtc)
-@@ -598,38 +780,69 @@ static int vc4_crtc_bind(struct device *dev, struct device *master, void *data)
+@@ -598,38 +1005,71 @@ static int vc4_crtc_bind(struct device *dev, struct device *master, void *data)
  		goto err;
  	}
  
@@ -28424,6 +31204,8 @@ index 265064c..07662bd 100644
 +		cursor_plane->crtc = crtc;
 +		crtc->cursor = cursor_plane;
 +	}
++
++	vc4_crtc_get_cob_allocation(vc4_crtc);
  
  	CRTC_WRITE(PV_INTEN, 0);
  	CRTC_WRITE(PV_INTSTAT, PV_INT_VFP_START);
@@ -28459,16 +31241,18 @@ index 265064c..07662bd 100644
  	return ret;
  }
 diff --git a/drivers/gpu/drm/vc4/vc4_debugfs.c b/drivers/gpu/drm/vc4/vc4_debugfs.c
-index 4297b0a5..94f2154 100644
+index 4297b0a5..ac549dd 100644
 --- a/drivers/gpu/drm/vc4/vc4_debugfs.c
 +++ b/drivers/gpu/drm/vc4/vc4_debugfs.c
-@@ -16,11 +16,16 @@
+@@ -16,11 +16,18 @@
  #include "vc4_regs.h"
  
  static const struct drm_info_list vc4_debugfs_list[] = {
 +	{"bo_stats", vc4_bo_stats_debugfs, 0},
 +	{"dpi_regs", vc4_dpi_debugfs_regs, 0},
 +	{"gem_exec", vc4_gem_exec_debugfs, 0},
++	{"dsi0_regs", vc4_dsi_debugfs_regs, 0, (void *)(uintptr_t)0},
++	{"dsi1_regs", vc4_dsi_debugfs_regs, 0, (void *)(uintptr_t)1},
  	{"hdmi_regs", vc4_hdmi_debugfs_regs, 0},
  	{"hvs_regs", vc4_hvs_debugfs_regs, 0},
  	{"crtc0_regs", vc4_crtc_debugfs_regs, 0, (void *)(uintptr_t)0},
@@ -28481,10 +31265,10 @@ index 4297b0a5..94f2154 100644
  #define VC4_DEBUGFS_ENTRIES ARRAY_SIZE(vc4_debugfs_list)
 diff --git a/drivers/gpu/drm/vc4/vc4_dpi.c b/drivers/gpu/drm/vc4/vc4_dpi.c
 new file mode 100644
-index 0000000..86e4e52
+index 0000000..2a1472b
 --- /dev/null
 +++ b/drivers/gpu/drm/vc4/vc4_dpi.c
-@@ -0,0 +1,520 @@
+@@ -0,0 +1,523 @@
 +/*
 + * Copyright (C) 2016 Broadcom Limited
 + *
@@ -28723,14 +31507,12 @@ index 0000000..86e4e52
 +{
 +	struct drm_connector *connector = NULL;
 +	struct vc4_dpi_connector *dpi_connector;
-+	int ret = 0;
 +
 +	dpi_connector = devm_kzalloc(dev->dev, sizeof(*dpi_connector),
 +				     GFP_KERNEL);
-+	if (!dpi_connector) {
-+		ret = -ENOMEM;
-+		goto fail;
-+	}
++	if (!dpi_connector)
++		return ERR_PTR(-ENOMEM);
++
 +	connector = &dpi_connector->base;
 +
 +	dpi_connector->encoder = dpi->encoder;
@@ -28747,12 +31529,6 @@ index 0000000..86e4e52
 +	drm_mode_connector_attach_encoder(connector, dpi->encoder);
 +
 +	return connector;
-+
-+ fail:
-+	if (connector)
-+		vc4_dpi_connector_destroy(connector);
-+
-+	return ERR_PTR(ret);
 +}
 +
 +static const struct drm_encoder_funcs vc4_dpi_encoder_funcs = {
@@ -28844,9 +31620,20 @@ index 0000000..86e4e52
 +	}
 +}
 +
++static bool vc4_dpi_encoder_mode_fixup(struct drm_encoder *encoder,
++				       const struct drm_display_mode *mode,
++				       struct drm_display_mode *adjusted_mode)
++{
++	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
++		return false;
++
++	return true;
++}
++
 +static const struct drm_encoder_helper_funcs vc4_dpi_encoder_helper_funcs = {
 +	.disable = vc4_dpi_encoder_disable,
 +	.enable = vc4_dpi_encoder_enable,
++	.mode_fixup = vc4_dpi_encoder_mode_fixup,
 +};
 +
 +static const struct of_device_id vc4_dpi_dt_match[] = {
@@ -29006,21 +31793,100 @@ index 0000000..86e4e52
 +	},
 +};
 diff --git a/drivers/gpu/drm/vc4/vc4_drv.c b/drivers/gpu/drm/vc4/vc4_drv.c
-index d5db9e0..2854ba3 100644
+index d5db9e0..d87828a 100644
 --- a/drivers/gpu/drm/vc4/vc4_drv.c
 +++ b/drivers/gpu/drm/vc4/vc4_drv.c
-@@ -14,8 +14,10 @@
+@@ -9,13 +9,16 @@
+ 
+ #include <linux/clk.h>
+ #include <linux/component.h>
++#include <linux/debugfs.h>
+ #include <linux/device.h>
+ #include <linux/io.h>
  #include <linux/module.h>
  #include <linux/of_platform.h>
  #include <linux/platform_device.h>
-+#include <soc/bcm2835/raspberrypi-firmware.h>
++#include <linux/pm_runtime.h>
  #include "drm_fb_cma_helper.h"
  
 +#include "uapi/drm/vc4_drm.h"
  #include "vc4_drv.h"
  #include "vc4_regs.h"
  
-@@ -63,7 +65,7 @@ static const struct file_operations vc4_drm_fops = {
+@@ -44,10 +47,70 @@ void __iomem *vc4_ioremap_regs(struct platform_device *dev, int index)
+ 
+ static void vc4_drm_preclose(struct drm_device *dev, struct drm_file *file)
+ {
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	struct drm_crtc *crtc;
+ 
+-	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
+-		vc4_cancel_page_flip(crtc, file);
++	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
++		if (vc4->firmware_kms)
++			vc4_fkms_cancel_page_flip(crtc, file);
++		else
++			vc4_cancel_page_flip(crtc, file);
++	}
++}
++
++void vc4_dump_regs32(const struct debugfs_reg32 *regs, unsigned int num_regs,
++		     void __iomem *base, const char *prefix)
++{
++	unsigned int i;
++
++	for (i = 0; i < num_regs; i++) {
++		DRM_INFO("%s0x%04lx (%s): 0x%08x\n",
++			 prefix, regs[i].offset, regs[i].name,
++			 readl(base + regs[i].offset));
++	}
++}
++
++static int vc4_get_param_ioctl(struct drm_device *dev, void *data,
++			       struct drm_file *file_priv)
++{
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct drm_vc4_get_param *args = data;
++	int ret;
++
++	if (args->pad != 0)
++		return -EINVAL;
++
++	switch (args->param) {
++	case DRM_VC4_PARAM_V3D_IDENT0:
++		ret = pm_runtime_get_sync(&vc4->v3d->pdev->dev);
++		if (ret < 0)
++			return ret;
++		args->value = V3D_READ(V3D_IDENT0);
++		pm_runtime_put(&vc4->v3d->pdev->dev);
++		break;
++	case DRM_VC4_PARAM_V3D_IDENT1:
++		ret = pm_runtime_get_sync(&vc4->v3d->pdev->dev);
++		if (ret < 0)
++			return ret;
++		args->value = V3D_READ(V3D_IDENT1);
++		pm_runtime_put(&vc4->v3d->pdev->dev);
++		break;
++	case DRM_VC4_PARAM_V3D_IDENT2:
++		ret = pm_runtime_get_sync(&vc4->v3d->pdev->dev);
++		if (ret < 0)
++			return ret;
++		args->value = V3D_READ(V3D_IDENT2);
++		pm_runtime_put(&vc4->v3d->pdev->dev);
++		break;
++	case DRM_VC4_PARAM_SUPPORTS_BRANCHES:
++		args->value = true;
++		break;
++	default:
++		DRM_DEBUG("Unknown parameter %d\n", args->param);
++		return -EINVAL;
++	}
++
++	return 0;
+ }
+ 
+ static void vc4_lastclose(struct drm_device *dev)
+@@ -63,7 +126,7 @@ static const struct file_operations vc4_drm_fops = {
  	.open = drm_open,
  	.release = drm_release,
  	.unlocked_ioctl = drm_ioctl,
@@ -29029,18 +31895,19 @@ index d5db9e0..2854ba3 100644
  	.poll = drm_poll,
  	.read = drm_read,
  #ifdef CONFIG_COMPAT
-@@ -73,37 +75,53 @@ static const struct file_operations vc4_drm_fops = {
+@@ -73,37 +136,56 @@ static const struct file_operations vc4_drm_fops = {
  };
  
  static const struct drm_ioctl_desc vc4_drm_ioctls[] = {
-+	DRM_IOCTL_DEF_DRV(VC4_SUBMIT_CL, vc4_submit_cl_ioctl, 0),
-+	DRM_IOCTL_DEF_DRV(VC4_WAIT_SEQNO, vc4_wait_seqno_ioctl, 0),
-+	DRM_IOCTL_DEF_DRV(VC4_WAIT_BO, vc4_wait_bo_ioctl, 0),
-+	DRM_IOCTL_DEF_DRV(VC4_CREATE_BO, vc4_create_bo_ioctl, 0),
-+	DRM_IOCTL_DEF_DRV(VC4_MMAP_BO, vc4_mmap_bo_ioctl, 0),
-+	DRM_IOCTL_DEF_DRV(VC4_CREATE_SHADER_BO, vc4_create_shader_bo_ioctl, 0),
++	DRM_IOCTL_DEF_DRV(VC4_SUBMIT_CL, vc4_submit_cl_ioctl, DRM_RENDER_ALLOW),
++	DRM_IOCTL_DEF_DRV(VC4_WAIT_SEQNO, vc4_wait_seqno_ioctl, DRM_RENDER_ALLOW),
++	DRM_IOCTL_DEF_DRV(VC4_WAIT_BO, vc4_wait_bo_ioctl, DRM_RENDER_ALLOW),
++	DRM_IOCTL_DEF_DRV(VC4_CREATE_BO, vc4_create_bo_ioctl, DRM_RENDER_ALLOW),
++	DRM_IOCTL_DEF_DRV(VC4_MMAP_BO, vc4_mmap_bo_ioctl, DRM_RENDER_ALLOW),
++	DRM_IOCTL_DEF_DRV(VC4_CREATE_SHADER_BO, vc4_create_shader_bo_ioctl, DRM_RENDER_ALLOW),
 +	DRM_IOCTL_DEF_DRV(VC4_GET_HANG_STATE, vc4_get_hang_state_ioctl,
 +			  DRM_ROOT_ONLY),
++	DRM_IOCTL_DEF_DRV(VC4_GET_PARAM, vc4_get_param_ioctl, DRM_RENDER_ALLOW),
  };
  
  static struct drm_driver vc4_drm_driver = {
@@ -29062,6 +31929,8 @@ index d5db9e0..2854ba3 100644
  	.disable_vblank = vc4_disable_vblank,
 -	.get_vblank_counter = drm_vblank_count,
 +	.get_vblank_counter = drm_vblank_no_hw_counter,
++	.get_scanout_position = vc4_crtc_get_scanoutpos,
++	.get_vblank_timestamp = vc4_crtc_get_vblank_timestamp,
  
  #if defined(CONFIG_DEBUG_FS)
  	.debugfs_init = vc4_debugfs_init,
@@ -29088,7 +31957,7 @@ index d5db9e0..2854ba3 100644
  
  	.dumb_create = vc4_dumb_create,
  	.dumb_map_offset = drm_gem_cma_dumb_map_offset,
-@@ -147,12 +165,31 @@ static void vc4_match_add_drivers(struct device *dev,
+@@ -147,6 +229,24 @@ static void vc4_match_add_drivers(struct device *dev,
  	}
  }
  
@@ -29113,40 +31982,18 @@ index d5db9e0..2854ba3 100644
  static int vc4_drm_bind(struct device *dev)
  {
  	struct platform_device *pdev = to_platform_device(dev);
- 	struct drm_device *drm;
- 	struct drm_connector *connector;
- 	struct vc4_dev *vc4;
-+	struct device_node *firmware_node;
- 	int ret = 0;
- 
- 	dev->coherent_dma_mask = DMA_BIT_MASK(32);
-@@ -161,6 +198,14 @@ static int vc4_drm_bind(struct device *dev)
- 	if (!vc4)
- 		return -ENOMEM;
- 
-+	firmware_node = of_parse_phandle(dev->of_node, "firmware", 0);
-+	vc4->firmware = rpi_firmware_get(firmware_node);
-+	if (!vc4->firmware) {
-+		DRM_DEBUG("Failed to get Raspberry Pi firmware reference.\n");
-+		return -EPROBE_DEFER;
-+	}
-+	of_node_put(firmware_node);
-+
- 	drm = drm_dev_alloc(&vc4_drm_driver, dev);
- 	if (!drm)
- 		return -ENOMEM;
-@@ -170,13 +215,19 @@ static int vc4_drm_bind(struct device *dev)
+@@ -170,13 +270,17 @@ static int vc4_drm_bind(struct device *dev)
  
  	drm_dev_set_unique(drm, dev_name(dev));
  
 +	vc4_bo_cache_init(drm);
 +
  	drm_mode_config_init(drm);
- 	if (ret)
- 		goto unref;
- 
-+	vc4_gem_init(drm);
+-	if (ret)
+-		goto unref;
 +
++	vc4_gem_init(drm);
+ 
  	ret = component_bind_all(dev, drm);
  	if (ret)
 -		goto unref;
@@ -29156,42 +32003,57 @@ index d5db9e0..2854ba3 100644
  
  	ret = drm_dev_register(drm, 0);
  	if (ret < 0)
-@@ -200,8 +251,11 @@ unregister:
+@@ -200,8 +304,10 @@ unregister:
  	drm_dev_unregister(drm);
  unbind_all:
  	component_unbind_all(dev, drm);
+-unref:
 +gem_destroy:
 +	vc4_gem_destroy(drm);
- unref:
  	drm_dev_unref(drm);
 +	vc4_bo_cache_destroy(drm);
  	return ret;
  }
  
-@@ -226,8 +280,10 @@ static const struct component_master_ops vc4_drm_ops = {
+@@ -226,8 +332,12 @@ static const struct component_master_ops vc4_drm_ops = {
  
  static struct platform_driver *const component_drivers[] = {
  	&vc4_hdmi_driver,
+-	&vc4_crtc_driver,
 +	&vc4_dpi_driver,
- 	&vc4_crtc_driver,
++	&vc4_dsi_driver,
  	&vc4_hvs_driver,
++	&vc4_crtc_driver,
++	&vc4_firmware_kms_driver,
 +	&vc4_v3d_driver,
  };
  
  static int vc4_platform_drm_probe(struct platform_device *pdev)
 diff --git a/drivers/gpu/drm/vc4/vc4_drv.h b/drivers/gpu/drm/vc4/vc4_drv.h
-index fd8319f..8b381d1 100644
+index fd8319f..3b4456b 100644
 --- a/drivers/gpu/drm/vc4/vc4_drv.h
 +++ b/drivers/gpu/drm/vc4/vc4_drv.h
-@@ -15,8 +15,98 @@ struct vc4_dev {
+@@ -9,14 +9,115 @@
+ #include "drmP.h"
+ #include "drm_gem_cma_helper.h"
+ 
++struct debugfs_reg32;
++
+ struct vc4_dev {
+ 	struct drm_device *dev;
+ 
++	bool firmware_kms;
++	struct rpi_firmware *firmware;
++
  	struct vc4_hdmi *hdmi;
  	struct vc4_hvs *hvs;
  	struct vc4_crtc *crtc[3];
 +	struct vc4_v3d *v3d;
 +	struct vc4_dpi *dpi;
++	struct vc4_dsi *dsi0;
++	struct vc4_dsi *dsi1;
  
  	struct drm_fbdev_cma *fbdev;
-+	struct rpi_firmware *firmware;
 +
 +	struct vc4_hang_state *hang_state;
 +
@@ -29273,6 +32135,11 @@ index fd8319f..8b381d1 100644
 +	struct vc4_bo *overflow_mem;
 +	struct work_struct overflow_mem_work;
 +
++	int power_refcount;
++
++	/* Mutex controlling the power refcount. */
++	struct mutex power_lock;
++
 +	struct {
 +		struct timer_list timer;
 +		struct work_struct reset_work;
@@ -29282,14 +32149,21 @@ index fd8319f..8b381d1 100644
  };
  
  static inline struct vc4_dev *
-@@ -27,6 +117,25 @@ to_vc4_dev(struct drm_device *dev)
+@@ -27,6 +128,32 @@ to_vc4_dev(struct drm_device *dev)
  
  struct vc4_bo {
  	struct drm_gem_cma_object base;
 +
-+	/* seqno of the last job to render to this BO. */
++	/* seqno of the last job to render using this BO. */
 +	uint64_t seqno;
 +
++	/* seqno of the last job to use the RCL to write to this BO.
++	 *
++	 * Note that this doesn't include binner overflow memory
++	 * writes.
++	 */
++	uint64_t write_seqno;
++
 +	/* List entry for the BO's position in either
 +	 * vc4_exec_info->unref_list or vc4_dev->bo_cache.time_list
 +	 */
@@ -29308,7 +32182,7 @@ index fd8319f..8b381d1 100644
  };
  
  static inline struct vc4_bo *
-@@ -35,10 +144,31 @@ to_vc4_bo(struct drm_gem_object *bo)
+@@ -35,10 +162,32 @@ to_vc4_bo(struct drm_gem_object *bo)
  	return (struct vc4_bo *)bo;
  }
  
@@ -29319,6 +32193,7 @@ index fd8319f..8b381d1 100644
 +};
 +
 +struct vc4_v3d {
++	struct vc4_dev *vc4;
 +	struct platform_device *pdev;
 +	void __iomem *regs;
 +};
@@ -29341,7 +32216,16 @@ index fd8319f..8b381d1 100644
  };
  
  struct vc4_plane {
-@@ -72,9 +202,156 @@ to_vc4_encoder(struct drm_encoder *encoder)
+@@ -60,6 +209,8 @@ enum vc4_encoder_type {
+ 	VC4_ENCODER_TYPE_DPI,
+ };
+ 
++#define VC4_DSI_USE_FIRMWARE_SETUP true
++
+ struct vc4_encoder {
+ 	struct drm_encoder base;
+ 	enum vc4_encoder_type type;
+@@ -72,9 +223,180 @@ to_vc4_encoder(struct drm_encoder *encoder)
  	return container_of(encoder, struct vc4_encoder, base);
  }
  
@@ -29350,10 +32234,15 @@ index fd8319f..8b381d1 100644
  #define HVS_READ(offset) readl(vc4->hvs->regs + offset)
  #define HVS_WRITE(offset, val) writel(val, vc4->hvs->regs + offset)
  
++#define VC4_DEBUG_REG(reg) { .name = #reg, .offset = reg }
++
 +struct vc4_exec_info {
 +	/* Sequence number for this bin/render job. */
 +	uint64_t seqno;
 +
++	/* Latest write_seqno of any BO that binning depends on. */
++	uint64_t bin_dep_seqno;
++
 +	/* Last current addresses the hardware was processing when the
 +	 * hangcheck timer checked on us.
 +	 */
@@ -29368,6 +32257,13 @@ index fd8319f..8b381d1 100644
 +	struct drm_gem_cma_object **bo;
 +	uint32_t bo_count;
 +
++	/* List of BOs that are being written by the RCL.  Other than
++	 * the binner temporary storage, this is all the BOs written
++	 * by the job.
++	 */
++	struct drm_gem_cma_object *rcl_write_bo[4];
++	uint32_t rcl_write_bo_count;
++
 +	/* Pointers for our position in vc4->job_list */
 +	struct list_head head;
 +
@@ -29459,6 +32355,15 @@ index fd8319f..8b381d1 100644
 +				struct vc4_exec_info, head);
 +}
 +
++static inline struct vc4_exec_info *
++vc4_last_render_job(struct vc4_dev *vc4)
++{
++	if (list_empty(&vc4->render_job_list))
++		return NULL;
++	return list_last_entry(&vc4->render_job_list,
++			       struct vc4_exec_info, head);
++}
++
 +/**
 + * struct vc4_texture_sample_info - saves the offsets into the UBO for texture
 + * setup parameters.
@@ -29493,12 +32398,15 @@ index fd8319f..8b381d1 100644
 +	uint32_t uniforms_src_size;
 +	uint32_t num_texture_samples;
 +	struct vc4_texture_sample_info *texture_samples;
++
++	uint32_t num_uniform_addr_offsets;
++	uint32_t *uniform_addr_offsets;
 +};
 +
  /**
   * _wait_for - magic (register) wait macro
   *
-@@ -104,13 +381,29 @@ to_vc4_encoder(struct drm_encoder *encoder)
+@@ -104,13 +426,29 @@ to_vc4_encoder(struct drm_encoder *encoder)
  #define wait_for(COND, MS) _wait_for(COND, MS, 1)
  
  /* vc4_bo.c */
@@ -29529,14 +32437,39 @@ index fd8319f..8b381d1 100644
  
  /* vc4_crtc.c */
  extern struct platform_driver vc4_crtc_driver;
-@@ -126,10 +419,41 @@ void vc4_debugfs_cleanup(struct drm_minor *minor);
+@@ -118,6 +456,13 @@ int vc4_enable_vblank(struct drm_device *dev, unsigned int crtc_id);
+ void vc4_disable_vblank(struct drm_device *dev, unsigned int crtc_id);
+ void vc4_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file);
+ int vc4_crtc_debugfs_regs(struct seq_file *m, void *arg);
++int vc4_crtc_get_scanoutpos(struct drm_device *dev, unsigned int crtc_id,
++			    unsigned int flags, int *vpos, int *hpos,
++			    ktime_t *stime, ktime_t *etime,
++			    const struct drm_display_mode *mode);
++int vc4_crtc_get_vblank_timestamp(struct drm_device *dev, unsigned int crtc_id,
++				  int *max_error, struct timeval *vblank_time,
++				  unsigned flags);
+ 
+ /* vc4_debugfs.c */
+ int vc4_debugfs_init(struct drm_minor *minor);
+@@ -125,11 +470,52 @@ void vc4_debugfs_cleanup(struct drm_minor *minor);
+ 
  /* vc4_drv.c */
  void __iomem *vc4_ioremap_regs(struct platform_device *dev, int index);
- 
++void vc4_dump_regs32(const struct debugfs_reg32 *reg, unsigned int num_regs,
++		     void __iomem *base, const char *prefix);
++
 +/* vc4_dpi.c */
 +extern struct platform_driver vc4_dpi_driver;
 +int vc4_dpi_debugfs_regs(struct seq_file *m, void *unused);
 +
++/* vc4_dsi.c */
++extern struct platform_driver vc4_dsi_driver;
++int vc4_dsi_debugfs_regs(struct seq_file *m, void *unused);
++
++/* vc4_firmware_kms.c */
++extern struct platform_driver vc4_firmware_kms_driver;
++void vc4_fkms_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file);
++
 +/* vc4_gem.c */
 +void vc4_gem_init(struct drm_device *dev);
 +void vc4_gem_destroy(struct drm_device *dev);
@@ -29556,7 +32489,7 @@ index fd8319f..8b381d1 100644
 +		       struct vc4_seqno_cb *cb, uint64_t seqno,
 +		       void (*func)(struct vc4_seqno_cb *cb));
 +int vc4_gem_exec_debugfs(struct seq_file *m, void *arg);
-+
+ 
  /* vc4_hdmi.c */
  extern struct platform_driver vc4_hdmi_driver;
  int vc4_hdmi_debugfs_regs(struct seq_file *m, void *unused);
@@ -29571,7 +32504,7 @@ index fd8319f..8b381d1 100644
  /* vc4_hvs.c */
  extern struct platform_driver vc4_hvs_driver;
  void vc4_hvs_dump_state(struct drm_device *dev);
-@@ -143,3 +467,35 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
+@@ -143,3 +529,34 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
  				 enum drm_plane_type type);
  u32 vc4_plane_write_dlist(struct drm_plane *plane, u32 __iomem *dlist);
  u32 vc4_plane_dlist_size(struct drm_plane_state *state);
@@ -29582,7 +32515,6 @@ index fd8319f..8b381d1 100644
 +extern struct platform_driver vc4_v3d_driver;
 +int vc4_v3d_debugfs_ident(struct seq_file *m, void *unused);
 +int vc4_v3d_debugfs_regs(struct seq_file *m, void *unused);
-+int vc4_v3d_set_power(struct vc4_dev *vc4, bool on);
 +
 +/* vc4_validate.c */
 +int
@@ -29607,12 +32539,2421 @@ index fd8319f..8b381d1 100644
 +/* vc4_validate_shader.c */
 +struct vc4_validated_shader_info *
 +vc4_validate_shader(struct drm_gem_cma_object *shader_obj);
+diff --git a/drivers/gpu/drm/vc4/vc4_dsi.c b/drivers/gpu/drm/vc4/vc4_dsi.c
+new file mode 100644
+index 0000000..2bce6af
+--- /dev/null
++++ b/drivers/gpu/drm/vc4/vc4_dsi.c
+@@ -0,0 +1,1737 @@
++ /*
++ * Copyright (C) 2016 Broadcom Limited
++ *
++ * This program is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 as published by
++ * the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
++ * more details.
++ *
++ * You should have received a copy of the GNU General Public License along with
++ * this program.  If not, see <http://www.gnu.org/licenses/>.
++ */
++
++/**
++ * DOC: VC4 DSI0 module
++ */
++
++#include "drm_atomic_helper.h"
++#include "drm_crtc_helper.h"
++#include "drm_edid.h"
++#include "drm_mipi_dsi.h"
++#include "drm_panel.h"
++#include "linux/clk.h"
++#include "linux/clk-provider.h"
++#include "linux/completion.h"
++#include "linux/component.h"
++#include "linux/debugfs.h"
++#include "linux/dmaengine.h"
++#include "linux/i2c.h"
++#include "linux/of_address.h"
++#include "linux/of_gpio.h"
++#include "linux/of_platform.h"
++#include "vc4_drv.h"
++#include "vc4_regs.h"
++
++#define DSI_CMD_FIFO_DEPTH  16
++#define DSI_PIX_FIFO_DEPTH 256
++#define DSI_PIX_FIFO_WIDTH   4
++
++#define DSI0_CTRL		0x00
++
++/* Command packet control. */
++#define DSI0_TXPKT1C		0x04 /* AKA PKTC */
++#define DSI1_TXPKT1C		0x04
++# define DSI_TXPKT1C_TRIG_CMD_MASK	VC4_MASK(31, 24)
++# define DSI_TXPKT1C_TRIG_CMD_SHIFT	24
++# define DSI_TXPKT1C_CMD_REPEAT_MASK	VC4_MASK(23, 10)
++# define DSI_TXPKT1C_CMD_REPEAT_SHIFT	10
++
++# define DSI_TXPKT1C_DISPLAY_NO_MASK	VC4_MASK(9, 8)
++# define DSI_TXPKT1C_DISPLAY_NO_SHIFT	8
++/* Short, trigger, BTA, or a long packet that fits all in CMDFIFO. */
++# define DSI_TXPKT1C_DISPLAY_NO_SHORT		0
++/* Primary display where cmdfifo provides part of the payload and
++ * pixelvalve the rest.
++ */
++# define DSI_TXPKT1C_DISPLAY_NO_PRIMARY		1
++/* Secondary display where cmdfifo provides part of the payload and
++ * pixfifo the rest.
++ */
++# define DSI_TXPKT1C_DISPLAY_NO_SECONDARY	2
++
++# define DSI_TXPKT1C_CMD_TX_TIME_MASK	VC4_MASK(7, 6)
++# define DSI_TXPKT1C_CMD_TX_TIME_SHIFT	6
++# define DSI_TXPKT1C_CMD_CTRL_MASK	VC4_MASK(5, 4)
++# define DSI_TXPKT1C_CMD_CTRL_SHIFT	4
++/* Command only.  Uses TXPKT1H and DISPLAY_NO */
++# define DSI_TXPKT1C_CMD_CTRL_TX	0
++/* Command with BTA for either ack or read data. */
++# define DSI_TXPKT1C_CMD_CTRL_RX	1
++/* Trigger according to TRIG_CMD */
++# define DSI_TXPKT1C_CMD_CTRL_TRIG	2
++/* BTA alone for getting error status after a command, or a TE trigger
++ * without a previous command.
++ */
++# define DSI_TXPKT1C_CMD_CTRL_BTA	3
++
++# define DSI_TXPKT1C_CMD_MODE_LP	BIT(3)
++# define DSI_TXPKT1C_CMD_TYPE_LONG	BIT(2)
++# define DSI_TXPKT1C_CMD_TE_EN		BIT(1)
++# define DSI_TXPKT1C_CMD_EN		BIT(0)
++
++/* Command packet header. */
++#define DSI0_TXPKT1H		0x08 /* AKA PKTH */
++#define DSI1_TXPKT1H		0x08
++# define DSI_TXPKT1H_BC_CMDFIFO_MASK	VC4_MASK(31, 24)
++# define DSI_TXPKT1H_BC_CMDFIFO_SHIFT	24
++# define DSI_TXPKT1H_BC_PARAM_MASK	VC4_MASK(23, 8)
++# define DSI_TXPKT1H_BC_PARAM_SHIFT	8
++# define DSI_TXPKT1H_BC_DT_MASK		VC4_MASK(7, 0)
++# define DSI_TXPKT1H_BC_DT_SHIFT	0
++
++#define DSI0_RXPKT1H		0x0c /* AKA RX1_PKTH */
++#define DSI1_RXPKT1H		0x14
++# define DSI_RXPKT1H_CRC_ERR		BIT(31)
++# define DSI_RXPKT1H_DET_ERR		BIT(30)
++# define DSI_RXPKT1H_ECC_ERR		BIT(29)
++# define DSI_RXPKT1H_COR_ERR		BIT(28)
++# define DSI_RXPKT1H_INCOMP_PKT		BIT(25)
++# define DSI_RXPKT1H_PKT_TYPE_LONG	BIT(24)
++/* Byte count if DSI_RXPKT1H_PKT_TYPE_LONG */
++# define DSI_RXPKT1H_BC_PARAM_MASK	VC4_MASK(23, 8)
++# define DSI_RXPKT1H_BC_PARAM_SHIFT	8
++/* Short return bytes if !DSI_RXPKT1H_PKT_TYPE_LONG */
++# define DSI_RXPKT1H_SHORT_1_MASK	VC4_MASK(23, 16)
++# define DSI_RXPKT1H_SHORT_1_SHIFT	16
++# define DSI_RXPKT1H_SHORT_0_MASK	VC4_MASK(15, 8)
++# define DSI_RXPKT1H_SHORT_0_SHIFT	8
++# define DSI_RXPKT1H_DT_LP_CMD_MASK	VC4_MASK(7, 0)
++# define DSI_RXPKT1H_DT_LP_CMD_SHIFT	0
++
++#define DSI0_RXPKT2H		0x10 /* AKA RX2_PKTH */
++#define DSI1_RXPKT2H		0x18
++# define DSI_RXPKT1H_DET_ERR		BIT(30)
++# define DSI_RXPKT1H_ECC_ERR		BIT(29)
++# define DSI_RXPKT1H_COR_ERR		BIT(28)
++# define DSI_RXPKT1H_INCOMP_PKT		BIT(25)
++# define DSI_RXPKT1H_BC_PARAM_MASK	VC4_MASK(23, 8)
++# define DSI_RXPKT1H_BC_PARAM_SHIFT	8
++# define DSI_RXPKT1H_DT_MASK		VC4_MASK(7, 0)
++# define DSI_RXPKT1H_DT_SHIFT		0
++
++#define DSI0_TXPKT_CMD_FIFO	0x14 /* AKA CMD_DATAF */
++#define DSI1_TXPKT_CMD_FIFO	0x1c
++
++#define DSI0_DISP0_CTRL		0x18
++# define DSI_DISP0_PIX_CLK_DIV_MASK	VC4_MASK(21, 13)
++# define DSI_DISP0_PIX_CLK_DIV_SHIFT	13
++# define DSI_DISP0_LP_STOP_CTRL_MASK	VC4_MASK(12, 11)
++# define DSI_DISP0_LP_STOP_CTRL_SHIFT	11
++# define DSI_DISP0_LP_STOP_DISABLE	0
++# define DSI_DISP0_LP_STOP_PERLINE	1
++# define DSI_DISP0_LP_STOP_PERFRAME	2
++
++/* Transmit RGB pixels and null packets only during HACTIVE, instead
++ * of going to LP-STOP.
++ */
++# define DSI_DISP_HACTIVE_NULL		BIT(10)
++/* Transmit blanking packet only during vblank, instead of allowing LP-STOP. */
++# define DSI_DISP_VBLP_CTRL		BIT(9)
++/* Transmit blanking packet only during HFP, instead of allowing LP-STOP. */
++# define DSI_DISP_HFP_CTRL		BIT(8)
++/* Transmit blanking packet only during HBP, instead of allowing LP-STOP. */
++# define DSI_DISP_HBP_CTRL		BIT(7)
++# define DSI_DISP0_CHANNEL_MASK		VC4_MASK(6, 5)
++# define DSI_DISP0_CHANNEL_SHIFT	5
++/* Enables and end events for HSYNC/VSYNC, not just start events. */
++# define DSI_DISP0_ST_END		BIT(4)
++# define DSI_DISP0_PFORMAT_MASK		VC4_MASK(3, 2)
++# define DSI_DISP0_PFORMAT_SHIFT	2
++# define DSI_PFORMAT_RGB565		0
++# define DSI_PFORMAT_RGB666_PACKED	1
++# define DSI_PFORMAT_RGB666		2
++# define DSI_PFORMAT_RGB888		3
++/* Default is VIDEO mode. */
++# define DSI_DISP0_COMMAND_MODE		BIT(1)
++# define DSI_DISP0_ENABLE		BIT(0)
++
++#define DSI0_DISP1_CTRL		0x1c
++#define DSI1_DISP1_CTRL		0x2c
++/* Format of the data written to TXPKT_PIX_FIFO. */
++# define DSI_DISP1_PFORMAT_MASK		VC4_MASK(2, 1)
++# define DSI_DISP1_PFORMAT_SHIFT	1
++# define DSI_DISP1_PFORMAT_16BIT	0
++# define DSI_DISP1_PFORMAT_24BIT	1
++# define DSI_DISP1_PFORMAT_32BIT_LE	2
++# define DSI_DISP1_PFORMAT_32BIT_BE	3
++
++/* DISP1 is always command mode. */
++# define DSI_DISP1_ENABLE		BIT(0)
++
++#define DSI0_TXPKT_PIX_FIFO		0x20 /* AKA PIX_FIFO */
++
++#define DSI0_INT_STAT		0x24
++#define DSI0_INT_EN		0x28
++# define DSI1_INT_PHY_D3_ULPS		BIT(30)
++# define DSI1_INT_PHY_D3_STOP		BIT(29)
++# define DSI1_INT_PHY_D2_ULPS		BIT(28)
++# define DSI1_INT_PHY_D2_STOP		BIT(27)
++# define DSI1_INT_PHY_D1_ULPS		BIT(26)
++# define DSI1_INT_PHY_D1_STOP		BIT(25)
++# define DSI1_INT_PHY_D0_ULPS		BIT(24)
++# define DSI1_INT_PHY_D0_STOP		BIT(23)
++# define DSI1_INT_FIFO_ERR		BIT(22)
++# define DSI1_INT_PHY_DIR_RTF		BIT(21)
++# define DSI1_INT_PHY_RXLPDT		BIT(20)
++# define DSI1_INT_PHY_RXTRIG		BIT(19)
++# define DSI1_INT_PHY_D0_LPDT		BIT(18)
++# define DSI1_INT_PHY_DIR_FTR		BIT(17)
++
++/* Signaled when the clock lane enters the given state. */
++# define DSI1_INT_PHY_CLOCK_ULPS	BIT(16)
++# define DSI1_INT_PHY_CLOCK_HS		BIT(15)
++# define DSI1_INT_PHY_CLOCK_STOP	BIT(14)
++
++/* Signaled on timeouts */
++# define DSI1_INT_PR_TO			BIT(13)
++# define DSI1_INT_TA_TO			BIT(12)
++# define DSI1_INT_LPRX_TO		BIT(11)
++# define DSI1_INT_HSTX_TO		BIT(10)
++
++/* Contention on a line when trying to drive the line low */
++# define DSI1_INT_ERR_CONT_LP1		BIT(9)
++# define DSI1_INT_ERR_CONT_LP0		BIT(8)
++
++/* Control error: incorrect line state sequence on data lane 0. */
++# define DSI1_INT_ERR_CONTROL		BIT(7)
++/* LPDT synchronization error (bits received not a multiple of 8. */
++
++# define DSI1_INT_ERR_SYNC_ESC		BIT(6)
++/* Signaled after receiving an error packet from the display in
++ * response to a read.
++ */
++# define DSI1_INT_RXPKT2		BIT(5)
++/* Signaled after receiving a packet.  The header and optional short
++ * response will be in RXPKT1H, and a long response will be in the
++ * RXPKT_FIFO.
++ */
++# define DSI1_INT_RXPKT1		BIT(4)
++# define DSI1_INT_TXPKT2_DONE		BIT(3)
++# define DSI1_INT_TXPKT2_END		BIT(2)
++/* Signaled after all repeats of TXPKT1 are transferred. */
++# define DSI1_INT_TXPKT1_DONE		BIT(1)
++/* Signaled after each TXPKT1 repeat is scheduled. */
++# define DSI1_INT_TXPKT1_END		BIT(0)
++
++#define DSI1_INTERRUPTS_ALWAYS_ENABLED	(DSI1_INT_ERR_SYNC_ESC | \
++					 DSI1_INT_ERR_CONTROL |	 \
++					 DSI1_INT_ERR_CONT_LP0 | \
++					 DSI1_INT_ERR_CONT_LP1 | \
++					 DSI1_INT_HSTX_TO |	 \
++					 DSI1_INT_LPRX_TO |	 \
++					 DSI1_INT_TA_TO |	 \
++					 DSI1_INT_PR_TO)
++
++#define DSI0_STAT		0x2c
++#define DSI0_HSTX_TO_CNT	0x30
++#define DSI0_LPRX_TO_CNT	0x34
++#define DSI0_TA_TO_CNT		0x38
++#define DSI0_PR_TO_CNT		0x3c
++#define DSI0_PHYC		0x40
++# define DSI1_PHYC_ESC_CLK_LPDT_MASK	VC4_MASK(25, 20)
++# define DSI1_PHYC_ESC_CLK_LPDT_SHIFT	20
++# define DSI1_PHYC_HS_CLK_CONTINUOUS	BIT(18)
++# define DSI1_PHYC_CLANE_ULPS		BIT(17)
++# define DSI0_PHYC_ESC_CLK_LPDT_MASK	VC4_MASK(17, 12)
++# define DSI0_PHYC_ESC_CLK_LPDT_SHIFT	12
++# define DSI1_PHYC_CLANE_ENABLE		BIT(16)
++# define DSI_PHYC_DLANE3_ULPS		BIT(13)
++# define DSI_PHYC_DLANE3_ENABLE		BIT(12)
++# define DSI0_PHYC_HS_CLK_CONTINUOUS	BIT(10)
++# define DSI0_PHYC_CLANE_ULPS		BIT(9)
++# define DSI_PHYC_DLANE2_ULPS		BIT(9)
++# define DSI0_PHYC_CLANE_ENABLE		BIT(8)
++# define DSI_PHYC_DLANE2_ENABLE		BIT(8)
++# define DSI_PHYC_DLANE1_ULPS		BIT(5)
++# define DSI_PHYC_DLANE1_ENABLE		BIT(4)
++# define DSI_PHYC_DLANE0_FORCE_STOP	BIT(2)
++# define DSI_PHYC_DLANE0_ULPS		BIT(1)
++# define DSI_PHYC_DLANE0_ENABLE		BIT(0)
++
++#define DSI0_HS_CLT0		0x44
++#define DSI0_HS_CLT1		0x48
++#define DSI0_HS_CLT2		0x4c
++#define DSI0_HS_DLT3		0x50
++#define DSI0_HS_DLT4		0x54
++#define DSI0_HS_DLT5		0x58
++#define DSI0_HS_DLT6		0x5c
++#define DSI0_HS_DLT7		0x60
++
++#define DSI0_PHY_AFEC0		0x64
++# define DSI0_PHY_AFEC0_DDR2CLK_EN		BIT(26)
++# define DSI0_PHY_AFEC0_DDRCLK_EN		BIT(25)
++# define DSI0_PHY_AFEC0_LATCH_ULPS		BIT(24)
++# define DSI1_PHY_AFEC0_IDR_DLANE3_MASK		VC4_MASK(31, 29)
++# define DSI1_PHY_AFEC0_IDR_DLANE3_SHIFT	29
++# define DSI1_PHY_AFEC0_IDR_DLANE2_MASK		VC4_MASK(28, 26)
++# define DSI1_PHY_AFEC0_IDR_DLANE2_SHIFT	26
++# define DSI1_PHY_AFEC0_IDR_DLANE1_MASK		VC4_MASK(27, 23)
++# define DSI1_PHY_AFEC0_IDR_DLANE1_SHIFT	23
++# define DSI1_PHY_AFEC0_IDR_DLANE0_MASK		VC4_MASK(22, 20)
++# define DSI1_PHY_AFEC0_IDR_DLANE0_SHIFT	20
++# define DSI1_PHY_AFEC0_IDR_CLANE_MASK		VC4_MASK(19, 17)
++# define DSI1_PHY_AFEC0_IDR_CLANE_SHIFT		17
++# define DSI0_PHY_AFEC0_ACTRL_DLANE1_MASK	VC4_MASK(23, 20)
++# define DSI0_PHY_AFEC0_ACTRL_DLANE1_SHIFT	20
++# define DSI0_PHY_AFEC0_ACTRL_DLANE0_MASK	VC4_MASK(19, 16)
++# define DSI0_PHY_AFEC0_ACTRL_DLANE0_SHIFT	16
++# define DSI0_PHY_AFEC0_ACTRL_CLANE_MASK	VC4_MASK(15, 12)
++# define DSI0_PHY_AFEC0_ACTRL_CLANE_SHIFT	12
++# define DSI1_PHY_AFEC0_DDR2CLK_EN		BIT(16)
++# define DSI1_PHY_AFEC0_DDRCLK_EN		BIT(15)
++# define DSI1_PHY_AFEC0_LATCH_ULPS		BIT(14)
++# define DSI1_PHY_AFEC0_RESET			BIT(13)
++# define DSI1_PHY_AFEC0_PD			BIT(12)
++# define DSI0_PHY_AFEC0_RESET			BIT(11)
++# define DSI1_PHY_AFEC0_PD_BG			BIT(11)
++# define DSI0_PHY_AFEC0_PD			BIT(10)
++# define DSI1_PHY_AFEC0_PD_DLANE3		BIT(10)
++# define DSI0_PHY_AFEC0_PD_BG			BIT(9)
++# define DSI1_PHY_AFEC0_PD_DLANE2		BIT(9)
++# define DSI0_PHY_AFEC0_PD_DLANE1		BIT(8)
++# define DSI1_PHY_AFEC0_PD_DLANE1		BIT(8)
++# define DSI_PHY_AFEC0_PTATADJ_MASK		VC4_MASK(7, 4)
++# define DSI_PHY_AFEC0_PTATADJ_SHIFT		4
++# define DSI_PHY_AFEC0_CTATADJ_MASK		VC4_MASK(3, 0)
++# define DSI_PHY_AFEC0_CTATADJ_SHIFT		0
++
++#define DSI0_PHY_AFEC1		0x68
++# define DSI0_PHY_AFEC1_IDR_DLANE1_MASK		VC4_MASK(10, 8)
++# define DSI0_PHY_AFEC1_IDR_DLANE1_SHIFT	8
++# define DSI0_PHY_AFEC1_IDR_DLANE0_MASK		VC4_MASK(6, 4)
++# define DSI0_PHY_AFEC1_IDR_DLANE0_SHIFT	4
++# define DSI0_PHY_AFEC1_IDR_CLANE_MASK		VC4_MASK(2, 0)
++# define DSI0_PHY_AFEC1_IDR_CLANE_SHIFT		0
++
++#define DSI0_TST_SEL		0x6c
++#define DSI0_TST_MON		0x70
++#define DSI0_ID			0x74
++# define DSI_ID_VALUE		0x00647369
++
++
++#define DSI1_CTRL		0x00
++# define DSI_CTRL_HS_CLKC_MASK		VC4_MASK(15, 14)
++# define DSI_CTRL_HS_CLKC_SHIFT		14
++# define DSI_CTRL_HS_CLKC_BYTE		0
++# define DSI_CTRL_HS_CLKC_DDR2		1
++# define DSI_CTRL_HS_CLKC_DDR		2
++
++# define DSI_CTRL_RX_LPDT_EOT_DISABLE	BIT(13)
++# define DSI_CTRL_LPDT_EOT_DISABLE	BIT(12)
++# define DSI_CTRL_HSDT_EOT_DISABLE	BIT(11)
++# define DSI_CTRL_SOFT_RESET_CFG	BIT(10)
++# define DSI_CTRL_CAL_BYTE		BIT(9)
++# define DSI_CTRL_INV_BYTE		BIT(8)
++# define DSI_CTRL_CLR_LDF		BIT(7)
++# define DSI0_CTRL_CLR_PBCF		BIT(6)
++# define DSI1_CTRL_CLR_RXF		BIT(6)
++# define DSI0_CTRL_CLR_CPBCF		BIT(5)
++# define DSI1_CTRL_CLR_PDF		BIT(5)
++# define DSI0_CTRL_CLR_PDF		BIT(4)
++# define DSI1_CTRL_CLR_CDF		BIT(4)
++# define DSI0_CTRL_CLR_CDF		BIT(3)
++# define DSI0_CTRL_CTRL2		BIT(2)
++# define DSI1_CTRL_DISABLE_DISP_CRCC	BIT(2)
++# define DSI0_CTRL_CTRL1		BIT(1)
++# define DSI1_CTRL_DISABLE_DISP_ECCC	BIT(1)
++# define DSI0_CTRL_CTRL0		BIT(0)
++# define DSI1_CTRL_EN			BIT(0)
++# define DSI0_CTRL_RESET_FIFOS		(DSI_CTRL_CLR_LDF | \
++					 DSI0_CTRL_CLR_PBCF | \
++					 DSI0_CTRL_CLR_CPBCF |	\
++					 DSI0_CTRL_CLR_PDF | \
++					 DSI0_CTRL_CLR_CDF)
++# define DSI1_CTRL_RESET_FIFOS		(DSI_CTRL_CLR_LDF | \
++					 DSI1_CTRL_CLR_RXF | \
++					 DSI1_CTRL_CLR_PDF | \
++					 DSI1_CTRL_CLR_CDF)
++
++#define DSI1_TXPKT2C		0x0c
++#define DSI1_TXPKT2H		0x10
++#define DSI1_TXPKT_PIX_FIFO	0x20
++#define DSI1_RXPKT_FIFO		0x24
++#define DSI1_DISP0_CTRL		0x28
++#define DSI1_INT_STAT		0x30
++#define DSI1_INT_EN		0x34
++
++/* State reporting bits.  These mostly behave like INT_STAT, where
++ * writing a 1 clears the bit.
++ */
++#define DSI1_STAT		0x38
++# define DSI1_STAT_PHY_D3_ULPS		BIT(31)
++# define DSI1_STAT_PHY_D3_STOP		BIT(30)
++# define DSI1_STAT_PHY_D2_ULPS		BIT(29)
++# define DSI1_STAT_PHY_D2_STOP		BIT(28)
++# define DSI1_STAT_PHY_D1_ULPS		BIT(27)
++# define DSI1_STAT_PHY_D1_STOP		BIT(26)
++# define DSI1_STAT_PHY_D0_ULPS		BIT(25)
++# define DSI1_STAT_PHY_D0_STOP		BIT(24)
++# define DSI1_STAT_FIFO_ERR		BIT(23)
++# define DSI1_STAT_PHY_RXLPDT		BIT(22)
++# define DSI1_STAT_PHY_RXTRIG		BIT(21)
++# define DSI1_STAT_PHY_D0_LPDT		BIT(20)
++/* Set when in forward direction */
++# define DSI1_STAT_PHY_DIR		BIT(19)
++# define DSI1_STAT_PHY_CLOCK_ULPS	BIT(18)
++# define DSI1_STAT_PHY_CLOCK_HS		BIT(17)
++# define DSI1_STAT_PHY_CLOCK_STOP	BIT(16)
++# define DSI1_STAT_PR_TO		BIT(15)
++# define DSI1_STAT_TA_TO		BIT(14)
++# define DSI1_STAT_LPRX_TO		BIT(13)
++# define DSI1_STAT_HSTX_TO		BIT(12)
++# define DSI1_STAT_ERR_CONT_LP1		BIT(11)
++# define DSI1_STAT_ERR_CONT_LP0		BIT(10)
++# define DSI1_STAT_ERR_CONTROL		BIT(9)
++# define DSI1_STAT_ERR_SYNC_ESC		BIT(8)
++# define DSI1_STAT_RXPKT2		BIT(7)
++# define DSI1_STAT_RXPKT1		BIT(6)
++# define DSI1_STAT_TXPKT2_BUSY		BIT(5)
++# define DSI1_STAT_TXPKT2_DONE		BIT(4)
++# define DSI1_STAT_TXPKT2_END		BIT(3)
++# define DSI1_STAT_TXPKT1_BUSY		BIT(2)
++# define DSI1_STAT_TXPKT1_DONE		BIT(1)
++# define DSI1_STAT_TXPKT1_END		BIT(0)
++
++#define DSI1_HSTX_TO_CNT	0x3c
++#define DSI1_LPRX_TO_CNT	0x40
++#define DSI1_TA_TO_CNT		0x44
++#define DSI1_PR_TO_CNT		0x48
++#define DSI1_PHYC		0x4c
++
++#define DSI1_HS_CLT0		0x50
++# define DSI_HS_CLT0_CZERO_MASK		VC4_MASK(26, 18)
++# define DSI_HS_CLT0_CZERO_SHIFT	18
++# define DSI_HS_CLT0_CPRE_MASK		VC4_MASK(17, 9)
++# define DSI_HS_CLT0_CPRE_SHIFT		9
++# define DSI_HS_CLT0_CPREP_MASK		VC4_MASK(8, 0)
++# define DSI_HS_CLT0_CPREP_SHIFT	0
++
++#define DSI1_HS_CLT1		0x54
++# define DSI_HS_CLT1_CTRAIL_MASK	VC4_MASK(17, 9)
++# define DSI_HS_CLT1_CTRAIL_SHIFT	9
++# define DSI_HS_CLT1_CPOST_MASK		VC4_MASK(8, 0)
++# define DSI_HS_CLT1_CPOST_SHIFT	0
++
++#define DSI1_HS_CLT2		0x58
++# define DSI_HS_CLT2_WUP_MASK		VC4_MASK(23, 0)
++# define DSI_HS_CLT2_WUP_SHIFT		0
++
++#define DSI1_HS_DLT3		0x5c
++# define DSI_HS_DLT3_EXIT_MASK		VC4_MASK(26, 18)
++# define DSI_HS_DLT3_EXIT_SHIFT		18
++# define DSI_HS_DLT3_ZERO_MASK		VC4_MASK(17, 9)
++# define DSI_HS_DLT3_ZERO_SHIFT		9
++# define DSI_HS_DLT3_PRE_MASK		VC4_MASK(8, 0)
++# define DSI_HS_DLT3_PRE_SHIFT		0
++
++#define DSI1_HS_DLT4		0x60
++# define DSI_HS_DLT4_ANLAT_MASK		VC4_MASK(22, 18)
++# define DSI_HS_DLT4_ANLAT_SHIFT	18
++# define DSI_HS_DLT4_TRAIL_MASK		VC4_MASK(17, 9)
++# define DSI_HS_DLT4_TRAIL_SHIFT	9
++# define DSI_HS_DLT4_LPX_MASK		VC4_MASK(8, 0)
++# define DSI_HS_DLT4_LPX_SHIFT		0
++
++#define DSI1_HS_DLT5		0x64
++# define DSI_HS_DLT5_INIT_MASK		VC4_MASK(23, 0)
++# define DSI_HS_DLT5_INIT_SHIFT		0
++
++#define DSI1_HS_DLT6		0x68
++# define DSI_HS_DLT6_TA_GET_MASK	VC4_MASK(31, 24)
++# define DSI_HS_DLT6_TA_GET_SHIFT	24
++# define DSI_HS_DLT6_TA_SURE_MASK	VC4_MASK(23, 16)
++# define DSI_HS_DLT6_TA_SURE_SHIFT	16
++# define DSI_HS_DLT6_TA_GO_MASK		VC4_MASK(15, 8)
++# define DSI_HS_DLT6_TA_GO_SHIFT	8
++# define DSI_HS_DLT6_LP_LPX_MASK	VC4_MASK(7, 0)
++# define DSI_HS_DLT6_LP_LPX_SHIFT	0
++
++#define DSI1_HS_DLT7		0x6c
++# define DSI_HS_DLT7_LP_WUP_MASK	VC4_MASK(23, 0)
++# define DSI_HS_DLT7_LP_WUP_SHIFT	0
++
++#define DSI1_PHY_AFEC0		0x70
++
++#define DSI1_PHY_AFEC1		0x74
++# define DSI1_PHY_AFEC1_ACTRL_DLANE3_MASK	VC4_MASK(19, 16)
++# define DSI1_PHY_AFEC1_ACTRL_DLANE3_SHIFT	16
++# define DSI1_PHY_AFEC1_ACTRL_DLANE2_MASK	VC4_MASK(15, 12)
++# define DSI1_PHY_AFEC1_ACTRL_DLANE2_SHIFT	12
++# define DSI1_PHY_AFEC1_ACTRL_DLANE1_MASK	VC4_MASK(11, 8)
++# define DSI1_PHY_AFEC1_ACTRL_DLANE1_SHIFT	8
++# define DSI1_PHY_AFEC1_ACTRL_DLANE0_MASK	VC4_MASK(7, 4)
++# define DSI1_PHY_AFEC1_ACTRL_DLANE0_SHIFT	4
++# define DSI1_PHY_AFEC1_ACTRL_CLANE_MASK	VC4_MASK(3, 0)
++# define DSI1_PHY_AFEC1_ACTRL_CLANE_SHIFT	0
++
++#define DSI1_TST_SEL		0x78
++#define DSI1_TST_MON		0x7c
++#define DSI1_PHY_TST1		0x80
++#define DSI1_PHY_TST2		0x84
++#define DSI1_PHY_FIFO_STAT	0x88
++/* Actually, all registers in the range that aren't otherwise claimed
++ * will return the ID.
++ */
++#define DSI1_ID			0x8c
++
++/* General DSI hardware state. */
++struct vc4_dsi {
++	struct platform_device *pdev;
++
++	struct mipi_dsi_host dsi_host;
++	struct drm_encoder *encoder;
++	struct drm_connector *connector;
++	struct drm_panel *panel;
++
++	void __iomem *regs;
++
++	struct dma_chan *reg_dma_chan;
++	dma_addr_t reg_dma_paddr;
++	u32 *reg_dma_mem;
++	dma_addr_t reg_paddr;
++
++	/* Whether we're on bcm2835's DSI0 or DSI1. */
++	int port;
++
++	/* DSI channel for the panel we're connected to. */
++	u32 channel;
++	u32 lanes;
++	enum mipi_dsi_pixel_format format;
++	u32 mode_flags;
++
++	/* Input clock to the PHY, for the DSI escape clock. */
++	struct clk *escape_clock;
++
++	/* Input clock to the PHY, used to generate the DSI bit
++	 * clock.
++	 */
++	struct clk *pll_phy_clock;
++
++	/* Byte clock generated within the DSI PHY. */
++	struct clk_hw phy_byte_clock;
++
++	struct clk_onecell_data clk_onecell;
++
++	/* Pixel clock output to the pixelvalve, generated from the
++	 * byte clock.
++	 */
++	struct clk *pixel_clock;
++
++	struct completion xfer_completion;
++	int xfer_result;
++
++	bool use_firmware_setup;
++};
++
++static inline void
++dsi_write(struct vc4_dsi *dsi, u32 offset, u32 val)
++{
++	struct dma_chan *chan = dsi->reg_dma_chan;
++	struct dma_async_tx_descriptor *tx;
++	dma_cookie_t cookie;
++	int ret;
++
++#if 0 /* XXX */
++	dev_info(&dsi->pdev->dev, "WRITE 0x%04x -> 0x%08x\n", offset, val);
++#endif
++
++	if (!chan) {
++		writel(val, dsi->regs + offset);
++		return;
++	}
++
++	*dsi->reg_dma_mem = val;
++
++	tx = chan->device->device_prep_dma_memcpy(chan,
++						  dsi->reg_paddr + offset,
++						  dsi->reg_dma_paddr,
++						  4, 0);
++	if (!tx) {
++		DRM_ERROR("Failed to set up DMA register write\n");
++		return;
++	}
++
++	cookie = tx->tx_submit(tx);
++	ret = dma_submit_error(cookie);
++	if (ret) {
++		DRM_ERROR("Failed to submit DMA: %d\n", ret);
++		return;
++	}
++	ret = dma_sync_wait(chan, cookie);
++	if (ret)
++		DRM_ERROR("Failed to wait for DMA: %d\n", ret);
++
++#if 0 /* XXX */
++	if (offset != DSI1_TXPKT_CMD_FIFO &&
++	    offset != DSI1_TXPKT_PIX_FIFO) {
++		dev_info(&dsi->pdev->dev,
++			 "             -> 0x%08x\n",
++			 readl(dsi->regs + (offset)));
++	}
++#endif
++}
++
++#define DSI_READ(offset) readl(dsi->regs + (offset))
++#define DSI_WRITE(offset, val) dsi_write(dsi, offset, val)
++#define DSI_PORT_READ(offset) \
++	DSI_READ(dsi->port ? DSI1_##offset : DSI0_##offset)
++#define DSI_PORT_WRITE(offset, val) \
++	DSI_WRITE(dsi->port ? DSI1_##offset : DSI0_##offset, val)
++#define DSI_PORT_BIT(bit) (dsi->port ? DSI1_##bit : DSI0_##bit)
++
++/* VC4 DSI encoder KMS struct */
++struct vc4_dsi_encoder {
++	struct vc4_encoder base;
++	struct vc4_dsi *dsi;
++};
++
++static inline struct vc4_dsi_encoder *
++to_vc4_dsi_encoder(struct drm_encoder *encoder)
++{
++	return container_of(encoder, struct vc4_dsi_encoder, base.base);
++}
++#define host_to_dsi(host) container_of(host, struct vc4_dsi, dsi_host)
++
++/* VC4 DSI connector KMS struct */
++struct vc4_dsi_connector {
++	struct drm_connector base;
++	struct vc4_dsi *dsi;
++
++	/* Since the connector is attached to just the one encoder,
++	 * this is the reference to it so we can do the best_encoder()
++	 * hook.
++	 */
++	struct drm_encoder *encoder;
++};
++
++static inline struct vc4_dsi_connector *
++to_vc4_dsi_connector(struct drm_connector *connector)
++{
++	return container_of(connector, struct vc4_dsi_connector, base);
++}
++
++static const struct debugfs_reg32 dsi0_regs[] = {
++	VC4_DEBUG_REG(DSI0_CTRL),
++	VC4_DEBUG_REG(DSI0_STAT),
++	VC4_DEBUG_REG(DSI0_DISP0_CTRL),
++	VC4_DEBUG_REG(DSI0_DISP1_CTRL),
++	VC4_DEBUG_REG(DSI0_PHYC),
++	VC4_DEBUG_REG(DSI0_STAT),
++	VC4_DEBUG_REG(DSI0_HS_CLT0),
++	VC4_DEBUG_REG(DSI0_HS_CLT1),
++	VC4_DEBUG_REG(DSI0_HS_CLT2),
++	VC4_DEBUG_REG(DSI0_HS_DLT3),
++	VC4_DEBUG_REG(DSI0_HS_DLT4),
++	VC4_DEBUG_REG(DSI0_HS_DLT5),
++	VC4_DEBUG_REG(DSI0_HS_DLT6),
++	VC4_DEBUG_REG(DSI0_HS_DLT7),
++	VC4_DEBUG_REG(DSI0_PHY_AFEC0),
++	VC4_DEBUG_REG(DSI0_PHY_AFEC1),
++	VC4_DEBUG_REG(DSI0_ID),
++};
++
++static const struct debugfs_reg32 dsi1_regs[] = {
++	VC4_DEBUG_REG(DSI1_CTRL),
++	VC4_DEBUG_REG(DSI1_STAT),
++	VC4_DEBUG_REG(DSI1_DISP0_CTRL),
++	VC4_DEBUG_REG(DSI1_DISP1_CTRL),
++	VC4_DEBUG_REG(DSI1_PHYC),
++	VC4_DEBUG_REG(DSI1_STAT),
++	VC4_DEBUG_REG(DSI1_HS_CLT0),
++	VC4_DEBUG_REG(DSI1_HS_CLT1),
++	VC4_DEBUG_REG(DSI1_HS_CLT2),
++	VC4_DEBUG_REG(DSI1_HS_DLT3),
++	VC4_DEBUG_REG(DSI1_HS_DLT4),
++	VC4_DEBUG_REG(DSI1_HS_DLT5),
++	VC4_DEBUG_REG(DSI1_HS_DLT6),
++	VC4_DEBUG_REG(DSI1_HS_DLT7),
++	VC4_DEBUG_REG(DSI1_PHY_AFEC0),
++	VC4_DEBUG_REG(DSI1_PHY_AFEC1),
++	VC4_DEBUG_REG(DSI1_ID),
++};
++
++static void vc4_dsi_dump_regs(struct vc4_dsi *dsi, const char *prefix)
++{
++	if (dsi->port == 0) {
++		vc4_dump_regs32(dsi0_regs, ARRAY_SIZE(dsi0_regs), dsi->regs,
++				prefix);
++	} else {
++		vc4_dump_regs32(dsi1_regs, ARRAY_SIZE(dsi1_regs), dsi->regs,
++				prefix);
++	}
++}
++
++#ifdef CONFIG_DEBUG_FS
++int vc4_dsi_debugfs_regs(struct seq_file *m, void *number)
++{
++	struct drm_info_node *node = (struct drm_info_node *)m->private;
++	struct drm_device *dev = node->minor->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	struct vc4_dsi *dsi;
++	int port = (uintptr_t)number;
++
++	if (port == 0) {
++		dsi = vc4->dsi0;
++		debugfs_print_regs32(m, dsi0_regs, ARRAY_SIZE(dsi0_regs),
++				     dsi->regs, "");
++	} else {
++		dsi = vc4->dsi1;
++		debugfs_print_regs32(m, dsi1_regs, ARRAY_SIZE(dsi1_regs),
++				     dsi->regs, "");
++	}
++
++	return 0;
++}
++#endif
++
++static enum drm_connector_status
++vc4_dsi_connector_detect(struct drm_connector *connector, bool force)
++{
++	struct vc4_dsi_connector *vc4_connector =
++		to_vc4_dsi_connector(connector);
++	struct vc4_dsi *dsi = vc4_connector->dsi;
++
++	if (dsi->panel)
++		return connector_status_connected;
++	else
++		return connector_status_disconnected;
++}
++
++static void vc4_dsi_connector_destroy(struct drm_connector *connector)
++{
++	drm_connector_unregister(connector);
++	drm_connector_cleanup(connector);
++}
++
++static int vc4_dsi_connector_get_modes(struct drm_connector *connector)
++{
++	struct vc4_dsi_connector *vc4_connector =
++		to_vc4_dsi_connector(connector);
++	struct vc4_dsi *dsi = vc4_connector->dsi;
++
++	if (dsi->panel)
++		return drm_panel_get_modes(dsi->panel);
++
++	return 0;
++}
++
++static struct drm_encoder *
++vc4_dsi_connector_best_encoder(struct drm_connector *connector)
++{
++	struct vc4_dsi_connector *dsi_connector =
++		to_vc4_dsi_connector(connector);
++	return dsi_connector->encoder;
++}
++
++static const struct drm_connector_funcs vc4_dsi_connector_funcs = {
++	.dpms = drm_atomic_helper_connector_dpms,
++	.detect = vc4_dsi_connector_detect,
++	.fill_modes = drm_helper_probe_single_connector_modes,
++	.destroy = vc4_dsi_connector_destroy,
++	.reset = drm_atomic_helper_connector_reset,
++	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
++};
++
++static const struct drm_connector_helper_funcs vc4_dsi_connector_helper_funcs = {
++	.get_modes = vc4_dsi_connector_get_modes,
++	.best_encoder = vc4_dsi_connector_best_encoder,
++};
++
++static struct drm_connector *vc4_dsi_connector_init(struct drm_device *dev,
++						    struct vc4_dsi *dsi)
++{
++	struct drm_connector *connector = NULL;
++	struct vc4_dsi_connector *dsi_connector;
++	int ret = 0;
++
++	dsi_connector = devm_kzalloc(dev->dev, sizeof(*dsi_connector),
++				      GFP_KERNEL);
++	if (!dsi_connector) {
++		ret = -ENOMEM;
++		goto fail;
++	}
++	connector = &dsi_connector->base;
++
++	dsi_connector->encoder = dsi->encoder;
++	dsi_connector->dsi = dsi;
++
++	drm_connector_init(dev, connector, &vc4_dsi_connector_funcs,
++			   DRM_MODE_CONNECTOR_DSI);
++	drm_connector_helper_add(connector, &vc4_dsi_connector_helper_funcs);
++
++	connector->polled = 0;
++	connector->interlace_allowed = 0;
++	connector->doublescan_allowed = 0;
++
++	drm_mode_connector_attach_encoder(connector, dsi->encoder);
++
++	return connector;
++
++ fail:
++	if (connector)
++		vc4_dsi_connector_destroy(connector);
++
++	return ERR_PTR(ret);
++}
++
++static void vc4_dsi_encoder_destroy(struct drm_encoder *encoder)
++{
++	drm_encoder_cleanup(encoder);
++}
++
++static const struct drm_encoder_funcs vc4_dsi_encoder_funcs = {
++	.destroy = vc4_dsi_encoder_destroy,
++};
++
++static void vc4_dsi_latch_ulps(struct vc4_dsi *dsi, bool latch)
++{
++	u32 afec0 = DSI_PORT_READ(PHY_AFEC0);
++
++	if (latch)
++		afec0 |= DSI_PORT_BIT(PHY_AFEC0_LATCH_ULPS);
++	else
++		afec0 &= ~DSI_PORT_BIT(PHY_AFEC0_LATCH_ULPS);
++
++	DSI_PORT_WRITE(PHY_AFEC0, afec0);
++}
++
++/* Enters or exits Ultra Low Power State. */
++static void vc4_dsi_ulps(struct vc4_dsi *dsi, bool ulps)
++{
++	u32 phyc_ulps = (DSI_PORT_BIT(PHYC_CLANE_ULPS) |
++			 DSI_PHYC_DLANE0_ULPS |
++			 (dsi->lanes > 1 ? DSI_PHYC_DLANE1_ULPS : 0) |
++			 (dsi->lanes > 2 ? DSI_PHYC_DLANE2_ULPS : 0) |
++			 (dsi->lanes > 3 ? DSI_PHYC_DLANE3_ULPS : 0));
++	u32 stat_ulps = (DSI1_STAT_PHY_CLOCK_ULPS |
++			 DSI1_STAT_PHY_D0_ULPS |
++			 (dsi->lanes > 1 ? DSI1_STAT_PHY_D1_ULPS : 0) |
++			 (dsi->lanes > 2 ? DSI1_STAT_PHY_D2_ULPS : 0) |
++			 (dsi->lanes > 3 ? DSI1_STAT_PHY_D3_ULPS : 0));
++	u32 stat_stop = (DSI1_STAT_PHY_CLOCK_STOP |
++			 DSI1_STAT_PHY_D0_STOP |
++			 (dsi->lanes > 1 ? DSI1_STAT_PHY_D1_STOP : 0) |
++			 (dsi->lanes > 2 ? DSI1_STAT_PHY_D2_STOP : 0) |
++			 (dsi->lanes > 3 ? DSI1_STAT_PHY_D3_STOP : 0));
++	int ret;
++
++	DSI_PORT_WRITE(STAT, stat_ulps);
++	DSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) | phyc_ulps);
++	ret = wait_for((DSI_PORT_READ(STAT) & stat_ulps) == stat_ulps, 20);
++	if (ret) {
++		dev_warn(&dsi->pdev->dev,
++			 "Timeout waiting for DSI ULPS entry: STAT 0x%08x",
++			 DSI_PORT_READ(STAT));
++		DSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);
++		vc4_dsi_latch_ulps(dsi, false);
++		return;
++	}
++
++	/* The DSI module can't be disabled while the module is
++	 * generating ULPS state.  So, to be able to disable the
++	 * module, we have the AFE latch the ULPS state and continue
++	 * on to having the module enter STOP.
++	 */
++	vc4_dsi_latch_ulps(dsi, ulps);
++
++	DSI_PORT_WRITE(STAT, stat_stop);
++	DSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);
++	ret = wait_for((DSI_PORT_READ(STAT) & stat_stop) == stat_stop, 20);
++	if (ret) {
++		dev_warn(&dsi->pdev->dev,
++			 "Timeout waiting for DSI STOP entry: STAT 0x%08x",
++			 DSI_PORT_READ(STAT));
++		DSI_PORT_WRITE(PHYC, DSI_PORT_READ(PHYC) & ~phyc_ulps);
++		return;
++	}
++}
++
++static uint32_t
++dsi_hs_timing(u32 ui_ns, u32 ns, u32 ui)
++{
++	/* The HS timings have to be rounded up to a multiple of 8
++	 * because we're using the byte clock.
++	 */
++	return roundup(ui + DIV_ROUND_UP(ns, ui_ns), 8);
++}
++
++/* ESC always runs at 100Mhz. */
++#define ESC_TIME_NS 10
++
++static uint32_t
++dsi_esc_timing(u32 ns)
++{
++	return DIV_ROUND_UP(ns, ESC_TIME_NS);
++}
++
++static void vc4_dsi_encoder_disable(struct drm_encoder *encoder)
++{
++	struct vc4_dsi_encoder *vc4_encoder = to_vc4_dsi_encoder(encoder);
++	struct vc4_dsi *dsi = vc4_encoder->dsi;
++
++	drm_panel_disable(dsi->panel);
++
++	if (!dsi->use_firmware_setup)
++		vc4_dsi_ulps(dsi, true);
++
++	drm_panel_unprepare(dsi->panel);
++
++	if (dsi->use_firmware_setup) {
++		/* Since we're using the firmware setup and aren't
++		 * communicating with the panel to bring the link
++		 * down, we need to just keep the clocks and DSI
++		 * module running.
++		 */
++	} else {
++		clk_disable_unprepare(dsi->pll_phy_clock);
++		clk_disable_unprepare(dsi->escape_clock);
++		clk_disable_unprepare(dsi->pixel_clock);
++	}
++}
++
++static void vc4_dsi_encoder_enable(struct drm_encoder *encoder)
++{
++	struct drm_display_mode *mode = &encoder->crtc->mode;
++	struct vc4_dsi_encoder *vc4_encoder = to_vc4_dsi_encoder(encoder);
++	struct vc4_dsi *dsi = vc4_encoder->dsi;
++	struct device *dev = &dsi->pdev->dev;
++	uint32_t format = 0, divider = 0;
++	bool debug_dump_regs = false;
++	unsigned long hs_clock;
++	uint32_t ui_ns;
++	/* Minimum LP state duration in escape clock cycles. */
++	uint32_t lpx = dsi_esc_timing(60);
++	uint32_t phyc;
++	int ret;
++
++	ret = drm_panel_prepare(dsi->panel);
++	if (ret) {
++		DRM_ERROR("Panel failed to prepare\n");
++		return;
++	}
++
++	if (debug_dump_regs)
++		vc4_dsi_dump_regs(dsi, "DSI before: ");
++
++	/* XXX */
++	if (!dsi->use_firmware_setup) {
++		ret = clk_set_rate(dsi->pll_phy_clock, 2020000000 / 3);
++		if (ret)
++			dev_err(&dsi->pdev->dev, "Failed to set phy clock: %d\n", ret);
++		dev_info(&dsi->pdev->dev, "Tried to set clock to: %d\n", 2000000000 / 3);
++
++		ret = clk_prepare_enable(dsi->escape_clock);
++		if (ret) {
++			DRM_ERROR("Failed to turn on DSI escape clock: %d\n", ret);
++			return;
++		}
++
++		ret = clk_prepare_enable(dsi->pll_phy_clock);
++		if (ret) {
++			DRM_ERROR("Failed to turn on DSI PLL: %d\n", ret);
++			return;
++		}
++
++		ret = clk_set_rate(dsi->pixel_clock, mode->clock * 1000);
++		if (ret)
++			dev_err(dev, "Failed to set pixel clock: %d\n", ret);
++		dev_info(&dsi->pdev->dev, "Tried to set pixel clock to: %d\n", mode->clock * 1000);
++
++		ret = clk_prepare_enable(dsi->pixel_clock);
++		if (ret) {
++			DRM_ERROR("Failed to turn on DSI pixel clock: %d\n", ret);
++			return;
++		}
++	}
++
++	hs_clock = clk_get_rate(dsi->pll_phy_clock);
++
++	/* Reset the DSI and all its fifos. */
++	if (dsi->port == 0) {
++		DSI_PORT_WRITE(CTRL,
++			       DSI_CTRL_SOFT_RESET_CFG |
++			       DSI0_CTRL_RESET_FIFOS);
++	} else {
++		DSI_PORT_WRITE(CTRL,
++			       DSI_CTRL_SOFT_RESET_CFG |
++			       DSI1_CTRL_RESET_FIFOS);
++	}
++
++	DSI_PORT_WRITE(CTRL,
++		       DSI_CTRL_HSDT_EOT_DISABLE |
++		       DSI_CTRL_RX_LPDT_EOT_DISABLE);
++
++	switch (dsi->format) {
++	case MIPI_DSI_FMT_RGB888:
++		format = DSI_PFORMAT_RGB888;
++		divider = 24 / dsi->lanes;
++		break;
++	case MIPI_DSI_FMT_RGB666:
++		format = DSI_PFORMAT_RGB666;
++		divider = 24 / dsi->lanes;
++		break;
++	case MIPI_DSI_FMT_RGB666_PACKED:
++		format = DSI_PFORMAT_RGB666_PACKED;
++		divider = 18 / dsi->lanes;
++		break;
++	case MIPI_DSI_FMT_RGB565:
++		format = DSI_PFORMAT_RGB565;
++		divider = 16 / dsi->lanes;
++		break;
++	}
++
++	/* Set AFE CTR00/CTR1 to release powerdown of analog. */
++	if (dsi->port == 0) {
++		u32 afec0 = (VC4_SET_FIELD(7, DSI_PHY_AFEC0_PTATADJ) |
++			     VC4_SET_FIELD(7, DSI_PHY_AFEC0_CTATADJ));
++
++		if (dsi->lanes < 2)
++			afec0 |= DSI0_PHY_AFEC0_PD_DLANE1;
++
++		if (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO))
++			afec0 |= DSI0_PHY_AFEC0_RESET;
++
++		DSI_PORT_WRITE(PHY_AFEC0, afec0);
++
++		DSI_PORT_WRITE(PHY_AFEC1,
++			  VC4_SET_FIELD(6,  DSI0_PHY_AFEC1_IDR_DLANE1) |
++			  VC4_SET_FIELD(6,  DSI0_PHY_AFEC1_IDR_DLANE0) |
++			  VC4_SET_FIELD(6,  DSI0_PHY_AFEC1_IDR_CLANE));
++	} else {
++		u32 afec0 = (VC4_SET_FIELD(7, DSI_PHY_AFEC0_PTATADJ) |
++			     VC4_SET_FIELD(7, DSI_PHY_AFEC0_CTATADJ) |
++			     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_CLANE) |
++			     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_DLANE0) |
++			     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_DLANE1) |
++			     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_DLANE2) |
++			     VC4_SET_FIELD(6, DSI1_PHY_AFEC0_IDR_DLANE3));
++
++		if (dsi->lanes < 4)
++			afec0 |= DSI1_PHY_AFEC0_PD_DLANE3;
++		if (dsi->lanes < 3)
++			afec0 |= DSI1_PHY_AFEC0_PD_DLANE2;
++		if (dsi->lanes < 2)
++			afec0 |= DSI1_PHY_AFEC0_PD_DLANE1;
++
++		if (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO))
++			afec0 |= DSI1_PHY_AFEC0_RESET;
++
++		DSI_PORT_WRITE(PHY_AFEC0, afec0);
++
++		DSI_PORT_WRITE(PHY_AFEC1, 0);
++	}
++
++	/* How many ns one DSI unit interval is.  Note that the clock
++	 * is DDR, so there's an extra divide by 2.
++	 */
++	ui_ns = DIV_ROUND_UP(500000000, hs_clock);
++
++	DSI_PORT_WRITE(HS_CLT0,
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 262, 0),
++				     DSI_HS_CLT0_CZERO) |
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 0, 8),
++				     DSI_HS_CLT0_CPRE) |
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 38, 0),
++				     DSI_HS_CLT0_CPREP));
++
++	DSI_PORT_WRITE(HS_CLT1,
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 60, 0),
++				     DSI_HS_CLT1_CTRAIL) |
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 60, 52),
++				     DSI_HS_CLT1_CPOST));
++
++	DSI_PORT_WRITE(HS_CLT2,
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 1000000, 0),
++				     DSI_HS_CLT2_WUP));
++
++	DSI_PORT_WRITE(HS_DLT3,
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 100, 0),
++				     DSI_HS_DLT3_EXIT) |
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 105, 6),
++				     DSI_HS_DLT3_ZERO) |
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, 40, 4),
++				     DSI_HS_DLT3_PRE));
++
++	DSI_PORT_WRITE(HS_DLT4,
++		       VC4_SET_FIELD(dsi_hs_timing(ui_ns, lpx * ESC_TIME_NS, 0),
++				     DSI_HS_DLT4_LPX) |
++		       VC4_SET_FIELD(max(dsi_hs_timing(ui_ns, 0, 8),
++					 dsi_hs_timing(ui_ns, 60, 4)),
++				     DSI_HS_DLT4_TRAIL) |
++		       VC4_SET_FIELD(0, DSI_HS_DLT4_ANLAT));
++
++	DSI_PORT_WRITE(HS_DLT5, VC4_SET_FIELD(dsi_hs_timing(ui_ns, 1000, 5000),
++					      DSI_HS_DLT5_INIT));
++
++	DSI_PORT_WRITE(HS_DLT6,
++		       VC4_SET_FIELD(lpx * 5, DSI_HS_DLT6_TA_GET) |
++		       VC4_SET_FIELD(lpx, DSI_HS_DLT6_TA_SURE) |
++		       VC4_SET_FIELD(lpx * 4, DSI_HS_DLT6_TA_GO) |
++		       VC4_SET_FIELD(lpx, DSI_HS_DLT6_LP_LPX));
++
++	DSI_PORT_WRITE(HS_DLT7,
++		       VC4_SET_FIELD(dsi_esc_timing(1000000),
++				     DSI_HS_DLT7_LP_WUP));
++
++	/* Define EOT PKT in EOT reg. */
++
++	phyc = (DSI_PHYC_DLANE0_ENABLE |
++		(dsi->lanes >= 2 ? DSI_PHYC_DLANE1_ENABLE : 0) |
++		(dsi->lanes >= 3 ? DSI_PHYC_DLANE2_ENABLE : 0) |
++		(dsi->lanes >= 4 ? DSI_PHYC_DLANE3_ENABLE : 0) |
++		(dsi->port == 0 ?
++		 VC4_SET_FIELD(lpx - 1, DSI0_PHYC_ESC_CLK_LPDT) :
++		 VC4_SET_FIELD(lpx - 1, DSI1_PHYC_ESC_CLK_LPDT)) |
++		DSI_PORT_BIT(PHYC_CLANE_ENABLE));
++
++	DSI_PORT_WRITE(CTRL,
++		       DSI_PORT_READ(CTRL) |
++		       DSI_CTRL_CAL_BYTE);
++
++	/* HS timeout in HS clock cycles: disabled. */
++	DSI_PORT_WRITE(HSTX_TO_CNT, 0);
++	/* LP receive timeout in HS clocks. */
++	DSI_PORT_WRITE(LPRX_TO_CNT, 0xffffff);
++	/* Bus turnaround timeout */
++	DSI_PORT_WRITE(TA_TO_CNT, 100000);
++	/* Display reset sequence timeout */
++	DSI_PORT_WRITE(TA_TO_CNT, 100000);
++
++	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) {
++		DSI_PORT_WRITE(DISP0_CTRL,
++			       VC4_SET_FIELD(divider, DSI_DISP0_PIX_CLK_DIV) |
++			       VC4_SET_FIELD(format, DSI_DISP0_PFORMAT) |
++			       VC4_SET_FIELD(DSI_DISP0_LP_STOP_PERFRAME,
++					     DSI_DISP0_LP_STOP_CTRL) |
++			       DSI_DISP0_ST_END |
++			       DSI_DISP0_ENABLE);
++	} else {
++		DSI_PORT_WRITE(DISP0_CTRL,
++			       DSI_DISP0_COMMAND_MODE |
++			       DSI_DISP0_ENABLE);
++	}
++
++	/* Set up DISP1 for transferring long command payloads through
++	 * the pixfifo.
++	 */
++	DSI_PORT_WRITE(DISP1_CTRL,
++		       VC4_SET_FIELD(DSI_DISP1_PFORMAT_32BIT_LE,
++				     DSI_DISP1_PFORMAT) |
++		       DSI_DISP1_ENABLE);
++
++	if (!(dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS))
++		phyc |= DSI_PORT_BIT(PHYC_HS_CLK_CONTINUOUS);
++
++	DSI_PORT_WRITE(PHYC, phyc);
++
++	/* Ungate the block. */
++	if (dsi->port == 0)
++		DSI_PORT_WRITE(CTRL, DSI_PORT_READ(CTRL) | DSI0_CTRL_CTRL0);
++	else {
++		DSI_PORT_WRITE(CTRL, DSI_PORT_READ(CTRL) | DSI1_CTRL_EN);
++	}
++
++	if (!dsi->use_firmware_setup)
++		vc4_dsi_ulps(dsi, false);
++
++	if (debug_dump_regs)
++		vc4_dsi_dump_regs(dsi, "DSI after: ");
++
++	ret = drm_panel_enable(dsi->panel);
++	if (ret) {
++		DRM_ERROR("Panel failed to enable\n");
++		drm_panel_unprepare(dsi->panel);
++		return;
++	}
++}
++
++static ssize_t vc4_dsi_host_transfer(struct mipi_dsi_host *host,
++				     const struct mipi_dsi_msg *msg)
++{
++	struct vc4_dsi *dsi = host_to_dsi(host);
++	struct mipi_dsi_packet packet;
++	u32 pkth = 0, pktc = 0;
++	int i, ret;
++	bool is_long = mipi_dsi_packet_format_is_long(msg->type);
++	u32 cmd_fifo_len = 0, pix_fifo_len = 0;
++
++	mipi_dsi_create_packet(&packet, msg);
++	pr_err("DSI host xfer %db, %s\n",
++	       packet.payload_length,
++	       is_long ? "long" : "short");
++
++	pkth |= VC4_SET_FIELD(packet.header[0], DSI_TXPKT1H_BC_DT);
++	pkth |= VC4_SET_FIELD(packet.header[1] |
++			      (packet.header[2] << 8),
++			      DSI_TXPKT1H_BC_PARAM);
++	if (is_long) {
++		/* Divide data across the various FIFOs we have available.
++		 * The command FIFO takes byte-oriented data, but is of
++		 * limited size. The pixel FIFO (never actually used for
++		 * pixel data in reality) is word oriented, and substantially
++		 * larger. So, we use the pixel FIFO for most of the data,
++		 * sending the residual bytes in the command FIFO at the start.
++		 *
++		 * With this arrangement, the command FIFO will never get full.
++		 */
++		cmd_fifo_len = packet.payload_length % DSI_PIX_FIFO_WIDTH;
++		pix_fifo_len = ((packet.payload_length - cmd_fifo_len) /
++				DSI_PIX_FIFO_WIDTH);
++
++		WARN_ON_ONCE(pix_fifo_len >= DSI_PIX_FIFO_DEPTH);
++
++		pkth |= VC4_SET_FIELD(cmd_fifo_len, DSI_TXPKT1H_BC_CMDFIFO);
++	}
++
++	if (msg->rx_len) {
++		pktc |= VC4_SET_FIELD(DSI_TXPKT1C_CMD_CTRL_RX,
++				      DSI_TXPKT1C_CMD_CTRL);
++	} else {
++		pktc |= VC4_SET_FIELD(DSI_TXPKT1C_CMD_CTRL_TX,
++				      DSI_TXPKT1C_CMD_CTRL);
++	}
++
++	dev_info(&dsi->pdev->dev, "FIFO setup: %d, %d\n",
++		 cmd_fifo_len, pix_fifo_len);
++
++	for (i = 0; i < cmd_fifo_len; i++)
++		DSI_PORT_WRITE(TXPKT_CMD_FIFO, packet.payload[i]);
++	for (i = 0; i < pix_fifo_len; i++) {
++		const uint8_t *pix = packet.payload + cmd_fifo_len + i * 4;
++		DSI_PORT_WRITE(TXPKT_PIX_FIFO,
++			       pix[0] |
++			       pix[1] << 8 |
++			       pix[2] << 16 |
++			       pix[3] << 24);
++	}
++
++	if (msg->flags & MIPI_DSI_MSG_USE_LPM)
++		pktc |= DSI_TXPKT1C_CMD_MODE_LP;
++	if (is_long)
++		pktc |= DSI_TXPKT1C_CMD_TYPE_LONG;
++
++	/* Send one copy of the packet.  Larger repeats are used for pixel
++	 * data in command mode.
++	 */
++	pktc |= VC4_SET_FIELD(1, DSI_TXPKT1C_CMD_REPEAT);
++
++	pktc |= DSI_TXPKT1C_CMD_EN;
++	if (pix_fifo_len) {
++		pktc |= VC4_SET_FIELD(DSI_TXPKT1C_DISPLAY_NO_SECONDARY,
++				      DSI_TXPKT1C_DISPLAY_NO);
++	} else {
++		pktc |= VC4_SET_FIELD(DSI_TXPKT1C_DISPLAY_NO_SHORT,
++				      DSI_TXPKT1C_DISPLAY_NO);
++	}
++
++	/* Enable the appropriate interrupt for the transfer completion. */
++	dsi->xfer_result = 0;
++	reinit_completion(&dsi->xfer_completion);
++	DSI_PORT_WRITE(INT_STAT, DSI1_INT_TXPKT1_DONE | DSI1_INT_PHY_DIR_RTF);
++	if (msg->rx_len) {
++		DSI_PORT_WRITE(INT_EN, (DSI1_INTERRUPTS_ALWAYS_ENABLED |
++					DSI1_INT_PHY_DIR_RTF));
++	} else {
++		DSI_PORT_WRITE(INT_EN, (DSI1_INTERRUPTS_ALWAYS_ENABLED |
++					DSI1_INT_TXPKT1_DONE));
++	}
++
++	/* Send the packet. */
++	DSI_PORT_WRITE(TXPKT1H, pkth);
++	DSI_PORT_WRITE(TXPKT1C, pktc);
++
++	if (!wait_for_completion_timeout(&dsi->xfer_completion,
++					 msecs_to_jiffies(100))) {
++		u32 stat = DSI_PORT_READ(STAT);
++
++		dev_err(&dsi->pdev->dev, "transfer interrupt wait timeout");
++		dev_err(&dsi->pdev->dev, "INT_STAT: 0x%08x, STAT: 0x%08x\n",
++			DSI_PORT_READ(INT_STAT), stat);
++
++		if (stat & DSI1_STAT_TXPKT1_DONE) {
++			dev_info(&dsi->pdev->dev,
++				 "STAT reports DONE, though.\n");
++			ret = 0;
++		} else {
++			ret = -ETIMEDOUT;
++		}
++	} else {
++		ret = dsi->xfer_result;
++	}
++
++	DSI_PORT_WRITE(INT_EN, DSI1_INTERRUPTS_ALWAYS_ENABLED);
++	if (ret)
++		goto reset_fifo_and_return;
++
++	if (ret == 0 && msg->rx_len) {
++		u32 rxpkt1h = DSI_PORT_READ(RXPKT1H);
++		u8 *msg_rx = msg->rx_buf;
++
++		if (rxpkt1h & DSI_RXPKT1H_PKT_TYPE_LONG) {
++			u32 rxlen = VC4_GET_FIELD(rxpkt1h, DSI_RXPKT1H_BC_PARAM);
++
++			if (rxlen != msg->rx_len) {
++				DRM_ERROR("DSI returned %db, expecting %db\n",
++					  rxlen, msg->rx_len);
++				ret = -ENXIO;
++				goto reset_fifo_and_return;
++			}
++
++			for (i = 0; i < msg->rx_len; i++)
++				msg_rx[i] = DSI_READ(DSI1_RXPKT_FIFO);
++		} else {
++			/* XXX: AWER */
++
++			msg_rx[0] = VC4_GET_FIELD(rxpkt1h,
++						  DSI_RXPKT1H_SHORT_0);
++			if (msg->rx_len > 1) {
++				msg_rx[1] = VC4_GET_FIELD(rxpkt1h,
++							  DSI_RXPKT1H_SHORT_1);
++			}
++		}
++	}
++
++	return ret;
++
++reset_fifo_and_return:
++	DRM_ERROR("DSI TRANSFER failed, resetting: %d\n", ret);
++
++	DSI_PORT_WRITE(TXPKT1C, DSI_PORT_READ(TXPKT1C) & ~DSI_TXPKT1C_CMD_EN);
++	udelay(1);
++	if (dsi->port == 0) {
++		DSI_PORT_WRITE(CTRL,
++			       DSI_PORT_READ(CTRL) | DSI0_CTRL_RESET_FIFOS);
++	} else {
++		DSI_PORT_WRITE(CTRL,
++			       DSI_PORT_READ(CTRL) | DSI1_CTRL_RESET_FIFOS);
++	}
++
++	DSI_PORT_WRITE(TXPKT1C, 0);
++	DSI_PORT_WRITE(INT_EN, DSI1_INTERRUPTS_ALWAYS_ENABLED);
++
++
++	return ret;
++}
++
++static int vc4_dsi_host_attach(struct mipi_dsi_host *host,
++			       struct mipi_dsi_device *device)
++{
++	struct vc4_dsi *dsi = host_to_dsi(host);
++
++	dsi->lanes = device->lanes;
++	dsi->channel = device->channel;
++	dsi->format = device->format;
++	dsi->mode_flags = device->mode_flags;
++
++	if (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO)) {
++		dev_err(&dsi->pdev->dev,
++			"Only VIDEO mode panels supported currently.\n");
++		return 0;
++	}
++
++	dsi->panel = of_drm_find_panel(device->dev.of_node);
++	if (dsi->panel)
++		return drm_panel_attach(dsi->panel, dsi->connector);
++
++	drm_helper_hpd_irq_event(dsi->connector->dev);
++
++	return 0;
++}
++
++static int vc4_dsi_host_detach(struct mipi_dsi_host *host,
++			       struct mipi_dsi_device *device)
++{
++	struct vc4_dsi *dsi = host_to_dsi(host);
++
++	if (dsi->panel) {
++		int ret = drm_panel_detach(dsi->panel);
++		if (ret)
++			return ret;
++
++		dsi->panel = NULL;
++	}
++
++	drm_helper_hpd_irq_event(dsi->connector->dev);
++
++	return 0;
++}
++
++static const struct mipi_dsi_host_ops vc4_dsi_host_ops = {
++	.attach = vc4_dsi_host_attach,
++	.detach = vc4_dsi_host_detach,
++	.transfer = vc4_dsi_host_transfer,
++};
++
++static const struct drm_encoder_helper_funcs vc4_dsi_encoder_helper_funcs = {
++	.disable = vc4_dsi_encoder_disable,
++	.enable = vc4_dsi_encoder_enable,
++};
++
++static const struct of_device_id vc4_dsi_dt_match[] = {
++	{ .compatible = "brcm,bcm2835-dsi0", (void *)(uintptr_t)0 },
++	{ .compatible = "brcm,bcm2835-dsi1", (void *)(uintptr_t)1 },
++	{}
++};
++
++static long vc4_dsi_byte_clock_round_rate(struct clk_hw *hw, unsigned long rate,
++					  unsigned long *parent_rate)
++{
++	return *parent_rate / 8;
++}
++
++static unsigned long vc4_dsi_byte_clock_get_rate(struct clk_hw *hw,
++					  unsigned long parent_rate)
++{
++	return parent_rate / 8;
++}
++
++static int vc4_dsi_byte_clock_set_rate(struct clk_hw *hw,
++				       unsigned long rate,
++				       unsigned long parent_rate)
++{
++	return 0;
++}
++
++/* The byte clock has *no* ops filled.  It's always running when the
++ * PHY is.
++ */
++static const struct clk_ops vc4_dsi_byte_clock_ops = {
++	.recalc_rate = vc4_dsi_byte_clock_get_rate,
++	.set_rate = vc4_dsi_byte_clock_set_rate,
++	.round_rate = vc4_dsi_byte_clock_round_rate,
++};
++
++static void dsi_handle_error(struct vc4_dsi *dsi,
++			     irqreturn_t *ret, u32 stat, u32 bit,
++			     const char *type)
++{
++	if (!(stat & bit))
++		return;
++
++	DRM_ERROR("DSI%d: %s error\n", dsi->port, type);
++	*ret = IRQ_HANDLED;
++}
++
++static irqreturn_t vc4_dsi_irq_handler(int irq, void *data)
++{
++	struct vc4_dsi *dsi = data;
++	u32 stat = DSI_PORT_READ(INT_STAT);
++	irqreturn_t ret = IRQ_NONE;
++
++	DSI_PORT_WRITE(INT_STAT, stat);
++
++	dsi_handle_error(dsi, &ret, stat,
++			 DSI1_INT_ERR_SYNC_ESC, "LPDT sync");
++	dsi_handle_error(dsi, &ret, stat,
++			 DSI1_INT_ERR_CONTROL, "data lane 0 sequence");
++	dsi_handle_error(dsi, &ret, stat,
++			 DSI1_INT_ERR_CONT_LP0, "LP0 contention");
++	dsi_handle_error(dsi, &ret, stat,
++			 DSI1_INT_ERR_CONT_LP1, "LP1 contention");
++	dsi_handle_error(dsi, &ret, stat,
++			 DSI1_INT_HSTX_TO, "HSTX timeout");
++	dsi_handle_error(dsi, &ret, stat,
++			 DSI1_INT_LPRX_TO, "LPRX timeout");
++	dsi_handle_error(dsi, &ret, stat,
++			 DSI1_INT_TA_TO, "turnaround timeout");
++	dsi_handle_error(dsi, &ret, stat,
++			 DSI1_INT_PR_TO, "peripheral reset timeout");
++
++	if (stat & (DSI1_INT_TXPKT1_DONE | DSI1_INT_PHY_DIR_RTF)) {
++		complete(&dsi->xfer_completion);
++		ret = IRQ_HANDLED;
++	} else if (stat & DSI1_INT_HSTX_TO) {
++		complete(&dsi->xfer_completion);
++		dsi->xfer_result = -ETIMEDOUT;
++		ret = IRQ_HANDLED;
++	}
++
++	return ret;
++}
++
++static int
++vc4_dsi_init_phy_byte_clock(struct vc4_dsi *dsi)
++{
++	struct device *dev = &dsi->pdev->dev;
++	const char *parent_name = __clk_get_name(dsi->pll_phy_clock);
++	struct clk_init_data init;
++	struct clk *clk;
++
++	memset(&init, 0, sizeof(init));
++	init.parent_names = &parent_name;
++	init.num_parents = 1;
++	if (dsi->port == 1)
++		init.name = "dsi1_byte";
++	else
++		init.name = "dsi0_byte";
++	init.ops = &vc4_dsi_byte_clock_ops;
++	init.flags = 0;
++
++	dsi->phy_byte_clock.init = &init;
++	clk = devm_clk_register(dev, &dsi->phy_byte_clock);
++	if (IS_ERR(clk))
++		return PTR_ERR(clk);
++
++	/* Use the onecell provider because we may need to expose the
++	 * DDR and DDR2 clocks at some point, which we'd want to put
++	 * in slots 1 and 2.
++	 */
++	dsi->clk_onecell.clk_num = 1;
++	dsi->clk_onecell.clks = devm_kcalloc(dev,
++					     dsi->clk_onecell.clk_num,
++					     sizeof(*dsi->clk_onecell.clks),
++					     GFP_KERNEL);
++	if (!dsi->clk_onecell.clks)
++		return -ENOMEM;
++
++	dsi->clk_onecell.clks[0] = clk;
++
++	return of_clk_add_provider(dev->of_node,
++				   of_clk_src_onecell_get,
++				   &dsi->clk_onecell);
++}
++
++static int vc4_dsi_bind(struct device *dev, struct device *master, void *data)
++{
++	struct platform_device *pdev = to_platform_device(dev);
++	struct drm_device *drm = dev_get_drvdata(master);
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
++	struct vc4_dsi *dsi;
++	struct vc4_dsi_encoder *vc4_dsi_encoder;
++	const struct of_device_id *match;
++	dma_cap_mask_t dma_mask;
++	int ret;
++
++	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
++	if (!dsi)
++		return -ENOMEM;
++
++	match = of_match_device(vc4_dsi_dt_match, dev);
++	if (!match)
++		return -ENODEV;
++
++	dsi->port = (uintptr_t)match->data;
++
++	vc4_dsi_encoder = devm_kzalloc(dev, sizeof(*vc4_dsi_encoder),
++				       GFP_KERNEL);
++	if (!vc4_dsi_encoder)
++		return -ENOMEM;
++	vc4_dsi_encoder->base.type = VC4_ENCODER_TYPE_DSI1;
++	vc4_dsi_encoder->dsi = dsi;
++	dsi->encoder = &vc4_dsi_encoder->base.base;
++
++	dsi->pdev = pdev;
++	dsi->regs = vc4_ioremap_regs(pdev, 0);
++	if (IS_ERR(dsi->regs))
++		return PTR_ERR(dsi->regs);
++
++	if (DSI_PORT_READ(ID) != DSI_ID_VALUE) {
++		dev_err(dev, "Port returned 0x%08x for ID instead of 0x%08x\n",
++			DSI_PORT_READ(ID), DSI_ID_VALUE);
++		return -ENODEV;
++	}
++
++	if (DSI_PORT_READ(CTRL) == 0) {
++		dev_info(dev, "DSI not set up by firmware.\n");
++		return 0;
++	}
++
++	/* Set this flag to indicate that we're relying on boot-time
++	 * DSI state and can't successfully reconfigure DSI yet.
++	 */
++	dsi->use_firmware_setup = VC4_DSI_USE_FIRMWARE_SETUP;
++
++	if (dsi->use_firmware_setup) {
++		/* Increment references to the various clocks so that
++		 * they stay always enabled and the clock framework
++		 * doesn't disable their parents.
++		 */
++		ret = clk_prepare_enable(dsi->escape_clock);
++		if (ret) {
++			DRM_ERROR("Failed to refcount DSI escape clock: %d\n", ret);
++			return ret;
++		}
++
++		ret = clk_prepare_enable(dsi->pll_phy_clock);
++		if (ret) {
++			DRM_ERROR("Failed to refcount DSI PLL: %d\n", ret);
++			return ret;
++		}
++
++		ret = clk_prepare_enable(dsi->pixel_clock);
++		if (ret) {
++			DRM_ERROR("Failed to refcount pixel clock: %d\n", ret);
++			return ret;
++		}
++	}
++
++	/* DSI1 has a broken AXI slave that doesn't respond to writes
++	 * from the ARM.  It does handle writes from the DMA engine,
++	 * so set up a channel for talking to it.
++	 */
++	if (dsi->port == 1) {
++		dsi->reg_dma_mem = dma_alloc_coherent(dev, 4,
++						      &dsi->reg_dma_paddr,
++						      GFP_KERNEL);
++		if (!dsi->reg_dma_mem) {
++			DRM_ERROR("Failed to get DMA memory\n");
++			return -ENOMEM;
++		}
++
++		dma_cap_zero(dma_mask);
++		dma_cap_set(DMA_MEMCPY, dma_mask);
++		dsi->reg_dma_chan = dma_request_channel(dma_mask, NULL, NULL);
++		if (IS_ERR(dsi->reg_dma_chan)) {
++			ret = PTR_ERR(dsi->reg_dma_chan);
++			if (ret != -EPROBE_DEFER)
++				DRM_ERROR("Failed to get DMA channel: %d\n",
++					  ret);
++			return ret;
++		}
++
++		/* Get the physical address of the device's registers.  The
++		 * struct resource for the regs gives us the bus address
++		 * instead.
++		 */
++		dsi->reg_paddr = be32_to_cpup(of_get_address(dev->of_node,
++							     0, NULL, NULL));
++	}
++
++	init_completion(&dsi->xfer_completion);
++	/* At startup enable error-reporting interrupts and nothing else. */
++	DSI_PORT_WRITE(INT_EN, DSI1_INTERRUPTS_ALWAYS_ENABLED);
++	/* Clear any existing interrupt state. */
++	DSI_PORT_WRITE(INT_STAT, DSI_PORT_READ(INT_STAT));
++
++	ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
++			       vc4_dsi_irq_handler, 0, "vc4 dsi", dsi);
++	if (ret) {
++		if (ret != -EPROBE_DEFER)
++			dev_err(dev, "Failed to get interrupt: %d\n", ret);
++		return ret;
++	}
++
++	dsi->escape_clock = devm_clk_get(dev, "escape");
++	if (IS_ERR(dsi->escape_clock)) {
++		ret = PTR_ERR(dsi->escape_clock);
++		if (ret != -EPROBE_DEFER)
++			dev_err(dev, "Failed to get escape clock: %d\n", ret);
++		return ret;
++	}
++
++	dsi->pll_phy_clock = devm_clk_get(dev, "phy");
++	if (IS_ERR(dsi->pll_phy_clock)) {
++		ret = PTR_ERR(dsi->pll_phy_clock);
++		if (ret != -EPROBE_DEFER)
++			dev_err(dev, "Failed to get phy clock: %d\n", ret);
++		return ret;
++	}
++
++	dsi->pixel_clock = devm_clk_get(dev, "pixel");
++	if (IS_ERR(dsi->pixel_clock)) {
++		ret = PTR_ERR(dsi->pixel_clock);
++		if (ret != -EPROBE_DEFER)
++			dev_err(dev, "Failed to get pixel clock: %d\n", ret);
++		return ret;
++	}
++
++	/* The esc clock rate is supposed to always be 100Mhz. */
++	ret = clk_set_rate(dsi->escape_clock, 100 * 1000000);
++	if (ret) {
++		dev_err(dev, "Failed to set esc clock: %d\n", ret);
++		return ret;
++	}
++
++	ret = vc4_dsi_init_phy_byte_clock(dsi);
++	if (ret)
++		return ret;
++
++	if (dsi->port == 1)
++		vc4->dsi1 = dsi;
++
++	drm_encoder_init(drm, dsi->encoder, &vc4_dsi_encoder_funcs,
++			 DRM_MODE_ENCODER_DSI);
++	drm_encoder_helper_add(dsi->encoder, &vc4_dsi_encoder_helper_funcs);
++
++	dsi->connector = vc4_dsi_connector_init(drm, dsi);
++	if (IS_ERR(dsi->connector)) {
++		ret = PTR_ERR(dsi->connector);
++		goto err_destroy_encoder;
++	}
++
++	dsi->dsi_host.ops = &vc4_dsi_host_ops;
++	dsi->dsi_host.dev = dev;
++
++	mipi_dsi_host_register(&dsi->dsi_host);
++
++	dev_set_drvdata(dev, dsi);
++
++	return 0;
++
++err_destroy_encoder:
++	vc4_dsi_encoder_destroy(dsi->encoder);
++
++	return ret;
++}
++
++static void vc4_dsi_unbind(struct device *dev, struct device *master,
++			   void *data)
++{
++	struct drm_device *drm = dev_get_drvdata(master);
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
++	struct vc4_dsi *dsi = dev_get_drvdata(dev);
++
++	vc4_dsi_connector_destroy(dsi->connector);
++	vc4_dsi_encoder_destroy(dsi->encoder);
++
++	mipi_dsi_host_unregister(&dsi->dsi_host);
++
++	if (!dsi->use_firmware_setup) {
++		clk_disable_unprepare(dsi->pll_phy_clock);
++		clk_disable_unprepare(dsi->escape_clock);
++		clk_disable_unprepare(dsi->pixel_clock);
++	}
++
++	if (dsi->port == 1)
++		vc4->dsi1 = NULL;
++}
++
++static const struct component_ops vc4_dsi_ops = {
++	.bind   = vc4_dsi_bind,
++	.unbind = vc4_dsi_unbind,
++};
++
++static int vc4_dsi_dev_probe(struct platform_device *pdev)
++{
++	return component_add(&pdev->dev, &vc4_dsi_ops);
++}
++
++static int vc4_dsi_dev_remove(struct platform_device *pdev)
++{
++	component_del(&pdev->dev, &vc4_dsi_ops);
++	return 0;
++}
++
++struct platform_driver vc4_dsi_driver = {
++	.probe = vc4_dsi_dev_probe,
++	.remove = vc4_dsi_dev_remove,
++	.driver = {
++		.name = "vc4_dsi",
++		.of_match_table = vc4_dsi_dt_match,
++	},
++};
+diff --git a/drivers/gpu/drm/vc4/vc4_firmware_kms.c b/drivers/gpu/drm/vc4/vc4_firmware_kms.c
+new file mode 100644
+index 0000000..a1b6511
+--- /dev/null
++++ b/drivers/gpu/drm/vc4/vc4_firmware_kms.c
+@@ -0,0 +1,660 @@
++/*
++ * Copyright (C) 2016 Broadcom
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation.
++ */
++
++/**
++ * DOC: VC4 firmware KMS module.
++ *
++ * As a hack to get us from the current closed source driver world
++ * toward a totally open stack, implement KMS on top of the Raspberry
++ * Pi's firmware display stack.
++ */
++
++#include "drm_atomic.h"
++#include "drm_atomic_helper.h"
++#include "drm_plane_helper.h"
++#include "drm_crtc_helper.h"
++#include "linux/clk.h"
++#include "linux/debugfs.h"
++#include "drm_fb_cma_helper.h"
++#include "linux/component.h"
++#include "linux/of_device.h"
++#include "vc4_drv.h"
++#include "vc4_regs.h"
++#include <soc/bcm2835/raspberrypi-firmware.h>
++
++/* The firmware delivers a vblank interrupt to us through the SMI
++ * hardware, which has only this one register.
++ */
++#define SMICS 0x0
++#define SMICS_INTERRUPTS (BIT(9) | BIT(10) | BIT(11))
++
++struct vc4_crtc {
++	struct drm_crtc base;
++	struct drm_encoder *encoder;
++	struct drm_connector *connector;
++	void __iomem *regs;
++
++	struct drm_pending_vblank_event *event;
++};
++
++static inline struct vc4_crtc *to_vc4_crtc(struct drm_crtc *crtc)
++{
++	return container_of(crtc, struct vc4_crtc, base);
++}
++
++struct vc4_fkms_encoder {
++	struct drm_encoder base;
++};
++
++static inline struct vc4_fkms_encoder *
++to_vc4_fkms_encoder(struct drm_encoder *encoder)
++{
++	return container_of(encoder, struct vc4_fkms_encoder, base);
++}
++
++/* VC4 FKMS connector KMS struct */
++struct vc4_fkms_connector {
++	struct drm_connector base;
++
++	/* Since the connector is attached to just the one encoder,
++	 * this is the reference to it so we can do the best_encoder()
++	 * hook.
++	 */
++	struct drm_encoder *encoder;
++};
++
++static inline struct vc4_fkms_connector *
++to_vc4_fkms_connector(struct drm_connector *connector)
++{
++	return container_of(connector, struct vc4_fkms_connector, base);
++}
++
++/* Firmware's structure for making an FB mbox call. */
++struct fbinfo_s {
++	u32 xres, yres, xres_virtual, yres_virtual;
++	u32 pitch, bpp;
++	u32 xoffset, yoffset;
++	u32 base;
++	u32 screen_size;
++	u16 cmap[256];
++};
++
++struct vc4_fkms_plane {
++	struct drm_plane base;
++	struct fbinfo_s *fbinfo;
++	dma_addr_t fbinfo_bus_addr;
++	u32 pitch;
++};
++
++static inline struct vc4_fkms_plane *to_vc4_fkms_plane(struct drm_plane *plane)
++{
++	return (struct vc4_fkms_plane *)plane;
++}
++
++/* Turns the display on/off. */
++static int vc4_plane_set_primary_blank(struct drm_plane *plane, bool blank)
++{
++	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
++
++	u32 packet = blank;
++	return rpi_firmware_property(vc4->firmware,
++				     RPI_FIRMWARE_FRAMEBUFFER_BLANK,
++				     &packet, sizeof(packet));
++}
++
++static void vc4_primary_plane_atomic_update(struct drm_plane *plane,
++					    struct drm_plane_state *old_state)
++{
++	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
++	struct vc4_fkms_plane *vc4_plane = to_vc4_fkms_plane(plane);
++	struct drm_plane_state *state = plane->state;
++	struct drm_framebuffer *fb = state->fb;
++	struct drm_gem_cma_object *bo = drm_fb_cma_get_gem_obj(fb, 0);
++	volatile struct fbinfo_s *fbinfo = vc4_plane->fbinfo;
++	u32 bpp = 32;
++	int ret;
++
++	vc4_plane_set_primary_blank(plane, false);
++
++	fbinfo->xres = state->crtc_w;
++	fbinfo->yres = state->crtc_h;
++	fbinfo->xres_virtual = state->crtc_w;
++	fbinfo->yres_virtual = state->crtc_h;
++	fbinfo->bpp = bpp;
++	fbinfo->xoffset = state->crtc_x;
++	fbinfo->yoffset = state->crtc_y;
++	fbinfo->base = bo->paddr + fb->offsets[0];
++	fbinfo->pitch = fb->pitches[0];
++	/* A bug in the firmware makes it so that if the fb->base is
++	 * set to nonzero, the configured pitch gets overwritten with
++	 * the previous pitch.  So, to get the configured pitch
++	 * recomputed, we have to make it allocate itself a new buffer
++	 * in VC memory, first.
++	 */
++	if (vc4_plane->pitch != fb->pitches[0]) {
++		u32 saved_base = fbinfo->base;
++		fbinfo->base = 0;
++
++		ret = rpi_firmware_transaction(vc4->firmware,
++					       RPI_FIRMWARE_CHAN_FB,
++					       vc4_plane->fbinfo_bus_addr);
++		fbinfo->base = saved_base;
++
++		vc4_plane->pitch = fbinfo->pitch;
++		WARN_ON_ONCE(vc4_plane->pitch != fb->pitches[0]);
++	}
++
++	ret = rpi_firmware_transaction(vc4->firmware,
++				       RPI_FIRMWARE_CHAN_FB,
++				       vc4_plane->fbinfo_bus_addr);
++	WARN_ON_ONCE(fbinfo->pitch != fb->pitches[0]);
++	WARN_ON_ONCE(fbinfo->base != bo->paddr + fb->offsets[0]);
++}
++
++static void vc4_primary_plane_atomic_disable(struct drm_plane *plane,
++					     struct drm_plane_state *old_state)
++{
++	vc4_plane_set_primary_blank(plane, true);
++}
++
++static void vc4_cursor_plane_atomic_update(struct drm_plane *plane,
++					   struct drm_plane_state *old_state)
++{
++	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
++	struct drm_plane_state *state = plane->state;
++	struct drm_framebuffer *fb = state->fb;
++	struct drm_gem_cma_object *bo = drm_fb_cma_get_gem_obj(fb, 0);
++	int ret;
++	u32 packet_state[] = { true, state->crtc_x, state->crtc_y, 0 };
++	u32 packet_info[] = { state->crtc_w, state->crtc_h,
++			      0, /* unused */
++			      bo->paddr + fb->offsets[0],
++			      0, 0, /* hotx, hoty */};
++	WARN_ON_ONCE(fb->pitches[0] != state->crtc_w * 4);
++	WARN_ON_ONCE(fb->bits_per_pixel != 32);
++
++	ret = rpi_firmware_property(vc4->firmware,
++				    RPI_FIRMWARE_SET_CURSOR_STATE,
++				    &packet_state,
++				    sizeof(packet_state));
++	if (ret || packet_state[0] != 0)
++		DRM_ERROR("Failed to set cursor state: 0x%08x\n", packet_state[0]);
++
++	ret = rpi_firmware_property(vc4->firmware,
++				    RPI_FIRMWARE_SET_CURSOR_INFO,
++				    &packet_info,
++				    sizeof(packet_info));
++	if (ret || packet_info[0] != 0)
++		DRM_ERROR("Failed to set cursor info: 0x%08x\n", packet_info[0]);
++}
++
++static void vc4_cursor_plane_atomic_disable(struct drm_plane *plane,
++					    struct drm_plane_state *old_state)
++{
++	struct vc4_dev *vc4 = to_vc4_dev(plane->dev);
++	u32 packet_state[] = { false, 0, 0, 0 };
++	int ret;
++
++	ret = rpi_firmware_property(vc4->firmware,
++				    RPI_FIRMWARE_SET_CURSOR_STATE,
++				    &packet_state,
++				    sizeof(packet_state));
++	if (ret || packet_state[0] != 0)
++		DRM_ERROR("Failed to set cursor state: 0x%08x\n", packet_state[0]);
++}
++
++static int vc4_plane_atomic_check(struct drm_plane *plane,
++				  struct drm_plane_state *state)
++{
++	return 0;
++}
++
++static void vc4_plane_destroy(struct drm_plane *plane)
++{
++	drm_plane_helper_disable(plane);
++	drm_plane_cleanup(plane);
++}
++
++static const struct drm_plane_funcs vc4_plane_funcs = {
++	.update_plane = drm_atomic_helper_update_plane,
++	.disable_plane = drm_atomic_helper_disable_plane,
++	.destroy = vc4_plane_destroy,
++	.set_property = NULL,
++	.reset = drm_atomic_helper_plane_reset,
++	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
++};
++
++static const struct drm_plane_helper_funcs vc4_primary_plane_helper_funcs = {
++	.prepare_fb = NULL,
++	.cleanup_fb = NULL,
++	.atomic_check = vc4_plane_atomic_check,
++	.atomic_update = vc4_primary_plane_atomic_update,
++	.atomic_disable = vc4_primary_plane_atomic_disable,
++};
++
++static const struct drm_plane_helper_funcs vc4_cursor_plane_helper_funcs = {
++	.prepare_fb = NULL,
++	.cleanup_fb = NULL,
++	.atomic_check = vc4_plane_atomic_check,
++	.atomic_update = vc4_cursor_plane_atomic_update,
++	.atomic_disable = vc4_cursor_plane_atomic_disable,
++};
++
++static struct drm_plane *vc4_fkms_plane_init(struct drm_device *dev,
++					     enum drm_plane_type type)
++{
++	struct drm_plane *plane = NULL;
++	struct vc4_fkms_plane *vc4_plane;
++	u32 xrgb8888 = DRM_FORMAT_XRGB8888;
++	u32 argb8888 = DRM_FORMAT_ARGB8888;
++	int ret = 0;
++	bool primary = (type == DRM_PLANE_TYPE_PRIMARY);
++
++	vc4_plane = devm_kzalloc(dev->dev, sizeof(*vc4_plane),
++				 GFP_KERNEL);
++	if (!vc4_plane) {
++		ret = -ENOMEM;
++		goto fail;
++	}
++
++	plane = &vc4_plane->base;
++	ret = drm_universal_plane_init(dev, plane, 0xff,
++				       &vc4_plane_funcs,
++				       primary ? &xrgb8888 : &argb8888, 1,
++				       type);
++
++	if (type == DRM_PLANE_TYPE_PRIMARY) {
++		vc4_plane->fbinfo =
++			dma_alloc_coherent(dev->dev,
++					   sizeof(*vc4_plane->fbinfo),
++					   &vc4_plane->fbinfo_bus_addr,
++					   GFP_KERNEL);
++		memset(vc4_plane->fbinfo, 0, sizeof(*vc4_plane->fbinfo));
++
++		drm_plane_helper_add(plane, &vc4_primary_plane_helper_funcs);
++	} else {
++		drm_plane_helper_add(plane, &vc4_cursor_plane_helper_funcs);
++	}
++
++	return plane;
++fail:
++	if (plane)
++		vc4_plane_destroy(plane);
++
++	return ERR_PTR(ret);
++}
++
++static void vc4_crtc_mode_set_nofb(struct drm_crtc *crtc)
++{
++	/* Everyting is handled in the planes. */
++}
++
++static void vc4_crtc_disable(struct drm_crtc *crtc)
++{
++}
++
++static void vc4_crtc_enable(struct drm_crtc *crtc)
++{
++}
++
++static int vc4_crtc_atomic_check(struct drm_crtc *crtc,
++				 struct drm_crtc_state *state)
++{
++	return 0;
++}
++
++static void vc4_crtc_atomic_flush(struct drm_crtc *crtc,
++				  struct drm_crtc_state *old_state)
++{
++}
++
++static void vc4_crtc_handle_page_flip(struct vc4_crtc *vc4_crtc)
++{
++	struct drm_crtc *crtc = &vc4_crtc->base;
++	struct drm_device *dev = crtc->dev;
++	unsigned long flags;
++
++	spin_lock_irqsave(&dev->event_lock, flags);
++	if (vc4_crtc->event) {
++		drm_crtc_send_vblank_event(crtc, vc4_crtc->event);
++		vc4_crtc->event = NULL;
++		drm_crtc_vblank_put(crtc);
++	}
++	spin_unlock_irqrestore(&dev->event_lock, flags);
++}
++
++static irqreturn_t vc4_crtc_irq_handler(int irq, void *data)
++{
++	struct vc4_crtc *vc4_crtc = data;
++	u32 stat = readl(vc4_crtc->regs + SMICS);
++	irqreturn_t ret = IRQ_NONE;
++
++	if (stat & SMICS_INTERRUPTS) {
++		writel(0, vc4_crtc->regs + SMICS);
++		drm_crtc_handle_vblank(&vc4_crtc->base);
++		vc4_crtc_handle_page_flip(vc4_crtc);
++		ret = IRQ_HANDLED;
++	}
++
++	return ret;
++}
++
++static int vc4_page_flip(struct drm_crtc *crtc,
++			 struct drm_framebuffer *fb,
++			 struct drm_pending_vblank_event *event,
++			 uint32_t flags)
++{
++	if (flags & DRM_MODE_PAGE_FLIP_ASYNC) {
++		DRM_ERROR("Async flips aren't allowed\n");
++		return -EINVAL;
++	}
++
++	return drm_atomic_helper_page_flip(crtc, fb, event, flags);
++}
++
++static const struct drm_crtc_funcs vc4_crtc_funcs = {
++	.set_config = drm_atomic_helper_set_config,
++	.destroy = drm_crtc_cleanup,
++	.page_flip = vc4_page_flip,
++	.set_property = NULL,
++	.cursor_set = NULL, /* handled by drm_mode_cursor_universal */
++	.cursor_move = NULL, /* handled by drm_mode_cursor_universal */
++	.reset = drm_atomic_helper_crtc_reset,
++	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
++};
++
++static const struct drm_crtc_helper_funcs vc4_crtc_helper_funcs = {
++	.mode_set_nofb = vc4_crtc_mode_set_nofb,
++	.disable = vc4_crtc_disable,
++	.enable = vc4_crtc_enable,
++	.atomic_check = vc4_crtc_atomic_check,
++	.atomic_flush = vc4_crtc_atomic_flush,
++};
++
++/* Frees the page flip event when the DRM device is closed with the
++ * event still outstanding.
++ */
++void vc4_fkms_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file)
++{
++	struct vc4_crtc *vc4_crtc = to_vc4_crtc(crtc);
++	struct drm_device *dev = crtc->dev;
++	unsigned long flags;
++
++	spin_lock_irqsave(&dev->event_lock, flags);
++
++	if (vc4_crtc->event && vc4_crtc->event->base.file_priv == file) {
++		vc4_crtc->event->base.destroy(&vc4_crtc->event->base);
++		drm_crtc_vblank_put(crtc);
++		vc4_crtc->event = NULL;
++	}
++
++	spin_unlock_irqrestore(&dev->event_lock, flags);
++}
++
++static const struct of_device_id vc4_firmware_kms_dt_match[] = {
++	{ .compatible = "raspberrypi,rpi-firmware-kms" },
++	{}
++};
++
++static enum drm_connector_status
++vc4_fkms_connector_detect(struct drm_connector *connector, bool force)
++{
++	return connector_status_connected;
++}
++
++static int vc4_fkms_connector_get_modes(struct drm_connector *connector)
++{
++	struct drm_device *dev = connector->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	u32 wh[2] = {0, 0};
++	int ret;
++	struct drm_display_mode *mode;
++
++	ret = rpi_firmware_property(vc4->firmware,
++				    RPI_FIRMWARE_FRAMEBUFFER_GET_PHYSICAL_WIDTH_HEIGHT,
++				    &wh, sizeof(wh));
++	if (ret) {
++		DRM_ERROR("Failed to get screen size: %d (0x%08x 0x%08x)\n",
++			  ret, wh[0], wh[1]);
++		return 0;
++	}
++
++	mode = drm_cvt_mode(dev, wh[0], wh[1], 60 /* vrefresh */,
++			    0, 0, false);
++	drm_mode_probed_add(connector, mode);
++
++	return 1;
++}
++
++static struct drm_encoder *
++vc4_fkms_connector_best_encoder(struct drm_connector *connector)
++{
++	struct vc4_fkms_connector *fkms_connector =
++		to_vc4_fkms_connector(connector);
++	return fkms_connector->encoder;
++}
++
++static void vc4_fkms_connector_destroy(struct drm_connector *connector)
++{
++	drm_connector_unregister(connector);
++	drm_connector_cleanup(connector);
++}
++
++static const struct drm_connector_funcs vc4_fkms_connector_funcs = {
++	.dpms = drm_atomic_helper_connector_dpms,
++	.detect = vc4_fkms_connector_detect,
++	.fill_modes = drm_helper_probe_single_connector_modes,
++	.destroy = vc4_fkms_connector_destroy,
++	.reset = drm_atomic_helper_connector_reset,
++	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
++	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
++};
++
++static const struct drm_connector_helper_funcs vc4_fkms_connector_helper_funcs = {
++	.get_modes = vc4_fkms_connector_get_modes,
++	.best_encoder = vc4_fkms_connector_best_encoder,
++};
++
++static struct drm_connector *vc4_fkms_connector_init(struct drm_device *dev,
++						     struct drm_encoder *encoder)
++{
++	struct drm_connector *connector = NULL;
++	struct vc4_fkms_connector *fkms_connector;
++	int ret = 0;
++
++	fkms_connector = devm_kzalloc(dev->dev, sizeof(*fkms_connector),
++				      GFP_KERNEL);
++	if (!fkms_connector) {
++		ret = -ENOMEM;
++		goto fail;
++	}
++	connector = &fkms_connector->base;
++
++	fkms_connector->encoder = encoder;
++
++	drm_connector_init(dev, connector, &vc4_fkms_connector_funcs,
++			   DRM_MODE_CONNECTOR_HDMIA);
++	drm_connector_helper_add(connector, &vc4_fkms_connector_helper_funcs);
++
++	connector->polled = (DRM_CONNECTOR_POLL_CONNECT |
++			     DRM_CONNECTOR_POLL_DISCONNECT);
++
++	connector->interlace_allowed = 0;
++	connector->doublescan_allowed = 0;
++
++	drm_mode_connector_attach_encoder(connector, encoder);
++
++	return connector;
++
++ fail:
++	if (connector)
++		vc4_fkms_connector_destroy(connector);
++
++	return ERR_PTR(ret);
++}
++
++static void vc4_fkms_encoder_destroy(struct drm_encoder *encoder)
++{
++	drm_encoder_cleanup(encoder);
++}
++
++static const struct drm_encoder_funcs vc4_fkms_encoder_funcs = {
++	.destroy = vc4_fkms_encoder_destroy,
++};
++
++static void vc4_fkms_encoder_enable(struct drm_encoder *encoder)
++{
++}
++
++static void vc4_fkms_encoder_disable(struct drm_encoder *encoder)
++{
++}
++
++static const struct drm_encoder_helper_funcs vc4_fkms_encoder_helper_funcs = {
++	.enable = vc4_fkms_encoder_enable,
++	.disable = vc4_fkms_encoder_disable,
++};
++
++static int vc4_fkms_bind(struct device *dev, struct device *master, void *data)
++{
++	struct platform_device *pdev = to_platform_device(dev);
++	struct drm_device *drm = dev_get_drvdata(master);
++	struct vc4_dev *vc4 = to_vc4_dev(drm);
++	struct vc4_crtc *vc4_crtc;
++	struct vc4_fkms_encoder *vc4_encoder;
++	struct drm_crtc *crtc;
++	struct drm_plane *primary_plane, *cursor_plane, *destroy_plane, *temp;
++	struct device_node *firmware_node;
++	int ret;
++
++	vc4->firmware_kms = true;
++
++	vc4_crtc = devm_kzalloc(dev, sizeof(*vc4_crtc), GFP_KERNEL);
++	if (!vc4_crtc)
++		return -ENOMEM;
++	crtc = &vc4_crtc->base;
++
++	firmware_node = of_parse_phandle(dev->of_node, "brcm,firmware", 0);
++	vc4->firmware = rpi_firmware_get(firmware_node);
++	if (!vc4->firmware) {
++		DRM_DEBUG("Failed to get Raspberry Pi firmware reference.\n");
++		return -EPROBE_DEFER;
++	}
++	of_node_put(firmware_node);
++
++	/* Map the SMI interrupt reg */
++	vc4_crtc->regs = vc4_ioremap_regs(pdev, 0);
++	if (IS_ERR(vc4_crtc->regs))
++		return PTR_ERR(vc4_crtc->regs);
++
++	/* For now, we create just the primary and the legacy cursor
++	 * planes.  We should be able to stack more planes on easily,
++	 * but to do that we would need to compute the bandwidth
++	 * requirement of the plane configuration, and reject ones
++	 * that will take too much.
++	 */
++	primary_plane = vc4_fkms_plane_init(drm, DRM_PLANE_TYPE_PRIMARY);
++	if (IS_ERR(primary_plane)) {
++		dev_err(dev, "failed to construct primary plane\n");
++		ret = PTR_ERR(primary_plane);
++		goto err;
++	}
++
++	cursor_plane = vc4_fkms_plane_init(drm, DRM_PLANE_TYPE_CURSOR);
++	if (IS_ERR(cursor_plane)) {
++		dev_err(dev, "failed to construct cursor plane\n");
++		ret = PTR_ERR(cursor_plane);
++		goto err;
++	}
++
++	drm_crtc_init_with_planes(drm, crtc, primary_plane, cursor_plane,
++				  &vc4_crtc_funcs);
++	drm_crtc_helper_add(crtc, &vc4_crtc_helper_funcs);
++	primary_plane->crtc = crtc;
++	cursor_plane->crtc = crtc;
++	vc4->crtc[drm_crtc_index(crtc)] = vc4_crtc;
++
++	vc4_encoder = devm_kzalloc(dev, sizeof(*vc4_encoder), GFP_KERNEL);
++	if (!vc4_encoder)
++		return -ENOMEM;
++	vc4_crtc->encoder = &vc4_encoder->base;
++	vc4_encoder->base.possible_crtcs |= drm_crtc_mask(crtc) ;
++	drm_encoder_init(drm, &vc4_encoder->base, &vc4_fkms_encoder_funcs,
++			 DRM_MODE_ENCODER_TMDS);
++	drm_encoder_helper_add(&vc4_encoder->base,
++			       &vc4_fkms_encoder_helper_funcs);
++
++	vc4_crtc->connector = vc4_fkms_connector_init(drm, &vc4_encoder->base);
++	if (IS_ERR(vc4_crtc->connector)) {
++		ret = PTR_ERR(vc4_crtc->connector);
++		goto err_destroy_encoder;
++	}
++
++	writel(0, vc4_crtc->regs + SMICS);
++	ret = devm_request_irq(dev, platform_get_irq(pdev, 0),
++			       vc4_crtc_irq_handler, 0, "vc4 firmware kms",
++			       vc4_crtc);
++	if (ret)
++		goto err_destroy_connector;
++
++	platform_set_drvdata(pdev, vc4_crtc);
++
++	return 0;
++
++err_destroy_connector:
++	vc4_fkms_connector_destroy(vc4_crtc->connector);
++err_destroy_encoder:
++	vc4_fkms_encoder_destroy(vc4_crtc->encoder);
++	list_for_each_entry_safe(destroy_plane, temp,
++				 &drm->mode_config.plane_list, head) {
++		if (destroy_plane->possible_crtcs == 1 << drm_crtc_index(crtc))
++		    destroy_plane->funcs->destroy(destroy_plane);
++	}
++err:
++	return ret;
++}
++
++static void vc4_fkms_unbind(struct device *dev, struct device *master,
++			    void *data)
++{
++	struct platform_device *pdev = to_platform_device(dev);
++	struct vc4_crtc *vc4_crtc = dev_get_drvdata(dev);
++
++	vc4_fkms_connector_destroy(vc4_crtc->connector);
++	vc4_fkms_encoder_destroy(vc4_crtc->encoder);
++	drm_crtc_cleanup(&vc4_crtc->base);
++
++	platform_set_drvdata(pdev, NULL);
++}
++
++static const struct component_ops vc4_fkms_ops = {
++	.bind   = vc4_fkms_bind,
++	.unbind = vc4_fkms_unbind,
++};
++
++static int vc4_fkms_probe(struct platform_device *pdev)
++{
++	return component_add(&pdev->dev, &vc4_fkms_ops);
++}
++
++static int vc4_fkms_remove(struct platform_device *pdev)
++{
++	component_del(&pdev->dev, &vc4_fkms_ops);
++	return 0;
++}
++
++struct platform_driver vc4_firmware_kms_driver = {
++	.probe = vc4_fkms_probe,
++	.remove = vc4_fkms_remove,
++	.driver = {
++		.name = "vc4_firmware_kms",
++		.of_match_table = vc4_firmware_kms_dt_match,
++	},
++};
 diff --git a/drivers/gpu/drm/vc4/vc4_gem.c b/drivers/gpu/drm/vc4/vc4_gem.c
 new file mode 100644
-index 0000000..9b03a90
+index 0000000..3fa4501
 --- /dev/null
 +++ b/drivers/gpu/drm/vc4/vc4_gem.c
-@@ -0,0 +1,942 @@
+@@ -0,0 +1,977 @@
 +/*
 + * Copyright  2014 Broadcom
 + *
@@ -29638,6 +34979,7 @@ index 0000000..9b03a90
 +
 +#include <linux/module.h>
 +#include <linux/platform_device.h>
++#include <linux/pm_runtime.h>
 +#include <linux/device.h>
 +#include <linux/io.h>
 +
@@ -29875,8 +35217,16 @@ index 0000000..9b03a90
 +	struct vc4_dev *vc4 = to_vc4_dev(dev);
 +
 +	DRM_INFO("Resetting GPU.\n");
-+	vc4_v3d_set_power(vc4, false);
-+	vc4_v3d_set_power(vc4, true);
++
++	mutex_lock(&vc4->power_lock);
++	if (vc4->power_refcount) {
++		/* Power the device off and back on the by dropping the
++		 * reference on runtime PM.
++		 */
++		pm_runtime_put_sync_suspend(&vc4->v3d->pdev->dev);
++		pm_runtime_get_sync(&vc4->v3d->pdev->dev);
++	}
++	mutex_unlock(&vc4->power_lock);
 +
 +	vc4_irq_reset(dev);
 +
@@ -30041,10 +35391,6 @@ index 0000000..9b03a90
 +
 +	vc4_flush_caches(dev);
 +
-+	/* Disable the binner's pre-loaded overflow memory address */
-+	V3D_WRITE(V3D_BPOA, 0);
-+	V3D_WRITE(V3D_BPOS, 0);
-+
 +	/* Either put the job in the binner if it uses the binner, or
 +	 * immediately move it to the to-be-rendered queue.
 +	 */
@@ -30093,6 +35439,11 @@ index 0000000..9b03a90
 +	list_for_each_entry(bo, &exec->unref_list, unref_head) {
 +		bo->seqno = seqno;
 +	}
++
++	for (i = 0; i < exec->rcl_write_bo_count; i++) {
++		bo = to_vc4_bo(&exec->rcl_write_bo[i]->base);
++		bo->write_seqno = seqno;
++	}
 +}
 +
 +/* Queues a struct vc4_exec_info for execution.  If no job is
@@ -30194,8 +35545,8 @@ index 0000000..9b03a90
 +	spin_unlock(&file_priv->table_lock);
 +
 +fail:
-+	kfree(handles);
-+	return 0;
++	drm_free_large(handles);
++	return ret;
 +}
 +
 +static int
@@ -30295,6 +35646,14 @@ index 0000000..9b03a90
 +		goto fail;
 +
 +	ret = vc4_validate_shader_recs(dev, exec);
++	if (ret)
++		goto fail;
++
++	/* Block waiting on any previous rendering into the CS's VBO,
++	 * IB, or textures, so that pixels are actually written by the
++	 * time we try to read them.
++	 */
++	ret = vc4_wait_for_seqno(dev, exec->bin_dep_seqno, ~0ull, true);
 +
 +fail:
 +	kfree(temp);
@@ -30304,6 +35663,7 @@ index 0000000..9b03a90
 +static void
 +vc4_complete_exec(struct drm_device *dev, struct vc4_exec_info *exec)
 +{
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
 +	unsigned i;
 +
 +	/* Need the struct lock for drm_gem_object_unreference(). */
@@ -30322,6 +35682,11 @@ index 0000000..9b03a90
 +	}
 +	mutex_unlock(&dev->struct_mutex);
 +
++	mutex_lock(&vc4->power_lock);
++	if (--vc4->power_refcount == 0)
++		pm_runtime_put(&vc4->v3d->pdev->dev);
++	mutex_unlock(&vc4->power_lock);
++
 +	kfree(exec);
 +}
 +
@@ -30462,7 +35827,7 @@ index 0000000..9b03a90
 +	struct vc4_dev *vc4 = to_vc4_dev(dev);
 +	struct drm_vc4_submit_cl *args = data;
 +	struct vc4_exec_info *exec;
-+	int ret;
++	int ret = 0;
 +
 +	if ((args->flags & ~VC4_SUBMIT_CL_USE_CLEAR_COLOR) != 0) {
 +		DRM_ERROR("Unknown flags: 0x%02x\n", args->flags);
@@ -30475,6 +35840,15 @@ index 0000000..9b03a90
 +		return -ENOMEM;
 +	}
 +
++	mutex_lock(&vc4->power_lock);
++	if (vc4->power_refcount++ == 0)
++		ret = pm_runtime_get_sync(&vc4->v3d->pdev->dev);
++	mutex_unlock(&vc4->power_lock);
++	if (ret < 0) {
++		kfree(exec);
++		return ret;
++	}
++
 +	exec->args = args;
 +	INIT_LIST_HEAD(&exec->unref_list);
 +
@@ -30530,6 +35904,8 @@ index 0000000..9b03a90
 +		    (unsigned long)dev);
 +
 +	INIT_WORK(&vc4->job_done_work, vc4_job_done_work);
++
++	mutex_init(&vc4->power_lock);
 +}
 +
 +void
@@ -30556,7 +35932,7 @@ index 0000000..9b03a90
 +		vc4_free_hang_state(dev, vc4->hang_state);
 +}
 diff --git a/drivers/gpu/drm/vc4/vc4_hdmi.c b/drivers/gpu/drm/vc4/vc4_hdmi.c
-index da9a36d..69650a8 100644
+index da9a36d..99018be 100644
 --- a/drivers/gpu/drm/vc4/vc4_hdmi.c
 +++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
 @@ -47,6 +47,7 @@ struct vc4_hdmi {
@@ -30567,7 +35943,16 @@ index da9a36d..69650a8 100644
  
  	struct clk *pixel_clock;
  	struct clk *hsm_clock;
-@@ -95,6 +96,7 @@ static const struct {
+@@ -61,6 +62,8 @@ struct vc4_hdmi {
+ struct vc4_hdmi_encoder {
+ 	struct vc4_encoder base;
+ 	bool hdmi_monitor;
++	bool limited_rgb_range;
++	bool rgb_range_selectable;
+ };
+ 
+ static inline struct vc4_hdmi_encoder *
+@@ -95,6 +98,7 @@ static const struct {
  	HDMI_REG(VC4_HDMI_SW_RESET_CONTROL),
  	HDMI_REG(VC4_HDMI_HOTPLUG_INT),
  	HDMI_REG(VC4_HDMI_HOTPLUG),
@@ -30575,12 +35960,9 @@ index da9a36d..69650a8 100644
  	HDMI_REG(VC4_HDMI_HORZA),
  	HDMI_REG(VC4_HDMI_HORZB),
  	HDMI_REG(VC4_HDMI_FIFO_CTL),
-@@ -164,8 +166,11 @@ vc4_hdmi_connector_detect(struct drm_connector *connector, bool force)
- 	struct drm_device *dev = connector->dev;
+@@ -165,12 +169,16 @@ vc4_hdmi_connector_detect(struct drm_connector *connector, bool force)
  	struct vc4_dev *vc4 = to_vc4_dev(dev);
  
-+	return connector_status_connected;
-+
  	if (vc4->hdmi->hpd_gpio) {
 -		if (gpio_get_value(vc4->hdmi->hpd_gpio))
 +		if (gpio_get_value_cansleep(vc4->hdmi->hpd_gpio) ^
@@ -30588,7 +35970,336 @@ index da9a36d..69650a8 100644
  			return connector_status_connected;
  		else
  			return connector_status_disconnected;
-@@ -495,6 +500,16 @@ static int vc4_hdmi_bind(struct device *dev, struct device *master, void *data)
+ 	}
+ 
++	if (drm_probe_ddc(vc4->hdmi->ddc))
++		return connector_status_connected;
++
+ 	if (HDMI_READ(VC4_HDMI_HOTPLUG) & VC4_HDMI_HOTPLUG_CONNECTED)
+ 		return connector_status_connected;
+ 	else
+@@ -199,6 +207,12 @@ static int vc4_hdmi_connector_get_modes(struct drm_connector *connector)
+ 		return -ENODEV;
+ 
+ 	vc4_encoder->hdmi_monitor = drm_detect_hdmi_monitor(edid);
++
++	if (edid && edid->input & DRM_EDID_INPUT_DIGITAL) {
++		vc4_encoder->rgb_range_selectable =
++			drm_rgb_quant_range_selectable(edid);
++	}
++
+ 	drm_mode_connector_update_edid_property(connector, edid);
+ 	ret = drm_add_edid_modes(connector, edid);
+ 
+@@ -252,7 +266,7 @@ static struct drm_connector *vc4_hdmi_connector_init(struct drm_device *dev,
+ 	connector->polled = (DRM_CONNECTOR_POLL_CONNECT |
+ 			     DRM_CONNECTOR_POLL_DISCONNECT);
+ 
+-	connector->interlace_allowed = 0;
++	connector->interlace_allowed = 1;
+ 	connector->doublescan_allowed = 0;
+ 
+ 	drm_mode_connector_attach_encoder(connector, encoder);
+@@ -275,25 +289,143 @@ static const struct drm_encoder_funcs vc4_hdmi_encoder_funcs = {
+ 	.destroy = vc4_hdmi_encoder_destroy,
+ };
+ 
++static int vc4_hdmi_stop_packet(struct drm_encoder *encoder,
++				enum hdmi_infoframe_type type)
++{
++	struct drm_device *dev = encoder->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	u32 packet_id = type - 0x80;
++
++	HDMI_WRITE(VC4_HDMI_RAM_PACKET_CONFIG,
++		   HDMI_READ(VC4_HDMI_RAM_PACKET_CONFIG) & ~BIT(packet_id));
++
++	return wait_for(!(HDMI_READ(VC4_HDMI_RAM_PACKET_STATUS) &
++			  BIT(packet_id)), 100);
++}
++
++static void vc4_hdmi_write_infoframe(struct drm_encoder *encoder,
++				     union hdmi_infoframe *frame)
++{
++	struct drm_device *dev = encoder->dev;
++	struct vc4_dev *vc4 = to_vc4_dev(dev);
++	u32 packet_id = frame->any.type - 0x80;
++	u32 packet_reg = VC4_HDMI_GCP_0 + VC4_HDMI_PACKET_STRIDE * packet_id;
++	uint8_t buffer[VC4_HDMI_PACKET_STRIDE];
++	ssize_t len, i;
++	int ret;
++
++	WARN_ONCE(!(HDMI_READ(VC4_HDMI_RAM_PACKET_CONFIG) &
++		    VC4_HDMI_RAM_PACKET_ENABLE),
++		  "Packet RAM has to be on to store the packet.");
++
++	len = hdmi_infoframe_pack(frame, buffer, sizeof(buffer));
++	if (len < 0)
++		return;
++
++	ret = vc4_hdmi_stop_packet(encoder, frame->any.type);
++	if (ret) {
++		DRM_ERROR("Failed to wait for infoframe to go idle: %d\n", ret);
++		return;
++	}
++
++	for (i = 0; i < len; i += 7) {
++		HDMI_WRITE(packet_reg,
++			   buffer[i + 0] << 0 |
++			   buffer[i + 1] << 8 |
++			   buffer[i + 2] << 16);
++		packet_reg += 4;
++
++		HDMI_WRITE(packet_reg,
++			   buffer[i + 3] << 0 |
++			   buffer[i + 4] << 8 |
++			   buffer[i + 5] << 16 |
++			   buffer[i + 6] << 24);
++		packet_reg += 4;
++	}
++
++	HDMI_WRITE(VC4_HDMI_RAM_PACKET_CONFIG,
++		   HDMI_READ(VC4_HDMI_RAM_PACKET_CONFIG) | BIT(packet_id));
++	ret = wait_for((HDMI_READ(VC4_HDMI_RAM_PACKET_STATUS) &
++			BIT(packet_id)), 100);
++	if (ret)
++		DRM_ERROR("Failed to wait for infoframe to start: %d\n", ret);
++}
++
++static void vc4_hdmi_set_avi_infoframe(struct drm_encoder *encoder)
++{
++	struct vc4_hdmi_encoder *vc4_encoder = to_vc4_hdmi_encoder(encoder);
++	struct drm_crtc *crtc = encoder->crtc;
++	const struct drm_display_mode *mode = &crtc->state->adjusted_mode;
++	union hdmi_infoframe frame;
++	int ret;
++
++	ret = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode);
++	if (ret < 0) {
++		DRM_ERROR("couldn't fill AVI infoframe\n");
++		return;
++	}
++
++	if (vc4_encoder->rgb_range_selectable) {
++		if (vc4_encoder->limited_rgb_range) {
++			frame.avi.quantization_range =
++				HDMI_QUANTIZATION_RANGE_LIMITED;
++		} else {
++			frame.avi.quantization_range =
++				HDMI_QUANTIZATION_RANGE_FULL;
++		}
++	}
++
++	vc4_hdmi_write_infoframe(encoder, &frame);
++}
++
++static void vc4_hdmi_set_spd_infoframe(struct drm_encoder *encoder)
++{
++	union hdmi_infoframe frame;
++	int ret;
++
++	ret = hdmi_spd_infoframe_init(&frame.spd, "Broadcom", "Videocore");
++	if (ret < 0) {
++		DRM_ERROR("couldn't fill SPD infoframe\n");
++		return;
++	}
++
++	frame.spd.sdi = HDMI_SPD_SDI_PC;
++
++	vc4_hdmi_write_infoframe(encoder, &frame);
++}
++
++static void vc4_hdmi_set_infoframes(struct drm_encoder *encoder)
++{
++	vc4_hdmi_set_avi_infoframe(encoder);
++	vc4_hdmi_set_spd_infoframe(encoder);
++}
++
+ static void vc4_hdmi_encoder_mode_set(struct drm_encoder *encoder,
+ 				      struct drm_display_mode *unadjusted_mode,
+ 				      struct drm_display_mode *mode)
+ {
++	struct vc4_hdmi_encoder *vc4_encoder = to_vc4_hdmi_encoder(encoder);
+ 	struct drm_device *dev = encoder->dev;
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 	bool debug_dump_regs = false;
+ 	bool hsync_pos = mode->flags & DRM_MODE_FLAG_PHSYNC;
+ 	bool vsync_pos = mode->flags & DRM_MODE_FLAG_PVSYNC;
+-	u32 vactive = (mode->vdisplay >>
+-		       ((mode->flags & DRM_MODE_FLAG_INTERLACE) ? 1 : 0));
+-	u32 verta = (VC4_SET_FIELD(mode->vsync_end - mode->vsync_start,
++	bool interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;
++	u32 pixel_rep = (mode->flags & DRM_MODE_FLAG_DBLCLK) ? 2 : 1;
++	u32 verta = (VC4_SET_FIELD(mode->crtc_vsync_end - mode->crtc_vsync_start,
+ 				   VC4_HDMI_VERTA_VSP) |
+-		     VC4_SET_FIELD(mode->vsync_start - mode->vdisplay,
++		     VC4_SET_FIELD(mode->crtc_vsync_start - mode->crtc_vdisplay,
+ 				   VC4_HDMI_VERTA_VFP) |
+-		     VC4_SET_FIELD(vactive, VC4_HDMI_VERTA_VAL));
++		     VC4_SET_FIELD(mode->crtc_vdisplay, VC4_HDMI_VERTA_VAL));
+ 	u32 vertb = (VC4_SET_FIELD(0, VC4_HDMI_VERTB_VSPO) |
+-		     VC4_SET_FIELD(mode->vtotal - mode->vsync_end,
++		     VC4_SET_FIELD(mode->crtc_vtotal - mode->crtc_vsync_end,
+ 				   VC4_HDMI_VERTB_VBP));
++	u32 vertb_even = (VC4_SET_FIELD(0, VC4_HDMI_VERTB_VSPO) |
++			  VC4_SET_FIELD(mode->crtc_vtotal -
++					mode->crtc_vsync_end -
++					interlaced,
++					VC4_HDMI_VERTB_VBP));
++	u32 csc_ctl;
+ 
+ 	if (debug_dump_regs) {
+ 		DRM_INFO("HDMI regs before:\n");
+@@ -302,7 +434,8 @@ static void vc4_hdmi_encoder_mode_set(struct drm_encoder *encoder,
+ 
+ 	HD_WRITE(VC4_HD_VID_CTL, 0);
+ 
+-	clk_set_rate(vc4->hdmi->pixel_clock, mode->clock * 1000);
++	clk_set_rate(vc4->hdmi->pixel_clock, mode->clock * 1000 *
++		     ((mode->flags & DRM_MODE_FLAG_DBLCLK) ? 2 : 1));
+ 
+ 	HDMI_WRITE(VC4_HDMI_SCHEDULER_CONTROL,
+ 		   HDMI_READ(VC4_HDMI_SCHEDULER_CONTROL) |
+@@ -312,29 +445,62 @@ static void vc4_hdmi_encoder_mode_set(struct drm_encoder *encoder,
+ 	HDMI_WRITE(VC4_HDMI_HORZA,
+ 		   (vsync_pos ? VC4_HDMI_HORZA_VPOS : 0) |
+ 		   (hsync_pos ? VC4_HDMI_HORZA_HPOS : 0) |
+-		   VC4_SET_FIELD(mode->hdisplay, VC4_HDMI_HORZA_HAP));
++		   VC4_SET_FIELD(mode->hdisplay * pixel_rep,
++				 VC4_HDMI_HORZA_HAP));
+ 
+ 	HDMI_WRITE(VC4_HDMI_HORZB,
+-		   VC4_SET_FIELD(mode->htotal - mode->hsync_end,
++		   VC4_SET_FIELD((mode->htotal -
++				  mode->hsync_end) * pixel_rep,
+ 				 VC4_HDMI_HORZB_HBP) |
+-		   VC4_SET_FIELD(mode->hsync_end - mode->hsync_start,
++		   VC4_SET_FIELD((mode->hsync_end -
++				  mode->hsync_start) * pixel_rep,
+ 				 VC4_HDMI_HORZB_HSP) |
+-		   VC4_SET_FIELD(mode->hsync_start - mode->hdisplay,
++		   VC4_SET_FIELD((mode->hsync_start -
++				  mode->hdisplay) * pixel_rep,
+ 				 VC4_HDMI_HORZB_HFP));
+ 
+ 	HDMI_WRITE(VC4_HDMI_VERTA0, verta);
+ 	HDMI_WRITE(VC4_HDMI_VERTA1, verta);
+ 
+-	HDMI_WRITE(VC4_HDMI_VERTB0, vertb);
++	HDMI_WRITE(VC4_HDMI_VERTB0, vertb_even);
+ 	HDMI_WRITE(VC4_HDMI_VERTB1, vertb);
+ 
+ 	HD_WRITE(VC4_HD_VID_CTL,
+ 		 (vsync_pos ? 0 : VC4_HD_VID_CTL_VSYNC_LOW) |
+ 		 (hsync_pos ? 0 : VC4_HD_VID_CTL_HSYNC_LOW));
+ 
++	csc_ctl = VC4_SET_FIELD(VC4_HD_CSC_CTL_ORDER_BGR,
++				VC4_HD_CSC_CTL_ORDER);
++
++	if (vc4_encoder->hdmi_monitor && drm_match_cea_mode(mode) > 1) {
++		/* CEA VICs other than #1 requre limited range RGB
++		 * output unless overridden by an AVI infoframe.
++		 * Apply a colorspace conversion to squash 0-255 down
++		 * to 16-235.  The matrix here is:
++		 *
++		 * [ 0      0      0.8594 16]
++		 * [ 0      0.8594 0      16]
++		 * [ 0.8594 0      0      16]
++		 * [ 0      0      0       1]
++		 */
++		csc_ctl |= VC4_HD_CSC_CTL_ENABLE;
++		csc_ctl |= VC4_HD_CSC_CTL_RGB2YCC;
++		csc_ctl |= VC4_SET_FIELD(VC4_HD_CSC_CTL_MODE_CUSTOM,
++					 VC4_HD_CSC_CTL_MODE);
++
++		HD_WRITE(VC4_HD_CSC_12_11, (0x000 << 16) | 0x000);
++		HD_WRITE(VC4_HD_CSC_14_13, (0x100 << 16) | 0x6e0);
++		HD_WRITE(VC4_HD_CSC_22_21, (0x6e0 << 16) | 0x000);
++		HD_WRITE(VC4_HD_CSC_24_23, (0x100 << 16) | 0x000);
++		HD_WRITE(VC4_HD_CSC_32_31, (0x000 << 16) | 0x6e0);
++		HD_WRITE(VC4_HD_CSC_34_33, (0x100 << 16) | 0x000);
++		vc4_encoder->limited_rgb_range = true;
++	} else {
++		vc4_encoder->limited_rgb_range = false;
++	}
++
+ 	/* The RGB order applies even when CSC is disabled. */
+-	HD_WRITE(VC4_HD_CSC_CTL, VC4_SET_FIELD(VC4_HD_CSC_CTL_ORDER_BGR,
+-					       VC4_HD_CSC_CTL_ORDER));
++	HD_WRITE(VC4_HD_CSC_CTL, csc_ctl);
+ 
+ 	HDMI_WRITE(VC4_HDMI_FIFO_CTL, VC4_HDMI_FIFO_CTL_MASTER_SLAVE_N);
+ 
+@@ -349,6 +515,8 @@ static void vc4_hdmi_encoder_disable(struct drm_encoder *encoder)
+ 	struct drm_device *dev = encoder->dev;
+ 	struct vc4_dev *vc4 = to_vc4_dev(dev);
+ 
++	HDMI_WRITE(VC4_HDMI_RAM_PACKET_CONFIG, 0);
++
+ 	HDMI_WRITE(VC4_HDMI_TX_PHY_RESET_CTL, 0xf << 16);
+ 	HD_WRITE(VC4_HD_VID_CTL,
+ 		 HD_READ(VC4_HD_VID_CTL) & ~VC4_HD_VID_CTL_ENABLE);
+@@ -375,7 +543,7 @@ static void vc4_hdmi_encoder_enable(struct drm_encoder *encoder)
+ 			   VC4_HDMI_SCHEDULER_CONTROL_MODE_HDMI);
+ 
+ 		ret = wait_for(HDMI_READ(VC4_HDMI_SCHEDULER_CONTROL) &
+-			       VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE, 1);
++			       VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE, 1000);
+ 		WARN_ONCE(ret, "Timeout waiting for "
+ 			  "VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE\n");
+ 	} else {
+@@ -387,7 +555,7 @@ static void vc4_hdmi_encoder_enable(struct drm_encoder *encoder)
+ 			   ~VC4_HDMI_SCHEDULER_CONTROL_MODE_HDMI);
+ 
+ 		ret = wait_for(!(HDMI_READ(VC4_HDMI_SCHEDULER_CONTROL) &
+-				 VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE), 1);
++				 VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE), 1000);
+ 		WARN_ONCE(ret, "Timeout waiting for "
+ 			  "!VC4_HDMI_SCHEDULER_CONTROL_HDMI_ACTIVE\n");
+ 	}
+@@ -401,9 +569,10 @@ static void vc4_hdmi_encoder_enable(struct drm_encoder *encoder)
+ 			   HDMI_READ(VC4_HDMI_SCHEDULER_CONTROL) |
+ 			   VC4_HDMI_SCHEDULER_CONTROL_VERT_ALWAYS_KEEPOUT);
+ 
+-		/* XXX: Set HDMI_RAM_PACKET_CONFIG (1 << 16) and set
+-		 * up the infoframe.
+-		 */
++		HDMI_WRITE(VC4_HDMI_RAM_PACKET_CONFIG,
++			   VC4_HDMI_RAM_PACKET_ENABLE);
++
++		vc4_hdmi_set_infoframes(encoder);
+ 
+ 		drift = HDMI_READ(VC4_HDMI_FIFO_CTL);
+ 		drift &= VC4_HDMI_FIFO_VALID_WRITE_MASK;
+@@ -462,12 +631,6 @@ static int vc4_hdmi_bind(struct device *dev, struct device *master, void *data)
+ 	if (IS_ERR(hdmi->hd_regs))
+ 		return PTR_ERR(hdmi->hd_regs);
+ 
+-	ddc_node = of_parse_phandle(dev->of_node, "ddc", 0);
+-	if (!ddc_node) {
+-		DRM_ERROR("Failed to find ddc node in device tree\n");
+-		return -ENODEV;
+-	}
+-
+ 	hdmi->pixel_clock = devm_clk_get(dev, "pixel");
+ 	if (IS_ERR(hdmi->pixel_clock)) {
+ 		DRM_ERROR("Failed to get pixel clock\n");
+@@ -479,7 +642,14 @@ static int vc4_hdmi_bind(struct device *dev, struct device *master, void *data)
+ 		return PTR_ERR(hdmi->hsm_clock);
+ 	}
+ 
++	ddc_node = of_parse_phandle(dev->of_node, "ddc", 0);
++	if (!ddc_node) {
++		DRM_ERROR("Failed to find ddc node in device tree\n");
++		return -ENODEV;
++	}
++
+ 	hdmi->ddc = of_find_i2c_adapter_by_node(ddc_node);
++	of_node_put(ddc_node);
+ 	if (!hdmi->ddc) {
+ 		DRM_DEBUG("Failed to get ddc i2c adapter by node\n");
+ 		return -EPROBE_DEFER;
+@@ -495,6 +665,16 @@ static int vc4_hdmi_bind(struct device *dev, struct device *master, void *data)
  		goto err_put_i2c;
  	}
  
@@ -30605,7 +36316,7 @@ index da9a36d..69650a8 100644
  	ret = clk_prepare_enable(hdmi->hsm_clock);
  	if (ret) {
  		DRM_ERROR("Failed to turn on HDMI state machine clock: %d\n",
-@@ -506,17 +521,40 @@ static int vc4_hdmi_bind(struct device *dev, struct device *master, void *data)
+@@ -506,17 +686,40 @@ static int vc4_hdmi_bind(struct device *dev, struct device *master, void *data)
  	 * we'll use the HDMI core's register.
  	 */
  	if (of_find_property(dev->of_node, "hpd-gpios", &value)) {
@@ -30648,7 +36359,7 @@ index da9a36d..69650a8 100644
  
  	drm_encoder_init(drm, hdmi->encoder, &vc4_hdmi_encoder_funcs,
  			 DRM_MODE_ENCODER_TMDS);
-@@ -537,7 +575,7 @@ err_unprepare_hsm:
+@@ -537,7 +740,7 @@ err_unprepare_hsm:
  err_unprepare_pix:
  	clk_disable_unprepare(hdmi->pixel_clock);
  err_put_i2c:
@@ -30787,10 +36498,10 @@ index 8098c5b..6fbab1c 100644
  
 diff --git a/drivers/gpu/drm/vc4/vc4_irq.c b/drivers/gpu/drm/vc4/vc4_irq.c
 new file mode 100644
-index 0000000..b0104a34
+index 0000000..094bc6a
 --- /dev/null
 +++ b/drivers/gpu/drm/vc4/vc4_irq.c
-@@ -0,0 +1,250 @@
+@@ -0,0 +1,252 @@
 +/*
 + * Copyright  2014 Broadcom
 + *
@@ -30876,8 +36587,10 @@ index 0000000..b0104a34
 +
 +		spin_lock_irqsave(&vc4->job_lock, irqflags);
 +		current_exec = vc4_first_bin_job(vc4);
++		if (!current_exec)
++			current_exec = vc4_last_render_job(vc4);
 +		if (current_exec) {
-+			vc4->overflow_mem->seqno = vc4->finished_seqno + 1;
++			vc4->overflow_mem->seqno = current_exec->seqno;
 +			list_add_tail(&vc4->overflow_mem->unref_head,
 +				      &current_exec->unref_list);
 +			vc4->overflow_mem = NULL;
@@ -31042,7 +36755,7 @@ index 0000000..b0104a34
 +	spin_unlock_irqrestore(&vc4->job_lock, irqflags);
 +}
 diff --git a/drivers/gpu/drm/vc4/vc4_kms.c b/drivers/gpu/drm/vc4/vc4_kms.c
-index 2e5597d..d423ba1 100644
+index 2e5597d..f5484a2 100644
 --- a/drivers/gpu/drm/vc4/vc4_kms.c
 +++ b/drivers/gpu/drm/vc4/vc4_kms.c
 @@ -15,6 +15,7 @@
@@ -31053,7 +36766,7 @@ index 2e5597d..d423ba1 100644
  #include "drm_atomic_helper.h"
  #include "drm_crtc_helper.h"
  #include "drm_plane_helper.h"
-@@ -29,10 +30,161 @@ static void vc4_output_poll_changed(struct drm_device *dev)
+@@ -29,10 +30,165 @@ static void vc4_output_poll_changed(struct drm_device *dev)
  		drm_fbdev_cma_hotplug_event(vc4->fbdev);
  }
  
@@ -31138,16 +36851,26 @@ index 2e5597d..d423ba1 100644
 +	int i;
 +	uint64_t wait_seqno = 0;
 +	struct vc4_commit *c;
++	struct drm_plane *plane;
++	struct drm_plane_state *new_state;
 +
 +	c = commit_init(state);
 +	if (!c)
 +		return -ENOMEM;
 +
 +	/* Make sure that any outstanding modesets have finished. */
-+	ret = down_interruptible(&vc4->async_modeset);
-+	if (ret) {
-+		kfree(c);
-+		return ret;
++	if (nonblock) {
++		ret = down_trylock(&vc4->async_modeset);
++		if (ret) {
++			kfree(c);
++			return -EBUSY;
++		}
++	} else {
++		ret = down_interruptible(&vc4->async_modeset);
++		if (ret) {
++			kfree(c);
++			return ret;
++		}
 +	}
 +
 +	ret = drm_atomic_helper_prepare_planes(dev, state);
@@ -31157,13 +36880,7 @@ index 2e5597d..d423ba1 100644
 +		return ret;
 +	}
 +
-+	for (i = 0; i < dev->mode_config.num_total_plane; i++) {
-+		struct drm_plane *plane = state->planes[i];
-+		struct drm_plane_state *new_state = state->plane_states[i];
-+
-+		if (!plane)
-+			continue;
-+
++	for_each_plane_in_state(state, plane, new_state, i) {
 +		if ((plane->state->fb != new_state->fb) && new_state->fb) {
 +			struct drm_gem_cma_object *cma_bo =
 +				drm_fb_cma_get_gem_obj(new_state->fb, 0);
@@ -31216,7 +36933,7 @@ index 2e5597d..d423ba1 100644
  	.fb_create = drm_fb_cma_create,
  };
  
-@@ -41,6 +193,8 @@ int vc4_kms_load(struct drm_device *dev)
+@@ -41,6 +197,8 @@ int vc4_kms_load(struct drm_device *dev)
  	struct vc4_dev *vc4 = to_vc4_dev(dev);
  	int ret;
  
@@ -31225,7 +36942,7 @@ index 2e5597d..d423ba1 100644
  	ret = drm_vblank_init(dev, dev->mode_config.num_crtc);
  	if (ret < 0) {
  		dev_err(dev->dev, "failed to initialize vblank\n");
-@@ -51,6 +205,8 @@ int vc4_kms_load(struct drm_device *dev)
+@@ -51,6 +209,8 @@ int vc4_kms_load(struct drm_device *dev)
  	dev->mode_config.max_height = 2048;
  	dev->mode_config.funcs = &vc4_mode_funcs;
  	dev->mode_config.preferred_depth = 24;
@@ -31640,7 +37357,7 @@ index 0000000..0f31cc0
 +
 +#endif /* VC4_PACKET_H */
 diff --git a/drivers/gpu/drm/vc4/vc4_plane.c b/drivers/gpu/drm/vc4/vc4_plane.c
-index 887f3ca..90f6f99 100644
+index 887f3ca..7577ad0 100644
 --- a/drivers/gpu/drm/vc4/vc4_plane.c
 +++ b/drivers/gpu/drm/vc4/vc4_plane.c
 @@ -24,11 +24,52 @@
@@ -31705,11 +37422,19 @@ index 887f3ca..90f6f99 100644
  } hvs_formats[] = {
  	{
  		.drm = DRM_FORMAT_XRGB8888, .hvs = HVS_PIXEL_FORMAT_RGBA8888,
-@@ -51,6 +93,48 @@ static const struct hvs_format {
+@@ -51,6 +93,56 @@ static const struct hvs_format {
  		.drm = DRM_FORMAT_ARGB8888, .hvs = HVS_PIXEL_FORMAT_RGBA8888,
  		.pixel_order = HVS_PIXEL_ORDER_ABGR, .has_alpha = true,
  	},
 +	{
++		.drm = DRM_FORMAT_ABGR8888, .hvs = HVS_PIXEL_FORMAT_RGBA8888,
++		.pixel_order = HVS_PIXEL_ORDER_ARGB, .has_alpha = true,
++	},
++	{
++		.drm = DRM_FORMAT_XBGR8888, .hvs = HVS_PIXEL_FORMAT_RGBA8888,
++		.pixel_order = HVS_PIXEL_ORDER_ARGB, .has_alpha = false,
++	},
++	{
 +		.drm = DRM_FORMAT_RGB565, .hvs = HVS_PIXEL_FORMAT_RGB565,
 +		.pixel_order = HVS_PIXEL_ORDER_XRGB, .has_alpha = false,
 +	},
@@ -31754,7 +37479,7 @@ index 887f3ca..90f6f99 100644
  };
  
  static const struct hvs_format *vc4_get_hvs_format(u32 drm_format)
-@@ -65,6 +149,16 @@ static const struct hvs_format *vc4_get_hvs_format(u32 drm_format)
+@@ -65,6 +157,16 @@ static const struct hvs_format *vc4_get_hvs_format(u32 drm_format)
  	return NULL;
  }
  
@@ -31771,7 +37496,7 @@ index 887f3ca..90f6f99 100644
  static bool plane_enabled(struct drm_plane_state *state)
  {
  	return state->fb && state->crtc;
-@@ -81,6 +175,8 @@ static struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane
+@@ -81,6 +183,8 @@ static struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane
  	if (!vc4_state)
  		return NULL;
  
@@ -31780,7 +37505,7 @@ index 887f3ca..90f6f99 100644
  	__drm_atomic_helper_plane_duplicate_state(plane, &vc4_state->base);
  
  	if (vc4_state->dlist) {
-@@ -100,8 +196,17 @@ static struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane
+@@ -100,8 +204,17 @@ static struct drm_plane_state *vc4_plane_duplicate_state(struct drm_plane *plane
  static void vc4_plane_destroy_state(struct drm_plane *plane,
  				    struct drm_plane_state *state)
  {
@@ -31798,7 +37523,7 @@ index 887f3ca..90f6f99 100644
  	kfree(vc4_state->dlist);
  	__drm_atomic_helper_plane_destroy_state(plane, &vc4_state->base);
  	kfree(state);
-@@ -140,82 +245,400 @@ static void vc4_dlist_write(struct vc4_plane_state *vc4_state, u32 val)
+@@ -140,82 +253,400 @@ static void vc4_dlist_write(struct vc4_plane_state *vc4_state, u32 val)
  	vc4_state->dlist[vc4_state->dlist_count++] = val;
  }
  
@@ -32239,7 +37964,7 @@ index 887f3ca..90f6f99 100644
  
  	vc4_state->dlist[ctl0_offset] |=
  		VC4_SET_FIELD(vc4_state->dlist_count, SCALER_CTL0_SIZE);
-@@ -258,6 +681,8 @@ u32 vc4_plane_write_dlist(struct drm_plane *plane, u32 __iomem *dlist)
+@@ -258,6 +689,8 @@ u32 vc4_plane_write_dlist(struct drm_plane *plane, u32 __iomem *dlist)
  	struct vc4_plane_state *vc4_state = to_vc4_plane_state(plane->state);
  	int i;
  
@@ -32248,7 +37973,7 @@ index 887f3ca..90f6f99 100644
  	/* Can't memcpy_toio() because it needs to be 32-bit writes. */
  	for (i = 0; i < vc4_state->dlist_count; i++)
  		writel(vc4_state->dlist[i], &dlist[i]);
-@@ -272,6 +697,34 @@ u32 vc4_plane_dlist_size(struct drm_plane_state *state)
+@@ -272,6 +705,34 @@ u32 vc4_plane_dlist_size(struct drm_plane_state *state)
  	return vc4_state->dlist_count;
  }
  
@@ -32283,7 +38008,7 @@ index 887f3ca..90f6f99 100644
  static const struct drm_plane_helper_funcs vc4_plane_helper_funcs = {
  	.prepare_fb = NULL,
  	.cleanup_fb = NULL,
-@@ -285,8 +738,83 @@ static void vc4_plane_destroy(struct drm_plane *plane)
+@@ -285,8 +746,83 @@ static void vc4_plane_destroy(struct drm_plane *plane)
  	drm_plane_cleanup(plane);
  }
  
@@ -32368,7 +38093,7 @@ index 887f3ca..90f6f99 100644
  	.disable_plane = drm_atomic_helper_disable_plane,
  	.destroy = vc4_plane_destroy,
  	.set_property = NULL,
-@@ -301,6 +829,7 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
+@@ -301,6 +837,7 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
  	struct drm_plane *plane = NULL;
  	struct vc4_plane *vc4_plane;
  	u32 formats[ARRAY_SIZE(hvs_formats)];
@@ -32376,7 +38101,7 @@ index 887f3ca..90f6f99 100644
  	int ret = 0;
  	unsigned i;
  
-@@ -311,12 +840,20 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
+@@ -311,12 +848,20 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
  		goto fail;
  	}
  
@@ -32402,10 +38127,10 @@ index 887f3ca..90f6f99 100644
  	drm_plane_helper_add(plane, &vc4_plane_helper_funcs);
 diff --git a/drivers/gpu/drm/vc4/vc4_qpu_defines.h b/drivers/gpu/drm/vc4/vc4_qpu_defines.h
 new file mode 100644
-index 0000000..d5c2f3c
+index 0000000..f4e795a
 --- /dev/null
 +++ b/drivers/gpu/drm/vc4/vc4_qpu_defines.h
-@@ -0,0 +1,264 @@
+@@ -0,0 +1,279 @@
 +/*
 + * Copyright  2014 Broadcom
 + *
@@ -32478,7 +38203,7 @@ index 0000000..d5c2f3c
 +	QPU_R_ELEM_QPU = 38,
 +	QPU_R_NOP,
 +	QPU_R_XY_PIXEL_COORD = 41,
-+	QPU_R_MS_REV_FLAGS = 41,
++	QPU_R_MS_REV_FLAGS = 42,
 +	QPU_R_VPM = 48,
 +	QPU_R_VPM_LD_BUSY,
 +	QPU_R_VPM_LD_WAIT,
@@ -32638,6 +38363,15 @@ index 0000000..d5c2f3c
 +#define QPU_COND_MUL_SHIFT              46
 +#define QPU_COND_MUL_MASK               QPU_MASK(48, 46)
 +
++#define QPU_BRANCH_COND_SHIFT           52
++#define QPU_BRANCH_COND_MASK            QPU_MASK(55, 52)
++
++#define QPU_BRANCH_REL                  ((uint64_t)1 << 51)
++#define QPU_BRANCH_REG                  ((uint64_t)1 << 50)
++
++#define QPU_BRANCH_RADDR_A_SHIFT        45
++#define QPU_BRANCH_RADDR_A_MASK         QPU_MASK(49, 45)
++
 +#define QPU_SF                          ((uint64_t)1 << 45)
 +
 +#define QPU_WADDR_ADD_SHIFT             38
@@ -32669,9 +38403,15 @@ index 0000000..d5c2f3c
 +#define QPU_OP_ADD_SHIFT                24
 +#define QPU_OP_ADD_MASK                 QPU_MASK(28, 24)
 +
++#define QPU_LOAD_IMM_SHIFT              0
++#define QPU_LOAD_IMM_MASK               QPU_MASK(31, 0)
++
++#define QPU_BRANCH_TARGET_SHIFT         0
++#define QPU_BRANCH_TARGET_MASK          QPU_MASK(31, 0)
++
 +#endif /* VC4_QPU_DEFINES_H */
 diff --git a/drivers/gpu/drm/vc4/vc4_regs.h b/drivers/gpu/drm/vc4/vc4_regs.h
-index 9e4e904..6163b95 100644
+index 9e4e904..14c8f23 100644
 --- a/drivers/gpu/drm/vc4/vc4_regs.h
 +++ b/drivers/gpu/drm/vc4/vc4_regs.h
 @@ -154,7 +154,7 @@
@@ -32683,7 +38423,25 @@ index 9e4e904..6163b95 100644
  #define V3D_FDBGO    0x00f04
  #define V3D_FDBGB    0x00f08
  #define V3D_FDBGR    0x00f0c
-@@ -187,7 +187,7 @@
+@@ -175,6 +175,8 @@
+ # define PV_CONTROL_CLR_AT_START		BIT(14)
+ # define PV_CONTROL_TRIGGER_UNDERFLOW		BIT(13)
+ # define PV_CONTROL_WAIT_HSTART			BIT(12)
++# define PV_CONTROL_PIXEL_REP_MASK		VC4_MASK(5, 4)
++# define PV_CONTROL_PIXEL_REP_SHIFT		4
+ # define PV_CONTROL_CLK_SELECT_DSI_VEC		0
+ # define PV_CONTROL_CLK_SELECT_DPI_SMI_HDMI	1
+ # define PV_CONTROL_CLK_SELECT_MASK		VC4_MASK(3, 2)
+@@ -183,11 +185,16 @@
+ # define PV_CONTROL_EN				BIT(0)
+ 
+ #define PV_V_CONTROL				0x04
++# define PV_VCONTROL_ODD_DELAY_MASK		VC4_MASK(22, 6)
++# define PV_VCONTROL_ODD_DELAY_SHIFT		6
++# define PV_VCONTROL_ODD_FIRST			BIT(5)
+ # define PV_VCONTROL_INTERLACE			BIT(4)
++# define PV_VCONTROL_DSI			BIT(3)
++# define PV_VCONTROL_COMMAND			BIT(2)
  # define PV_VCONTROL_CONTINUOUS			BIT(1)
  # define PV_VCONTROL_VIDEN			BIT(0)
  
@@ -32692,7 +38450,18 @@ index 9e4e904..6163b95 100644
  
  #define PV_HORZA				0x0c
  # define PV_HORZA_HBP_MASK			VC4_MASK(31, 16)
-@@ -350,6 +350,17 @@
+@@ -341,6 +348,10 @@
+ #define SCALER_DISPLACT0                        0x00000030
+ #define SCALER_DISPLACT1                        0x00000034
+ #define SCALER_DISPLACT2                        0x00000038
++#define SCALER_DISPLACTX(x)			(SCALER_DISPLACT0 +	\
++						 (x) * (SCALER_DISPLACT1 - \
++							SCALER_DISPLACT0))
++
+ #define SCALER_DISPCTRL0                        0x00000040
+ # define SCALER_DISPCTRLX_ENABLE		BIT(31)
+ # define SCALER_DISPCTRLX_RESET			BIT(30)
+@@ -350,8 +361,18 @@
  # define SCALER_DISPCTRLX_HEIGHT_SHIFT		0
  
  #define SCALER_DISPBKGND0                       0x00000044
@@ -32708,10 +38477,32 @@ index 9e4e904..6163b95 100644
 +# define SCALER_DISPBKGND_FILL			BIT(24)
 +
  #define SCALER_DISPSTAT0                        0x00000048
- #define SCALER_DISPBASE0                        0x0000004c
+-#define SCALER_DISPBASE0                        0x0000004c
  # define SCALER_DISPSTATX_MODE_MASK		VC4_MASK(31, 30)
-@@ -362,6 +373,9 @@
+ # define SCALER_DISPSTATX_MODE_SHIFT		30
+ # define SCALER_DISPSTATX_MODE_DISABLED		0
+@@ -360,13 +381,37 @@
+ # define SCALER_DISPSTATX_MODE_EOF		3
+ # define SCALER_DISPSTATX_FULL			BIT(29)
  # define SCALER_DISPSTATX_EMPTY			BIT(28)
++# define SCALER_DISPSTATX_FRAME_COUNT_MASK	VC4_MASK(17, 12)
++# define SCALER_DISPSTATX_FRAME_COUNT_SHIFT	12
++# define SCALER_DISPSTATX_LINE_MASK		VC4_MASK(11, 0)
++# define SCALER_DISPSTATX_LINE_SHIFT		0
++
++#define SCALER_DISPBASE0                        0x0000004c
++/* Last pixel in the COB (display FIFO memory) allocated to this HVS
++ * channel.  Must be 4-pixel aligned (and thus 4 pixels less than the
++ * next COB base).
++ */
++# define SCALER_DISPBASEX_TOP_MASK		VC4_MASK(31, 16)
++# define SCALER_DISPBASEX_TOP_SHIFT		16
++/* First pixel in the COB (display FIFO memory) allocated to this HVS
++ * channel.  Must be 4-pixel aligned.
++ */
++# define SCALER_DISPBASEX_BASE_MASK		VC4_MASK(15, 0)
++# define SCALER_DISPBASEX_BASE_SHIFT		0
++
  #define SCALER_DISPCTRL1                        0x00000050
  #define SCALER_DISPBKGND1                       0x00000054
 +#define SCALER_DISPBKGNDX(x)			(SCALER_DISPBKGND0 +        \
@@ -32720,7 +38511,15 @@ index 9e4e904..6163b95 100644
  #define SCALER_DISPSTAT1                        0x00000058
  #define SCALER_DISPSTATX(x)			(SCALER_DISPSTAT0 +        \
  						 (x) * (SCALER_DISPSTAT1 - \
-@@ -376,6 +390,12 @@
+ 							SCALER_DISPSTAT0))
+ #define SCALER_DISPBASE1                        0x0000005c
++#define SCALER_DISPBASEX(x)			(SCALER_DISPBASE0 +        \
++						 (x) * (SCALER_DISPBASE1 - \
++							SCALER_DISPBASE0))
+ #define SCALER_DISPCTRL2                        0x00000060
+ #define SCALER_DISPCTRLX(x)			(SCALER_DISPCTRL0 +        \
+ 						 (x) * (SCALER_DISPCTRL1 - \
+@@ -376,6 +421,12 @@
  #define SCALER_DISPBASE2                        0x0000006c
  #define SCALER_DISPALPHA2                       0x00000070
  #define SCALER_GAMADDR                          0x00000078
@@ -32733,16 +38532,48 @@ index 9e4e904..6163b95 100644
  #define SCALER_GAMDATA                          0x000000e0
  #define SCALER_DLIST_START                      0x00002000
  #define SCALER_DLIST_SIZE                       0x00004000
-@@ -456,6 +476,8 @@
+@@ -394,6 +445,8 @@
+ #define VC4_HDMI_RAM_PACKET_CONFIG		0x0a0
+ # define VC4_HDMI_RAM_PACKET_ENABLE		BIT(16)
+ 
++#define VC4_HDMI_RAM_PACKET_STATUS		0x0a4
++
+ #define VC4_HDMI_HORZA				0x0c4
+ # define VC4_HDMI_HORZA_VPOS			BIT(14)
+ # define VC4_HDMI_HORZA_HPOS			BIT(13)
+@@ -455,7 +508,12 @@
+ 
  #define VC4_HDMI_TX_PHY_RESET_CTL		0x2c0
  
++#define VC4_HDMI_GCP_0				0x400
++#define VC4_HDMI_PACKET_STRIDE			0x24
++
  #define VC4_HD_M_CTL				0x00c
 +# define VC4_HD_M_REGISTER_FILE_STANDBY		(3 << 6)
 +# define VC4_HD_M_RAM_STANDBY			(3 << 4)
  # define VC4_HD_M_SW_RST			BIT(2)
  # define VC4_HD_M_ENABLE			BIT(0)
  
-@@ -503,7 +525,12 @@ enum hvs_pixel_format {
+@@ -482,10 +540,17 @@
+ # define VC4_HD_CSC_CTL_MODE_SHIFT		2
+ # define VC4_HD_CSC_CTL_MODE_RGB_TO_SD_YPRPB	0
+ # define VC4_HD_CSC_CTL_MODE_RGB_TO_HD_YPRPB	1
+-# define VC4_HD_CSC_CTL_MODE_CUSTOM		2
++# define VC4_HD_CSC_CTL_MODE_CUSTOM		3
+ # define VC4_HD_CSC_CTL_RGB2YCC			BIT(1)
+ # define VC4_HD_CSC_CTL_ENABLE			BIT(0)
+ 
++#define VC4_HD_CSC_12_11			0x044
++#define VC4_HD_CSC_14_13			0x048
++#define VC4_HD_CSC_22_21			0x04c
++#define VC4_HD_CSC_24_23			0x050
++#define VC4_HD_CSC_32_31			0x054
++#define VC4_HD_CSC_34_33			0x058
++
+ #define VC4_HD_FRAME_COUNT			0x068
+ 
+ /* HVS display list information. */
+@@ -503,7 +568,12 @@ enum hvs_pixel_format {
  	HVS_PIXEL_FORMAT_RGB888 = 5,
  	HVS_PIXEL_FORMAT_RGBA6666 = 6,
  	/* 32bpp */
@@ -32756,7 +38587,7 @@ index 9e4e904..6163b95 100644
  };
  
  /* Note: the LSB is the rightmost character shown.  Only valid for
-@@ -536,6 +563,21 @@ enum hvs_pixel_format {
+@@ -536,6 +606,21 @@ enum hvs_pixel_format {
  #define SCALER_CTL0_ORDER_MASK			VC4_MASK(14, 13)
  #define SCALER_CTL0_ORDER_SHIFT			13
  
@@ -32778,7 +38609,7 @@ index 9e4e904..6163b95 100644
  /* Set to indicate no scaling. */
  #define SCALER_CTL0_UNITY			BIT(4)
  
-@@ -551,6 +593,12 @@ enum hvs_pixel_format {
+@@ -551,6 +636,12 @@ enum hvs_pixel_format {
  #define SCALER_POS0_START_X_MASK		VC4_MASK(11, 0)
  #define SCALER_POS0_START_X_SHIFT		0
  
@@ -32791,7 +38622,7 @@ index 9e4e904..6163b95 100644
  #define SCALER_POS2_ALPHA_MODE_MASK		VC4_MASK(31, 30)
  #define SCALER_POS2_ALPHA_MODE_SHIFT		30
  #define SCALER_POS2_ALPHA_MODE_PIPELINE		0
-@@ -564,6 +612,80 @@ enum hvs_pixel_format {
+@@ -564,6 +655,80 @@ enum hvs_pixel_format {
  #define SCALER_POS2_WIDTH_MASK			VC4_MASK(11, 0)
  #define SCALER_POS2_WIDTH_SHIFT			0
  
@@ -32874,10 +38705,10 @@ index 9e4e904..6163b95 100644
  
 diff --git a/drivers/gpu/drm/vc4/vc4_render_cl.c b/drivers/gpu/drm/vc4/vc4_render_cl.c
 new file mode 100644
-index 0000000..0f12418
+index 0000000..08886a3
 --- /dev/null
 +++ b/drivers/gpu/drm/vc4/vc4_render_cl.c
-@@ -0,0 +1,634 @@
+@@ -0,0 +1,647 @@
 +/*
 + * Copyright  2014-2015 Broadcom
 + *
@@ -32925,6 +38756,8 @@ index 0000000..0f12418
 +
 +	struct drm_gem_cma_object *rcl;
 +	u32 next_offset;
++
++	u32 next_write_bo_index;
 +};
 +
 +static inline void rcl_u8(struct vc4_rcl_setup *setup, u8 val)
@@ -33287,6 +39120,8 @@ index 0000000..0f12418
 +	if (!*obj)
 +		return -EINVAL;
 +
++	exec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;
++
 +	if (surf->offset & 0xf) {
 +		DRM_ERROR("MSAA write must be 16b aligned.\n");
 +		return -EINVAL;
@@ -33297,7 +39132,8 @@ index 0000000..0f12418
 +
 +static int vc4_rcl_surface_setup(struct vc4_exec_info *exec,
 +				 struct drm_gem_cma_object **obj,
-+				 struct drm_vc4_submit_rcl_surface *surf)
++				 struct drm_vc4_submit_rcl_surface *surf,
++				 bool is_write)
 +{
 +	uint8_t tiling = VC4_GET_FIELD(surf->bits,
 +				       VC4_LOADSTORE_TILE_BUFFER_TILING);
@@ -33320,6 +39156,9 @@ index 0000000..0f12418
 +	if (!*obj)
 +		return -EINVAL;
 +
++	if (is_write)
++		exec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;
++
 +	if (surf->flags & VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {
 +		if (surf == &exec->args->zs_write) {
 +			DRM_ERROR("general zs write may not be a full-res.\n");
@@ -33422,6 +39261,8 @@ index 0000000..0f12418
 +	if (!*obj)
 +		return -EINVAL;
 +
++	exec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;
++
 +	if (tiling > VC4_TILING_FORMAT_LT) {
 +		DRM_ERROR("Bad tiling format\n");
 +		return -EINVAL;
@@ -33479,15 +39320,18 @@ index 0000000..0f12418
 +	if (ret)
 +		return ret;
 +
-+	ret = vc4_rcl_surface_setup(exec, &setup.color_read, &args->color_read);
++	ret = vc4_rcl_surface_setup(exec, &setup.color_read, &args->color_read,
++				    false);
 +	if (ret)
 +		return ret;
 +
-+	ret = vc4_rcl_surface_setup(exec, &setup.zs_read, &args->zs_read);
++	ret = vc4_rcl_surface_setup(exec, &setup.zs_read, &args->zs_read,
++				    false);
 +	if (ret)
 +		return ret;
 +
-+	ret = vc4_rcl_surface_setup(exec, &setup.zs_write, &args->zs_write);
++	ret = vc4_rcl_surface_setup(exec, &setup.zs_write, &args->zs_write,
++				    true);
 +	if (ret)
 +		return ret;
 +
@@ -33603,10 +39447,10 @@ index 0000000..e6278f2
 +#endif
 diff --git a/drivers/gpu/drm/vc4/vc4_v3d.c b/drivers/gpu/drm/vc4/vc4_v3d.c
 new file mode 100644
-index 0000000..3422306
+index 0000000..e6d3c60
 --- /dev/null
 +++ b/drivers/gpu/drm/vc4/vc4_v3d.c
-@@ -0,0 +1,271 @@
+@@ -0,0 +1,284 @@
 +/*
 + * Copyright (c) 2014 The Linux Foundation. All rights reserved.
 + * Copyright (C) 2013 Red Hat
@@ -33626,7 +39470,7 @@ index 0000000..3422306
 + */
 +
 +#include "linux/component.h"
-+#include "soc/bcm2835/raspberrypi-firmware.h"
++#include "linux/pm_runtime.h"
 +#include "vc4_drv.h"
 +#include "vc4_regs.h"
 +
@@ -33754,22 +39598,6 @@ index 0000000..3422306
 +}
 +#endif /* CONFIG_DEBUG_FS */
 +
-+/*
-+ * Asks the firmware to turn on power to the V3D engine.
-+ *
-+ * This may be doable with just the clocks interface, though this
-+ * packet does some other register setup from the firmware, too.
-+ */
-+int
-+vc4_v3d_set_power(struct vc4_dev *vc4, bool on)
-+{
-+	u32 packet = on;
-+
-+	return rpi_firmware_property(vc4->firmware,
-+				     RPI_FIRMWARE_SET_ENABLE_QPU,
-+				     &packet, sizeof(packet));
-+}
-+
 +static void vc4_v3d_init_hw(struct drm_device *dev)
 +{
 +	struct vc4_dev *vc4 = to_vc4_dev(dev);
@@ -33781,6 +39609,29 @@ index 0000000..3422306
 +	V3D_WRITE(V3D_VPMBASE, 0);
 +}
 +
++#ifdef CONFIG_PM
++static int vc4_v3d_runtime_suspend(struct device *dev)
++{
++	struct vc4_v3d *v3d = dev_get_drvdata(dev);
++	struct vc4_dev *vc4 = v3d->vc4;
++
++	vc4_irq_uninstall(vc4->dev);
++
++	return 0;
++}
++
++static int vc4_v3d_runtime_resume(struct device *dev)
++{
++	struct vc4_v3d *v3d = dev_get_drvdata(dev);
++	struct vc4_dev *vc4 = v3d->vc4;
++
++	vc4_v3d_init_hw(vc4->dev);
++	vc4_irq_postinstall(vc4->dev);
++
++	return 0;
++}
++#endif
++
 +static int vc4_v3d_bind(struct device *dev, struct device *master, void *data)
 +{
 +	struct platform_device *pdev = to_platform_device(dev);
@@ -33793,6 +39644,8 @@ index 0000000..3422306
 +	if (!v3d)
 +		return -ENOMEM;
 +
++	dev_set_drvdata(dev, v3d);
++
 +	v3d->pdev = pdev;
 +
 +	v3d->regs = vc4_ioremap_regs(pdev, 0);
@@ -33800,10 +39653,7 @@ index 0000000..3422306
 +		return PTR_ERR(v3d->regs);
 +
 +	vc4->v3d = v3d;
-+
-+	ret = vc4_v3d_set_power(vc4, true);
-+	if (ret)
-+		return ret;
++	v3d->vc4 = vc4;
 +
 +	if (V3D_READ(V3D_IDENT0) != V3D_EXPECTED_IDENT0) {
 +		DRM_ERROR("V3D_IDENT0 read 0x%08x instead of 0x%08x\n",
@@ -33825,6 +39675,8 @@ index 0000000..3422306
 +		return ret;
 +	}
 +
++	pm_runtime_enable(dev);
++
 +	return 0;
 +}
 +
@@ -33834,6 +39686,8 @@ index 0000000..3422306
 +	struct drm_device *drm = dev_get_drvdata(master);
 +	struct vc4_dev *vc4 = to_vc4_dev(drm);
 +
++	pm_runtime_disable(dev);
++
 +	drm_irq_uninstall(drm);
 +
 +	/* Disable the binner's overflow memory address, so the next
@@ -33843,11 +39697,13 @@ index 0000000..3422306
 +	V3D_WRITE(V3D_BPOA, 0);
 +	V3D_WRITE(V3D_BPOS, 0);
 +
-+	vc4_v3d_set_power(vc4, false);
-+
 +	vc4->v3d = NULL;
 +}
 +
++static const struct dev_pm_ops vc4_v3d_pm_ops = {
++	SET_RUNTIME_PM_OPS(vc4_v3d_runtime_suspend, vc4_v3d_runtime_resume, NULL)
++};
++
 +static const struct component_ops vc4_v3d_ops = {
 +	.bind   = vc4_v3d_bind,
 +	.unbind = vc4_v3d_unbind,
@@ -33876,14 +39732,15 @@ index 0000000..3422306
 +	.driver = {
 +		.name = "vc4_v3d",
 +		.of_match_table = vc4_v3d_dt_match,
++		.pm = &vc4_v3d_pm_ops,
 +	},
 +};
 diff --git a/drivers/gpu/drm/vc4/vc4_validate.c b/drivers/gpu/drm/vc4/vc4_validate.c
 new file mode 100644
-index 0000000..24c2c74
+index 0000000..26503e3
 --- /dev/null
 +++ b/drivers/gpu/drm/vc4/vc4_validate.c
-@@ -0,0 +1,900 @@
+@@ -0,0 +1,922 @@
 +/*
 + * Copyright  2014 Broadcom
 + *
@@ -34153,6 +40010,9 @@ index 0000000..24c2c74
 +	if (!ib)
 +		return -EINVAL;
 +
++	exec->bin_dep_seqno = max(exec->bin_dep_seqno,
++				  to_vc4_bo(&ib->base)->write_seqno);
++
 +	if (offset > ib->base.size ||
 +	    (ib->base.size - offset) / index_size < length) {
 +		DRM_ERROR("IB access overflow (%d + %d*%d > %zd)\n",
@@ -34441,8 +40301,7 @@ index 0000000..24c2c74
 +reloc_tex(struct vc4_exec_info *exec,
 +	  void *uniform_data_u,
 +	  struct vc4_texture_sample_info *sample,
-+	  uint32_t texture_handle_index)
-+
++	  uint32_t texture_handle_index, bool is_cs)
 +{
 +	struct drm_gem_cma_object *tex;
 +	uint32_t p0 = *(uint32_t *)(uniform_data_u + sample->p_offset[0]);
@@ -34600,6 +40459,11 @@ index 0000000..24c2c74
 +
 +	*validated_p0 = tex->paddr + p0;
 +
++	if (is_cs) {
++		exec->bin_dep_seqno = max(exec->bin_dep_seqno,
++					  to_vc4_bo(&tex->base)->write_seqno);
++	}
++
 +	return true;
 + fail:
 +	DRM_INFO("Texture p0 at %d: 0x%08x\n", sample->p_offset[0], p0);
@@ -34688,7 +40552,7 @@ index 0000000..24c2c74
 +		uint32_t src_offset = *(uint32_t *)(pkt_u + o);
 +		uint32_t *texture_handles_u;
 +		void *uniform_data_u;
-+		uint32_t tex;
++		uint32_t tex, uni;
 +
 +		*(uint32_t *)(pkt_v + o) = bo[i]->paddr + src_offset;
 +
@@ -34721,11 +40585,23 @@ index 0000000..24c2c74
 +			if (!reloc_tex(exec,
 +				       uniform_data_u,
 +				       &validated_shader->texture_samples[tex],
-+				       texture_handles_u[tex])) {
++				       texture_handles_u[tex],
++				       i == 2)) {
 +				return -EINVAL;
 +			}
 +		}
 +
++		/* Fill in the uniform slots that need this shader's
++		 * start-of-uniforms address (used for resetting the uniform
++		 * stream in the presence of control flow).
++		 */
++		for (uni = 0;
++		     uni < validated_shader->num_uniform_addr_offsets;
++		     uni++) {
++			uint32_t o = validated_shader->uniform_addr_offsets[uni];
++			((uint32_t *)exec->uniforms_v)[o] = exec->uniforms_p;
++		}
++
 +		*(uint32_t *)(pkt_v + o + 4) = exec->uniforms_p;
 +
 +		exec->uniforms_u += validated_shader->uniforms_src_size;
@@ -34742,6 +40618,9 @@ index 0000000..24c2c74
 +		uint32_t stride = *(uint8_t *)(pkt_u + o + 5);
 +		uint32_t max_index;
 +
++		exec->bin_dep_seqno = max(exec->bin_dep_seqno,
++					  to_vc4_bo(&vbo->base)->write_seqno);
++
 +		if (state->addr & 0x8)
 +			stride |= (*(uint32_t *)(pkt_u + 100 + i * 4)) & ~0xff;
 +
@@ -34786,10 +40665,10 @@ index 0000000..24c2c74
 +}
 diff --git a/drivers/gpu/drm/vc4/vc4_validate_shaders.c b/drivers/gpu/drm/vc4/vc4_validate_shaders.c
 new file mode 100644
-index 0000000..f67124b
+index 0000000..2543cf5
 --- /dev/null
 +++ b/drivers/gpu/drm/vc4/vc4_validate_shaders.c
-@@ -0,0 +1,513 @@
+@@ -0,0 +1,884 @@
 +/*
 + * Copyright  2014 Broadcom
 + *
@@ -34831,7 +40710,17 @@ index 0000000..f67124b
 +#include "vc4_drv.h"
 +#include "vc4_qpu_defines.h"
 +
++#define LIVE_REG_COUNT (32 + 32 + 4)
++
 +struct vc4_shader_validation_state {
++	/* Current IP being validated. */
++	uint32_t ip;
++
++	/* IP at the end of the BO, do not read shader[max_ip] */
++	uint32_t max_ip;
++
++	uint64_t *shader;
++
 +	struct vc4_texture_sample_info tmu_setup[2];
 +	int tmu_write_count[2];
 +
@@ -34841,8 +40730,30 @@ index 0000000..f67124b
 +	 *
 +	 * This is used for the validation of direct address memory reads.
 +	 */
-+	uint32_t live_min_clamp_offsets[32 + 32 + 4];
-+	bool live_max_clamp_regs[32 + 32 + 4];
++	uint32_t live_min_clamp_offsets[LIVE_REG_COUNT];
++	bool live_max_clamp_regs[LIVE_REG_COUNT];
++	uint32_t live_immediates[LIVE_REG_COUNT];
++
++	/* Bitfield of which IPs are used as branch targets.
++	 *
++	 * Used for validation that the uniform stream is updated at the right
++	 * points and clearing the texturing/clamping state.
++	 */
++	unsigned long *branch_targets;
++
++	/* Set when entering a basic block, and cleared when the uniform
++	 * address update is found.  This is used to make sure that we don't
++	 * read uniforms when the address is undefined.
++	 */
++	bool needs_uniform_address_update;
++
++	/* Set when we find a backwards branch.  If the branch is backwards,
++	 * the taraget is probably doing an address reset to read uniforms,
++	 * and so we need to be sure that a uniforms address is present in the
++	 * stream, even if the shader didn't need to read uniforms in later
++	 * basic blocks.
++	 */
++	bool needs_uniform_address_for_loop;
 +};
 +
 +static uint32_t
@@ -34921,11 +40832,11 @@ index 0000000..f67124b
 +}
 +
 +static bool
-+check_tmu_write(uint64_t inst,
-+		struct vc4_validated_shader_info *validated_shader,
++check_tmu_write(struct vc4_validated_shader_info *validated_shader,
 +		struct vc4_shader_validation_state *validation_state,
 +		bool is_mul)
 +{
++	uint64_t inst = validation_state->shader[validation_state->ip];
 +	uint32_t waddr = (is_mul ?
 +			  QPU_GET_FIELD(inst, QPU_WADDR_MUL) :
 +			  QPU_GET_FIELD(inst, QPU_WADDR_ADD));
@@ -34954,7 +40865,7 @@ index 0000000..f67124b
 +			return false;
 +		}
 +
-+		/* We assert that the the clamped address is the first
++		/* We assert that the clamped address is the first
 +		 * argument, and the UBO base address is the second argument.
 +		 * This is arbitrary, but simpler than supporting flipping the
 +		 * two either way.
@@ -35004,8 +40915,14 @@ index 0000000..f67124b
 +	/* Since direct uses a RADDR uniform reference, it will get counted in
 +	 * check_instruction_reads()
 +	 */
-+	if (!is_direct)
++	if (!is_direct) {
++		if (validation_state->needs_uniform_address_update) {
++			DRM_ERROR("Texturing with undefined uniform address\n");
++			return false;
++		}
++
 +		validated_shader->uniforms_size += 4;
++	}
 +
 +	if (submit) {
 +		if (!record_texture_sample(validated_shader,
@@ -35019,23 +40936,144 @@ index 0000000..f67124b
 +	return true;
 +}
 +
++static bool require_uniform_address_uniform(struct vc4_validated_shader_info *validated_shader)
++{
++	uint32_t o = validated_shader->num_uniform_addr_offsets;
++	uint32_t num_uniforms = validated_shader->uniforms_size / 4;
++
++	validated_shader->uniform_addr_offsets =
++		krealloc(validated_shader->uniform_addr_offsets,
++			 (o + 1) *
++			 sizeof(*validated_shader->uniform_addr_offsets),
++			 GFP_KERNEL);
++	if (!validated_shader->uniform_addr_offsets)
++		return false;
++
++	validated_shader->uniform_addr_offsets[o] = num_uniforms;
++	validated_shader->num_uniform_addr_offsets++;
++
++	return true;
++}
++
 +static bool
-+check_reg_write(uint64_t inst,
-+		struct vc4_validated_shader_info *validated_shader,
++validate_uniform_address_write(struct vc4_validated_shader_info *validated_shader,
++			       struct vc4_shader_validation_state *validation_state,
++			       bool is_mul)
++{
++	uint64_t inst = validation_state->shader[validation_state->ip];
++	u32 add_b = QPU_GET_FIELD(inst, QPU_ADD_B);
++	u32 raddr_a = QPU_GET_FIELD(inst, QPU_RADDR_A);
++	u32 raddr_b = QPU_GET_FIELD(inst, QPU_RADDR_B);
++	u32 add_lri = raddr_add_a_to_live_reg_index(inst);
++	/* We want our reset to be pointing at whatever uniform follows the
++	 * uniforms base address.
++	 */
++	u32 expected_offset = validated_shader->uniforms_size + 4;
++
++	/* We only support absolute uniform address changes, and we
++	 * require that they be in the current basic block before any
++	 * of its uniform reads.
++	 *
++	 * One could potentially emit more efficient QPU code, by
++	 * noticing that (say) an if statement does uniform control
++	 * flow for all threads and that the if reads the same number
++	 * of uniforms on each side.  However, this scheme is easy to
++	 * validate so it's all we allow for now.
++	 */
++	switch (QPU_GET_FIELD(inst, QPU_SIG)) {
++	case QPU_SIG_NONE:
++	case QPU_SIG_SCOREBOARD_UNLOCK:
++	case QPU_SIG_COLOR_LOAD:
++	case QPU_SIG_LOAD_TMU0:
++	case QPU_SIG_LOAD_TMU1:
++		break;
++	default:
++		DRM_ERROR("uniforms address change must be "
++			  "normal math\n");
++		return false;
++	}
++
++	if (is_mul || QPU_GET_FIELD(inst, QPU_OP_ADD) != QPU_A_ADD) {
++		DRM_ERROR("Uniform address reset must be an ADD.\n");
++		return false;
++	}
++
++	if (QPU_GET_FIELD(inst, QPU_COND_ADD) != QPU_COND_ALWAYS) {
++		DRM_ERROR("Uniform address reset must be unconditional.\n");
++		return false;
++	}
++
++	if (QPU_GET_FIELD(inst, QPU_PACK) != QPU_PACK_A_NOP &&
++	    !(inst & QPU_PM)) {
++		DRM_ERROR("No packing allowed on uniforms reset\n");
++		return false;
++	}
++
++	if (add_lri == -1) {
++		DRM_ERROR("First argument of uniform address write must be "
++			  "an immediate value.\n");
++		return false;
++	}
++
++	if (validation_state->live_immediates[add_lri] != expected_offset) {
++		DRM_ERROR("Resetting uniforms with offset %db instead of %db\n",
++			  validation_state->live_immediates[add_lri],
++			  expected_offset);
++		return false;
++	}
++
++	if (!(add_b == QPU_MUX_A && raddr_a == QPU_R_UNIF) &&
++	    !(add_b == QPU_MUX_B && raddr_b == QPU_R_UNIF)) {
++		DRM_ERROR("Second argument of uniform address write must be "
++			  "a uniform.\n");
++		return false;
++	}
++
++	validation_state->needs_uniform_address_update = false;
++	validation_state->needs_uniform_address_for_loop = false;
++	return require_uniform_address_uniform(validated_shader);
++}
++
++static bool
++check_reg_write(struct vc4_validated_shader_info *validated_shader,
 +		struct vc4_shader_validation_state *validation_state,
 +		bool is_mul)
 +{
++	uint64_t inst = validation_state->shader[validation_state->ip];
 +	uint32_t waddr = (is_mul ?
 +			  QPU_GET_FIELD(inst, QPU_WADDR_MUL) :
 +			  QPU_GET_FIELD(inst, QPU_WADDR_ADD));
++	uint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);
++	bool ws = inst & QPU_WS;
++	bool is_b = is_mul ^ ws;
++	u32 lri = waddr_to_live_reg_index(waddr, is_b);
++
++	if (lri != -1) {
++		uint32_t cond_add = QPU_GET_FIELD(inst, QPU_COND_ADD);
++		uint32_t cond_mul = QPU_GET_FIELD(inst, QPU_COND_MUL);
++
++		if (sig == QPU_SIG_LOAD_IMM &&
++		    QPU_GET_FIELD(inst, QPU_PACK) == QPU_PACK_A_NOP &&
++		    ((is_mul && cond_mul == QPU_COND_ALWAYS) ||
++		     (!is_mul && cond_add == QPU_COND_ALWAYS))) {
++			validation_state->live_immediates[lri] =
++				QPU_GET_FIELD(inst, QPU_LOAD_IMM);
++		} else {
++			validation_state->live_immediates[lri] = ~0;
++		}
++	}
 +
 +	switch (waddr) {
 +	case QPU_W_UNIFORMS_ADDRESS:
-+		/* XXX: We'll probably need to support this for reladdr, but
-+		 * it's definitely a security-related one.
-+		 */
-+		DRM_ERROR("uniforms address load unsupported\n");
-+		return false;
++		if (is_b) {
++			DRM_ERROR("relative uniforms address change "
++				  "unsupported\n");
++			return false;
++		}
++
++		return validate_uniform_address_write(validated_shader,
++						      validation_state,
++						      is_mul);
 +
 +	case QPU_W_TLB_COLOR_MS:
 +	case QPU_W_TLB_COLOR_ALL:
@@ -35053,7 +41091,7 @@ index 0000000..f67124b
 +	case QPU_W_TMU1_T:
 +	case QPU_W_TMU1_R:
 +	case QPU_W_TMU1_B:
-+		return check_tmu_write(inst, validated_shader, validation_state,
++		return check_tmu_write(validated_shader, validation_state,
 +				       is_mul);
 +
 +	case QPU_W_HOST_INT:
@@ -35086,10 +41124,10 @@ index 0000000..f67124b
 +}
 +
 +static void
-+track_live_clamps(uint64_t inst,
-+		  struct vc4_validated_shader_info *validated_shader,
++track_live_clamps(struct vc4_validated_shader_info *validated_shader,
 +		  struct vc4_shader_validation_state *validation_state)
 +{
++	uint64_t inst = validation_state->shader[validation_state->ip];
 +	uint32_t op_add = QPU_GET_FIELD(inst, QPU_OP_ADD);
 +	uint32_t waddr_add = QPU_GET_FIELD(inst, QPU_WADDR_ADD);
 +	uint32_t waddr_mul = QPU_GET_FIELD(inst, QPU_WADDR_MUL);
@@ -35161,10 +41199,10 @@ index 0000000..f67124b
 +}
 +
 +static bool
-+check_instruction_writes(uint64_t inst,
-+			 struct vc4_validated_shader_info *validated_shader,
++check_instruction_writes(struct vc4_validated_shader_info *validated_shader,
 +			 struct vc4_shader_validation_state *validation_state)
 +{
++	uint64_t inst = validation_state->shader[validation_state->ip];
 +	uint32_t waddr_add = QPU_GET_FIELD(inst, QPU_WADDR_ADD);
 +	uint32_t waddr_mul = QPU_GET_FIELD(inst, QPU_WADDR_MUL);
 +	bool ok;
@@ -35174,20 +41212,44 @@ index 0000000..f67124b
 +		return false;
 +	}
 +
-+	ok = (check_reg_write(inst, validated_shader, validation_state,
-+			      false) &&
-+	      check_reg_write(inst, validated_shader, validation_state,
-+			      true));
++	ok = (check_reg_write(validated_shader, validation_state, false) &&
++	      check_reg_write(validated_shader, validation_state, true));
 +
-+	track_live_clamps(inst, validated_shader, validation_state);
++	track_live_clamps(validated_shader, validation_state);
 +
 +	return ok;
 +}
 +
 +static bool
-+check_instruction_reads(uint64_t inst,
-+			struct vc4_validated_shader_info *validated_shader)
++check_branch(uint64_t inst,
++	     struct vc4_validated_shader_info *validated_shader,
++	     struct vc4_shader_validation_state *validation_state,
++	     int ip)
 +{
++	int32_t branch_imm = QPU_GET_FIELD(inst, QPU_BRANCH_TARGET);
++	uint32_t waddr_add = QPU_GET_FIELD(inst, QPU_WADDR_ADD);
++	uint32_t waddr_mul = QPU_GET_FIELD(inst, QPU_WADDR_MUL);
++
++	if ((int)branch_imm < 0)
++		validation_state->needs_uniform_address_for_loop = true;
++
++	/* We don't want to have to worry about validation of this, and
++	 * there's no need for it.
++	 */
++	if (waddr_add != QPU_W_NOP || waddr_mul != QPU_W_NOP) {
++		DRM_ERROR("branch instruction at %d wrote a register.\n",
++			  validation_state->ip);
++		return false;
++	}
++
++	return true;
++}
++
++static bool
++check_instruction_reads(struct vc4_validated_shader_info *validated_shader,
++			struct vc4_shader_validation_state *validation_state)
++{
++	uint64_t inst = validation_state->shader[validation_state->ip];
 +	uint32_t raddr_a = QPU_GET_FIELD(inst, QPU_RADDR_A);
 +	uint32_t raddr_b = QPU_GET_FIELD(inst, QPU_RADDR_B);
 +	uint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);
@@ -35199,40 +41261,204 @@ index 0000000..f67124b
 +		 * already be OOM.
 +		 */
 +		validated_shader->uniforms_size += 4;
++
++		if (validation_state->needs_uniform_address_update) {
++			DRM_ERROR("Uniform read with undefined uniform "
++				  "address\n");
++			return false;
++		}
++	}
++
++	return true;
++}
++
++/* Make sure that all branches are absolute and point within the shader, and
++ * note their targets for later.
++ */
++static bool
++vc4_validate_branches(struct vc4_shader_validation_state *validation_state)
++{
++	uint32_t max_branch_target = 0;
++	bool found_shader_end = false;
++	int ip;
++	int shader_end_ip = 0;
++	int last_branch = -2;
++
++	for (ip = 0; ip < validation_state->max_ip; ip++) {
++		uint64_t inst = validation_state->shader[ip];
++		int32_t branch_imm = QPU_GET_FIELD(inst, QPU_BRANCH_TARGET);
++		uint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);
++		uint32_t after_delay_ip = ip + 4;
++		uint32_t branch_target_ip;
++
++		if (sig == QPU_SIG_PROG_END) {
++			shader_end_ip = ip;
++			found_shader_end = true;
++			continue;
++		}
++
++		if (sig != QPU_SIG_BRANCH)
++			continue;
++
++		if (ip - last_branch < 4) {
++			DRM_ERROR("Branch at %d during delay slots\n", ip);
++			return false;
++		}
++		last_branch = ip;
++
++		if (inst & QPU_BRANCH_REG) {
++			DRM_ERROR("branching from register relative "
++				  "not supported\n");
++			return false;
++		}
++
++		if (!(inst & QPU_BRANCH_REL)) {
++			DRM_ERROR("relative branching required\n");
++			return false;
++		}
++
++		/* The actual branch target is the instruction after the delay
++		 * slots, plus whatever byte offset is in the low 32 bits of
++		 * the instruction.  Make sure we're not branching beyond the
++		 * end of the shader object.
++		 */
++		if (branch_imm % sizeof(inst) != 0) {
++			DRM_ERROR("branch target not aligned\n");
++			return false;
++		}
++
++		branch_target_ip = after_delay_ip + (branch_imm >> 3);
++		if (branch_target_ip >= validation_state->max_ip) {
++			DRM_ERROR("Branch at %d outside of shader (ip %d/%d)\n",
++				  ip, branch_target_ip,
++				  validation_state->max_ip);
++			return false;
++		}
++		set_bit(branch_target_ip, validation_state->branch_targets);
++
++		/* Make sure that the non-branching path is also not outside
++		 * the shader.
++		 */
++		if (after_delay_ip >= validation_state->max_ip) {
++			DRM_ERROR("Branch at %d continues past shader end "
++				  "(%d/%d)\n",
++				  ip, after_delay_ip, validation_state->max_ip);
++			return false;
++		}
++		set_bit(after_delay_ip, validation_state->branch_targets);
++		max_branch_target = max(max_branch_target, after_delay_ip);
++
++		/* There are two delay slots after program end is signaled
++		 * that are still executed, then we're finished.
++		 */
++		if (found_shader_end && ip == shader_end_ip + 2)
++			break;
++	}
++
++	if (max_branch_target > shader_end_ip) {
++		DRM_ERROR("Branch landed after QPU_SIG_PROG_END");
++		return false;
 +	}
 +
 +	return true;
 +}
 +
++/* Resets any known state for the shader, used when we may be branched to from
++ * multiple locations in the program (or at shader start).
++ */
++static void
++reset_validation_state(struct vc4_shader_validation_state *validation_state)
++{
++	int i;
++
++	for (i = 0; i < 8; i++)
++		validation_state->tmu_setup[i / 4].p_offset[i % 4] = ~0;
++
++	for (i = 0; i < LIVE_REG_COUNT; i++) {
++		validation_state->live_min_clamp_offsets[i] = ~0;
++		validation_state->live_max_clamp_regs[i] = false;
++		validation_state->live_immediates[i] = ~0;
++	}
++}
++
++static bool
++texturing_in_progress(struct vc4_shader_validation_state *validation_state)
++{
++	return (validation_state->tmu_write_count[0] != 0 ||
++		validation_state->tmu_write_count[1] != 0);
++}
++
++static bool
++vc4_handle_branch_target(struct vc4_shader_validation_state *validation_state)
++{
++	uint32_t ip = validation_state->ip;
++
++	if (!test_bit(ip, validation_state->branch_targets))
++		return true;
++
++	if (texturing_in_progress(validation_state)) {
++		DRM_ERROR("Branch target landed during TMU setup\n");
++		return false;
++	}
++
++	/* Reset our live values tracking, since this instruction may have
++	 * multiple predecessors.
++	 *
++	 * One could potentially do analysis to determine that, for
++	 * example, all predecessors have a live max clamp in the same
++	 * register, but we don't bother with that.
++	 */
++	reset_validation_state(validation_state);
++
++	/* Since we've entered a basic block from potentially multiple
++	 * predecessors, we need the uniforms address to be updated before any
++	 * unforms are read.  We require that after any branch point, the next
++	 * uniform to be loaded is a uniform address offset.  That uniform's
++	 * offset will be marked by the uniform address register write
++	 * validation, or a one-off the end-of-program check.
++	 */
++	validation_state->needs_uniform_address_update = true;
++
++	return true;
++}
++
 +struct vc4_validated_shader_info *
 +vc4_validate_shader(struct drm_gem_cma_object *shader_obj)
 +{
 +	bool found_shader_end = false;
 +	int shader_end_ip = 0;
-+	uint32_t ip, max_ip;
-+	uint64_t *shader;
-+	struct vc4_validated_shader_info *validated_shader;
++	uint32_t ip;
++	struct vc4_validated_shader_info *validated_shader = NULL;
 +	struct vc4_shader_validation_state validation_state;
-+	int i;
 +
 +	memset(&validation_state, 0, sizeof(validation_state));
++	validation_state.shader = shader_obj->vaddr;
++	validation_state.max_ip = shader_obj->base.size / sizeof(uint64_t);
 +
-+	for (i = 0; i < 8; i++)
-+		validation_state.tmu_setup[i / 4].p_offset[i % 4] = ~0;
-+	for (i = 0; i < ARRAY_SIZE(validation_state.live_min_clamp_offsets); i++)
-+		validation_state.live_min_clamp_offsets[i] = ~0;
++	reset_validation_state(&validation_state);
 +
-+	shader = shader_obj->vaddr;
-+	max_ip = shader_obj->base.size / sizeof(uint64_t);
++	validation_state.branch_targets =
++		kcalloc(BITS_TO_LONGS(validation_state.max_ip),
++			sizeof(unsigned long), GFP_KERNEL);
++	if (!validation_state.branch_targets)
++		goto fail;
 +
 +	validated_shader = kcalloc(1, sizeof(*validated_shader), GFP_KERNEL);
 +	if (!validated_shader)
-+		return NULL;
++		goto fail;
 +
-+	for (ip = 0; ip < max_ip; ip++) {
-+		uint64_t inst = shader[ip];
++	if (!vc4_validate_branches(&validation_state))
++		goto fail;
++
++	for (ip = 0; ip < validation_state.max_ip; ip++) {
++		uint64_t inst = validation_state.shader[ip];
 +		uint32_t sig = QPU_GET_FIELD(inst, QPU_SIG);
 +
++		validation_state.ip = ip;
++
++		if (!vc4_handle_branch_target(&validation_state))
++			goto fail;
++
 +		switch (sig) {
 +		case QPU_SIG_NONE:
 +		case QPU_SIG_WAIT_FOR_SCOREBOARD:
@@ -35242,13 +41468,14 @@ index 0000000..f67124b
 +		case QPU_SIG_LOAD_TMU1:
 +		case QPU_SIG_PROG_END:
 +		case QPU_SIG_SMALL_IMM:
-+			if (!check_instruction_writes(inst, validated_shader,
++			if (!check_instruction_writes(validated_shader,
 +						      &validation_state)) {
 +				DRM_ERROR("Bad write at ip %d\n", ip);
 +				goto fail;
 +			}
 +
-+			if (!check_instruction_reads(inst, validated_shader))
++			if (!check_instruction_reads(validated_shader,
++						     &validation_state))
 +				goto fail;
 +
 +			if (sig == QPU_SIG_PROG_END) {
@@ -35259,13 +41486,18 @@ index 0000000..f67124b
 +			break;
 +
 +		case QPU_SIG_LOAD_IMM:
-+			if (!check_instruction_writes(inst, validated_shader,
++			if (!check_instruction_writes(validated_shader,
 +						      &validation_state)) {
 +				DRM_ERROR("Bad LOAD_IMM write at ip %d\n", ip);
 +				goto fail;
 +			}
 +			break;
 +
++		case QPU_SIG_BRANCH:
++			if (!check_branch(inst, validated_shader,
++					  &validation_state, ip))
++				goto fail;
++			break;
 +		default:
 +			DRM_ERROR("Unsupported QPU signal %d at "
 +				  "instruction %d\n", sig, ip);
@@ -35279,13 +41511,28 @@ index 0000000..f67124b
 +			break;
 +	}
 +
-+	if (ip == max_ip) {
++	if (ip == validation_state.max_ip) {
 +		DRM_ERROR("shader failed to terminate before "
 +			  "shader BO end at %zd\n",
 +			  shader_obj->base.size);
 +		goto fail;
 +	}
 +
++	/* If we did a backwards branch and we haven't emitted a uniforms
++	 * reset since then, we still need the uniforms stream to have the
++	 * uniforms address available so that the backwards branch can do its
++	 * uniforms reset.
++	 *
++	 * We could potentially prove that the backwards branch doesn't
++	 * contain any uses of uniforms until program exit, but that doesn't
++	 * seem to be worth the trouble.
++	 */
++	if (validation_state.needs_uniform_address_for_loop) {
++		if (!require_uniform_address_uniform(validated_shader))
++			goto fail;
++		validated_shader->uniforms_size += 4;
++	}
++
 +	/* Again, no chance of integer overflow here because the worst case
 +	 * scenario is 8 bytes of uniforms plus handles per 8-byte
 +	 * instruction.
@@ -35294,9 +41541,12 @@ index 0000000..f67124b
 +		(validated_shader->uniforms_size +
 +		 4 * validated_shader->num_texture_samples);
 +
++	kfree(validation_state.branch_targets);
++
 +	return validated_shader;
 +
 +fail:
++	kfree(validation_state.branch_targets);
 +	if (validated_shader) {
 +		kfree(validated_shader->texture_samples);
 +		kfree(validated_shader);
@@ -35385,10 +41635,10 @@ index 37f2819..e309579 100644
  
 diff --git a/drivers/i2c/busses/i2c-bcm2708.c b/drivers/i2c/busses/i2c-bcm2708.c
 new file mode 100644
-index 0000000..c9b8e5c
+index 0000000..962f2e5c
 --- /dev/null
 +++ b/drivers/i2c/busses/i2c-bcm2708.c
-@@ -0,0 +1,508 @@
+@@ -0,0 +1,512 @@
 +/*
 + * Driver for Broadcom BCM2708 BSC Controllers
 + *
@@ -35506,13 +41756,13 @@ index 0000000..c9b8e5c
 +
 +static inline void bcm2708_bsc_fifo_drain(struct bcm2708_i2c *bi)
 +{
-+	while ((bcm2708_rd(bi, BSC_S) & BSC_S_RXD) && (bi->pos < bi->msg->len))
++	while ((bi->pos < bi->msg->len) && (bcm2708_rd(bi, BSC_S) & BSC_S_RXD))
 +		bi->msg->buf[bi->pos++] = bcm2708_rd(bi, BSC_FIFO);
 +}
 +
 +static inline void bcm2708_bsc_fifo_fill(struct bcm2708_i2c *bi)
 +{
-+	while ((bcm2708_rd(bi, BSC_S) & BSC_S_TXD) && (bi->pos < bi->msg->len))
++	while ((bi->pos < bi->msg->len) && (bcm2708_rd(bi, BSC_S) & BSC_S_TXD))
 +		bcm2708_wr(bi, BSC_FIFO, bi->msg->buf[bi->pos++]);
 +}
 +
@@ -35546,6 +41796,10 @@ index 0000000..c9b8e5c
 +		if ( (bi->nmsgs > 1) &&
 +			!(bi->msg[0].flags & I2C_M_RD) && (bi->msg[1].flags & I2C_M_RD) &&
 +			 (bi->msg[0].addr == bi->msg[1].addr) && (bi->msg[0].len <= 16)) {
++
++			/* Clear FIFO */
++			bcm2708_wr(bi, BSC_C, BSC_C_CLEAR_1);
++
 +			/* Fill FIFO with entire write message (16 byte FIFO) */
 +			while (bi->pos < bi->msg->len) {
 +				bcm2708_wr(bi, BSC_FIFO, bi->msg->buf[bi->pos++]);
@@ -44087,7 +50341,7 @@ index 5a503a6..2e82cdd 100644
  		&rtl28xxu_props, "Leadtek WinFast DTV Dongle mini", NULL) },
  	{ DVB_USB_DEVICE(USB_VID_GTEK, USB_PID_CPYTO_REDI_PC50A,
 diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
-index 4d92df6..c5730dc 100644
+index 7398262..445b80a 100644
 --- a/drivers/mfd/Kconfig
 +++ b/drivers/mfd/Kconfig
 @@ -10,6 +10,14 @@ config MFD_CORE
@@ -58346,7 +64600,7 @@ index 0000000..b6bfa21
 +   return vchiq_build_time;
 +}
 diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
-index c641c20..a29bf78 100644
+index 6495003..6adc6b5 100644
 --- a/drivers/mmc/card/block.c
 +++ b/drivers/mmc/card/block.c
 @@ -137,6 +137,13 @@ enum {
@@ -58463,7 +64717,7 @@ index fad660b..b79fe14 100644
  }
  EXPORT_SYMBOL(mmc_fixup_device);
 diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
-index 1dee533..d509d10 100644
+index 2e6d2ff..7b7951d 100644
 --- a/drivers/mmc/host/Kconfig
 +++ b/drivers/mmc/host/Kconfig
 @@ -4,6 +4,45 @@
@@ -60104,10 +66358,10 @@ index 0000000..ceb3793
 +MODULE_AUTHOR("Gellert Weisz");
 diff --git a/drivers/mmc/host/bcm2835-sdhost.c b/drivers/mmc/host/bcm2835-sdhost.c
 new file mode 100644
-index 0000000..d7b6b5a
+index 0000000..22bfb34
 --- /dev/null
 +++ b/drivers/mmc/host/bcm2835-sdhost.c
-@@ -0,0 +1,2189 @@
+@@ -0,0 +1,2185 @@
 +/*
 + * BCM2835 SD host driver.
 + *
@@ -60483,7 +66737,7 @@ index 0000000..d7b6b5a
 +	pr_info("%s: SDRSP2 0x%08x\n",
 +		mmc_hostname(host->mmc),
 +		bcm2835_sdhost_read(host, SDRSP2));
-+	pr_err("%s: SDRSP3 0x%08x\n",
++	pr_info("%s: SDRSP3 0x%08x\n",
 +		mmc_hostname(host->mmc),
 +		bcm2835_sdhost_read(host, SDRSP3));
 +	pr_info("%s: SDHSTS 0x%08x\n",
@@ -61293,9 +67547,8 @@ index 0000000..d7b6b5a
 +		retries = 1; // We've already waited long enough this time
 +	}
 +
-+	retries = host->cmd_quick_poll_retries;
 +	for (sdcmd = bcm2835_sdhost_read(host, SDCMD);
-+	     (sdcmd & SDCMD_NEW_FLAG) && !(sdcmd & SDCMD_FAIL_FLAG) && retries;
++	     (sdcmd & SDCMD_NEW_FLAG) && retries;
 +	     retries--) {
 +		cpu_relax();
 +		sdcmd = bcm2835_sdhost_read(host, SDCMD);
@@ -61318,8 +67571,7 @@ index 0000000..d7b6b5a
 +			usleep_range(1, 10);
 +			spin_lock_irqsave(&host->lock, *irq_flags);
 +			sdcmd = bcm2835_sdhost_read(host, SDCMD);
-+			if (!(sdcmd & SDCMD_NEW_FLAG) ||
-+			    (sdcmd & SDCMD_FAIL_FLAG))
++			if (!(sdcmd & SDCMD_NEW_FLAG))
 +				break;
 +		}
 +	}
@@ -62002,8 +68254,6 @@ index 0000000..d7b6b5a
 +
 +	mmc = host->mmc;
 +
-+	bcm2835_sdhost_reset_internal(host);
-+
 +	mmc->f_max = host->max_clk;
 +	mmc->f_min = host->max_clk / SDCDIV_MAX_CDIV;
 +
@@ -62602,23 +68852,88 @@ index 0000000..b747326
 +	("Driver for NAND chips using Broadcom Secondary Memory Interface");
 +MODULE_AUTHOR("Luke Wren <luke@raspberrypi.org>");
 diff --git a/drivers/net/ethernet/microchip/enc28j60.c b/drivers/net/ethernet/microchip/enc28j60.c
-index 86ea17e..a1b20c1 100644
+index 86ea17e..5a19f47 100644
 --- a/drivers/net/ethernet/microchip/enc28j60.c
 +++ b/drivers/net/ethernet/microchip/enc28j60.c
-@@ -1630,9 +1630,16 @@ static int enc28j60_remove(struct spi_device *spi)
+@@ -28,11 +28,12 @@
+ #include <linux/skbuff.h>
+ #include <linux/delay.h>
+ #include <linux/spi/spi.h>
++#include <linux/of_net.h>
+ 
+ #include "enc28j60_hw.h"
+ 
+ #define DRV_NAME	"enc28j60"
+-#define DRV_VERSION	"1.01"
++#define DRV_VERSION	"1.02"
+ 
+ #define SPI_OPLEN	1
+ 
+@@ -1146,7 +1147,8 @@ static void enc28j60_irq_work_handler(struct work_struct *work)
+ 			enc28j60_phy_read(priv, PHIR);
+ 		}
+ 		/* TX complete handler */
+-		if ((intflags & EIR_TXIF) != 0) {
++		if (((intflags & EIR_TXIF) != 0) &&
++		    ((intflags & EIR_TXERIF) == 0)) {
+ 			bool err = false;
+ 			loop++;
+ 			if (netif_msg_intr(priv))
+@@ -1198,7 +1200,7 @@ static void enc28j60_irq_work_handler(struct work_struct *work)
+ 					enc28j60_tx_clear(ndev, true);
+ 			} else
+ 				enc28j60_tx_clear(ndev, true);
+-			locked_reg_bfclr(priv, EIR, EIR_TXERIF);
++			locked_reg_bfclr(priv, EIR, EIR_TXERIF | EIR_TXIF);
+ 		}
+ 		/* RX Error handler */
+ 		if ((intflags & EIR_RXERIF) != 0) {
+@@ -1233,6 +1235,8 @@ static void enc28j60_irq_work_handler(struct work_struct *work)
+  */
+ static void enc28j60_hw_tx(struct enc28j60_net *priv)
+ {
++	BUG_ON(!priv->tx_skb);
++
+ 	if (netif_msg_tx_queued(priv))
+ 		printk(KERN_DEBUG DRV_NAME
+ 			": Tx Packet Len:%d\n", priv->tx_skb->len);
+@@ -1544,6 +1548,7 @@ static int enc28j60_probe(struct spi_device *spi)
+ {
+ 	struct net_device *dev;
+ 	struct enc28j60_net *priv;
++	const void *macaddr;
+ 	int ret = 0;
+ 
+ 	if (netif_msg_drv(&debug))
+@@ -1575,7 +1580,12 @@ static int enc28j60_probe(struct spi_device *spi)
+ 		ret = -EIO;
+ 		goto error_irq;
+ 	}
+-	eth_hw_addr_random(dev);
++
++	macaddr = of_get_mac_address(spi->dev.of_node);
++	if (macaddr)
++		ether_addr_copy(dev->dev_addr, macaddr);
++	else
++		eth_hw_addr_random(dev);
+ 	enc28j60_set_hw_macaddr(dev);
+ 
+ 	/* Board setup must set the relevant edge trigger type;
+@@ -1630,9 +1640,16 @@ static int enc28j60_remove(struct spi_device *spi)
  	return 0;
  }
  
-+static const struct of_device_id enc28j60_of_match[] = {
-+	{ .compatible = "microchip,enc28j60", },
++static const struct of_device_id enc28j60_dt_ids[] = {
++	{ .compatible = "microchip,enc28j60" },
 +	{ /* sentinel */ }
 +};
-+MODULE_DEVICE_TABLE(of, enc28j60_of_match);
++MODULE_DEVICE_TABLE(of, enc28j60_dt_ids);
 +
  static struct spi_driver enc28j60_driver = {
  	.driver = {
- 		   .name = DRV_NAME,
-+		   .of_match_table = enc28j60_of_match,
+-		   .name = DRV_NAME,
++		.name = DRV_NAME,
++		.of_match_table = enc28j60_dt_ids,
  	 },
  	.probe = enc28j60_probe,
  	.remove = enc28j60_remove,
@@ -62779,9 +69094,18 @@ index f9f9422..cfb2280 100644
  source "drivers/net/wireless/ti/Kconfig"
  source "drivers/net/wireless/zd1211rw/Kconfig"
 diff --git a/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
-index deb5f78..f6bf1078 100644
+index 71493d2..eb5eddf 100644
 --- a/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
 +++ b/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c
+@@ -232,7 +232,7 @@ struct parsed_vndr_ies {
+ 	struct parsed_vndr_ie_info ie_info[VNDR_IE_PARSE_LIMIT];
+ };
+ 
+-static int brcmf_roamoff;
++static int brcmf_roamoff = 1;
+ module_param_named(roamoff, brcmf_roamoff, int, S_IRUSR);
+ MODULE_PARM_DESC(roamoff, "do not use internal roaming engine");
+ 
 @@ -392,15 +392,23 @@ static int brcmf_vif_change_validate(struct brcmf_cfg80211_info *cfg,
  {
  	int iftype_num[NUM_NL80211_IFTYPES];
@@ -62832,26 +69156,7 @@ index deb5f78..f6bf1078 100644
  	}
  	clear_bit(BRCMF_VIF_STATUS_CONNECTING, &vif->sme_state);
  	clear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);
-@@ -2408,7 +2416,7 @@ static void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)
- 				     WL_BSS_INFO_MAX);
- 	if (err) {
- 		brcmf_err("Failed to get bss info (%d)\n", err);
--		return;
-+		goto out_err;
- 	}
- 	si->filled |= BIT(NL80211_STA_INFO_BSS_PARAM);
- 	si->bss_param.beacon_interval = le16_to_cpu(buf->bss_le.beacon_period);
-@@ -2420,6 +2428,9 @@ static void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)
- 		si->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;
- 	if (capability & WLAN_CAPABILITY_SHORT_SLOT_TIME)
- 		si->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;
-+
-+out_err:
-+	kfree(buf);
- }
- 
- static s32
-@@ -2567,6 +2578,8 @@ brcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
+@@ -2570,6 +2578,8 @@ brcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
  	 * preference in cfg struct to apply this to
  	 * FW later while initializing the dongle
  	 */
@@ -62860,7 +69165,7 @@ index deb5f78..f6bf1078 100644
  	cfg->pwr_save = enabled;
  	if (!check_vif_up(ifp->vif)) {
  
-@@ -2691,8 +2704,8 @@ static s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)
+@@ -2694,8 +2704,8 @@ static s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)
  	return err;
  }
  
@@ -62871,7 +69176,7 @@ index deb5f78..f6bf1078 100644
  {
  	struct wiphy *wiphy = cfg_to_wiphy(cfg);
  	struct ieee80211_channel *notify_channel;
-@@ -2737,6 +2750,7 @@ static s32 wl_inform_ibss(struct brcmf_cfg80211_info *cfg,
+@@ -2740,6 +2750,7 @@ static s32 wl_inform_ibss(struct brcmf_cfg80211_info *cfg,
  		band = wiphy->bands[IEEE80211_BAND_5GHZ];
  
  	freq = ieee80211_channel_to_frequency(ch.chnum, band->band);
@@ -62879,7 +69184,26 @@ index deb5f78..f6bf1078 100644
  	notify_channel = ieee80211_get_channel(wiphy, freq);
  
  	notify_capability = le16_to_cpu(bi->capability);
-@@ -5016,9 +5030,9 @@ brcmf_notify_connect_status(struct brcmf_if *ifp,
+@@ -4291,12 +4302,15 @@ static int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
+ 		if (err < 0)
+ 			brcmf_err("BRCMF_C_DOWN error %d\n", err);
+-		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);
+-		if (err < 0)
+-			brcmf_err("setting AP mode failed %d\n", err);
++
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 0);
+ 		if (err < 0)
+ 			brcmf_err("setting INFRA mode failed %d\n", err);
++
++		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);
++		if (err < 0)
++			brcmf_err("setting AP mode failed %d\n", err);
++
+ 		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))
+ 			brcmf_fil_iovar_int_set(ifp, "mbss", 0);
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
+@@ -5019,9 +5033,9 @@ brcmf_notify_connect_status(struct brcmf_if *ifp,
  	} else if (brcmf_is_linkup(e)) {
  		brcmf_dbg(CONN, "Linkup\n");
  		if (brcmf_is_ibssmode(ifp->vif)) {
@@ -235699,6 +242023,15 @@ index 0000000..7b66deb
 +	return ret;
 +}
 +late_initcall(of_cfs_init);
+diff --git a/drivers/of/device.c b/drivers/of/device.c
+index e5f47ce..58caa26 100644
+--- a/drivers/of/device.c
++++ b/drivers/of/device.c
+@@ -287,3 +287,4 @@ int of_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)
+ 
+ 	return 0;
+ }
++EXPORT_SYMBOL(of_device_uevent_modalias);
 diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
 index 655f79d..fdc4501 100644
 --- a/drivers/of/fdt.c
@@ -236499,10 +242832,10 @@ index 5430adf..9e53cd0 100644
  obj-$(CONFIG_LIRC_SIR)		+= lirc_sir.o
 diff --git a/drivers/staging/media/lirc/lirc_rpi.c b/drivers/staging/media/lirc/lirc_rpi.c
 new file mode 100644
-index 0000000..0624439
+index 0000000..6132896
 --- /dev/null
 +++ b/drivers/staging/media/lirc/lirc_rpi.c
-@@ -0,0 +1,730 @@
+@@ -0,0 +1,734 @@
 +/*
 + * lirc_rpi.c
 + *
@@ -236584,6 +242917,7 @@ index 0000000..0624439
 +
 +struct gpio_chip *gpiochip;
 +static int irq_num;
++static int auto_sense = 1;
 +
 +/* forward declarations */
 +static long send_pulse(unsigned long length);
@@ -236784,7 +243118,9 @@ index 0000000..0624439
 +				 * detecting pulse while this
 +				 * MUST be a space!
 +				 */
-+				sense = sense ? 0 : 1;
++				if (auto_sense) {
++					sense = sense ? 0 : 1;
++				}
 +			}
 +		} else {
 +			data = (int) (deltv*1000000 +
@@ -236922,6 +243258,7 @@ index 0000000..0624439
 +		printk(KERN_INFO LIRC_DRIVER_NAME
 +		       ": manually using active %s receiver on GPIO pin %d\n",
 +		       sense ? "low" : "high", gpio_in_pin);
++		auto_sense = 0;
 +	}
 +
 +	return 0;
@@ -237433,10 +243770,10 @@ index 358ca8d..abaac7c 100644
  	return i;
  }
 diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
-index 84df093..116a774 100644
+index bcc1e1b..922f95c 100644
 --- a/drivers/usb/core/hub.c
 +++ b/drivers/usb/core/hub.c
-@@ -4973,7 +4973,7 @@ static void port_event(struct usb_hub *hub, int port1)
+@@ -4972,7 +4972,7 @@ static void port_event(struct usb_hub *hub, int port1)
  	if (portchange & USB_PORT_STAT_C_OVERCURRENT) {
  		u16 status = 0, unused;
  
@@ -299011,10 +305348,10 @@ index a2bb276..436494f 100644
  					start_index, pitch_index);
  	} else
 diff --git a/drivers/video/fbdev/core/fbmem.c b/drivers/video/fbdev/core/fbmem.c
-index 0705d88..771992a 100644
+index 0705d88..3bff91e 100644
 --- a/drivers/video/fbdev/core/fbmem.c
 +++ b/drivers/video/fbdev/core/fbmem.c
-@@ -1084,6 +1084,25 @@ fb_blank(struct fb_info *info, int blank)
+@@ -1084,6 +1084,31 @@ fb_blank(struct fb_info *info, int blank)
  }
  EXPORT_SYMBOL(fb_blank);
  
@@ -299024,7 +305361,13 @@ index 0705d88..771992a 100644
 +	int ret = 0;
 +	if (!lock_fb_info(info))
 +		return -ENODEV;
-+	if (copy->dx + copy->width > info->var.xres ||
++	if (copy->dx >= info->var.xres ||
++	    copy->sx >= info->var.xres ||
++	    copy->width > info->var.xres ||
++	    copy->dy >= info->var.yres ||
++	    copy->sy >= info->var.yres ||
++	    copy->height > info->var.yres ||
++	    copy->dx + copy->width > info->var.xres ||
 +	    copy->sx + copy->width > info->var.xres ||
 +	    copy->dy + copy->height > info->var.yres ||
 +	    copy->sy + copy->height > info->var.yres) {
@@ -299040,7 +305383,7 @@ index 0705d88..771992a 100644
  static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
  			unsigned long arg)
  {
-@@ -1094,6 +1113,7 @@ static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
+@@ -1094,6 +1119,7 @@ static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
  	struct fb_cmap cmap_from;
  	struct fb_cmap_user cmap;
  	struct fb_event event;
@@ -299048,7 +305391,7 @@ index 0705d88..771992a 100644
  	void __user *argp = (void __user *)arg;
  	long ret = 0;
  
-@@ -1211,6 +1231,15 @@ static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
+@@ -1211,6 +1237,15 @@ static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
  		unlock_fb_info(info);
  		console_unlock();
  		break;
@@ -299064,7 +305407,7 @@ index 0705d88..771992a 100644
  	default:
  		if (!lock_fb_info(info))
  			return -ENODEV;
-@@ -1365,6 +1394,7 @@ static long fb_compat_ioctl(struct file *file, unsigned int cmd,
+@@ -1365,6 +1400,7 @@ static long fb_compat_ioctl(struct file *file, unsigned int cmd,
  	case FBIOPAN_DISPLAY:
  	case FBIOGET_CON2FBMAP:
  	case FBIOPUT_CON2FBMAP:
@@ -302586,10 +308929,10 @@ index 0000000..d91156e
 +#define BCM2835_AUX_CLOCK_SPI2		2
 +#define BCM2835_AUX_CLOCK_COUNT		3
 diff --git a/include/dt-bindings/clock/bcm2835.h b/include/dt-bindings/clock/bcm2835.h
-index d323efa..360e00c 100644
+index d323efa..c30715a 100644
 --- a/include/dt-bindings/clock/bcm2835.h
 +++ b/include/dt-bindings/clock/bcm2835.h
-@@ -43,5 +43,24 @@
+@@ -43,5 +43,25 @@
  #define BCM2835_CLOCK_TSENS		27
  #define BCM2835_CLOCK_EMMC		28
  #define BCM2835_CLOCK_PERI_IMAGE	29
@@ -302615,6 +308958,7 @@ index d323efa..360e00c 100644
 +#define BCM2835_CLOCK_CAM1		46
 +#define BCM2835_CLOCK_DSI0E		47
 +#define BCM2835_CLOCK_DSI1E		48
++#define BCM2835_CLOCK_DSI1P		49
 diff --git a/include/dt-bindings/power/raspberrypi-power.h b/include/dt-bindings/power/raspberrypi-power.h
 new file mode 100644
 index 0000000..b3ff8e0
@@ -303907,10 +310251,19 @@ index 86df083..e5bba89 100644
  static inline void qdisc_reset_all_tx_gt(struct net_device *dev, unsigned int i)
  {
 diff --git a/include/soc/bcm2835/raspberrypi-firmware.h b/include/soc/bcm2835/raspberrypi-firmware.h
-index c07d74a..227a107 100644
+index c07d74a..b4d09f9 100644
 --- a/include/soc/bcm2835/raspberrypi-firmware.h
 +++ b/include/soc/bcm2835/raspberrypi-firmware.h
-@@ -63,6 +63,7 @@ enum rpi_firmware_property_tag {
+@@ -12,6 +12,8 @@
+ #include <linux/types.h>
+ #include <linux/of_device.h>
+ 
++#define RPI_FIRMWARE_CHAN_FB		1
++
+ struct rpi_firmware;
+ 
+ enum rpi_firmware_property_status {
+@@ -63,6 +65,7 @@ enum rpi_firmware_property_tag {
  	RPI_FIRMWARE_GET_MIN_VOLTAGE =                        0x00030008,
  	RPI_FIRMWARE_GET_TURBO =                              0x00030009,
  	RPI_FIRMWARE_GET_MAX_TEMPERATURE =                    0x0003000a,
@@ -303918,7 +310271,7 @@ index c07d74a..227a107 100644
  	RPI_FIRMWARE_ALLOCATE_MEMORY =                        0x0003000c,
  	RPI_FIRMWARE_LOCK_MEMORY =                            0x0003000d,
  	RPI_FIRMWARE_UNLOCK_MEMORY =                          0x0003000e,
-@@ -72,10 +73,15 @@ enum rpi_firmware_property_tag {
+@@ -72,10 +75,15 @@ enum rpi_firmware_property_tag {
  	RPI_FIRMWARE_SET_ENABLE_QPU =                         0x00030012,
  	RPI_FIRMWARE_GET_DISPMANX_RESOURCE_MEM_HANDLE =       0x00030014,
  	RPI_FIRMWARE_GET_EDID_BLOCK =                         0x00030020,
@@ -303934,7 +310287,7 @@ index c07d74a..227a107 100644
  
  	/* Dispmanx TAGS */
  	RPI_FIRMWARE_FRAMEBUFFER_ALLOCATE =                   0x00040001,
-@@ -89,6 +95,8 @@ enum rpi_firmware_property_tag {
+@@ -89,6 +97,8 @@ enum rpi_firmware_property_tag {
  	RPI_FIRMWARE_FRAMEBUFFER_GET_VIRTUAL_OFFSET =         0x00040009,
  	RPI_FIRMWARE_FRAMEBUFFER_GET_OVERSCAN =               0x0004000a,
  	RPI_FIRMWARE_FRAMEBUFFER_GET_PALETTE =                0x0004000b,
@@ -303943,7 +310296,7 @@ index c07d74a..227a107 100644
  	RPI_FIRMWARE_FRAMEBUFFER_RELEASE =                    0x00048001,
  	RPI_FIRMWARE_FRAMEBUFFER_TEST_PHYSICAL_WIDTH_HEIGHT = 0x00044003,
  	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_WIDTH_HEIGHT =  0x00044004,
-@@ -98,6 +106,7 @@ enum rpi_firmware_property_tag {
+@@ -98,6 +108,7 @@ enum rpi_firmware_property_tag {
  	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_OFFSET =        0x00044009,
  	RPI_FIRMWARE_FRAMEBUFFER_TEST_OVERSCAN =              0x0004400a,
  	RPI_FIRMWARE_FRAMEBUFFER_TEST_PALETTE =               0x0004400b,
@@ -303951,7 +310304,7 @@ index c07d74a..227a107 100644
  	RPI_FIRMWARE_FRAMEBUFFER_SET_PHYSICAL_WIDTH_HEIGHT =  0x00048003,
  	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_WIDTH_HEIGHT =   0x00048004,
  	RPI_FIRMWARE_FRAMEBUFFER_SET_DEPTH =                  0x00048005,
-@@ -106,6 +115,10 @@ enum rpi_firmware_property_tag {
+@@ -106,6 +117,10 @@ enum rpi_firmware_property_tag {
  	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_OFFSET =         0x00048009,
  	RPI_FIRMWARE_FRAMEBUFFER_SET_OVERSCAN =               0x0004800a,
  	RPI_FIRMWARE_FRAMEBUFFER_SET_PALETTE =                0x0004800b,
@@ -303962,6 +310315,13 @@ index c07d74a..227a107 100644
  
  	RPI_FIRMWARE_GET_COMMAND_LINE =                       0x00050001,
  	RPI_FIRMWARE_GET_DMA_CHANNELS =                       0x00060001,
+@@ -116,5 +131,6 @@ int rpi_firmware_property(struct rpi_firmware *fw,
+ int rpi_firmware_property_list(struct rpi_firmware *fw,
+ 			       void *data, size_t tag_size);
+ struct rpi_firmware *rpi_firmware_get(struct device_node *firmware_node);
++int rpi_firmware_transaction(struct rpi_firmware *fw, u32 chan, u32 data);
+ 
+ #endif /* __SOC_RASPBERRY_FIRMWARE_H__ */
 diff --git a/include/uapi/drm/Kbuild b/include/uapi/drm/Kbuild
 index 38d4370..23381b5 100644
 --- a/include/uapi/drm/Kbuild
@@ -303996,10 +310356,10 @@ index 6c11ca4..325e9eb 100644
  
 diff --git a/include/uapi/drm/vc4_drm.h b/include/uapi/drm/vc4_drm.h
 new file mode 100644
-index 0000000..eeb37e3
+index 0000000..ad7edc3
 --- /dev/null
 +++ b/include/uapi/drm/vc4_drm.h
-@@ -0,0 +1,279 @@
+@@ -0,0 +1,300 @@
 +/*
 + * Copyright  2014-2015 Broadcom
 + *
@@ -304028,6 +310388,10 @@ index 0000000..eeb37e3
 +
 +#include "drm.h"
 +
++#if defined(__cplusplus)
++extern "C" {
++#endif
++
 +#define DRM_VC4_SUBMIT_CL                         0x00
 +#define DRM_VC4_WAIT_SEQNO                        0x01
 +#define DRM_VC4_WAIT_BO                           0x02
@@ -304035,6 +310399,7 @@ index 0000000..eeb37e3
 +#define DRM_VC4_MMAP_BO                           0x04
 +#define DRM_VC4_CREATE_SHADER_BO                  0x05
 +#define DRM_VC4_GET_HANG_STATE                    0x06
++#define DRM_VC4_GET_PARAM                         0x07
 +
 +#define DRM_IOCTL_VC4_SUBMIT_CL           DRM_IOWR(DRM_COMMAND_BASE + DRM_VC4_SUBMIT_CL, struct drm_vc4_submit_cl)
 +#define DRM_IOCTL_VC4_WAIT_SEQNO          DRM_IOWR(DRM_COMMAND_BASE + DRM_VC4_WAIT_SEQNO, struct drm_vc4_wait_seqno)
@@ -304043,6 +310408,7 @@ index 0000000..eeb37e3
 +#define DRM_IOCTL_VC4_MMAP_BO             DRM_IOWR(DRM_COMMAND_BASE + DRM_VC4_MMAP_BO, struct drm_vc4_mmap_bo)
 +#define DRM_IOCTL_VC4_CREATE_SHADER_BO    DRM_IOWR(DRM_COMMAND_BASE + DRM_VC4_CREATE_SHADER_BO, struct drm_vc4_create_shader_bo)
 +#define DRM_IOCTL_VC4_GET_HANG_STATE      DRM_IOWR(DRM_COMMAND_BASE + DRM_VC4_GET_HANG_STATE, struct drm_vc4_get_hang_state)
++#define DRM_IOCTL_VC4_GET_PARAM           DRM_IOWR(DRM_COMMAND_BASE + DRM_VC4_GET_PARAM, struct drm_vc4_get_param)
 +
 +struct drm_vc4_submit_rcl_surface {
 +	__u32 hindex; /* Handle index, or ~0 if not present. */
@@ -304278,6 +310644,21 @@ index 0000000..eeb37e3
 +	__u32 pad[16];
 +};
 +
++#define DRM_VC4_PARAM_V3D_IDENT0		0
++#define DRM_VC4_PARAM_V3D_IDENT1		1
++#define DRM_VC4_PARAM_V3D_IDENT2		2
++#define DRM_VC4_PARAM_SUPPORTS_BRANCHES		3
++
++struct drm_vc4_get_param {
++	__u32 param;
++	__u32 pad;
++	__u64 value;
++};
++
++#if defined(__cplusplus)
++}
++#endif
++
 +#endif /* _UAPI_VC4_DRM_H_ */
 diff --git a/include/uapi/linux/fb.h b/include/uapi/linux/fb.h
 index fb795c3..fa72af0 100644
@@ -304296,10 +310677,10 @@ index fb795c3..fa72af0 100644
  #define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
  #define FB_TYPE_PLANES			1	/* Non interleaved planes */
 diff --git a/kernel/cgroup.c b/kernel/cgroup.c
-index 1c9d701..35264cd 100644
+index a3424f2..e400a3c 100644
 --- a/kernel/cgroup.c
 +++ b/kernel/cgroup.c
-@@ -5306,7 +5306,7 @@ int __init cgroup_init_early(void)
+@@ -5307,7 +5307,7 @@ int __init cgroup_init_early(void)
  	return 0;
  }
  
@@ -304308,7 +310689,7 @@ index 1c9d701..35264cd 100644
  
  /**
   * cgroup_init - cgroup initialization
-@@ -5802,6 +5802,27 @@ static int __init cgroup_disable(char *str)
+@@ -5803,6 +5803,27 @@ static int __init cgroup_disable(char *str)
  }
  __setup("cgroup_disable=", cgroup_disable);
  
@@ -304354,10 +310735,10 @@ index 249b1eb..eb973a53 100644
  	for (;;) {
  		tmp = *p;
 diff --git a/mm/page_alloc.c b/mm/page_alloc.c
-index 99c1738..7d24010 100644
+index 2bcdfbf..819ed3b 100644
 --- a/mm/page_alloc.c
 +++ b/mm/page_alloc.c
-@@ -6780,8 +6780,6 @@ int alloc_contig_range(unsigned long start, unsigned long end,
+@@ -6782,8 +6782,6 @@ int alloc_contig_range(unsigned long start, unsigned long end,
  
  	/* Make sure the range is really isolated. */
  	if (test_pages_isolated(outer_start, end, false)) {
@@ -308621,10 +315002,10 @@ index 0000000..d2de13c
 +}
 diff --git a/sound/arm/bcm2835-vchiq.c b/sound/arm/bcm2835-vchiq.c
 new file mode 100755
-index 0000000..3de3094
+index 0000000..7ee436c
 --- /dev/null
 +++ b/sound/arm/bcm2835-vchiq.c
-@@ -0,0 +1,902 @@
+@@ -0,0 +1,889 @@
 +/*****************************************************************************
 +* Copyright 2011 Broadcom Corporation.  All rights reserved.
 +*
@@ -309138,12 +315519,7 @@ index 0000000..3de3094
 +	}
 +
 +	/* We are expecting a reply from the videocore */
-+	ret = wait_for_completion_interruptible(&instance->msg_avail_comp);
-+	if (ret) {
-+		LOG_DBG("%s: failed on waiting for event (status=%d)\n",
-+			__func__, success);
-+		goto unlock;
-+	}
++	wait_for_completion(&instance->msg_avail_comp);
 +
 +	if (instance->result != 0) {
 +		LOG_ERR("%s: result=%d\n", __func__, instance->result);
@@ -309242,12 +315618,7 @@ index 0000000..3de3094
 +	}
 +
 +	/* We are expecting a reply from the videocore */
-+	ret = wait_for_completion_interruptible(&instance->msg_avail_comp);
-+	if (ret) {
-+		LOG_DBG("%s: failed on waiting for event (status=%d)\n",
-+			__func__, success);
-+		goto unlock;
-+	}
++	wait_for_completion(&instance->msg_avail_comp);
 +
 +	if (instance->result != 0) {
 +		LOG_ERR("%s: result=%d", __func__, instance->result);
@@ -309388,14 +315759,11 @@ index 0000000..3de3094
 +		goto unlock;
 +	}
 +
-+	ret = wait_for_completion_interruptible(&instance->msg_avail_comp);
-+	if (ret) {
-+		LOG_DBG("%s: failed on waiting for event (status=%d)\n",
-+			__func__, success);
-+		goto unlock;
-+	}
++	/* We are expecting a reply from the videocore */
++	wait_for_completion(&instance->msg_avail_comp);
++
 +	if (instance->result != 0) {
-+		LOG_ERR("%s: failed result (status=%d)\n",
++		LOG_ERR("%s: failed result (result=%d)\n",
 +			__func__, instance->result);
 +
 +		ret = -1;
@@ -310340,10 +316708,10 @@ index 0000000..af3e6eb
 +
 +#endif // _VC_AUDIO_DEFS_H_
 diff --git a/sound/soc/bcm/Kconfig b/sound/soc/bcm/Kconfig
-index 6a834e1..8873fd8a 100644
+index 6a834e1..23eefb5 100644
 --- a/sound/soc/bcm/Kconfig
 +++ b/sound/soc/bcm/Kconfig
-@@ -1,9 +1,116 @@
+@@ -1,9 +1,123 @@
  config SND_BCM2835_SOC_I2S
  	tristate "SoC Audio support for the Broadcom BCM2835 I2S module"
 -	depends on ARCH_BCM2835 || COMPILE_TEST
@@ -310461,11 +316829,18 @@ index 6a834e1..8873fd8a 100644
 +	select SND_SOC_PCM5102a
 +	help
 +	  Say Y or M if you want to add support for Dion Audio LOCO.
++
++config SND_BCM2708_SOC_ALLO_PIANO_DAC
++	tristate "Support for Allo Piano DAC"
++	depends on SND_BCM2708_SOC_I2S || SND_BCM2835_SOC_I2S
++	select SND_SOC_PCM512x_I2C
++	help
++	  Say Y or M if you want to add support for Allo Piano DAC.
 diff --git a/sound/soc/bcm/Makefile b/sound/soc/bcm/Makefile
-index bc816b7..17f70f9 100644
+index bc816b7..a2b642f 100644
 --- a/sound/soc/bcm/Makefile
 +++ b/sound/soc/bcm/Makefile
-@@ -3,3 +3,35 @@ snd-soc-bcm2835-i2s-objs := bcm2835-i2s.o
+@@ -3,3 +3,37 @@ snd-soc-bcm2835-i2s-objs := bcm2835-i2s.o
  
  obj-$(CONFIG_SND_BCM2835_SOC_I2S) += snd-soc-bcm2835-i2s.o
  
@@ -310485,6 +316860,7 @@ index bc816b7..17f70f9 100644
 +snd-soc-audioinjector-pi-soundcard-objs := audioinjector-pi-soundcard.o
 +snd-soc-digidac1-soundcard-objs := digidac1-soundcard.o
 +snd-soc-dionaudio-loco-objs := dionaudio_loco.o
++snd-soc-allo-piano-dac-objs := allo-piano-dac.o
 +
 +obj-$(CONFIG_SND_BCM2708_SOC_ADAU1977_ADC) += snd-soc-adau1977-adc.o
 +obj-$(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DAC) += snd-soc-hifiberry-dac.o
@@ -310501,6 +316877,7 @@ index bc816b7..17f70f9 100644
 +obj-$(CONFIG_SND_AUDIOINJECTOR_PI_SOUNDCARD) += snd-soc-audioinjector-pi-soundcard.o
 +obj-$(CONFIG_SND_DIGIDAC1_SOUNDCARD) += snd-soc-digidac1-soundcard.o
 +obj-$(CONFIG_SND_BCM2708_SOC_DIONAUDIO_LOCO) += snd-soc-dionaudio-loco.o
++obj-$(CONFIG_SND_BCM2708_SOC_ALLO_PIANO_DAC) += snd-soc-allo-piano-dac.o
 diff --git a/sound/soc/bcm/adau1977-adc.c b/sound/soc/bcm/adau1977-adc.c
 new file mode 100644
 index 0000000..6e2ee02
@@ -310632,6 +317009,156 @@ index 0000000..6e2ee02
 +MODULE_AUTHOR("Andrey Grodzovsky <andrey2805@gmail.com>");
 +MODULE_DESCRIPTION("ASoC Driver for ADAU1977 ADC");
 +MODULE_LICENSE("GPL v2");
+diff --git a/sound/soc/bcm/allo-piano-dac.c b/sound/soc/bcm/allo-piano-dac.c
+new file mode 100644
+index 0000000..8e8e62e
+--- /dev/null
++++ b/sound/soc/bcm/allo-piano-dac.c
+@@ -0,0 +1,144 @@
++/*
++ * ALSA ASoC Machine Driver for Allo Piano DAC
++ *
++ * Author:	Baswaraj K <jaikumar@cem-solutions.net>
++ *		Copyright 2016
++ *		based on code by Daniel Matuschek <info@crazy-audio.com>
++ *		based on code by Florian Meier <florian.meier@koalo.de>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * version 2 as published by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ */
++
++#include <linux/module.h>
++#include <linux/platform_device.h>
++
++#include <sound/core.h>
++#include <sound/pcm.h>
++#include <sound/pcm_params.h>
++#include <sound/soc.h>
++
++static bool digital_gain_0db_limit = true;
++
++static int snd_allo_piano_dac_init(struct snd_soc_pcm_runtime *rtd)
++{
++	if (digital_gain_0db_limit) {
++		int ret;
++		struct snd_soc_card *card = rtd->card;
++
++		ret = snd_soc_limit_volume(card, "Digital Playback Volume",
++					   207);
++		if (ret < 0)
++			dev_warn(card->dev, "Failed to set volume limit: %d\n",
++				 ret);
++	}
++
++	return 0;
++}
++
++static int snd_allo_piano_dac_hw_params(
++	struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
++{
++	struct snd_soc_pcm_runtime *rtd = substream->private_data;
++	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
++
++	unsigned int sample_bits =
++		snd_pcm_format_physical_width(params_format(params));
++
++	return snd_soc_dai_set_bclk_ratio(cpu_dai, sample_bits * 2);
++}
++
++/* machine stream operations */
++static struct snd_soc_ops snd_allo_piano_dac_ops = {
++	.hw_params = snd_allo_piano_dac_hw_params,
++};
++
++static struct snd_soc_dai_link snd_allo_piano_dac_dai[] = {
++{
++	.name		= "Piano DAC",
++	.stream_name	= "Piano DAC HiFi",
++	.cpu_dai_name	= "bcm2708-i2s.0",
++	.codec_dai_name	= "pcm512x-hifi",
++	.platform_name	= "bcm2708-i2s.0",
++	.codec_name	= "pcm512x.1-004c",
++	.dai_fmt	= SND_SOC_DAIFMT_I2S |
++			  SND_SOC_DAIFMT_NB_NF |
++			  SND_SOC_DAIFMT_CBS_CFS,
++	.ops		= &snd_allo_piano_dac_ops,
++	.init		= snd_allo_piano_dac_init,
++},
++};
++
++/* audio machine driver */
++static struct snd_soc_card snd_allo_piano_dac = {
++	.name         = "PianoDAC",
++	.owner        = THIS_MODULE,
++	.dai_link     = snd_allo_piano_dac_dai,
++	.num_links    = ARRAY_SIZE(snd_allo_piano_dac_dai),
++};
++
++static int snd_allo_piano_dac_probe(struct platform_device *pdev)
++{
++	int ret = 0;
++
++	snd_allo_piano_dac.dev = &pdev->dev;
++
++	if (pdev->dev.of_node) {
++		struct device_node *i2s_node;
++		struct snd_soc_dai_link *dai;
++
++		dai = &snd_allo_piano_dac_dai[0];
++		i2s_node = of_parse_phandle(pdev->dev.of_node,
++					    "i2s-controller", 0);
++
++		if (i2s_node) {
++			dai->cpu_dai_name = NULL;
++			dai->cpu_of_node = i2s_node;
++			dai->platform_name = NULL;
++			dai->platform_of_node = i2s_node;
++		}
++
++		digital_gain_0db_limit = !of_property_read_bool(
++			pdev->dev.of_node, "allo,24db_digital_gain");
++	}
++
++	ret = snd_soc_register_card(&snd_allo_piano_dac);
++	if (ret)
++		dev_err(&pdev->dev,
++			"snd_soc_register_card() failed: %d\n", ret);
++
++	return ret;
++}
++
++static int snd_allo_piano_dac_remove(struct platform_device *pdev)
++{
++	return snd_soc_unregister_card(&snd_allo_piano_dac);
++}
++
++static const struct of_device_id snd_allo_piano_dac_of_match[] = {
++	{ .compatible = "allo,piano-dac", },
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, snd_allo_piano_dac_of_match);
++
++static struct platform_driver snd_allo_piano_dac_driver = {
++	.driver = {
++		.name   = "snd-allo-piano-dac",
++		.owner  = THIS_MODULE,
++		.of_match_table = snd_allo_piano_dac_of_match,
++	},
++	.probe          = snd_allo_piano_dac_probe,
++	.remove         = snd_allo_piano_dac_remove,
++};
++
++module_platform_driver(snd_allo_piano_dac_driver);
++
++MODULE_AUTHOR("Baswaraj K <jaikumar@cem-solutions.net>");
++MODULE_DESCRIPTION("ALSA ASoC Machine Driver for Allo Piano DAC");
++MODULE_LICENSE("GPL v2");
 diff --git a/sound/soc/bcm/audioinjector-pi-soundcard.c b/sound/soc/bcm/audioinjector-pi-soundcard.c
 new file mode 100644
 index 0000000..5ff0985
@@ -312230,10 +318757,10 @@ index 0000000..6560067
 +MODULE_LICENSE("GPL v2");
 diff --git a/sound/soc/bcm/hifiberry_digi.c b/sound/soc/bcm/hifiberry_digi.c
 new file mode 100644
-index 0000000..9840e15
+index 0000000..52ab9dea
 --- /dev/null
 +++ b/sound/soc/bcm/hifiberry_digi.c
-@@ -0,0 +1,224 @@
+@@ -0,0 +1,275 @@
 +/*
 + * ASoC Driver for HifiBerry Digi
 + *
@@ -312259,6 +318786,7 @@ index 0000000..9840e15
 +#include <sound/pcm_params.h>
 +#include <sound/soc.h>
 +#include <sound/jack.h>
++#include <linux/gpio/consumer.h>
 +
 +#include "../codecs/wm8804.h"
 +
@@ -312266,9 +318794,34 @@ index 0000000..9840e15
 +module_param(auto_shutdown_output, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
 +MODULE_PARM_DESC(auto_shutdown_output, "Shutdown SP/DIF output if playback is stopped");
 +
++#define CLK_44EN_RATE 22579200UL
++#define CLK_48EN_RATE 24576000UL
++
++static bool snd_rpi_hifiberry_is_digipro;
++static struct gpio_desc *snd_rpi_hifiberry_clk44gpio;
++static struct gpio_desc *snd_rpi_hifiberry_clk48gpio;
 +
 +static int samplerate=44100;
 +
++static uint32_t snd_rpi_hifiberry_digi_enable_clock(int sample_rate)
++{
++	switch (sample_rate) {
++	case 11025:
++	case 22050:
++	case 44100:
++	case 88200:
++	case 176400:
++		gpiod_set_value_cansleep(snd_rpi_hifiberry_clk44gpio, 1);
++		gpiod_set_value_cansleep(snd_rpi_hifiberry_clk48gpio, 0);
++		return CLK_44EN_RATE;
++	default:
++		gpiod_set_value_cansleep(snd_rpi_hifiberry_clk48gpio, 1);
++		gpiod_set_value_cansleep(snd_rpi_hifiberry_clk44gpio, 0);
++		return CLK_48EN_RATE;
++	}
++}
++
++
 +static int snd_rpi_hifiberry_digi_init(struct snd_soc_pcm_runtime *rtd)
 +{
 +	struct snd_soc_codec *codec = rtd->codec;
@@ -312276,6 +318829,14 @@ index 0000000..9840e15
 +	/* enable TX output */
 +	snd_soc_update_bits(codec, WM8804_PWRDN, 0x4, 0x0);
 +
++	/* Initialize Digi+ Pro hardware */
++	if (snd_rpi_hifiberry_is_digipro) {
++		struct snd_soc_dai_link *dai = rtd->dai_link;
++
++		dai->name = "HiFiBerry Digi+ Pro";
++		dai->stream_name = "HiFiBerry Digi+ Pro HiFi";
++	}
++
 +	return 0;
 +}
 +
@@ -312323,6 +318884,9 @@ index 0000000..9840e15
 +		mclk_freq=samplerate*128;
 +		mclk_div=WM8804_MCLKDIV_128FS;
 +	}
++
++	if (snd_rpi_hifiberry_is_digipro)
++		sysclk = snd_rpi_hifiberry_digi_enable_clock(samplerate);
 +	
 +	switch (samplerate) {
 +		case 32000:
@@ -312357,6 +318921,7 @@ index 0000000..9840e15
 +
 +	ret = snd_soc_dai_set_sysclk(codec_dai, WM8804_TX_CLKSRC_PLL,
 +					sysclk, SND_SOC_CLOCK_OUT);
++
 +	if (ret < 0) {
 +		dev_err(codec->dev,
 +		"Failed to set WM8804 SYSCLK: %d\n", ret);
@@ -312423,6 +318988,19 @@ index 0000000..9840e15
 +		dai->platform_name = NULL;
 +		dai->platform_of_node = i2s_node;
 +	    }
++
++	    snd_rpi_hifiberry_is_digipro = 1;
++
++	    snd_rpi_hifiberry_clk44gpio =
++		devm_gpiod_get(&pdev->dev, "clock44", GPIOD_OUT_LOW);
++	    if (IS_ERR(snd_rpi_hifiberry_clk44gpio))
++		snd_rpi_hifiberry_is_digipro = 0;
++
++	    snd_rpi_hifiberry_clk48gpio =
++		devm_gpiod_get(&pdev->dev, "clock48", GPIOD_OUT_LOW);
++	    if (IS_ERR(snd_rpi_hifiberry_clk48gpio))
++		snd_rpi_hifiberry_is_digipro = 0;
++
 +	}
 +
 +	ret = snd_soc_register_card(&snd_rpi_hifiberry_digi);
diff --git a/package/kernel-osmc/patches/rbp-019-build-with-higher-optimisation.patch b/package/kernel-osmc/patches/rbp-019-build-with-higher-optimisation.patch
index 0e620bd21..cf652f2ae 100644
--- a/package/kernel-osmc/patches/rbp-019-build-with-higher-optimisation.patch
+++ b/package/kernel-osmc/patches/rbp-019-build-with-higher-optimisation.patch
@@ -1,8 +1,8 @@
 diff --git a/Makefile b/Makefile
-index 91cfe8d..b2d777d 100644
+index b6ee4ce..fe24891 100644
 --- a/Makefile
 +++ b/Makefile
-@@ -297,8 +297,8 @@ CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
+@@ -301,8 +301,8 @@ CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
  
  HOSTCC       = gcc
  HOSTCXX      = g++
@@ -13,11 +13,15 @@ index 91cfe8d..b2d777d 100644
  
  ifeq ($(shell $(HOSTCC) -v 2>&1 | grep -c "clang version"), 1)
  HOSTCFLAGS  += -Wno-unused-value -Wno-unused-parameter \
-@@ -614,7 +614,7 @@ KBUILD_CFLAGS	+= $(call cc-option,-fno-delete-null-pointer-checks,)
- ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
- KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
+@@ -622,9 +622,9 @@ ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
+ KBUILD_CFLAGS	+= -Os
  else
+ ifdef CONFIG_PROFILE_ALL_BRANCHES
 -KBUILD_CFLAGS	+= -O2
-+KBUILD_CFLAGS  += -O3
++KBUILD_CFLAGS	+= -O3
+ else
+-KBUILD_CFLAGS   += -O2
++KBUILD_CFLAGS   += -O3
+ endif
  endif
  
diff --git a/package/kernel-osmc/patches/rbp-029-alsa-by-default.patch b/package/kernel-osmc/patches/rbp-029-alsa-by-default.patch
index edac22e70..00b2b2582 100644
--- a/package/kernel-osmc/patches/rbp-029-alsa-by-default.patch
+++ b/package/kernel-osmc/patches/rbp-029-alsa-by-default.patch
@@ -1,26 +1,13 @@
-From e98c11c9ed072b3c0eccc5dc330f0e746bcebf41 Mon Sep 17 00:00:00 2001
-From: Sam Nazarko <email@samnazarko.co.uk>
-Date: Tue, 12 Jan 2016 00:36:37 +0000
-Subject: [PATCH] snd_bcm2835 by default
-
-Signed-off-by: Sam Nazarko <email@samnazarko.co.uk>
----
- arch/arm/boot/dts/bcm2708_common.dtsi | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
 diff --git a/arch/arm/boot/dts/bcm2708_common.dtsi b/arch/arm/boot/dts/bcm2708_common.dtsi
-index 75fb4ce..8b2e83e 100644
+index c449493..35d1d41 100644
 --- a/arch/arm/boot/dts/bcm2708_common.dtsi
 +++ b/arch/arm/boot/dts/bcm2708_common.dtsi
-@@ -34,7 +34,7 @@
- 	audio: audio {
- 		compatible = "brcm,bcm2835-audio";
- 		brcm,pwm-channels = <8>;
--		status = "disabled";
-+		status = "okay";
- 	};
+@@ -421,7 +421,7 @@
+ 		audio: audio {
+ 			compatible = "brcm,bcm2835-audio";
+ 			brcm,pwm-channels = <8>;
+-			status = "disabled";
++			status = "okay";
+ 		};
  
- 	/* External sound card */
--- 
-2.1.0
-
+ 		/* External sound card */
diff --git a/package/kernel-osmc/patches/rbp-031-xpad-upstream-changes.patch b/package/kernel-osmc/patches/rbp-031-xpad-upstream-changes.patch
deleted file mode 100644
index af71ce11f..000000000
--- a/package/kernel-osmc/patches/rbp-031-xpad-upstream-changes.patch
+++ /dev/null
@@ -1,1308 +0,0 @@
-diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c
-index fd4100d..2ff80cf 100644
---- a/drivers/input/joystick/xpad.c
-+++ b/drivers/input/joystick/xpad.c
-@@ -74,17 +74,20 @@
-  *
-  * Later changes can be tracked in SCM.
-  */
--
-+#define DEBUG
- #include <linux/kernel.h>
-+#include <linux/input.h>
-+#include <linux/rcupdate.h>
- #include <linux/slab.h>
- #include <linux/stat.h>
- #include <linux/module.h>
- #include <linux/usb/input.h>
-+#include <linux/usb/quirks.h>
- 
- #define DRIVER_AUTHOR "Marko Friedemann <mfr@bmx-chemnitz.de>"
- #define DRIVER_DESC "X-Box pad driver"
- 
--#define XPAD_PKT_LEN 32
-+#define XPAD_PKT_LEN 64
- 
- /* xbox d-pads should map to buttons, as is required for DDR pads
-    but we map them to axes when possible to simplify things */
-@@ -112,6 +115,10 @@ static bool sticks_to_null;
- module_param(sticks_to_null, bool, S_IRUGO);
- MODULE_PARM_DESC(sticks_to_null, "Do not map sticks at all for unknown pads");
- 
-+static bool auto_poweroff = true;
-+module_param(auto_poweroff, bool, S_IWUSR | S_IRUGO);
-+MODULE_PARM_DESC(auto_poweroff, "Power off wireless controllers on suspend");
-+
- static const struct xpad_device {
- 	u16 idVendor;
- 	u16 idProduct;
-@@ -125,7 +132,9 @@ static const struct xpad_device {
- 	{ 0x045e, 0x0289, "Microsoft X-Box pad v2 (US)", 0, XTYPE_XBOX },
- 	{ 0x045e, 0x028e, "Microsoft X-Box 360 pad", 0, XTYPE_XBOX360 },
- 	{ 0x045e, 0x02d1, "Microsoft X-Box One pad", 0, XTYPE_XBOXONE },
--	{ 0x045e, 0x02dd, "Microsoft X-Box One pad (Covert Forces)", 0, XTYPE_XBOXONE },
-+	{ 0x045e, 0x02dd, "Microsoft X-Box One pad (Firmware 2015)", 0, XTYPE_XBOXONE },
-+	{ 0x045e, 0x02ea, "Microsoft X-Box One S pad", 0, XTYPE_XBOXONE },
-+	{ 0x045e, 0x02e3, "Microsoft X-Box One Elite pad", 0, XTYPE_XBOXONE },
- 	{ 0x045e, 0x0291, "Xbox 360 Wireless Receiver (XBOX)", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },
- 	{ 0x045e, 0x0719, "Xbox 360 Wireless Receiver", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },
- 	{ 0x044f, 0x0f07, "Thrustmaster, Inc. Controller", 0, XTYPE_XBOX },
-@@ -150,6 +159,7 @@ static const struct xpad_device {
- 	{ 0x0738, 0x4728, "Mad Catz Street Fighter IV FightPad", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
- 	{ 0x0738, 0x4738, "Mad Catz Wired Xbox 360 Controller (SFIV)", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
- 	{ 0x0738, 0x4740, "Mad Catz Beat Pad", 0, XTYPE_XBOX360 },
-+	{ 0x0738, 0x4a01, "Mad Catz FightStick TE 2", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOXONE },
- 	{ 0x0738, 0x6040, "Mad Catz Beat Pad Pro", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
- 	{ 0x0738, 0xb726, "Mad Catz Xbox controller - MW2", 0, XTYPE_XBOX360 },
- 	{ 0x0738, 0xbeef, "Mad Catz JOYTECH NEO SE Advanced GamePad", XTYPE_XBOX360 },
-@@ -169,9 +179,11 @@ static const struct xpad_device {
- 	{ 0x0e6f, 0x0006, "Edge wireless Controller", 0, XTYPE_XBOX },
- 	{ 0x0e6f, 0x0105, "HSM3 Xbox360 dancepad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },
- 	{ 0x0e6f, 0x0113, "Afterglow AX.1 Gamepad for Xbox 360", 0, XTYPE_XBOX360 },
-+	{ 0x0e6f, 0x0139, "Afterglow Prismatic Wired Controller", 0, XTYPE_XBOXONE },
- 	{ 0x0e6f, 0x0201, "Pelican PL-3601 'TSZ' Wired Xbox 360 Controller", 0, XTYPE_XBOX360 },
- 	{ 0x0e6f, 0x0213, "Afterglow Gamepad for Xbox 360", 0, XTYPE_XBOX360 },
- 	{ 0x0e6f, 0x021f, "Rock Candy Gamepad for Xbox 360", 0, XTYPE_XBOX360 },
-+	{ 0x0e6f, 0x0146, "Rock Candy Wired Controller for Xbox One", 0, XTYPE_XBOXONE },
- 	{ 0x0e6f, 0x0301, "Logic3 Controller", 0, XTYPE_XBOX360 },
- 	{ 0x0e6f, 0x0401, "Logic3 Controller", 0, XTYPE_XBOX360 },
- 	{ 0x0e8f, 0x0201, "SmartJoy Frag Xpad/PS2 adaptor", 0, XTYPE_XBOX },
-@@ -179,6 +191,7 @@ static const struct xpad_device {
- 	{ 0x0f0d, 0x000a, "Hori Co. DOA4 FightStick", 0, XTYPE_XBOX360 },
- 	{ 0x0f0d, 0x000d, "Hori Fighting Stick EX2", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
- 	{ 0x0f0d, 0x0016, "Hori Real Arcade Pro.EX", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
-+	{ 0x0f0d, 0x0067, "HORIPAD ONE", 0, XTYPE_XBOXONE },
- 	{ 0x0f30, 0x0202, "Joytech Advanced Controller", 0, XTYPE_XBOX },
- 	{ 0x0f30, 0x8888, "BigBen XBMiniPad Controller", 0, XTYPE_XBOX },
- 	{ 0x102c, 0xff0c, "Joytech Wireless Advanced Controller", 0, XTYPE_XBOX },
-@@ -195,6 +208,7 @@ static const struct xpad_device {
- 	{ 0x162e, 0xbeef, "Joytech Neo-Se Take2", 0, XTYPE_XBOX360 },
- 	{ 0x1689, 0xfd00, "Razer Onza Tournament Edition", 0, XTYPE_XBOX360 },
- 	{ 0x1689, 0xfd01, "Razer Onza Classic Edition", 0, XTYPE_XBOX360 },
-+	{ 0x24c6, 0x542a, "Xbox ONE spectra", 0, XTYPE_XBOXONE },
- 	{ 0x24c6, 0x5d04, "Razer Sabertooth", 0, XTYPE_XBOX360 },
- 	{ 0x1bad, 0x0002, "Harmonix Rock Band Guitar", 0, XTYPE_XBOX360 },
- 	{ 0x1bad, 0x0003, "Harmonix Rock Band Drumkit", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },
-@@ -208,6 +222,8 @@ static const struct xpad_device {
- 	{ 0x24c6, 0x5000, "Razer Atrox Arcade Stick", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
- 	{ 0x24c6, 0x5300, "PowerA MINI PROEX Controller", 0, XTYPE_XBOX360 },
- 	{ 0x24c6, 0x5303, "Xbox Airflo wired controller", 0, XTYPE_XBOX360 },
-+	{ 0x24c6, 0x541a, "PowerA Xbox One Mini Wired Controller", 0, XTYPE_XBOXONE },
-+	{ 0x24c6, 0x543a, "PowerA Xbox One wired controller", 0, XTYPE_XBOXONE },
- 	{ 0x24c6, 0x5500, "Hori XBOX 360 EX 2 with Turbo", 0, XTYPE_XBOX360 },
- 	{ 0x24c6, 0x5501, "Hori Real Arcade Pro VX-SA", 0, XTYPE_XBOX360 },
- 	{ 0x24c6, 0x5506, "Hori SOULCALIBUR V Stick", 0, XTYPE_XBOX360 },
-@@ -217,54 +233,55 @@ static const struct xpad_device {
- 	{ 0x0000, 0x0000, "Generic X-Box pad", 0, XTYPE_UNKNOWN }
- };
- 
--/* buttons shared with xbox and xbox360 */
--static const signed short xpad_common_btn[] = {
--	BTN_A, BTN_B, BTN_X, BTN_Y,			/* "analog" buttons */
-+/* buttons shared with all xbox compatible controllers */
-+static const signed short xpad_btn_common[] = {
-+	BTN_A, BTN_B, BTN_X, BTN_Y,						/* coloured buttons */
- 	BTN_START, BTN_SELECT, BTN_THUMBL, BTN_THUMBR,	/* start/back/sticks */
--	-1						/* terminating entry */
--};
--
--/* original xbox controllers only */
--static const signed short xpad_btn[] = {
--	BTN_C, BTN_Z,		/* "analog" buttons */
--	-1			/* terminating entry */
-+	-1												/* terminating entry */
- };
- 
- /* used when dpad is mapped to buttons */
--static const signed short xpad_btn_pad[] = {
-+static const signed short xpad_btn_dpad[] = {
- 	BTN_TRIGGER_HAPPY1, BTN_TRIGGER_HAPPY2,		/* d-pad left, right */
- 	BTN_TRIGGER_HAPPY3, BTN_TRIGGER_HAPPY4,		/* d-pad up, down */
--	-1				/* terminating entry */
-+	-1											/* terminating entry */
- };
- 
- /* used when triggers are mapped to buttons */
- static const signed short xpad_btn_triggers[] = {
- 	BTN_TL2, BTN_TR2,		/* triggers left/right */
--	-1
-+	-1						/* terminating entry */
- };
- 
--static const signed short xpad360_btn[] = {  /* buttons for x360 controller */
--	BTN_TL, BTN_TR,		/* Button LB/RB */
--	BTN_MODE,		/* The big X button */
--	-1
-+/* original xbox controllers only */
-+static const signed short xpad_btn_original[] = {
-+	BTN_C, BTN_Z,		/* "analog" buttons */
-+	-1					/* terminating entry */
-+};
-+
-+/* buttons for xbox 360 and xbox one controllers */
-+static const signed short xpad_btn_360[] = {
-+	BTN_TL, BTN_TR,		/* Button LBumper/RBumper */
-+	BTN_MODE,			/* The big X button */
-+	-1					/* terminating entry */
- };
- 
--static const signed short xpad_abs[] = {
-+static const signed short xpad_abs_sticks[] = {
- 	ABS_X, ABS_Y,		/* left stick */
- 	ABS_RX, ABS_RY,		/* right stick */
--	-1			/* terminating entry */
-+	-1					/* terminating entry */
- };
- 
- /* used when dpad is mapped to axes */
--static const signed short xpad_abs_pad[] = {
-+static const signed short xpad_abs_dpad[] = {
- 	ABS_HAT0X, ABS_HAT0Y,	/* d-pad axes */
--	-1			/* terminating entry */
-+	-1						/* terminating entry */
- };
- 
- /* used when triggers are mapped to axes */
- static const signed short xpad_abs_triggers[] = {
- 	ABS_Z, ABS_RZ,		/* triggers left/right */
--	-1
-+	-1					/* terminating entry */
- };
- 
- /*
-@@ -301,37 +318,62 @@ static struct usb_device_id xpad_table[] = {
- 	XPAD_XBOX360_VENDOR(0x046d),		/* Logitech X-Box 360 style controllers */
- 	XPAD_XBOX360_VENDOR(0x0738),		/* Mad Catz X-Box 360 controllers */
- 	{ USB_DEVICE(0x0738, 0x4540) },		/* Mad Catz Beat Pad */
-+	XPAD_XBOXONE_VENDOR(0x0738),		/* Mad Catz FightStick TE 2 */
- 	XPAD_XBOX360_VENDOR(0x0e6f),		/* 0x0e6f X-Box 360 controllers */
-+	XPAD_XBOXONE_VENDOR(0x0e6f),		/* 0x0e6f X-Box One controllers */
-+	XPAD_XBOX360_VENDOR(0x0f0d),		/* Hori X-Box 360 Controllers */
-+	XPAD_XBOXONE_VENDOR(0x0f0d),		/* Hori X-Box One Controllers */
- 	XPAD_XBOX360_VENDOR(0x12ab),		/* X-Box 360 dance pads */
- 	XPAD_XBOX360_VENDOR(0x1430),		/* RedOctane X-Box 360 controllers */
--	XPAD_XBOX360_VENDOR(0x146b),		/* BigBen Interactive Controllers */
--	XPAD_XBOX360_VENDOR(0x1bad),		/* Harminix Rock Band Guitar and Drums */
--	XPAD_XBOX360_VENDOR(0x0f0d),		/* Hori Controllers */
--	XPAD_XBOX360_VENDOR(0x1689),		/* Razer Onza */
--	XPAD_XBOX360_VENDOR(0x24c6),		/* PowerA Controllers */
-+	XPAD_XBOX360_VENDOR(0x146b),		/* BigBen Interactive X-Box 360 Controllers */
- 	XPAD_XBOX360_VENDOR(0x1532),		/* Razer Sabertooth */
- 	XPAD_XBOX360_VENDOR(0x15e4),		/* Numark X-Box 360 controllers */
- 	XPAD_XBOX360_VENDOR(0x162e),		/* Joytech X-Box 360 controllers */
-+	XPAD_XBOX360_VENDOR(0x1689),		/* Razer Onza */
-+	XPAD_XBOX360_VENDOR(0x1bad),		/* Harminix Rock Band Guitar and Drums */
-+	XPAD_XBOX360_VENDOR(0x24c6),		/* PowerA X-Box 360 Controllers */
-+	XPAD_XBOXONE_VENDOR(0x24c6),		/* PowerA X-Box One Controllers */
- 	{ }
- };
- 
- MODULE_DEVICE_TABLE(usb, xpad_table);
- 
-+struct xpad_output_packet {
-+	u8 data[XPAD_PKT_LEN];
-+	u8 len;
-+	bool pending;
-+};
-+
-+#define XPAD_OUT_CMD_IDX	0
-+#define XPAD_OUT_FF_IDX		1
-+#define XPAD_OUT_LED_IDX	(1 + IS_ENABLED(CONFIG_JOYSTICK_XPAD_FF))
-+#define XPAD_NUM_OUT_PACKETS	(1 + \
-+				 IS_ENABLED(CONFIG_JOYSTICK_XPAD_FF) + \
-+				 IS_ENABLED(CONFIG_JOYSTICK_XPAD_LEDS))
-+
- struct usb_xpad {
- 	struct input_dev *dev;		/* input device interface */
-+	struct input_dev __rcu *x360w_dev;
- 	struct usb_device *udev;	/* usb device */
- 	struct usb_interface *intf;	/* usb interface */
- 
--	int pad_present;
-+	bool pad_present;
-+	bool input_created;
- 
- 	struct urb *irq_in;		/* urb for interrupt in report */
- 	unsigned char *idata;		/* input data */
- 	dma_addr_t idata_dma;
- 
- 	struct urb *irq_out;		/* urb for interrupt out report */
-+	struct usb_anchor irq_out_anchor;
-+	bool irq_out_active;		/* we must not use an active URB */
-+	u8 odata_serial;		/* serial number for xbox one protocol */
- 	unsigned char *odata;		/* output data */
- 	dma_addr_t odata_dma;
--	struct mutex odata_mutex;
-+	spinlock_t odata_lock;
-+
-+	struct xpad_output_packet out_packets[XPAD_NUM_OUT_PACKETS];
-+	int last_out_packet;
- 
- #if defined(CONFIG_JOYSTICK_XPAD_LEDS)
- 	struct xpad_led *led;
-@@ -343,8 +385,12 @@ struct usb_xpad {
- 	int xtype;			/* type of xbox device */
- 	int pad_nr;			/* the order x360 pads were attached */
- 	const char *name;		/* name of the device */
-+	struct work_struct work;	/* init/remove device from callback */
- };
- 
-+static int xpad_init_input(struct usb_xpad *xpad);
-+static void xpad_deinit_input(struct usb_xpad *xpad);
-+
- /*
-  *	xpad_process_packet
-  *
-@@ -424,10 +470,12 @@ static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *d
-  *		http://www.free60.org/wiki/Gamepad
-  */
- 
--static void xpad360_process_packet(struct usb_xpad *xpad,
-+static void xpad360_process_packet(struct usb_xpad *xpad, struct input_dev *dev,
- 				   u16 cmd, unsigned char *data)
- {
--	struct input_dev *dev = xpad->dev;
-+	/* valid pad data */
-+	if (data[0] != 0x00)
-+		return;
- 
- 	/* digital pad */
- 	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
-@@ -495,7 +543,30 @@ static void xpad360_process_packet(struct usb_xpad *xpad,
- 	input_sync(dev);
- }
- 
--static void xpad_identify_controller(struct usb_xpad *xpad);
-+static void xpad_presence_work(struct work_struct *work)
-+{
-+	struct usb_xpad *xpad = container_of(work, struct usb_xpad, work);
-+	int error;
-+
-+	if (xpad->pad_present) {
-+		error = xpad_init_input(xpad);
-+		if (error) {
-+			/* complain only, not much else we can do here */
-+			dev_err(&xpad->dev->dev,
-+				"unable to init device: %d\n", error);
-+		} else {
-+			rcu_assign_pointer(xpad->x360w_dev, xpad->dev);
-+		}
-+	} else {
-+		RCU_INIT_POINTER(xpad->x360w_dev, NULL);
-+		synchronize_rcu();
-+		/*
-+		 * Now that we are sure xpad360w_process_packet is not
-+		 * using input device we can get rid of it.
-+		 */
-+		xpad_deinit_input(xpad);
-+	}
-+}
- 
- /*
-  * xpad360w_process_packet
-@@ -513,35 +584,53 @@ static void xpad_identify_controller(struct usb_xpad *xpad);
-  */
- static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)
- {
-+	struct input_dev *dev;
-+	bool present;
-+
- 	/* Presence change */
- 	if (data[0] & 0x08) {
--		if (data[1] & 0x80) {
--			xpad->pad_present = 1;
--			/*
--			 * Light up the segment corresponding to
--			 * controller number.
--			 */
--			xpad_identify_controller(xpad);
--		} else
--			xpad->pad_present = 0;
-+		present = (data[1] & 0x80) != 0;
-+
-+		if (xpad->pad_present != present) {
-+			xpad->pad_present = present;
-+			schedule_work(&xpad->work);
-+		}
- 	}
- 
- 	/* Valid pad data */
--	if (!(data[1] & 0x1))
-+	if (data[1] != 0x1)
- 		return;
- 
--	xpad360_process_packet(xpad, cmd, &data[4]);
-+	rcu_read_lock();
-+	dev = rcu_dereference(xpad->x360w_dev);
-+	if (dev)
-+		xpad360_process_packet(xpad, dev, cmd, &data[4]);
-+	rcu_read_unlock();
- }
- 
- /*
-- *	xpadone_process_buttons
-+ *	xpadone_process_packet
-+ *
-+ *	Completes a request by converting the data into events for the
-+ *	input subsystem. This version is for the Xbox One controller.
-  *
-- *	Process a button update packet from an Xbox one controller.
-+ *	The report format was gleaned from
-+ *	https://github.com/kylelemons/xbox/blob/master/xbox.go
-  */
--static void xpadone_process_buttons(struct usb_xpad *xpad,
--				struct input_dev *dev,
--				unsigned char *data)
-+static void xpadone_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)
- {
-+	struct input_dev *dev = xpad->dev;
-+
-+	/* the xbox button has its own special report */
-+	if (data[0] == 0X07) {
-+		input_report_key(dev, BTN_MODE, data[4] & 0x01);
-+		input_sync(dev);
-+		return;
-+	}
-+	/* check invalid packet */
-+	else if (data[0] != 0X20)
-+		return;
-+
- 	/* menu/view buttons */
- 	input_report_key(dev, BTN_START,  data[4] & 0x04);
- 	input_report_key(dev, BTN_SELECT, data[4] & 0x08);
-@@ -604,34 +693,6 @@ static void xpadone_process_buttons(struct usb_xpad *xpad,
- 	input_sync(dev);
- }
- 
--/*
-- *	xpadone_process_packet
-- *
-- *	Completes a request by converting the data into events for the
-- *	input subsystem. This version is for the Xbox One controller.
-- *
-- *	The report format was gleaned from
-- *	https://github.com/kylelemons/xbox/blob/master/xbox.go
-- */
--
--static void xpadone_process_packet(struct usb_xpad *xpad,
--				u16 cmd, unsigned char *data)
--{
--	struct input_dev *dev = xpad->dev;
--
--	switch (data[0]) {
--	case 0x20:
--		xpadone_process_buttons(xpad, dev, data);
--		break;
--
--	case 0x07:
--		/* the xbox button has its own special report */
--		input_report_key(dev, BTN_MODE, data[4] & 0x01);
--		input_sync(dev);
--		break;
--	}
--}
--
- static void xpad_irq_in(struct urb *urb)
- {
- 	struct usb_xpad *xpad = urb->context;
-@@ -657,9 +718,16 @@ static void xpad_irq_in(struct urb *urb)
- 		goto exit;
- 	}
- 
-+#if defined(DEBUG_VERBOSE)
-+	/* If you set rowsize to larger than 32 it defaults to 16?
-+	 * Otherwise I would set it to XPAD_PKT_LEN                  V
-+	 */
-+	print_hex_dump(KERN_DEBUG, "xpad-dbg: ", DUMP_PREFIX_OFFSET, 32, 1, xpad->idata, XPAD_PKT_LEN, 0);
-+#endif
-+
- 	switch (xpad->xtype) {
- 	case XTYPE_XBOX360:
--		xpad360_process_packet(xpad, 0, xpad->idata);
-+		xpad360_process_packet(xpad, xpad->dev, 0, xpad->idata);
- 		break;
- 	case XTYPE_XBOX360W:
- 		xpad360w_process_packet(xpad, 0, xpad->idata);
-@@ -678,18 +746,73 @@ exit:
- 			__func__, retval);
- }
- 
-+/* Callers must hold xpad->odata_lock spinlock */
-+static bool xpad_prepare_next_out_packet(struct usb_xpad *xpad)
-+{
-+	struct xpad_output_packet *pkt, *packet = NULL;
-+	int i;
-+
-+	for (i = 0; i < XPAD_NUM_OUT_PACKETS; i++) {
-+		if (++xpad->last_out_packet >= XPAD_NUM_OUT_PACKETS)
-+			xpad->last_out_packet = 0;
-+
-+		pkt = &xpad->out_packets[xpad->last_out_packet];
-+		if (pkt->pending) {
-+			dev_dbg(&xpad->intf->dev,
-+				"%s - found pending output packet %d\n",
-+				__func__, xpad->last_out_packet);
-+			packet = pkt;
-+			break;
-+		}
-+	}
-+
-+	if (packet) {
-+		memcpy(xpad->odata, packet->data, packet->len);
-+		xpad->irq_out->transfer_buffer_length = packet->len;
-+		packet->pending = false;
-+		return true;
-+	}
-+
-+	return false;
-+}
-+
-+/* Callers must hold xpad->odata_lock spinlock */
-+static int xpad_try_sending_next_out_packet(struct usb_xpad *xpad)
-+{
-+	int error;
-+
-+	if (!xpad->irq_out_active && xpad_prepare_next_out_packet(xpad)) {
-+		usb_anchor_urb(xpad->irq_out, &xpad->irq_out_anchor);
-+		error = usb_submit_urb(xpad->irq_out, GFP_ATOMIC);
-+		if (error) {
-+			dev_err(&xpad->intf->dev,
-+				"%s - usb_submit_urb failed with result %d\n",
-+				__func__, error);
-+			usb_unanchor_urb(xpad->irq_out);
-+			return -EIO;
-+		}
-+
-+		xpad->irq_out_active = true;
-+	}
-+
-+	return 0;
-+}
-+
- static void xpad_irq_out(struct urb *urb)
- {
- 	struct usb_xpad *xpad = urb->context;
- 	struct device *dev = &xpad->intf->dev;
--	int retval, status;
-+	int status = urb->status;
-+	int error;
-+	unsigned long flags;
- 
--	status = urb->status;
-+	spin_lock_irqsave(&xpad->odata_lock, flags);
- 
- 	switch (status) {
- 	case 0:
- 		/* success */
--		return;
-+		xpad->irq_out_active = xpad_prepare_next_out_packet(xpad);
-+		break;
- 
- 	case -ECONNRESET:
- 	case -ENOENT:
-@@ -697,43 +820,52 @@ static void xpad_irq_out(struct urb *urb)
- 		/* this urb is terminated, clean up */
- 		dev_dbg(dev, "%s - urb shutting down with status: %d\n",
- 			__func__, status);
--		return;
-+		xpad->irq_out_active = false;
-+		break;
- 
- 	default:
- 		dev_dbg(dev, "%s - nonzero urb status received: %d\n",
- 			__func__, status);
--		goto exit;
-+		break;
- 	}
- 
--exit:
--	retval = usb_submit_urb(urb, GFP_ATOMIC);
--	if (retval)
--		dev_err(dev, "%s - usb_submit_urb failed with result %d\n",
--			__func__, retval);
-+	if (xpad->irq_out_active) {
-+		usb_anchor_urb(urb, &xpad->irq_out_anchor);
-+		error = usb_submit_urb(urb, GFP_ATOMIC);
-+		if (error) {
-+			dev_err(dev,
-+				"%s - usb_submit_urb failed with result %d\n",
-+				__func__, error);
-+			usb_unanchor_urb(urb);
-+			xpad->irq_out_active = false;
-+		}
-+	}
-+
-+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
- }
- 
- static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
- {
- 	struct usb_endpoint_descriptor *ep_irq_out;
- 	int ep_irq_out_idx;
--	int error;
- 
- 	if (xpad->xtype == XTYPE_UNKNOWN)
- 		return 0;
- 
-+	init_usb_anchor(&xpad->irq_out_anchor);
-+
- 	xpad->odata = usb_alloc_coherent(xpad->udev, XPAD_PKT_LEN,
- 					 GFP_KERNEL, &xpad->odata_dma);
- 	if (!xpad->odata) {
--		error = -ENOMEM;
--		goto fail1;
-+		return -ENOMEM;
- 	}
- 
--	mutex_init(&xpad->odata_mutex);
-+	spin_lock_init(&xpad->odata_lock);
- 
- 	xpad->irq_out = usb_alloc_urb(0, GFP_KERNEL);
- 	if (!xpad->irq_out) {
--		error = -ENOMEM;
--		goto fail2;
-+		usb_free_coherent(xpad->udev, XPAD_PKT_LEN, xpad->odata, xpad->odata_dma);
-+		return -ENOMEM;
- 	}
- 
- 	/* Xbox One controller has in/out endpoints swapped. */
-@@ -748,15 +880,18 @@ static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
- 	xpad->irq_out->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
- 
- 	return 0;
--
-- fail2:	usb_free_coherent(xpad->udev, XPAD_PKT_LEN, xpad->odata, xpad->odata_dma);
-- fail1:	return error;
- }
- 
- static void xpad_stop_output(struct usb_xpad *xpad)
- {
--	if (xpad->xtype != XTYPE_UNKNOWN)
--		usb_kill_urb(xpad->irq_out);
-+	if (xpad->xtype != XTYPE_UNKNOWN) {
-+		if (!usb_wait_anchor_empty_timeout(&xpad->irq_out_anchor,
-+						   5000)) {
-+			dev_warn(&xpad->intf->dev,
-+				 "timed out waiting for output URB to complete, killing\n");
-+			usb_kill_anchored_urbs(&xpad->irq_out_anchor);
-+		}
-+	}
- }
- 
- static void xpad_deinit_output(struct usb_xpad *xpad)
-@@ -770,27 +905,60 @@ static void xpad_deinit_output(struct usb_xpad *xpad)
- 
- static int xpad_inquiry_pad_presence(struct usb_xpad *xpad)
- {
-+	struct xpad_output_packet *packet =
-+			&xpad->out_packets[XPAD_OUT_CMD_IDX];
-+	unsigned long flags;
-+	int retval;
-+
-+	spin_lock_irqsave(&xpad->odata_lock, flags);
-+
-+	packet->data[0] = 0x08;
-+	packet->data[1] = 0x00;
-+	packet->data[2] = 0x0F;
-+	packet->data[3] = 0xC0;
-+	packet->data[4] = 0x00;
-+	packet->data[5] = 0x00;
-+	packet->data[6] = 0x00;
-+	packet->data[7] = 0x00;
-+	packet->data[8] = 0x00;
-+	packet->data[9] = 0x00;
-+	packet->data[10] = 0x00;
-+	packet->data[11] = 0x00;
-+	packet->len = 12;
-+	packet->pending = true;
-+
-+	/* Reset the sequence so we send out presence first */
-+	xpad->last_out_packet = -1;
-+	retval = xpad_try_sending_next_out_packet(xpad);
-+
-+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
-+
-+	return retval;
-+}
-+
-+static int xpad_start_xbox_one(struct usb_xpad *xpad)
-+{
-+	struct xpad_output_packet *packet =
-+			&xpad->out_packets[XPAD_OUT_CMD_IDX];
-+	unsigned long flags;
- 	int retval;
- 
--	mutex_lock(&xpad->odata_mutex);
-+	spin_lock_irqsave(&xpad->odata_lock, flags);
- 
--	xpad->odata[0] = 0x08;
--	xpad->odata[1] = 0x00;
--	xpad->odata[2] = 0x0F;
--	xpad->odata[3] = 0xC0;
--	xpad->odata[4] = 0x00;
--	xpad->odata[5] = 0x00;
--	xpad->odata[6] = 0x00;
--	xpad->odata[7] = 0x00;
--	xpad->odata[8] = 0x00;
--	xpad->odata[9] = 0x00;
--	xpad->odata[10] = 0x00;
--	xpad->odata[11] = 0x00;
--	xpad->irq_out->transfer_buffer_length = 12;
-+	/* Xbox one controller needs to be initialized. */
-+	packet->data[0] = 0x05;
-+	packet->data[1] = 0x20;
-+	packet->data[2] = xpad->odata_serial++; /* packet serial */
-+	packet->data[3] = 0x01; /* rumble bit enable?  */
-+	packet->data[4] = 0x00;
-+	packet->len = 5;
-+	packet->pending = true;
- 
--	retval = usb_submit_urb(xpad->irq_out, GFP_KERNEL);
-+	/* Reset the sequence so we send out start packet first */
-+	xpad->last_out_packet = -1;
-+	retval = xpad_try_sending_next_out_packet(xpad);
- 
--	mutex_unlock(&xpad->odata_mutex);
-+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
- 
- 	return retval;
- }
-@@ -799,8 +967,11 @@ static int xpad_inquiry_pad_presence(struct usb_xpad *xpad)
- static int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)
- {
- 	struct usb_xpad *xpad = input_get_drvdata(dev);
-+	struct xpad_output_packet *packet = &xpad->out_packets[XPAD_OUT_FF_IDX];
- 	__u16 strong;
- 	__u16 weak;
-+	int retval;
-+	unsigned long flags;
- 
- 	if (effect->type != FF_RUMBLE)
- 		return 0;
-@@ -808,69 +979,81 @@ static int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect
- 	strong = effect->u.rumble.strong_magnitude;
- 	weak = effect->u.rumble.weak_magnitude;
- 
-+	spin_lock_irqsave(&xpad->odata_lock, flags);
-+
- 	switch (xpad->xtype) {
- 	case XTYPE_XBOX:
--		xpad->odata[0] = 0x00;
--		xpad->odata[1] = 0x06;
--		xpad->odata[2] = 0x00;
--		xpad->odata[3] = strong / 256;	/* left actuator */
--		xpad->odata[4] = 0x00;
--		xpad->odata[5] = weak / 256;	/* right actuator */
--		xpad->irq_out->transfer_buffer_length = 6;
-+		packet->data[0] = 0x00;
-+		packet->data[1] = 0x06;
-+		packet->data[2] = 0x00;
-+		packet->data[3] = strong / 256;	/* left actuator */
-+		packet->data[4] = 0x00;
-+		packet->data[5] = weak / 256;	/* right actuator */
-+		packet->len = 6;
-+		packet->pending = true;
- 		break;
- 
- 	case XTYPE_XBOX360:
--		xpad->odata[0] = 0x00;
--		xpad->odata[1] = 0x08;
--		xpad->odata[2] = 0x00;
--		xpad->odata[3] = strong / 256;  /* left actuator? */
--		xpad->odata[4] = weak / 256;	/* right actuator? */
--		xpad->odata[5] = 0x00;
--		xpad->odata[6] = 0x00;
--		xpad->odata[7] = 0x00;
--		xpad->irq_out->transfer_buffer_length = 8;
-+		packet->data[0] = 0x00;
-+		packet->data[1] = 0x08;
-+		packet->data[2] = 0x00;
-+		packet->data[3] = strong / 256;  /* left actuator? */
-+		packet->data[4] = weak / 256;	/* right actuator? */
-+		packet->data[5] = 0x00;
-+		packet->data[6] = 0x00;
-+		packet->data[7] = 0x00;
-+		packet->len = 8;
-+		packet->pending = true;
- 		break;
- 
- 	case XTYPE_XBOX360W:
--		xpad->odata[0] = 0x00;
--		xpad->odata[1] = 0x01;
--		xpad->odata[2] = 0x0F;
--		xpad->odata[3] = 0xC0;
--		xpad->odata[4] = 0x00;
--		xpad->odata[5] = strong / 256;
--		xpad->odata[6] = weak / 256;
--		xpad->odata[7] = 0x00;
--		xpad->odata[8] = 0x00;
--		xpad->odata[9] = 0x00;
--		xpad->odata[10] = 0x00;
--		xpad->odata[11] = 0x00;
--		xpad->irq_out->transfer_buffer_length = 12;
-+		packet->data[0] = 0x00;
-+		packet->data[1] = 0x01;
-+		packet->data[2] = 0x0F;
-+		packet->data[3] = 0xC0;
-+		packet->data[4] = 0x00;
-+		packet->data[5] = strong / 256;
-+		packet->data[6] = weak / 256;
-+		packet->data[7] = 0x00;
-+		packet->data[8] = 0x00;
-+		packet->data[9] = 0x00;
-+		packet->data[10] = 0x00;
-+		packet->data[11] = 0x00;
-+		packet->len = 12;
-+		packet->pending = true;
- 		break;
- 
- 	case XTYPE_XBOXONE:
--		xpad->odata[0] = 0x09; /* activate rumble */
--		xpad->odata[1] = 0x08;
--		xpad->odata[2] = 0x00;
--		xpad->odata[3] = 0x08; /* continuous effect */
--		xpad->odata[4] = 0x00; /* simple rumble mode */
--		xpad->odata[5] = 0x03; /* L and R actuator only */
--		xpad->odata[6] = 0x00; /* TODO: LT actuator */
--		xpad->odata[7] = 0x00; /* TODO: RT actuator */
--		xpad->odata[8] = strong / 256;	/* left actuator */
--		xpad->odata[9] = weak / 256;	/* right actuator */
--		xpad->odata[10] = 0x80;	/* length of pulse */
--		xpad->odata[11] = 0x00;	/* stop period of pulse */
--		xpad->irq_out->transfer_buffer_length = 12;
-+		packet->data[0] = 0x09; /* activate rumble */
-+		packet->data[1] = 0x00;
-+		packet->data[2] = xpad->odata_serial++;
-+		packet->data[3] = 0x09;
-+		packet->data[4] = 0x00;
-+		packet->data[5] = 0x0F;
-+		packet->data[6] = 0x00;
-+		packet->data[7] = 0x00;
-+		packet->data[8] = strong / 512;	/* left actuator */
-+		packet->data[9] = weak / 512;	/* right actuator */
-+		packet->data[10] = 0xFF;
-+		packet->data[11] = 0x00;
-+		packet->data[12] = 0x00;
-+		packet->len = 13;
-+		packet->pending = true;
- 		break;
- 
- 	default:
- 		dev_dbg(&xpad->dev->dev,
- 			"%s - rumble command sent to unsupported xpad type: %d\n",
- 			__func__, xpad->xtype);
--		return -EINVAL;
-+		retval = -EINVAL;
-+		goto out;
- 	}
- 
--	return usb_submit_urb(xpad->irq_out, GFP_ATOMIC);
-+	retval = xpad_try_sending_next_out_packet(xpad);
-+
-+out:
-+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
-+	return retval;
- }
- 
- static int xpad_init_ff(struct usb_xpad *xpad)
-@@ -921,36 +1104,44 @@ struct xpad_led {
-  */
- static void xpad_send_led_command(struct usb_xpad *xpad, int command)
- {
-+	struct xpad_output_packet *packet =
-+			&xpad->out_packets[XPAD_OUT_LED_IDX];
-+	unsigned long flags;
-+
- 	command %= 16;
- 
--	mutex_lock(&xpad->odata_mutex);
-+	spin_lock_irqsave(&xpad->odata_lock, flags);
- 
- 	switch (xpad->xtype) {
- 	case XTYPE_XBOX360:
--		xpad->odata[0] = 0x01;
--		xpad->odata[1] = 0x03;
--		xpad->odata[2] = command;
--		xpad->irq_out->transfer_buffer_length = 3;
-+		packet->data[0] = 0x01;
-+		packet->data[1] = 0x03;
-+		packet->data[2] = command;
-+		packet->len = 3;
-+		packet->pending = true;
- 		break;
-+
- 	case XTYPE_XBOX360W:
--		xpad->odata[0] = 0x00;
--		xpad->odata[1] = 0x00;
--		xpad->odata[2] = 0x08;
--		xpad->odata[3] = 0x40 + command;
--		xpad->odata[4] = 0x00;
--		xpad->odata[5] = 0x00;
--		xpad->odata[6] = 0x00;
--		xpad->odata[7] = 0x00;
--		xpad->odata[8] = 0x00;
--		xpad->odata[9] = 0x00;
--		xpad->odata[10] = 0x00;
--		xpad->odata[11] = 0x00;
--		xpad->irq_out->transfer_buffer_length = 12;
-+		packet->data[0] = 0x00;
-+		packet->data[1] = 0x00;
-+		packet->data[2] = 0x08;
-+		packet->data[3] = 0x40 + command;
-+		packet->data[4] = 0x00;
-+		packet->data[5] = 0x00;
-+		packet->data[6] = 0x00;
-+		packet->data[7] = 0x00;
-+		packet->data[8] = 0x00;
-+		packet->data[9] = 0x00;
-+		packet->data[10] = 0x00;
-+		packet->data[11] = 0x00;
-+		packet->len = 12;
-+		packet->pending = true;
- 		break;
- 	}
- 
--	usb_submit_urb(xpad->irq_out, GFP_KERNEL);
--	mutex_unlock(&xpad->odata_mutex);
-+	xpad_try_sending_next_out_packet(xpad);
-+
-+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
- }
- 
- /*
-@@ -959,7 +1150,7 @@ static void xpad_send_led_command(struct usb_xpad *xpad, int command)
-  */
- static void xpad_identify_controller(struct usb_xpad *xpad)
- {
--	xpad_send_led_command(xpad, (xpad->pad_nr % 4) + 2);
-+	led_set_brightness(&xpad->led->led_cdev, (xpad->pad_nr % 4) + 2);
- }
- 
- static void xpad_led_set(struct led_classdev *led_cdev,
-@@ -1001,14 +1192,7 @@ static int xpad_led_probe(struct usb_xpad *xpad)
- 	if (error)
- 		goto err_free_id;
- 
--	if (xpad->xtype == XTYPE_XBOX360) {
--		/*
--		 * Light up the segment corresponding to controller
--		 * number on wired devices. On wireless we'll do that
--		 * when they respond to "presence" packet.
--		 */
--		xpad_identify_controller(xpad);
--	}
-+	xpad_identify_controller(xpad);
- 
- 	return 0;
- 
-@@ -1033,40 +1217,105 @@ static void xpad_led_disconnect(struct usb_xpad *xpad)
- #else
- static int xpad_led_probe(struct usb_xpad *xpad) { return 0; }
- static void xpad_led_disconnect(struct usb_xpad *xpad) { }
--static void xpad_identify_controller(struct usb_xpad *xpad) { }
- #endif
- 
--static int xpad_open(struct input_dev *dev)
-+static int xpad_start_input(struct usb_xpad *xpad)
- {
--	struct usb_xpad *xpad = input_get_drvdata(dev);
--
--	/* URB was submitted in probe */
--	if (xpad->xtype == XTYPE_XBOX360W)
--		return 0;
-+	int error;
- 
--	xpad->irq_in->dev = xpad->udev;
- 	if (usb_submit_urb(xpad->irq_in, GFP_KERNEL))
- 		return -EIO;
- 
- 	if (xpad->xtype == XTYPE_XBOXONE) {
--		/* Xbox one controller needs to be initialized. */
--		xpad->odata[0] = 0x05;
--		xpad->odata[1] = 0x20;
--		xpad->irq_out->transfer_buffer_length = 2;
--		return usb_submit_urb(xpad->irq_out, GFP_KERNEL);
-+		error = xpad_start_xbox_one(xpad);
-+		if (error) {
-+			usb_kill_urb(xpad->irq_in);
-+			return error;
-+		}
- 	}
- 
- 	return 0;
- }
- 
--static void xpad_close(struct input_dev *dev)
-+static void xpad_stop_input(struct usb_xpad *xpad)
- {
--	struct usb_xpad *xpad = input_get_drvdata(dev);
-+	usb_kill_urb(xpad->irq_in);
-+}
-+
-+static void xpad360w_poweroff_controller(struct usb_xpad *xpad)
-+{
-+	unsigned long flags;
-+	struct xpad_output_packet *packet =
-+			&xpad->out_packets[XPAD_OUT_CMD_IDX];
-+
-+	spin_lock_irqsave(&xpad->odata_lock, flags);
-+
-+	packet->data[0] = 0x00;
-+	packet->data[1] = 0x00;
-+	packet->data[2] = 0x08;
-+	packet->data[3] = 0xC0;
-+	packet->data[4] = 0x00;
-+	packet->data[5] = 0x00;
-+	packet->data[6] = 0x00;
-+	packet->data[7] = 0x00;
-+	packet->data[8] = 0x00;
-+	packet->data[9] = 0x00;
-+	packet->data[10] = 0x00;
-+	packet->data[11] = 0x00;
-+	packet->len = 12;
-+	packet->pending = true;
-+
-+	/* Reset the sequence so we send out poweroff now */
-+	xpad->last_out_packet = -1;
-+	xpad_try_sending_next_out_packet(xpad);
-+
-+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
-+}
-+
-+static int xpad360w_start_input(struct usb_xpad *xpad)
-+{
-+	int error;
-+
-+	error = usb_submit_urb(xpad->irq_in, GFP_KERNEL);
-+	if (error)
-+		return -EIO;
- 
--	if (xpad->xtype != XTYPE_XBOX360W)
-+	/*
-+	 * Send presence packet.
-+	 * This will force the controller to resend connection packets.
-+	 * This is useful in the case we activate the module after the
-+	 * adapter has been plugged in, as it won't automatically
-+	 * send us info about the controllers.
-+	 */
-+	error = xpad_inquiry_pad_presence(xpad);
-+	if (error) {
- 		usb_kill_urb(xpad->irq_in);
-+		return error;
-+	}
- 
--	xpad_stop_output(xpad);
-+	return 0;
-+}
-+
-+static void xpad360w_stop_input(struct usb_xpad *xpad)
-+{
-+	usb_kill_urb(xpad->irq_in);
-+
-+	/* Make sure we are done with presence work if it was scheduled */
-+	flush_work(&xpad->work);
-+}
-+
-+static int xpad_open(struct input_dev *dev)
-+{
-+	struct usb_xpad *xpad = input_get_drvdata(dev);
-+
-+	return xpad_start_input(xpad);
-+}
-+
-+static void xpad_close(struct input_dev *dev)
-+{
-+	struct usb_xpad *xpad = input_get_drvdata(dev);
-+
-+	xpad_stop_input(xpad);
- }
- 
- static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)
-@@ -1097,8 +1346,11 @@ static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)
- 
- static void xpad_deinit_input(struct usb_xpad *xpad)
- {
--	xpad_led_disconnect(xpad);
--	input_unregister_device(xpad->dev);
-+	if (xpad->input_created) {
-+		xpad->input_created = false;
-+		xpad_led_disconnect(xpad);
-+		input_unregister_device(xpad->dev);
-+	}
- }
- 
- static int xpad_init_input(struct usb_xpad *xpad)
-@@ -1118,35 +1370,37 @@ static int xpad_init_input(struct usb_xpad *xpad)
- 
- 	input_set_drvdata(input_dev, xpad);
- 
--	input_dev->open = xpad_open;
--	input_dev->close = xpad_close;
-+	if (xpad->xtype != XTYPE_XBOX360W) {
-+		input_dev->open = xpad_open;
-+		input_dev->close = xpad_close;
-+	}
- 
- 	__set_bit(EV_KEY, input_dev->evbit);
- 
- 	if (!(xpad->mapping & MAP_STICKS_TO_NULL)) {
- 		__set_bit(EV_ABS, input_dev->evbit);
- 		/* set up axes */
--		for (i = 0; xpad_abs[i] >= 0; i++)
--			xpad_set_up_abs(input_dev, xpad_abs[i]);
-+		for (i = 0; xpad_abs_sticks[i] >= 0; i++)
-+			xpad_set_up_abs(input_dev, xpad_abs_sticks[i]);
- 	}
- 
- 	/* set up standard buttons */
--	for (i = 0; xpad_common_btn[i] >= 0; i++)
--		__set_bit(xpad_common_btn[i], input_dev->keybit);
-+	for (i = 0; xpad_btn_common[i] >= 0; i++)
-+		__set_bit(xpad_btn_common[i], input_dev->keybit);
- 
- 	/* set up model-specific ones */
- 	if (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX360W ||
- 	    xpad->xtype == XTYPE_XBOXONE) {
--		for (i = 0; xpad360_btn[i] >= 0; i++)
--			__set_bit(xpad360_btn[i], input_dev->keybit);
-+		for (i = 0; xpad_btn_360[i] >= 0; i++)
-+			__set_bit(xpad_btn_360[i], input_dev->keybit);
- 	} else {
--		for (i = 0; xpad_btn[i] >= 0; i++)
--			__set_bit(xpad_btn[i], input_dev->keybit);
-+		for (i = 0; xpad_btn_original[i] >= 0; i++)
-+			__set_bit(xpad_btn_original[i], input_dev->keybit);
- 	}
- 
- 	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
--		for (i = 0; xpad_btn_pad[i] >= 0; i++)
--			__set_bit(xpad_btn_pad[i], input_dev->keybit);
-+		for (i = 0; xpad_btn_dpad[i] >= 0; i++)
-+			__set_bit(xpad_btn_dpad[i], input_dev->keybit);
- 	}
- 
- 	/*
-@@ -1157,8 +1411,8 @@ static int xpad_init_input(struct usb_xpad *xpad)
- 	 */
- 	if (!(xpad->mapping & MAP_DPAD_TO_BUTTONS) ||
- 	    xpad->xtype == XTYPE_XBOX360W) {
--		for (i = 0; xpad_abs_pad[i] >= 0; i++)
--			xpad_set_up_abs(input_dev, xpad_abs_pad[i]);
-+		for (i = 0; xpad_abs_dpad[i] >= 0; i++)
-+			xpad_set_up_abs(input_dev, xpad_abs_dpad[i]);
- 	}
- 
- 	if (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {
-@@ -1181,6 +1435,7 @@ static int xpad_init_input(struct usb_xpad *xpad)
- 	if (error)
- 		goto err_disconnect_led;
- 
-+	xpad->input_created = true;
- 	return 0;
- 
- err_disconnect_led:
-@@ -1200,22 +1455,15 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
- 	int ep_irq_in_idx;
- 	int i, error;
- 
-+	if (intf->cur_altsetting->desc.bNumEndpoints != 2)
-+		return -ENODEV;
-+
- 	for (i = 0; xpad_device[i].idVendor; i++) {
- 		if ((le16_to_cpu(udev->descriptor.idVendor) == xpad_device[i].idVendor) &&
- 		    (le16_to_cpu(udev->descriptor.idProduct) == xpad_device[i].idProduct))
- 			break;
- 	}
- 
--	if (xpad_device[i].xtype == XTYPE_XBOXONE &&
--	    intf->cur_altsetting->desc.bInterfaceNumber != 0) {
--		/*
--		 * The Xbox One controller lists three interfaces all with the
--		 * same interface class, subclass and protocol. Differentiate by
--		 * interface number.
--		 */
--		return -ENODEV;
--	}
--
- 	xpad = kzalloc(sizeof(struct usb_xpad), GFP_KERNEL);
- 	if (!xpad)
- 		return -ENOMEM;
-@@ -1241,11 +1489,14 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
- 	xpad->mapping = xpad_device[i].mapping;
- 	xpad->xtype = xpad_device[i].xtype;
- 	xpad->name = xpad_device[i].name;
-+	INIT_WORK(&xpad->work, xpad_presence_work);
- 
- 	if (xpad->xtype == XTYPE_UNKNOWN) {
- 		if (intf->cur_altsetting->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC) {
- 			if (intf->cur_altsetting->desc.bInterfaceProtocol == 129)
- 				xpad->xtype = XTYPE_XBOX360W;
-+			else if (intf->cur_altsetting->desc.bInterfaceProtocol == 208)
-+				xpad->xtype = XTYPE_XBOXONE;
- 			else
- 				xpad->xtype = XTYPE_XBOX360;
- 		} else {
-@@ -1260,6 +1511,17 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
- 			xpad->mapping |= MAP_STICKS_TO_NULL;
- 	}
- 
-+	if (xpad->xtype == XTYPE_XBOXONE &&
-+	    intf->cur_altsetting->desc.bInterfaceNumber != 0) {
-+		/*
-+		 * The Xbox One controller lists three interfaces all with the
-+		 * same interface class, subclass and protocol. Differentiate by
-+		 * interface number.
-+		 */
-+		error = -ENODEV;
-+		goto err_free_in_urb;
-+	}
-+
- 	error = xpad_init_output(intf, xpad);
- 	if (error)
- 		goto err_free_in_urb;
-@@ -1277,10 +1539,6 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
- 
- 	usb_set_intfdata(intf, xpad);
- 
--	error = xpad_init_input(xpad);
--	if (error)
--		goto err_deinit_output;
--
- 	if (xpad->xtype == XTYPE_XBOX360W) {
- 		/*
- 		 * Submit the int URB immediately rather than waiting for open
-@@ -1289,28 +1547,24 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
- 		 * exactly the message that a controller has arrived that
- 		 * we're waiting for.
- 		 */
--		xpad->irq_in->dev = xpad->udev;
--		error = usb_submit_urb(xpad->irq_in, GFP_KERNEL);
-+		error = xpad360w_start_input(xpad);
- 		if (error)
--			goto err_deinit_input;
--
-+			goto err_deinit_output;
- 		/*
--		 * Send presence packet.
--		 * This will force the controller to resend connection packets.
--		 * This is useful in the case we activate the module after the
--		 * adapter has been plugged in, as it won't automatically
--		 * send us info about the controllers.
-+		 * Wireless controllers require RESET_RESUME to work properly
-+		 * after suspend. Ideally this quirk should be in usb core
-+		 * quirk list, but we have too many vendors producing these
-+		 * controllers and we'd need to maintain 2 identical lists
-+		 * here in this driver and in usb core.
- 		 */
--		error = xpad_inquiry_pad_presence(xpad);
-+		udev->quirks |= USB_QUIRK_RESET_RESUME;
-+	} else {
-+		error = xpad_init_input(xpad);
- 		if (error)
--			goto err_kill_in_urb;
-+			goto err_deinit_output;
- 	}
- 	return 0;
- 
--err_kill_in_urb:
--	usb_kill_urb(xpad->irq_in);
--err_deinit_input:
--	xpad_deinit_input(xpad);
- err_deinit_output:
- 	xpad_deinit_output(xpad);
- err_free_in_urb:
-@@ -1320,19 +1574,24 @@ err_free_idata:
- err_free_mem:
- 	kfree(xpad);
- 	return error;
--
- }
- 
- static void xpad_disconnect(struct usb_interface *intf)
- {
--	struct usb_xpad *xpad = usb_get_intfdata (intf);
-+	struct usb_xpad *xpad = usb_get_intfdata(intf);
-+
-+	if (xpad->xtype == XTYPE_XBOX360W)
-+		xpad360w_stop_input(xpad);
- 
- 	xpad_deinit_input(xpad);
--	xpad_deinit_output(xpad);
- 
--	if (xpad->xtype == XTYPE_XBOX360W) {
--		usb_kill_urb(xpad->irq_in);
--	}
-+	/*
-+	 * Now that both input device and LED device are gone we can
-+	 * stop output URB.
-+	 */
-+	xpad_stop_output(xpad);
-+
-+	xpad_deinit_output(xpad);
- 
- 	usb_free_urb(xpad->irq_in);
- 	usb_free_coherent(xpad->udev, XPAD_PKT_LEN,
-@@ -1343,10 +1602,63 @@ static void xpad_disconnect(struct usb_interface *intf)
- 	usb_set_intfdata(intf, NULL);
- }
- 
-+static int xpad_suspend(struct usb_interface *intf, pm_message_t message)
-+{
-+	struct usb_xpad *xpad = usb_get_intfdata(intf);
-+	struct input_dev *input = xpad->dev;
-+
-+	if (xpad->xtype == XTYPE_XBOX360W) {
-+		/*
-+		 * Wireless controllers always listen to input so
-+		 * they are notified when controller shows up
-+		 * or goes away.
-+		 */
-+		xpad360w_stop_input(xpad);
-+
-+		/*
-+		 * The wireless adapter is going off now, so the
-+		 * gamepads are going to become disconnected.
-+		 * Unless explicitly disabled, power them down
-+		 * so they don't just sit there flashing.
-+		 */
-+		if (auto_poweroff && xpad->pad_present)
-+			xpad360w_poweroff_controller(xpad);
-+	} else {
-+		mutex_lock(&input->mutex);
-+		if (input->users)
-+			xpad_stop_input(xpad);
-+		mutex_unlock(&input->mutex);
-+	}
-+
-+	xpad_stop_output(xpad);
-+
-+	return 0;
-+}
-+
-+static int xpad_resume(struct usb_interface *intf)
-+{
-+	struct usb_xpad *xpad = usb_get_intfdata(intf);
-+	struct input_dev *input = xpad->dev;
-+	int retval = 0;
-+
-+	if (xpad->xtype == XTYPE_XBOX360W) {
-+		retval = xpad360w_start_input(xpad);
-+	} else {
-+		mutex_lock(&input->mutex);
-+		if (input->users)
-+			retval = xpad_start_input(xpad);
-+		mutex_unlock(&input->mutex);
-+	}
-+
-+	return retval;
-+}
-+
- static struct usb_driver xpad_driver = {
- 	.name		= "xpad",
- 	.probe		= xpad_probe,
- 	.disconnect	= xpad_disconnect,
-+	.suspend	= xpad_suspend,
-+	.resume		= xpad_resume,
- 	.id_table	= xpad_table,
- };
- 
diff --git a/package/kernel-osmc/patches/rbp-032-add-retropie-xpad-fixes.patch b/package/kernel-osmc/patches/rbp-032-add-retropie-xpad-fixes.patch
deleted file mode 100644
index c8de083a4..000000000
--- a/package/kernel-osmc/patches/rbp-032-add-retropie-xpad-fixes.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-diff --git a/xpad.c b/xpad.c
-index 2ff80cf..8c8ea54 100644
---- a/drivers/input/joystick/xpad.c
-+++ b/drivers/input/joystick/xpad.c
-@@ -75,6 +75,7 @@
-  * Later changes can be tracked in SCM.
-  */
- #define DEBUG
-+#define CONFIG_JOYSTICK_XPAD_LEDS 1
- #include <linux/kernel.h>
- #include <linux/input.h>
- #include <linux/rcupdate.h>
-@@ -1505,12 +1506,13 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
- 
- 		if (dpad_to_buttons)
- 			xpad->mapping |= MAP_DPAD_TO_BUTTONS;
--		if (triggers_to_buttons)
--			xpad->mapping |= MAP_TRIGGERS_TO_BUTTONS;
- 		if (sticks_to_null)
- 			xpad->mapping |= MAP_STICKS_TO_NULL;
- 	}
- 
-+	if (triggers_to_buttons)
-+		xpad->mapping |= MAP_TRIGGERS_TO_BUTTONS;
-+
- 	if (xpad->xtype == XTYPE_XBOXONE &&
- 	    intf->cur_altsetting->desc.bInterfaceNumber != 0) {
- 		/*
diff --git a/package/kernel-osmc/patches/rbp1-000-add-kernel-config.patch b/package/kernel-osmc/patches/rbp1-000-add-kernel-config.patch
index 949850426..d89075a83 100644
--- a/package/kernel-osmc/patches/rbp1-000-add-kernel-config.patch
+++ b/package/kernel-osmc/patches/rbp1-000-add-kernel-config.patch
@@ -1,9 +1,9 @@
 --- /dev/null	2016-10-16 16:16:51.870941319 +0100
-+++ b/.config	2016-10-18 21:56:08.769347973 +0100
-@@ -0,0 +1,4816 @@
++++ b/.config	2016-10-22 17:51:33.503972030 +0100
+@@ -0,0 +1,4817 @@
 +#
 +# Automatically generated file; DO NOT EDIT.
-+# Linux/arm 4.4.16 Kernel Configuration
++# Linux/arm 4.4.27 Kernel Configuration
 +#
 +CONFIG_ARM=y
 +CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -3037,6 +3037,7 @@
 +CONFIG_SND_AUDIOINJECTOR_PI_SOUNDCARD=m
 +CONFIG_SND_DIGIDAC1_SOUNDCARD=m
 +CONFIG_SND_BCM2708_SOC_DIONAUDIO_LOCO=m
++CONFIG_SND_BCM2708_SOC_ALLO_PIANO_DAC=m
 +# CONFIG_SND_DESIGNWARE_I2S is not set
 +
 +#
diff --git a/package/kernel-osmc/patches/rbp2-000-add-kernel-config.patch b/package/kernel-osmc/patches/rbp2-000-add-kernel-config.patch
index 3d1b589ca..5bfb2c920 100644
--- a/package/kernel-osmc/patches/rbp2-000-add-kernel-config.patch
+++ b/package/kernel-osmc/patches/rbp2-000-add-kernel-config.patch
@@ -1,9 +1,9 @@
 --- /dev/null	2016-10-16 16:16:51.870941319 +0100
-+++ b/.config	2016-10-18 21:58:00.426078006 +0100
-@@ -0,0 +1,4887 @@
++++ b/.config	2016-10-22 17:52:20.956169632 +0100
+@@ -0,0 +1,4888 @@
 +#
 +# Automatically generated file; DO NOT EDIT.
-+# Linux/arm 4.4.16 Kernel Configuration
++# Linux/arm 4.4.27 Kernel Configuration
 +#
 +CONFIG_ARM=y
 +CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -3099,6 +3099,7 @@
 +CONFIG_SND_AUDIOINJECTOR_PI_SOUNDCARD=m
 +CONFIG_SND_DIGIDAC1_SOUNDCARD=m
 +CONFIG_SND_BCM2708_SOC_DIONAUDIO_LOCO=m
++CONFIG_SND_BCM2708_SOC_ALLO_PIANO_DAC=m
 +# CONFIG_SND_DESIGNWARE_I2S is not set
 +
 +#
