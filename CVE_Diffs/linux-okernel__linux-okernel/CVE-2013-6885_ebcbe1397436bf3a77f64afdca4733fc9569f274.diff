linux-okernel__linux-okernel
commit ebcbe1397436bf3a77f64afdca4733fc9569f274
Author:     Borislav Petkov <bp@suse.de>
AuthorDate: Wed Jan 15 00:07:11 2014 +0100
Commit:     Willy Tarreau <w@1wt.eu>
CommitDate: Sun May 24 10:10:37 2015 +0200

    x86, cpu, amd: Add workaround for family 16h, erratum 793
    
    commit 3b56496865f9f7d9bcb2f93b44c63f274f08e3b6 upstream
    
    This adds the workaround for erratum 793 as a precaution in case not
    every BIOS implements it.  This addresses CVE-2013-6885.
    
    Erratum text:
    
    [Revision Guide for AMD Family 16h Models 00h-0Fh Processors,
    document 51810 Rev. 3.04 November 2013]
    
    793 Specific Combination of Writes to Write Combined Memory Types and
    Locked Instructions May Cause Core Hang
    
    Description
    
    Under a highly specific and detailed set of internal timing
    conditions, a locked instruction may trigger a timing sequence whereby
    the write to a write combined memory type is not flushed, causing the
    locked instruction to stall indefinitely.
    
    Potential Effect on System
    
    Processor core hang.
    
    Suggested Workaround
    
    BIOS should set MSR
    C001_1020[15] = 1b.
    
    Fix Planned
    
    No fix planned
    
    [ hpa: updated description, fixed typo in MSR name ]
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: http://lkml.kernel.org/r/20140114230711.GS29865@pd.tnic
    Tested-by: Aravind Gopalakrishnan <aravind.gopalakrishnan@amd.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    [bwh: Backported to 3.2:
     - Adjust filename
     - Venkatesh Srinivas pointed out we should use {rd,wr}msrl_safe() to
       avoid crashing on KVM.  This was fixed upstream by commit 8f86a7373a1c
       ("x86, AMD: Convert to the new bit access MSR accessors") but that's too
       much trouble to backport.  Here we must use {rd,wr}msrl_amd_safe().]
    Signed-off-by: Willy Tarreau <w@1wt.eu>

diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index 883037b75340..6057b7036979 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -110,6 +110,7 @@
 #define MSR_AMD64_PATCH_LOADER		0xc0010020
 #define MSR_AMD64_OSVW_ID_LENGTH	0xc0010140
 #define MSR_AMD64_OSVW_STATUS		0xc0010141
+#define MSR_AMD64_LS_CFG		0xc0011020
 #define MSR_AMD64_DC_CFG		0xc0011022
 #define MSR_AMD64_IBSFETCHCTL		0xc0011030
 #define MSR_AMD64_IBSFETCHLINAD		0xc0011031
diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c
index 6e082dca4cf3..ae8b02c6db24 100644
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@ -413,6 +413,16 @@ static void __cpuinit early_init_amd(struct cpuinfo_x86 *c)
 			set_cpu_cap(c, X86_FEATURE_EXTD_APICID);
 	}
 #endif
+
+	/* F16h erratum 793, CVE-2013-6885 */
+	if (c->x86 == 0x16 && c->x86_model <= 0xf) {
+		u64 val;
+
+		if (!rdmsrl_amd_safe(MSR_AMD64_LS_CFG, &val) &&
+		    !(val & BIT(15)))
+			wrmsrl_amd_safe(MSR_AMD64_LS_CFG, val | BIT(15));
+	}
+
 }
 
 static void __cpuinit init_amd(struct cpuinfo_x86 *c)
