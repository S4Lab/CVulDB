CipherShed__CipherShed
commit 47515b223ff535523300abc4bf091010d29a5cbb
Author:     Jason Pyeron <jpyeron@pdinc.us>
AuthorDate: Tue Sep 29 11:48:51 2015 -0400
Commit:     Jason Pyeron <jpyeron@pdinc.us>
CommitDate: Tue Sep 29 11:48:51 2015 -0400

    CVE-2015-7358 (critical): Local Elevation of Privilege on Windows by abusing drive letter handling.
    
    * Google did not disclose this to CipherShed, found out about it from VeraCrypt's release notes.
    * Note: this has been mitigated, but should really be updated with a choice on monting drives to be a GLOBAL or PRIVATE drive mapping.

diff --git a/src/Common/Apidrvr.h b/src/Common/Apidrvr.h
index ce6ad45..613a6cb 100644
--- a/src/Common/Apidrvr.h
+++ b/src/Common/Apidrvr.h
@@ -311,6 +311,8 @@ typedef struct
 /* CipherSheds mounted volume name prefix. */
 #define TC_MOUNT_PREFIX L"\\Device\\TrueCryptVolume"
 #define NT_MOUNT_PREFIX DRIVER_STR("\\Device\\TrueCryptVolume")
+
+//CVE-2015-7358: this should be addressed
 #define DOS_MOUNT_PREFIX DRIVER_STR("\\DosDevices\\")
 
 /* CipherSheds name for the kernel driver device object. */
diff --git a/src/Driver/Ntdriver.c b/src/Driver/Ntdriver.c
index b71967d..d60b894 100644
--- a/src/Driver/Ntdriver.c
+++ b/src/Driver/Ntdriver.c
@@ -1858,6 +1858,7 @@ void TCGetDosNameFromNumber (LPWSTR dosname, int nDriveNo)
 	int j = nDriveNo + (WCHAR) 'A';
 
 	tmp[0] = (short) j;
+	//This is a risk point from CVE-2015-7358, there are global and per user mounts, need more logic here.
 	wcscpy (dosname, (LPWSTR) DOS_MOUNT_PREFIX);
 	wcscat (dosname, tmp);
 }
@@ -2896,25 +2897,37 @@ BOOL UserCanAccessDriveDevice ()
 	return IsAccessibleByUser (&name, FALSE);
 }
 
+/**
+Cehck if a drive leter is available. 
 
+CVE-2015-7358: Need to add a parameter to this function global/private drives.
+*/
 BOOL IsDriveLetterAvailable (int nDosDriveNo)
 {
 	OBJECT_ATTRIBUTES objectAttributes;
 	UNICODE_STRING objectName;
 	WCHAR link[128];
 	HANDLE handle;
+	NTSTATUS ntStatus;
 
 	TCGetDosNameFromNumber (link, nDosDriveNo);
 	RtlInitUnicodeString (&objectName, link);
 	InitializeObjectAttributes (&objectAttributes, &objectName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);
 
-	if (NT_SUCCESS (ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes)))
+	ntStatus=ZwOpenSymbolicLinkObject (&handle, GENERIC_READ, &objectAttributes);
+	if (NT_SUCCESS (ntStatus))
 	{
 		ZwClose (handle);
 		return FALSE;
 	}
-
-	return TRUE;
+	else if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND)
+	{
+		return TRUE;
+	}
+	else
+	{
+		return FALSE;
+	}
 }
 
 
