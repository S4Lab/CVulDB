google__boringssl
commit d4c349b56ca380c0578f4917fb5abaddf13b9747
Author:     David Benjamin <davidben@google.com>
AuthorDate: Thu Feb 9 14:07:17 2017 -0500
Commit:     Adam Langley <agl@google.com>
CommitDate: Thu Feb 9 23:09:16 2017 +0000

    Test various lengths of ticket session IDs.
    
    In honor of CVE-2016-9244. Although that particular bug BoGo was already
    testing since it uses 16 bytes here.
    
    The empty session ID case is particularly worth testing to make sure we
    don't get confused somewhere. RFC 5077 allows clients to offer tickets
    with no session ID. This is absurd since the client then has no way of
    detecting resumption except by lookahead. We'll never do this as a
    client, but should handle it correctly as a server.
    
    Change-Id: I49695d19f03c4efdef43749c07372d590a010cda
    Reviewed-on: https://boringssl-review.googlesource.com/13740
    Commit-Queue: David Benjamin <davidben@google.com>
    Reviewed-by: Adam Langley <agl@google.com>

diff --git a/ssl/test/runner/common.go b/ssl/test/runner/common.go
index 8f8aa1085..2e7b05375 100644
--- a/ssl/test/runner/common.go
+++ b/ssl/test/runner/common.go
@@ -668,9 +668,16 @@ type ProtocolBugs struct {
 	// ticket before sending it in a resume handshake.
 	FilterTicket func([]byte) ([]byte, error)
 
-	// OversizedSessionId causes the session id that is sent with a ticket
-	// resumption attempt to be too large (33 bytes).
-	OversizedSessionId bool
+	// TicketSessionIDLength, if non-zero, is the length of the session ID
+	// to send with a ticket resumption offer.
+	TicketSessionIDLength int
+
+	// EmptyTicketSessionID, if true, causes the client to send an empty
+	// session ID with a ticket resumption offer. For simplicity, this will
+	// also cause the client to interpret a ServerHello with empty session
+	// ID as a resumption. (A client which sends empty session ID is
+	// normally expected to look ahead for ChangeCipherSpec.)
+	EmptyTicketSessionID bool
 
 	// ExpectNoTLS12Session, if true, causes the server to fail the
 	// connection if either a session ID or TLS 1.2 ticket is offered.
diff --git a/ssl/test/runner/handshake_client.go b/ssl/test/runner/handshake_client.go
index 83ac3a5c5..162302e8f 100644
--- a/ssl/test/runner/handshake_client.go
+++ b/ssl/test/runner/handshake_client.go
@@ -289,8 +289,11 @@ NextCipherSuite:
 				// server accepted the ticket and is resuming a session
 				// (see RFC 5077).
 				sessionIdLen := 16
-				if c.config.Bugs.OversizedSessionId {
-					sessionIdLen = 33
+				if c.config.Bugs.TicketSessionIDLength != 0 {
+					sessionIdLen = c.config.Bugs.TicketSessionIDLength
+				}
+				if c.config.Bugs.EmptyTicketSessionID {
+					sessionIdLen = 0
 				}
 				hello.sessionId = make([]byte, sessionIdLen)
 				if _, err := io.ReadFull(c.config.rand(), hello.sessionId); err != nil {
@@ -1349,6 +1352,10 @@ func (hs *clientHandshakeState) processServerExtensions(serverExtensions *server
 func (hs *clientHandshakeState) serverResumedSession() bool {
 	// If the server responded with the same sessionId then it means the
 	// sessionTicket is being used to resume a TLS session.
+	//
+	// Note that, if hs.hello.sessionId is a non-nil empty array, this will
+	// accept an empty session ID from the server as resumption. See
+	// EmptyTicketSessionID.
 	return hs.session != nil && hs.hello.sessionId != nil &&
 		bytes.Equal(hs.serverHello.sessionId, hs.hello.sessionId)
 }
diff --git a/ssl/test/runner/runner.go b/ssl/test/runner/runner.go
index dd18ce8a4..336aa31f0 100644
--- a/ssl/test/runner/runner.go
+++ b/ssl/test/runner/runner.go
@@ -5044,19 +5044,53 @@ func addExtensionTests() {
 			},
 		})
 
-		// Resume with an oversized session id.
+		// Resume with various lengths of ticket session id.
 		if ver.version < VersionTLS13 {
 			testCases = append(testCases, testCase{
 				testType: serverTest,
-				name:     "OversizedSessionId-" + ver.name,
+				name:     "TicketSessionIDLength-0-" + ver.name,
 				config: Config{
 					MaxVersion: ver.version,
 					Bugs: ProtocolBugs{
-						OversizedSessionId: true,
+						EmptyTicketSessionID: true,
+					},
+				},
+				resumeSession: true,
+			})
+			testCases = append(testCases, testCase{
+				testType: serverTest,
+				name:     "TicketSessionIDLength-16-" + ver.name,
+				config: Config{
+					MaxVersion: ver.version,
+					Bugs: ProtocolBugs{
+						TicketSessionIDLength: 16,
+					},
+				},
+				resumeSession: true,
+			})
+			testCases = append(testCases, testCase{
+				testType: serverTest,
+				name:     "TicketSessionIDLength-32-" + ver.name,
+				config: Config{
+					MaxVersion: ver.version,
+					Bugs: ProtocolBugs{
+						TicketSessionIDLength: 32,
+					},
+				},
+				resumeSession: true,
+			})
+			testCases = append(testCases, testCase{
+				testType: serverTest,
+				name:     "TicketSessionIDLength-33-" + ver.name,
+				config: Config{
+					MaxVersion: ver.version,
+					Bugs: ProtocolBugs{
+						TicketSessionIDLength: 33,
 					},
 				},
 				resumeSession: true,
 				shouldFail:    true,
+				// The maximum session ID length is 32.
 				expectedError: ":DECODE_ERROR:",
 			})
 		}
