AquariaOSE__Aquaria
commit a9f9dd0736084c859b4a5c3d5ec04302ab476456
Author:     fgenesis <false.genesis@googlemail.com>
AuthorDate: Sat Jun 7 18:36:47 2014 +0200
Commit:     fgenesis <false.genesis@googlemail.com>
CommitDate: Sat Jun 7 18:36:47 2014 +0200

    glpng: Fix CVE-2010-1519, update to v1.46. By James Le Cuirot.

diff --git a/ExternalLibs/glpng.h b/ExternalLibs/glpng.h
index 59a454b..6ce2434 100644
--- a/ExternalLibs/glpng.h
+++ b/ExternalLibs/glpng.h
@@ -1,5 +1,5 @@
 /*
- * PNG loader library for OpenGL v1.45 (10/07/00)
+ * PNG loader library for OpenGL v1.46 (02/06/14)
  * by Ben Wyatt ben@wyatt100.freeserve.co.uk
  * Using LibPNG 1.0.2 and ZLib 1.1.3
  *
@@ -20,6 +20,8 @@
  * 3. This notice must not be removed or altered from any source distribution.
  */
 
+// Fixed for use in Aquaria -- fg
+
 #ifndef _GLPNG_H_
 #define _GLPNG_H_
 
@@ -29,7 +31,7 @@
 extern "C" {
 #endif
 
-	/*
+/*
 #ifdef _MSC_VER
 	#ifdef _DEBUG
 		#pragma comment (lib, "glpngd.lib")
@@ -37,7 +39,7 @@ extern "C" {
 		#pragma comment (lib, "glpng.lib")
 	#endif
 #endif
-	*/
+*/
 
 /* XXX This is from Win32's <windef.h> */
 #ifndef APIENTRY
@@ -59,7 +61,7 @@ extern "C" {
 #define PNG_SIMPLEMIPMAP PNG_SIMPLEMIPMAPS
 
 /* Transparency parameters */
-#define PNG_LUMINANCEALPHA	-4
+#define PNG_LUMINANCEALPHA -4
 #define PNG_CALLBACKT -3 /* Call the callback function to generate alpha   */
 #define PNG_ALPHA     -2 /* Use alpha channel in PNG file, if there is one */
 #define PNG_SOLID     -1 /* No transparency                                */
@@ -73,7 +75,6 @@ extern "C" {
 #define PNG_BLEND7     7 /* a = (r*r+g*g+b*b)/4                            */
 #define PNG_BLEND8     8 /* a = sqrt(r*r+g*g+b*b)                          */
 
-
 typedef struct {
 	unsigned int Width;
 	unsigned int Height;
@@ -113,4 +114,3 @@ extern void APIENTRY pngSetStandardOrientation(int standardorientation);
 #endif
 
 #endif
-
diff --git a/ExternalLibs/glpng/glpng.c b/ExternalLibs/glpng/glpng.c
index b828dd1..fb970ba 100644
--- a/ExternalLibs/glpng/glpng.c
+++ b/ExternalLibs/glpng/glpng.c
@@ -1,35 +1,50 @@
 /*
-* PNG loader library for OpenGL v1.45 (10/07/00)
-* by Ben Wyatt ben@wyatt100.freeserve.co.uk
-* Using LibPNG 1.0.2 and ZLib 1.1.3
-*
-* This software is provided 'as-is', without any express or implied warranty.
-* In no event will the author be held liable for any damages arising from the
-* use of this software.
-*
-* Permission is hereby granted to use, copy, modify, and distribute this
-* source code, or portions hereof, for any purpose, without fee, subject to
-* the following restrictions:
-*
-* 1. The origin of this source code must not be misrepresented. You must not
-*    claim that you wrote the original software. If you use this software in
-*    a product, an acknowledgment in the product documentation would be
-*    appreciated but is not required.
-* 2. Altered versions must be plainly marked as such and must not be
-*    misrepresented as being the original source.
-* 3. This notice must not be removed or altered from any source distribution.
-*/
-
+ * PNG loader library for OpenGL v1.46 (02/06/14)
+ * by Ben Wyatt ben@wyatt100.freeserve.co.uk
+ * Using LibPNG 1.0.2 and ZLib 1.1.3
+ *
+ * This software is provided 'as-is', without any express or implied warranty.
+ * In no event will the author be held liable for any damages arising from the
+ * use of this software.
+ *
+ * Permission is hereby granted to use, copy, modify, and distribute this
+ * source code, or portions hereof, for any purpose, without fee, subject to
+ * the following restrictions:
+ *
+ * 1. The origin of this source code must not be misrepresented. You must not
+ *    claim that you wrote the original software. If you use this software in
+ *    a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered versions must be plainly marked as such and must not be
+ *    misrepresented as being the original source.
+ * 3. This notice must not be removed or altered from any source distribution.
+ */
+
+/* Changed things slightly to be compatible with compilers not having stdint.h,
+ * plus #include changes for static linking into Aquaria. -- fg */
 
 #ifdef _WIN32 /* Stupid Windows needs to include windows.h before gl.h */
-#undef FAR
-#include <windows.h>
+	#undef FAR
+	#include <windows.h>
 #endif
 
+#define GL_GLEXT_PROTOTYPES
+
+//#include <GL/glpng.h>
+//#include <GL/gl.h>
+//#include <GL/glext.h>
 #include "../glpng.h"
 #include "gl.h"
 #include <stdlib.h>
+#include <string.h>
 #include <math.h>
+#ifdef _MSC_VER
+typedef unsigned __int64 uint64;
+#else
+# include <stdint.h>
+typedef uint64_t uint64;
+#endif
+
 #include <png.h>
 
 /* Used to decide if GL/gl.h supports the paletted extension */
@@ -55,17 +70,17 @@ static int PalettedTextures = -1;
 static GLint MaxTextureSize = 0;
 
 /* screenGamma = displayGamma/viewingGamma
-* displayGamma = CRT has gamma of ~2.2
-* viewingGamma depends on platform. PC is 1.0, Mac is 1.45, SGI defaults
-* to 1.7, but this can be checked and changed w/ /usr/sbin/gamma command.
-* If the environment variable VIEWING_GAMMA is set, adjust gamma per this value.
-*/
+ * displayGamma = CRT has gamma of ~2.2
+ * viewingGamma depends on platform. PC is 1.0, Mac is 1.45, SGI defaults
+ * to 1.7, but this can be checked and changed w/ /usr/sbin/gamma command.
+ * If the environment variable VIEWING_GAMMA is set, adjust gamma per this value.
+ */
 #ifdef _MAC
-static double screenGamma = 2.2 / 1.45;
+	static double screenGamma = 2.2 / 1.45;
 #elif SGI
-static double screenGamma = 2.2 / 1.7;
+	static double screenGamma = 2.2 / 1.7;
 #else /* PC/default */
-static double screenGamma = 2.2 / 1.0;
+	static double screenGamma = 2.2 / 1.0;
 #endif
 
 static char gammaExplicit = 0;	/*if  */
@@ -114,6 +129,8 @@ static void Resize(int components, const png_bytep d1, int w1, int h1, png_bytep
 	}
 }
 
+#ifdef SUPPORTS_PALETTE_EXT
+#ifdef _WIN32
 static int ExtSupported(const char *x) {
 	static const GLubyte *ext = NULL;
 	const char *c;
@@ -130,6 +147,8 @@ static int ExtSupported(const char *x) {
 
 	return 0;
 }
+#endif
+#endif
 
 #define GET(o) ((int)*(data + (o)))
 
@@ -258,14 +277,13 @@ int APIENTRY pngLoadRawF(FILE *fp, pngRawInfo *pinfo) {
 	png_structp png;
 	png_infop   info;
 	png_infop   endinfo;
-	png_bytep   data;
-	png_bytep  *row_p;
-	double	fileGamma;
+	double      fileGamma;
 
-	png_uint_32 width, height;
+	png_uint_32 width, height, i;
 	int depth, color;
 
-	png_uint_32 i;
+	png_bytep data = NULL;
+	png_bytep *row_p = NULL;
 
 	if (pinfo == NULL) return 0;
 
@@ -273,16 +291,14 @@ int APIENTRY pngLoadRawF(FILE *fp, pngRawInfo *pinfo) {
 	if (!png_check_sig(header, 8)) return 0;
 
 	png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+	if (!png) return 0;
 	info = png_create_info_struct(png);
+	if (!info) return 0;
 	endinfo = png_create_info_struct(png);
+	if (!endinfo) return 0;
 
-	// DH: added following lines
 	if (setjmp(png_jmpbuf(png)))
-	{
-		png_destroy_read_struct(&png, &info, &endinfo);
-		return 0;
-	}
-	// ~DH
+		goto error;
 
 	png_init_io(png, fp);
 	png_set_sig_bytes(png, 8);
@@ -302,8 +318,16 @@ int APIENTRY pngLoadRawF(FILE *fp, pngRawInfo *pinfo) {
 
 	png_read_update_info(png, info);
 
+	/* HDG: We allocate all the png data in one linear array, thus
+	   height * png_get_rowbytes() may not be > PNG_UINT_32_MAX !
+	   This check fixes CVE-2010-1519. */
+	if ((uint64)height * png_get_rowbytes(png, info) > PNG_UINT_32_MAX)
+		goto error;
+
 	data = (png_bytep) malloc(png_get_rowbytes(png, info)*height);
 	row_p = (png_bytep *) malloc(sizeof(png_bytep)*height);
+	if (!data || !row_p)
+		goto error;
 
 	for (i = 0; i < height; i++) {
 		if (StandardOrientation)
@@ -314,6 +338,7 @@ int APIENTRY pngLoadRawF(FILE *fp, pngRawInfo *pinfo) {
 
 	png_read_image(png, row_p);
 	free(row_p);
+	row_p = NULL;
 
 	if (color == PNG_COLOR_TYPE_PALETTE) {
 		int cols;
@@ -342,53 +367,27 @@ int APIENTRY pngLoadRawF(FILE *fp, pngRawInfo *pinfo) {
 
 	png_read_end(png, endinfo);
 	png_destroy_read_struct(&png, &info, &endinfo);
-
 	return 1;
-}
-
-int APIENTRY pngLoad(const char *filename, int mipmap, int trans, pngInfo *pinfo) {
-	int result;
-	FILE *fp = fopen(filename, "rb");
-	if (fp == NULL) return 0;
 
-	result = pngLoadF(fp, mipmap, trans, pinfo);
-
-	if (fclose(fp) != 0) return 0;
-
-	return result;
+error:
+	png_destroy_read_struct(&png, &info, &endinfo);
+	free(data);
+	free(row_p);
+	return 0;
 }
 
-int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
+static int pngLoadCommon(int mipmap, int trans, pngInfo *pinfo, png_structp png, png_infop info, png_infop endinfo) {
 	GLint pack, unpack;
-	unsigned char header[8];
-	png_structp png;
-	png_infop   info;
-	png_infop   endinfo;
-	png_bytep   data, data2;
-	png_bytep  *row_p;
-	double	fileGamma;
+	double fileGamma;
 
-	png_uint_32 width, height, rw, rh;
+	png_uint_32 width, height, rw, rh, i;
 	int depth, color;
 
-	png_uint_32 i;
+	png_bytep data = NULL, data2 = NULL;
+	png_bytep *row_p = NULL;
 
-	if (fread(header, 1, 8, fp) != 8) return 0;
-	if (!png_check_sig(header, 8)) return 0;
-
-	png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-	info = png_create_info_struct(png);
-	endinfo = png_create_info_struct(png);
+	int ret = 0;
 
-	// DH: added following lines
-	if (setjmp(png_jmpbuf(png)))
-	{
-		png_destroy_read_struct(&png, &info, &endinfo);
-		return 0;
-	}
-	// ~DH
-
-	png_init_io(png, fp);
 	png_set_sig_bytes(png, 8);
 	png_read_info(png, info);
 	png_get_IHDR(png, info, &width, &height, &depth, &color, NULL, NULL, NULL);
@@ -402,20 +401,20 @@ int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
 	if (MaxTextureSize == 0)
 		glGetIntegerv(GL_MAX_TEXTURE_SIZE, &MaxTextureSize);
 
-#ifdef SUPPORTS_PALETTE_EXT
-#ifdef _WIN32
-	if (PalettedTextures == -1)
-		PalettedTextures = ExtSupported("GL_EXT_paletted_texture") && (strstr((const char *) glGetString(GL_VERSION), "1.1.0 3Dfx Beta") == NULL);
+	#ifdef SUPPORTS_PALETTE_EXT
+	#ifdef _WIN32
+		if (PalettedTextures == -1)
+			PalettedTextures = ExtSupported("GL_EXT_paletted_texture") && (strstr((const char *) glGetString(GL_VERSION), "1.1.0 3Dfx Beta") == NULL);
 
-	if (PalettedTextures) {
-		if (glColorTableEXT == NULL) {
-			glColorTableEXT = (PFNGLCOLORTABLEEXTPROC) wglGetProcAddress("glColorTableEXT");
-			if (glColorTableEXT == NULL)
-				PalettedTextures = 0;
+		if (PalettedTextures) {
+			if (glColorTableEXT == NULL) {
+				glColorTableEXT = (PFNGLCOLORTABLEEXTPROC) wglGetProcAddress("glColorTableEXT");
+				if (glColorTableEXT == NULL)
+					PalettedTextures = 0;
+			}
 		}
-	}
-#endif
-#endif
+	#endif
+	#endif
 
 	if (PalettedTextures == -1)
 		PalettedTextures = 0;
@@ -441,8 +440,16 @@ int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
 
 	png_read_update_info(png, info);
 
+	/* HDG: We allocate all the png data in one linear array, thus
+	   height * png_get_rowbytes() may not be > PNG_UINT_32_MAX !
+	   This check fixes CVE-2010-1519. */
+	if ((uint64)height * png_get_rowbytes(png, info) > PNG_UINT_32_MAX)
+		goto finish;
+
 	data = (png_bytep) malloc(png_get_rowbytes(png, info)*height);
 	row_p = (png_bytep *) malloc(sizeof(png_bytep)*height);
+	if (!data || !row_p)
+		goto finish;
 
 	for (i = 0; i < height; i++) {
 		if (StandardOrientation)
@@ -453,6 +460,7 @@ int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
 
 	png_read_image(png, row_p);
 	free(row_p);
+	row_p = NULL;
 
 	rw = SafeSize(width), rh = SafeSize(height);
 
@@ -460,16 +468,19 @@ int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
 		const int channels = png_get_rowbytes(png, info)/width;
 
 		data2 = (png_bytep) malloc(rw*rh*channels);
+		if (!data2)
+			goto finish;
 
-		/* Doesn't work on certain sizes */
-		/* 		if (gluScaleImage(glformat, width, height, GL_UNSIGNED_BYTE, data, rw, rh, GL_UNSIGNED_BYTE, data2) != 0)
-		return 0;
-		*/
+ 		/* Doesn't work on certain sizes */
+/* 		if (gluScaleImage(glformat, width, height, GL_UNSIGNED_BYTE, data, rw, rh, GL_UNSIGNED_BYTE, data2) != 0)
+			goto finish;
+*/
 		Resize(channels, data, width, height, data2, rw, rh);
 
 		width = rw, height = rh;
 		free(data);
 		data = data2;
+		data2 = NULL;
 	}
 
 	{ /* OpenGL stuff */
@@ -478,7 +489,7 @@ int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
 		glPixelStorei(GL_PACK_ALIGNMENT, 1);
 		glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
 
-#ifdef SUPPORTS_PALETTE_EXT
+		#ifdef SUPPORTS_PALETTE_EXT
 		if (PalettedTextures && mipmap >= 0 && trans == PNG_SOLID && color == PNG_COLOR_TYPE_PALETTE) {
 			png_colorp pal;
 			int cols;
@@ -496,18 +507,18 @@ int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
 				case 1<<16: intf = GL_COLOR_INDEX16_EXT; break;
 				default:
 					/*printf("Warning: Colour depth %i not recognised\n", cols);*/
-					return 0;
+					goto finish;
 			}
 			glColorTableEXT(GL_TEXTURE_2D, GL_RGB8, cols, GL_RGB, GL_UNSIGNED_BYTE, pal);
 			glTexImage2D(GL_TEXTURE_2D, mipmap, intf, width, height, 0, GL_COLOR_INDEX, GL_UNSIGNED_BYTE, data);
 		}
 		else
-#endif
-			if (trans == PNG_SOLID || trans == PNG_ALPHA || trans == PNG_LUMINANCEALPHA || color == PNG_COLOR_TYPE_RGB_ALPHA || color == PNG_COLOR_TYPE_GRAY_ALPHA) {
-				GLenum glformat;
-				GLint glcomponent;
+		#endif
+		if (trans == PNG_SOLID || trans == PNG_ALPHA || trans == PNG_LUMINANCEALPHA || color == PNG_COLOR_TYPE_RGB_ALPHA || color == PNG_COLOR_TYPE_GRAY_ALPHA) {
+			GLenum glformat;
+			GLint glcomponent;
 
-				switch (color) {
+			switch (color) {
 				case PNG_COLOR_TYPE_GRAY:
 				case PNG_COLOR_TYPE_RGB:
 				case PNG_COLOR_TYPE_PALETTE:
@@ -525,49 +536,55 @@ int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
 
 				default:
 					/*puts("glformat not set");*/
-					return 0;
-				}
+					goto finish;
+			}
 
-				if (trans == PNG_LUMINANCEALPHA)
-					glformat = GL_LUMINANCE_ALPHA;
+			if (trans == PNG_LUMINANCEALPHA)
+				glformat = GL_LUMINANCE_ALPHA;
 
-				if (mipmap == PNG_BUILDMIPMAPS)
-					Build2DMipmaps(glcomponent, width, height, glformat, data, 1);
-				else if (mipmap == PNG_SIMPLEMIPMAPS)
-					Build2DMipmaps(glcomponent, width, height, glformat, data, 0);
-				else
-					glTexImage2D(GL_TEXTURE_2D, mipmap, glcomponent, width, height, 0, glformat, GL_UNSIGNED_BYTE, data);
-			}
-			else {
-				png_bytep p, endp, q;
-				int r, g, b, a;
+			if (mipmap == PNG_BUILDMIPMAPS)
+				Build2DMipmaps(glcomponent, width, height, glformat, data, 1);
+			else if (mipmap == PNG_SIMPLEMIPMAPS)
+				Build2DMipmaps(glcomponent, width, height, glformat, data, 0);
+			else
+				glTexImage2D(GL_TEXTURE_2D, mipmap, glcomponent, width, height, 0, glformat, GL_UNSIGNED_BYTE, data);
+		}
+		else {
+			png_bytep p, endp, q;
+			int r, g, b, a;
+
+			/* HDG another potential 32 bit address overflow, the
+			   original png had 3 channels and we are going to
+			   4 channels now! */
+			if ((uint64)width * height > (PNG_UINT_32_MAX >> 2))
+				goto finish;
 
-				p = data, endp = p+width*height*3;
-				q = data2 = (png_bytep) malloc(sizeof(png_byte)*width*height*4);
+			p = data, endp = p+width*height*3;
+			q = data2 = (png_bytep) malloc(sizeof(png_byte)*width*height*4);
 
-				if (pinfo != NULL) pinfo->Alpha = 8;
+			if (pinfo != NULL) pinfo->Alpha = 8;
 
-#define FORSTART \
-	do { \
-	r = *p++; /*red  */ \
-	g = *p++; /*green*/ \
-	b = *p++; /*blue */ \
-	*q++ = r; \
-	*q++ = g; \
-	*q++ = b;
+			#define FORSTART \
+				do { \
+					r = *p++; /*red  */ \
+					g = *p++; /*green*/ \
+					b = *p++; /*blue */ \
+					*q++ = r; \
+					*q++ = g; \
+					*q++ = b;
 
-#define FOREND \
-	q++; \
-	} while (p != endp);
+			#define FOREND \
+					q++; \
+				} while (p != endp);
 
-#define ALPHA *q
+			#define ALPHA *q
 
-				switch (trans) {
+			switch (trans) {
 				case PNG_CALLBACKT:
 					FORSTART
 						ALPHA = AlphaCallback((unsigned char) r, (unsigned char) g, (unsigned char) b);
 					FOREND
-						break;
+					break;
 
 				case PNG_STENCIL:
 					FORSTART
@@ -576,85 +593,169 @@ int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
 						else
 							ALPHA = 255;
 					FOREND
-						break;
+					break;
 
 				case PNG_BLEND1:
 					FORSTART
 						a = r+g+b;
-					if (a > 255) ALPHA = 255; else ALPHA = a;
+						if (a > 255) ALPHA = 255; else ALPHA = a;
 					FOREND
-						break;
+					break;
 
 				case PNG_BLEND2:
 					FORSTART
 						a = r+g+b;
-					if (a > 255*2) ALPHA = 255; else ALPHA = a/2;
+						if (a > 255*2) ALPHA = 255; else ALPHA = a/2;
 					FOREND
-						break;
+					break;
 
 				case PNG_BLEND3:
 					FORSTART
 						ALPHA = (r+g+b)/3;
 					FOREND
-						break;
+					break;
 
 				case PNG_BLEND4:
 					FORSTART
 						a = r*r+g*g+b*b;
-					if (a > 255) ALPHA = 255; else ALPHA = a;
+						if (a > 255) ALPHA = 255; else ALPHA = a;
 					FOREND
-						break;
+					break;
 
 				case PNG_BLEND5:
 					FORSTART
 						a = r*r+g*g+b*b;
-					if (a > 255*2) ALPHA = 255; else ALPHA = a/2;
+						if (a > 255*2) ALPHA = 255; else ALPHA = a/2;
 					FOREND
-						break;
+					break;
 
 				case PNG_BLEND6:
 					FORSTART
 						a = r*r+g*g+b*b;
-					if (a > 255*3) ALPHA = 255; else ALPHA = a/3;
+						if (a > 255*3) ALPHA = 255; else ALPHA = a/3;
 					FOREND
-						break;
+					break;
 
 				case PNG_BLEND7:
 					FORSTART
 						a = r*r+g*g+b*b;
-					if (a > 255*255) ALPHA = 255; else ALPHA = (int) sqrt(a);
+						if (a > 255*255) ALPHA = 255; else ALPHA = (int) sqrt(a);
 					FOREND
-						break;
-				}
+					break;
+			}
 
-#undef FORSTART
-#undef FOREND
-#undef ALPHA
+			#undef FORSTART
+			#undef FOREND
+			#undef ALPHA
 
-				if (mipmap == PNG_BUILDMIPMAPS)
-					Build2DMipmaps(4, width, height, GL_RGBA, data2, 1);
-				else if (mipmap == PNG_SIMPLEMIPMAPS)
-					Build2DMipmaps(4, width, height, GL_RGBA, data2, 0);
-				else
-					glTexImage2D(GL_TEXTURE_2D, mipmap, 4, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data2);
+			if (mipmap == PNG_BUILDMIPMAPS)
+				Build2DMipmaps(4, width, height, GL_RGBA, data2, 1);
+			else if (mipmap == PNG_SIMPLEMIPMAPS)
+				Build2DMipmaps(4, width, height, GL_RGBA, data2, 0);
+			else
+				glTexImage2D(GL_TEXTURE_2D, mipmap, 4, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data2);
 
-				free(data2);
-			}
+		}
 
-			glPixelStorei(GL_PACK_ALIGNMENT, pack);
-			glPixelStorei(GL_UNPACK_ALIGNMENT, unpack);
+		glPixelStorei(GL_PACK_ALIGNMENT, pack);
+		glPixelStorei(GL_UNPACK_ALIGNMENT, unpack);
 	} /* OpenGL end */
 
 	png_read_end(png, endinfo);
-	png_destroy_read_struct(&png, &info, &endinfo);
+	ret = 1;
 
+finish:
 	free(data);
+	free(data2);
+	free(row_p);
+	return ret;
+}
 
-	return 1;
+int APIENTRY pngLoad(const char *filename, int mipmap, int trans, pngInfo *pinfo) {
+	int result;
+	FILE *fp = fopen(filename, "rb");
+	if (fp == NULL) return 0;
+
+	result = pngLoadF(fp, mipmap, trans, pinfo);
+
+	if (fclose(fp) != 0) return 0;
+
+	return result;
+}
+
+int APIENTRY pngLoadF(FILE *fp, int mipmap, int trans, pngInfo *pinfo) {
+	unsigned char header[8];
+	png_structp png;
+	png_infop info;
+	png_infop endinfo;
+
+	int ret = 0;
+
+	if (fread(header, 1, 8, fp) != 8) return 0;
+	if (!png_check_sig(header, 8)) return 0;
+
+	png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+	if (!png) return 0;
+	info = png_create_info_struct(png);
+	if (!info) return 0;
+	endinfo = png_create_info_struct(png);
+	if (!endinfo) return 0;
+
+	if (!setjmp(png_jmpbuf(png))) {
+		png_init_io(png, fp);
+		ret = pngLoadCommon(mipmap, trans, pinfo, png, info, endinfo);
+	}
+
+	png_destroy_read_struct(&png, &info, &endinfo);
+	return ret;
+}
+
+typedef struct glpng_memread_struct {
+	png_bytep mem;
+	png_size_t rpos;
+} glpng_memread;
+
+static void glpng_read_mem(png_structp png, png_bytep dst, png_size_t size) {
+	glpng_memread *mr = (glpng_memread*) png_get_io_ptr(png);
+	memcpy(dst, mr->mem + mr->rpos, size);
+	mr->rpos += size;
+}
+
+int APIENTRY pngLoadMem(const char *mem, int size, int mipmap, int trans, pngInfo *pinfo) {
+	unsigned char header[8];
+	png_structp png;
+	png_infop info;
+	png_infop endinfo;
+	glpng_memread memread;
+
+	int ret = 0;
+
+	if (size < 8)
+		return 0; // error
+
+	memcpy(header, mem, 8);
+	if (!png_check_sig(header, 8)) return 0;
+
+	png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+	if (!png) return 0;
+	info = png_create_info_struct(png);
+	if (!info) return 0;
+	endinfo = png_create_info_struct(png);
+	if (!endinfo) return 0;
+
+	if (!setjmp(png_jmpbuf(png))) {
+		memread.rpos = 0;
+		memread.mem = ((png_bytep) mem) + 8;
+		png_set_read_fn(png, &memread, glpng_read_mem);
+		ret = pngLoadCommon(mipmap, trans, pinfo, png, info, endinfo);
+	}
+
+	png_destroy_read_struct(&png, &info, &endinfo);
+	return ret;
 }
 
 static unsigned int SetParams(int wrapst, int magfilter, int minfilter) {
-	GLuint id;
+	unsigned int id;
 
 	glGenTextures(1, &id);
 	glBindTexture(GL_TEXTURE_2D, id);
@@ -717,330 +818,3 @@ void APIENTRY pngSetViewingGamma(double viewingGamma) {
 void APIENTRY pngSetStandardOrientation(int standardorientation) {
 	StandardOrientation = standardorientation;
 }
-
-
-
-// -- added memory read functions --
-
-/*pointer to a new input function that takes as its
-arguments a pointer to a png_struct, a pointer to
-a location where input data can be stored, and a 32-bit
-unsigned int that is the number of bytes to be read.
-To exit and output any fatal error messages the new write
-function should call png_error(png_ptr, "Error msg"). */
-
-typedef struct glpng_memread_struct
-{
-	png_bytep mem;
-	png_size_t rpos;
-} glpng_memread;
-
-void glpng_read_mem(png_structp png, png_bytep dst, png_size_t size)
-{
-	glpng_memread *mr = (glpng_memread*)png_get_io_ptr(png);
-	memcpy(dst, mr->mem + mr->rpos, size);
-	mr->rpos += size;
-}
-
-int APIENTRY pngLoadMem(const char *mem, int size, int mipmap, int trans, pngInfo *pinfo) {
-	GLint pack, unpack;
-	unsigned char header[8];
-	png_structp png;
-	png_infop   info;
-	png_infop   endinfo;
-	png_bytep   data, data2;
-	png_bytep  *row_p;
-	double	fileGamma;
-
-	png_uint_32 width, height, rw, rh;
-	int depth, color;
-
-	png_uint_32 i;
-	glpng_memread memread;
-
-	if(size < 8)
-		return 0; // error
-
-	memcpy(header, mem, 8);
-
-	if (!png_check_sig(header, 8))
-		return 0;
-
-	png = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-	info = png_create_info_struct(png);
-	endinfo = png_create_info_struct(png);
-
-	// DH: added following lines
-	if (setjmp(png_jmpbuf(png)))
-	{
-		png_destroy_read_struct(&png, &info, &endinfo);
-		return 0;
-	}
-	// ~DH
-
-	memread.rpos = 0;
-	memread.mem = ((png_bytep)mem) + 8;
-	png_set_read_fn(png, &memread, glpng_read_mem);
-	png_set_sig_bytes(png, 8);
-	png_read_info(png, info);
-	png_get_IHDR(png, info, &width, &height, &depth, &color, NULL, NULL, NULL);
-
-	if (pinfo != NULL) {
-		pinfo->Width  = width;
-		pinfo->Height = height;
-		pinfo->Depth  = depth;
-	}
-
-	if (MaxTextureSize == 0)
-		glGetIntegerv(GL_MAX_TEXTURE_SIZE, &MaxTextureSize);
-
-#ifdef SUPPORTS_PALETTE_EXT
-#ifdef _WIN32
-	if (PalettedTextures == -1)
-		PalettedTextures = ExtSupported("GL_EXT_paletted_texture") && (strstr((const char *) glGetString(GL_VERSION), "1.1.0 3Dfx Beta") == NULL);
-
-	if (PalettedTextures) {
-		if (glColorTableEXT == NULL) {
-			glColorTableEXT = (PFNGLCOLORTABLEEXTPROC) wglGetProcAddress("glColorTableEXT");
-			if (glColorTableEXT == NULL)
-				PalettedTextures = 0;
-		}
-	}
-#endif
-#endif
-
-	if (PalettedTextures == -1)
-		PalettedTextures = 0;
-
-	if (color == PNG_COLOR_TYPE_GRAY || color == PNG_COLOR_TYPE_GRAY_ALPHA)
-		png_set_gray_to_rgb(png);
-
-	if (color&PNG_COLOR_MASK_ALPHA && trans != PNG_ALPHA) {
-		png_set_strip_alpha(png);
-		color &= ~PNG_COLOR_MASK_ALPHA;
-	}
-
-	if (!(PalettedTextures && mipmap >= 0 && trans == PNG_SOLID))
-		if (color == PNG_COLOR_TYPE_PALETTE)
-			png_set_expand(png);
-
-	/*--GAMMA--*/
-	checkForGammaEnv();
-	if (png_get_gAMA(png, info, &fileGamma))
-		png_set_gamma(png, screenGamma, fileGamma);
-	else
-		png_set_gamma(png, screenGamma, 1.0/2.2);
-
-	png_read_update_info(png, info);
-
-	data = (png_bytep) malloc(png_get_rowbytes(png, info)*height);
-	row_p = (png_bytep *) malloc(sizeof(png_bytep)*height);
-
-	for (i = 0; i < height; i++) {
-		if (StandardOrientation)
-			row_p[height - 1 - i] = &data[png_get_rowbytes(png, info)*i];
-		else
-			row_p[i] = &data[png_get_rowbytes(png, info)*i];
-	}
-
-	png_read_image(png, row_p);
-	free(row_p);
-
-	rw = SafeSize(width), rh = SafeSize(height);
-
-	if (rw != width || rh != height) {
-		const int channels = png_get_rowbytes(png, info)/width;
-
-		data2 = (png_bytep) malloc(rw*rh*channels);
-
-		/* Doesn't work on certain sizes */
-		/* 		if (gluScaleImage(glformat, width, height, GL_UNSIGNED_BYTE, data, rw, rh, GL_UNSIGNED_BYTE, data2) != 0)
-		return 0;
-		*/
-		Resize(channels, data, width, height, data2, rw, rh);
-
-		width = rw, height = rh;
-		free(data);
-		data = data2;
-	}
-
-	{ /* OpenGL stuff */
-		glGetIntegerv(GL_PACK_ALIGNMENT, &pack);
-		glGetIntegerv(GL_UNPACK_ALIGNMENT, &unpack);
-		glPixelStorei(GL_PACK_ALIGNMENT, 1);
-		glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
-
-#ifdef SUPPORTS_PALETTE_EXT
-		if (PalettedTextures && mipmap >= 0 && trans == PNG_SOLID && color == PNG_COLOR_TYPE_PALETTE) {
-			png_colorp pal;
-			int cols;
-			GLint intf;
-
-			if (pinfo != NULL) pinfo->Alpha = 0;
-			png_get_PLTE(png, info, &pal, &cols);
-
-			switch (cols) {
-				case 1<<1:  intf = GL_COLOR_INDEX1_EXT;  break;
-				case 1<<2:  intf = GL_COLOR_INDEX2_EXT;  break;
-				case 1<<4:  intf = GL_COLOR_INDEX4_EXT;  break;
-				case 1<<8:  intf = GL_COLOR_INDEX8_EXT;  break;
-				case 1<<12: intf = GL_COLOR_INDEX12_EXT; break;
-				case 1<<16: intf = GL_COLOR_INDEX16_EXT; break;
-				default:
-					/*printf("Warning: Colour depth %i not recognised\n", cols);*/
-					return 0;
-			}
-			glColorTableEXT(GL_TEXTURE_2D, GL_RGB8, cols, GL_RGB, GL_UNSIGNED_BYTE, pal);
-			glTexImage2D(GL_TEXTURE_2D, mipmap, intf, width, height, 0, GL_COLOR_INDEX, GL_UNSIGNED_BYTE, data);
-		}
-		else
-#endif
-			if (trans == PNG_SOLID || trans == PNG_ALPHA || trans == PNG_LUMINANCEALPHA || color == PNG_COLOR_TYPE_RGB_ALPHA || color == PNG_COLOR_TYPE_GRAY_ALPHA) {
-				GLenum glformat;
-				GLint glcomponent;
-
-				switch (color) {
-				case PNG_COLOR_TYPE_GRAY:
-				case PNG_COLOR_TYPE_RGB:
-				case PNG_COLOR_TYPE_PALETTE:
-					glformat = GL_RGB;
-					glcomponent = 3;
-					if (pinfo != NULL) pinfo->Alpha = 0;
-					break;
-
-				case PNG_COLOR_TYPE_GRAY_ALPHA:
-				case PNG_COLOR_TYPE_RGB_ALPHA:
-					glformat = GL_RGBA;
-					glcomponent = 4;
-					if (pinfo != NULL) pinfo->Alpha = 8;
-					break;
-
-				default:
-					/*puts("glformat not set");*/
-					return 0;
-				}
-
-				if (trans == PNG_LUMINANCEALPHA)
-					glformat = GL_LUMINANCE_ALPHA;
-
-				if (mipmap == PNG_BUILDMIPMAPS)
-					Build2DMipmaps(glcomponent, width, height, glformat, data, 1);
-				else if (mipmap == PNG_SIMPLEMIPMAPS)
-					Build2DMipmaps(glcomponent, width, height, glformat, data, 0);
-				else
-					glTexImage2D(GL_TEXTURE_2D, mipmap, glcomponent, width, height, 0, glformat, GL_UNSIGNED_BYTE, data);
-			}
-			else {
-				png_bytep p, endp, q;
-				int r, g, b, a;
-
-				p = data, endp = p+width*height*3;
-				q = data2 = (png_bytep) malloc(sizeof(png_byte)*width*height*4);
-
-				if (pinfo != NULL) pinfo->Alpha = 8;
-
-#define FORSTART \
-	do { \
-	r = *p++; /*red  */ \
-	g = *p++; /*green*/ \
-	b = *p++; /*blue */ \
-	*q++ = r; \
-	*q++ = g; \
-	*q++ = b;
-
-#define FOREND \
-	q++; \
-	} while (p != endp);
-
-#define ALPHA *q
-
-				switch (trans) {
-				case PNG_CALLBACKT:
-					FORSTART
-						ALPHA = AlphaCallback((unsigned char) r, (unsigned char) g, (unsigned char) b);
-					FOREND
-						break;
-
-				case PNG_STENCIL:
-					FORSTART
-						if (r == StencilRed && g == StencilGreen && b == StencilBlue)
-							ALPHA = 0;
-						else
-							ALPHA = 255;
-					FOREND
-						break;
-
-				case PNG_BLEND1:
-					FORSTART
-						a = r+g+b;
-					if (a > 255) ALPHA = 255; else ALPHA = a;
-					FOREND
-						break;
-
-				case PNG_BLEND2:
-					FORSTART
-						a = r+g+b;
-					if (a > 255*2) ALPHA = 255; else ALPHA = a/2;
-					FOREND
-						break;
-
-				case PNG_BLEND3:
-					FORSTART
-						ALPHA = (r+g+b)/3;
-					FOREND
-						break;
-
-				case PNG_BLEND4:
-					FORSTART
-						a = r*r+g*g+b*b;
-					if (a > 255) ALPHA = 255; else ALPHA = a;
-					FOREND
-						break;
-
-				case PNG_BLEND5:
-					FORSTART
-						a = r*r+g*g+b*b;
-					if (a > 255*2) ALPHA = 255; else ALPHA = a/2;
-					FOREND
-						break;
-
-				case PNG_BLEND6:
-					FORSTART
-						a = r*r+g*g+b*b;
-					if (a > 255*3) ALPHA = 255; else ALPHA = a/3;
-					FOREND
-						break;
-
-				case PNG_BLEND7:
-					FORSTART
-						a = r*r+g*g+b*b;
-					if (a > 255*255) ALPHA = 255; else ALPHA = (int) sqrt(a);
-					FOREND
-						break;
-				}
-
-#undef FORSTART
-#undef FOREND
-#undef ALPHA
-
-				if (mipmap == PNG_BUILDMIPMAPS)
-					Build2DMipmaps(4, width, height, GL_RGBA, data2, 1);
-				else if (mipmap == PNG_SIMPLEMIPMAPS)
-					Build2DMipmaps(4, width, height, GL_RGBA, data2, 0);
-				else
-					glTexImage2D(GL_TEXTURE_2D, mipmap, 4, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data2);
-
-				free(data2);
-			}
-
-			glPixelStorei(GL_PACK_ALIGNMENT, pack);
-			glPixelStorei(GL_UNPACK_ALIGNMENT, unpack);
-	} /* OpenGL end */
-
-	png_read_end(png, endinfo);
-	png_destroy_read_struct(&png, &info, &endinfo);
-
-	free(data);
-
-	return 1;
-}
