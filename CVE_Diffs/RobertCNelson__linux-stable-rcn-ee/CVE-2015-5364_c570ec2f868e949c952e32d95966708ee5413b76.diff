RobertCNelson__linux-stable-rcn-ee
commit c570ec2f868e949c952e32d95966708ee5413b76
Author:     Eric Dumazet <edumazet@google.com>
AuthorDate: Sat May 30 09:16:53 2015 -0700
Commit:     Willy Tarreau <w@1wt.eu>
CommitDate: Fri Sep 18 13:51:57 2015 +0200

    udp: fix behavior of wrong checksums
    
    commit beb39db59d14990e401e235faf66a6b9b31240b0 upstream.
    
    We have two problems in UDP stack related to bogus checksums :
    
    1) We return -EAGAIN to application even if receive queue is not empty.
       This breaks applications using edge trigger epoll()
    
    2) Under UDP flood, we can loop forever without yielding to other
       processes, potentially hanging the host, especially on non SMP.
    
    This patch is an attempt to make things better.
    
    We might in the future add extra support for rt applications
    wanting to better control time spent doing a recv() in a hostile
    environment. For example we could validate checksums before queuing
    packets in socket receive queue.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    
    CVE-2015-5364
    CVE-2015-5366
    
    Signed-off-by: Willy Tarreau <w@1wt.eu>

diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 0b2e07fbcaaa..3ae286b9c5ab 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1016,10 +1016,8 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
 	release_sock(sk);
 
-	if (noblock)
-		return -EAGAIN;
-
-	/* starting over for a new packet */
+	/* starting over for a new packet, but check if we need to yield */
+	cond_resched();
 	msg->msg_flags &= ~MSG_TRUNC;
 	goto try_again;
 }
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index d0367eb45ae3..0b023f35103d 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -301,10 +301,8 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,
 	}
 	release_sock(sk);
 
-	if (noblock)
-		return -EAGAIN;
-
-	/* starting over for a new packet */
+	/* starting over for a new packet, but check if we need to yield */
+	cond_resched();
 	msg->msg_flags &= ~MSG_TRUNC;
 	goto try_again;
 }
