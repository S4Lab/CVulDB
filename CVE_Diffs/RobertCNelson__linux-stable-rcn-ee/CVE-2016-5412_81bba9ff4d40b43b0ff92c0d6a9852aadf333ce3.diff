RobertCNelson__linux-stable-rcn-ee
commit 81bba9ff4d40b43b0ff92c0d6a9852aadf333ce3
Author:     Paul Mackerras <paulus@ozlabs.org>
AuthorDate: Wed Jun 22 15:52:55 2016 +1000
Commit:     Ben Hutchings <ben@decadent.org.uk>
CommitDate: Mon Aug 22 22:38:28 2016 +0100

    KVM: PPC: Book3S HV: Save/restore TM state in H_CEDE
    
    commit 93d17397e4e2182fdaad503e2f9da46202c0f1c3 upstream.
    
    It turns out that if the guest does a H_CEDE while the CPU is in
    a transactional state, and the H_CEDE does a nap, and the nap
    loses the architected state of the CPU (which is is allowed to do),
    then we lose the checkpointed state of the virtual CPU.  In addition,
    the transactional-memory state recorded in the MSR gets reset back
    to non-transactional, and when we try to return to the guest, we take
    a TM bad thing type of program interrupt because we are trying to
    transition from non-transactional to transactional with a hrfid
    instruction, which is not permitted.
    
    The result of the program interrupt occurring at that point is that
    the host CPU will hang in an infinite loop with interrupts disabled.
    Thus this is a denial of service vulnerability in the host which can
    be triggered by any guest (and depending on the guest kernel, it can
    potentially triggered by unprivileged userspace in the guest).
    
    This vulnerability has been assigned the ID CVE-2016-5412.
    
    To fix this, we save the TM state before napping and restore it
    on exit from the nap, when handling a H_CEDE in real mode.  The
    case where H_CEDE exits to host virtual mode is already OK (as are
    other hcalls which exit to host virtual mode) because the exit
    path saves the TM state.
    
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
    [bwh: Backported to 3.16: adjust context]
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>

diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
index 932a68ba0d3b..2f0c1394efa8 100644
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@ -1954,6 +1954,13 @@ END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_206)
 	/* save FP state */
 	bl	kvmppc_save_fp
 
+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
+BEGIN_FTR_SECTION
+	ld	r9, HSTATE_KVM_VCPU(r13)
+	bl	kvmppc_save_tm
+END_FTR_SECTION_IFSET(CPU_FTR_TM)
+#endif
+
 	/*
 	 * Take a nap until a decrementer or external or doobell interrupt
 	 * occurs, with PECE1, PECE0 and PECEDP set in LPCR. Also clear the
@@ -1993,6 +2000,12 @@ kvm_end_cede:
 	/* Woken by external or decrementer interrupt */
 	ld	r1, HSTATE_HOST_R1(r13)
 
+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM
+BEGIN_FTR_SECTION
+	bl	kvmppc_restore_tm
+END_FTR_SECTION_IFSET(CPU_FTR_TM)
+#endif
+
 	/* load up FP state */
 	bl	kvmppc_load_fp
 
