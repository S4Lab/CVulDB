RobertCNelson__linux-stable-rcn-ee
commit 9bc34abfec8f083cb5ea50534d22d114ab12c4e3
Author:     Colin Ian King <colin.king@canonical.com>
AuthorDate: Mon Jul 27 15:23:43 2015 +0100
Commit:     Luis Henriques <luis.henriques@canonical.com>
CommitDate: Tue Aug 11 09:57:27 2015 +0100

    KEYS: ensure we free the assoc array edit if edit is valid
    
    commit ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0 upstream.
    
    __key_link_end is not freeing the associated array edit structure
    and this leads to a 512 byte memory leak each time an identical
    existing key is added with add_key().
    
    The reason the add_key() system call returns okay is that
    key_create_or_update() calls __key_link_begin() before checking to see
    whether it can update a key directly rather than adding/replacing - which
    it turns out it can.  Thus __key_link() is not called through
    __key_instantiate_and_link() and __key_link_end() must cancel the edit.
    
    CVE-2015-1333
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>
    Cc: Moritz MÃ¼hlenhoff <jmm@inutil.org>
    Signed-off-by: Luis Henriques <luis.henriques@canonical.com>

diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index 9cf2575f0d97..860345cb05f1 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -1151,9 +1151,11 @@ void __key_link_end(struct key *keyring,
 	if (index_key->type == &key_type_keyring)
 		up_write(&keyring_serialise_link_sem);
 
-	if (edit && !edit->dead_leaf) {
-		key_payload_reserve(keyring,
-				    keyring->datalen - KEYQUOTA_LINK_BYTES);
+	if (edit) {
+		if (!edit->dead_leaf) {
+			key_payload_reserve(keyring,
+				keyring->datalen - KEYQUOTA_LINK_BYTES);
+		}
 		assoc_array_cancel_edit(edit);
 	}
 	up_write(&keyring->sem);
